Disassembly Listing for DoorBell_PIC32
Generated From:
/home/whatisthis/src/DoorBell_PIC32/firmware/DoorBell_PIC32.X/dist/default/debug/DoorBell_PIC32.X.debug.elf
2017/11/25 23:31:50

---  /home/whatisthis/src/DoorBell_PIC32/firmware/src/usart_tasks.c  ------------------------------------
1:                   
2:                   /*
3:                    * DOOR BELL PIC32 MX
4:                    *  USART TASKS.
5:                    * (C) 2017 K.Ohta <whatisthis.sowhat _at_ gmail.com>
6:                    */
7:                   
8:                   
9:                   #include <stddef.h>                     // Defines NULL
10:                  #include <stdbool.h>                    // Defines true
11:                  #include <stdlib.h>                     // Defines EXIT_FAILURE
12:                  #include "system/common/sys_module.h"
13:                  #include "doorbell.h"   // SYS function prototypes
14:                  #include "lm01_drv.h"
15:                  #include "ringbuffer.h"
16:                  
17:                  /* Kernel includes. */
18:                  #include "FreeRTOS.h"
19:                  #include "task.h"
20:                  #include "queue.h"
21:                  #include "timers.h"
22:                  
23:                  /* Standard demo includes. */
24:                  //#include "partest.h"
25:                  
26:                  /* Hardware specific includes. */
27:                  //#include "ConfigPerformance.h"
28:                  static char rdTmpUartBuf[4];
29:                  static char wrTmpUartBuf[4];
30:                  static char rdStrBuf[128];
31:                  extern RingBuffer_Char_t xUartRecvRing;
32:                  extern DRV_HANDLE xDevHandleUart_Recv;
33:                  extern DRV_HANDLE xDevHandleUart_Send;
34:                  
35:                  ssize_t recvUartQueue(char *buf, ssize_t len, int timeout)
36:                  {
37:                      ssize_t i = 0;
38:                      int ncount = 0;
39:                      bool b_stat;
40:                      BaseType_t stat;
41:                      //TickType_t prev;
42:                      SYS_WDT_TimerClear();
43:                      if (buf == NULL) return -1;
44:                      if (len <= 0) return 0;
45:                      //prev = xTaskGetTickCount();
46:                      while (i < len) {
47:                          b_stat = vRingBufferRead_Char(&xUartRecvRing, &(buf[i]));
48:                          if (b_stat) {
49:                              i++;
50:                              ncount += 10;
51:                          } else {
52:                              ncount += 10;
53:                          }
54:                          if (ncount >= timeout) break;
55:                          //vTaskDelayUntil(&prev, 2);
56:                          vTaskDelay(10);
57:                          SYS_WDT_TimerClear();
58:                      }
59:                      if (i < len) {
60:                          buf[i] = '\0';
61:                      }
62:                      SYS_WDT_TimerClear();
63:                      return i;
64:                  }
65:                  
66:                  ssize_t recvUartQueueDelim(char *buf, ssize_t maxlen, char delim, uint32_t timeout)
67:                  {
9D00C9D4  27BDFFC8   ADDIU SP, SP, -56
9D00C9D8  AFBF0034   SW RA, 52(SP)
9D00C9DC  AFB50030   SW S5, 48(SP)
9D00C9E0  AFB4002C   SW S4, 44(SP)
9D00C9E4  AFB30028   SW S3, 40(SP)
9D00C9E8  AFB20024   SW S2, 36(SP)
9D00C9EC  AFB10020   SW S1, 32(SP)
9D00C9F0  AFB0001C   SW S0, 28(SP)
9D00C9F4  00809021   ADDU S2, A0, ZERO
9D00C9F8  00A09821   ADDU S3, A1, ZERO
9D00C9FC  00C0A821   ADDU S5, A2, ZERO
9D00CA00  00E08821   ADDU S1, A3, ZERO
68:                      volatile bool b_stat;
69:                      volatile ssize_t i = 0;
9D00CA04  AFA00014   SW ZERO, 20(SP)
70:                      uint32_t ncount = 0;
71:                      BaseType_t stat;
72:                      //TickType_t prev;
73:                      SYS_WDT_TimerClear();
9D00CA08  0F405640   JAL SYS_WDT_TimerClear
9D00CA0C  00000000   NOP
74:                      if (buf == NULL) return -1;
9D00CA10  12400043   BEQ S2, ZERO, 0x9D00CB20
9D00CA14  2402FFFF   ADDIU V0, ZERO, -1
75:                      if (maxlen <= 0) return 0;
9D00CA18  1A600041   BLEZ S3, 0x9D00CB20
9D00CA1C  00001021   ADDU V0, ZERO, ZERO
76:                  
77:                      //prev = xTaskGetTickCount();
78:                      while (i < maxlen) {
9D00CA20  8FA20014   LW V0, 20(SP)
9D00CA24  0053102A   SLT V0, V0, S3
9D00CA28  10400039   BEQ V0, ZERO, 0x9D00CB10
9D00CA2C  24100005   ADDIU S0, ZERO, 5
9D00CB00  8FA20014   LW V0, 20(SP)
9D00CB04  0053102A   SLT V0, V0, S3
9D00CB08  1440FFCB   BNE V0, ZERO, 0x9D00CA38
9D00CB0C  26100005   ADDIU S0, S0, 5
79:                          b_stat = vRingBufferRead_Char(&xUartRecvRing, &(buf[i]));
9D00CA30  3C14A000   LUI S4, -24576
9D00CA34  26940400   ADDIU S4, S4, 1024
9D00CA38  8FA50014   LW A1, 20(SP)
9D00CA3C  02802021   ADDU A0, S4, ZERO
9D00CA40  0F4044ED   JAL vRingBufferRead_Char
9D00CA44  02452821   ADDU A1, S2, A1
9D00CA48  A3A20010   SB V0, 16(SP)
80:                          if ((b_stat)) {
9D00CA4C  93A20010   LBU V0, 16(SP)
9D00CA50  304200FF   ANDI V0, V0, 255
9D00CA54  1040001D   BEQ V0, ZERO, 0x9D00CACC
9D00CA58  00000000   NOP
81:                              if (buf[i] == delim) {
9D00CA5C  8FA20014   LW V0, 20(SP)
9D00CA60  02421021   ADDU V0, S2, V0
9D00CA64  80420000   LB V0, 0(V0)
9D00CA68  1455000F   BNE V0, S5, 0x9D00CAA8
9D00CA6C  00000000   NOP
82:                                  if ((i + 1) >= maxlen) {
9D00CA70  8FA20014   LW V0, 20(SP)
9D00CA74  24420001   ADDIU V0, V0, 1
9D00CA78  0053982A   SLT S3, V0, S3
9D00CA7C  16600004   BNE S3, ZERO, 0x9D00CA90
9D00CA80  00000000   NOP
83:                                      buf[0] = '\0';
9D00CA84  A2400000   SB ZERO, 0(S2)
84:                                      return 0;
9D00CA88  0B4032C8   J 0x9D00CB20
9D00CA8C  00001021   ADDU V0, ZERO, ZERO
85:                                  }
86:                                  buf[i + 1] = '\0';
9D00CA90  8FA20014   LW V0, 20(SP)
9D00CA94  02429021   ADDU S2, S2, V0
9D00CA98  A2400001   SB ZERO, 1(S2)
87:                                  return i + 1;
9D00CA9C  8FA20014   LW V0, 20(SP)
9D00CAA0  0B4032C8   J 0x9D00CB20
9D00CAA4  24420001   ADDIU V0, V0, 1
88:                              }
89:                              i++;
9D00CAA8  8FA20014   LW V0, 20(SP)
9D00CAAC  24420001   ADDIU V0, V0, 1
9D00CAB0  AFA20014   SW V0, 20(SP)
90:                              if (i >= maxlen) {
9D00CAB4  8FA20014   LW V0, 20(SP)
9D00CAB8  0053102A   SLT V0, V0, S3
9D00CABC  14400003   BNE V0, ZERO, 0x9D00CACC
9D00CAC0  00000000   NOP
91:                                  buf[0] = '\0';
92:                                  return 0;
9D00CAC4  0B4032C8   J 0x9D00CB20
9D00CAC8  A2400000   SB ZERO, 0(S2)
93:                              }
94:                              ncount += 5;
95:                          } else {
96:                              ncount += 5;
97:                          }
98:                          if (timeout != 0) {
9D00CACC  12200008   BEQ S1, ZERO, 0x9D00CAF0
9D00CAD0  0211102B   SLTU V0, S0, S1
99:                              if (ncount >= timeout) {
9D00CAD4  14400006   BNE V0, ZERO, 0x9D00CAF0
9D00CAD8  00000000   NOP
100:                                 buf[i] = '\0';
9D00CADC  8FA20014   LW V0, 20(SP)
9D00CAE0  02429021   ADDU S2, S2, V0
9D00CAE4  A2400000   SB ZERO, 0(S2)
101:                                 return -1;
9D00CAE8  0B4032C8   J 0x9D00CB20
9D00CAEC  2402FFFF   ADDIU V0, ZERO, -1
102:                             }
103:                         }
104:                         vTaskDelay(5);
9D00CAF0  0F405001   JAL vTaskDelay
9D00CAF4  24040005   ADDIU A0, ZERO, 5
105:                         SYS_WDT_TimerClear();
9D00CAF8  0F405640   JAL SYS_WDT_TimerClear
9D00CAFC  00000000   NOP
106:                     }
107:                     SYS_WDT_TimerClear();
9D00CB10  0F405640   JAL SYS_WDT_TimerClear
9D00CB14  00000000   NOP
108:                     buf[0] = '\0';
9D00CB18  A2400000   SB ZERO, 0(S2)
9D00CB1C  00001021   ADDU V0, ZERO, ZERO
109:                     return 0;
110:                 }
9D00CB20  8FBF0034   LW RA, 52(SP)
9D00CB24  8FB50030   LW S5, 48(SP)
9D00CB28  8FB4002C   LW S4, 44(SP)
9D00CB2C  8FB30028   LW S3, 40(SP)
9D00CB30  8FB20024   LW S2, 36(SP)
9D00CB34  8FB10020   LW S1, 32(SP)
9D00CB38  8FB0001C   LW S0, 28(SP)
9D00CB3C  03E00008   JR RA
9D00CB40  27BD0038   ADDIU SP, SP, 56
111:                 
112:                 enum {
113:                     UART_PHASE_INITIAL = 0,
114:                     UART_PHASE_WAIT_FOR_PROMPT,
115:                     UART_PHASE_WAIT_FOR_CMD,
116:                     UART_PHASE_SEND_DATA,
117:                 };
118:                 
119:                 int checkSender(char *data, uint32_t *hostnum, char **ps, size_t maxlen)
120:                 {
9D009220  27BDFFD8   ADDIU SP, SP, -40
9D009224  AFBE0024   SW S8, 36(SP)
9D009228  AFB70020   SW S7, 32(SP)
9D00922C  AFB6001C   SW S6, 28(SP)
9D009230  AFB50018   SW S5, 24(SP)
9D009234  AFB40014   SW S4, 20(SP)
9D009238  AFB30010   SW S3, 16(SP)
9D00923C  AFB2000C   SW S2, 12(SP)
9D009240  AFB10008   SW S1, 8(SP)
9D009244  AFB00004   SW S0, 4(SP)
121:                     int i, j, k, l;
122:                     int pre_case;
123:                     uint32_t pval;
124:                     uint32_t n;
125:                     bool pflag = false;
9D00924C  00008021   ADDU S0, ZERO, ZERO
126:                     if ((data == NULL) || (hostnum == NULL)) return N_HOST_FAIL;
9D009200  1080006D   BEQ A0, ZERO, 0x9D0093B8
9D009204  00000000   NOP
9D009208  10A0006D   BEQ A1, ZERO, 0x9D0093C0
9D00920C  00000000   NOP
9D0093B8  03E00008   JR RA
9D0093BC  2402FF00   ADDIU V0, ZERO, -256
9D0093C0  03E00008   JR RA
9D0093C4  2402FF00   ADDIU V0, ZERO, -256
127:                     k = 0;
9D009254  00006821   ADDU T5, ZERO, ZERO
128:                     if (ps != NULL) *ps = NULL;
9D009210  54C00001   BNEL A2, ZERO, 0x9D009218
9D009214  ACC00000   SW ZERO, 0(A2)
129:                     *hostnum = 0;
130:                     pre_case = N_UNSTABLE;
9D009250  2403FFFF   ADDIU V1, ZERO, -1
131:                     for (i = 0; i < maxlen; i++) {
9D009218  10E0006B   BEQ A3, ZERO, 0x9D0093C8
9D00921C  ACA00000   SW ZERO, 0(A1)
9D009248  00004021   ADDU T0, ZERO, ZERO
9D009258  00001021   ADDU V0, ZERO, ZERO
9D0093A4  24420001   ADDIU V0, V0, 1
9D0093A8  1447FFB5   BNE V0, A3, 0x9D009280
9D0093AC  00404021   ADDU T0, V0, ZERO
9D0093B0  0B4024F5   J 0x9D0093D4
9D0093B4  2402FF00   ADDIU V0, ZERO, -256
132:                         if (pre_case == N_UNSTABLE) {
9D00925C  2409FFFF   ADDIU T1, ZERO, -1
9D009280  1469000E   BNE V1, T1, 0x9D0092BC
9D009284  00000000   NOP
133:                             if ((data[i] == '\n') || (data[i] == '\r') || (data[i] == '\0')) {
9D009270  240F000A   ADDIU T7, ZERO, 10
9D009274  2418000D   ADDIU T8, ZERO, 13
9D009288  00884021   ADDU T0, A0, T0
9D00928C  81080000   LB T0, 0(T0)
9D009290  510F0050   BEQL T0, T7, 0x9D0093D4
9D009294  2402FFF0   ADDIU V0, ZERO, -16
9D009298  5118004E   BEQL T0, T8, 0x9D0093D4
9D00929C  2402FFF0   ADDIU V0, ZERO, -16
9D0092A0  5100004C   BEQL T0, ZERO, 0x9D0093D4
9D0092A4  2402FFF0   ADDIU V0, ZERO, -16
134:                                 return N_HOST_EOF;
135:                             }
136:                             if (data[i] == ':') {
9D009278  2419003A   ADDIU T9, ZERO, 58
9D0092A8  1119003C   BEQ T0, T9, 0x9D00939C
9D0092AC  010E6026   XOR T4, T0, T6
9D0092B0  004C680A   MOVZ T5, V0, T4
9D0092B4  0B4024E9   J 0x9D0093A4
9D0092B8  016C180A   MOVZ V1, T3, T4
137:                                 pre_case = N_PROMPT;
9D0093A0  01401821   ADDU V1, T2, ZERO
138:                                 k = i;
139:                             }
140:                             if (data[i] == '[') {
9D00927C  240E005B   ADDIU T6, ZERO, 91
141:                                 pre_case = N_HOST_PROGRESS;
142:                                 k = i;
143:                             }
144:                         } else if (pre_case == N_PROMPT) {
9D009260  240AFFFE   ADDIU T2, ZERO, -2
9D0092BC  146A0009   BNE V1, T2, 0x9D0092E4
9D0092C0  00886021   ADDU T4, A0, T0
145:                             if (data[i] == '>') {
9D00926C  2411003E   ADDIU S1, ZERO, 62
9D0092C4  818C0000   LB T4, 0(T4)
9D0092C8  55910037   BNEL T4, S1, 0x9D0093A8
9D0092CC  24420001   ADDIU V0, V0, 1
146:                                 //if (i > 9) {
147:                                 *ps = &(data[i + 1]);
9D0092D0  25080001   ADDIU T0, T0, 1
9D0092D4  00882021   ADDU A0, A0, T0
9D0092D8  ACC40000   SW A0, 0(A2)
148:                                 return N_PROMPT;
9D0092DC  0B4024F5   J 0x9D0093D4
9D0092E0  2402FFFE   ADDIU V0, ZERO, -2
149:                                 //}
150:                             }
151:                         } else if (pre_case == N_HOST_PROGRESS) {
9D009264  240BFFFD   ADDIU T3, ZERO, -3
9D0092E4  546B0030   BNEL V1, T3, 0x9D0093A8
9D0092E8  24420001   ADDIU V0, V0, 1
152:                             if (!pflag) {
9D0092EC  16000006   BNE S0, ZERO, 0x9D009308
9D0092F0  00886021   ADDU T4, A0, T0
153:                                 if (data[i] == ':') {
9D0092F4  00884021   ADDU T0, A0, T0
9D0092F8  81100000   LB S0, 0(T0)
9D0092FC  3A10003A   XORI S0, S0, 58
9D009300  0B4024E9   J 0x9D0093A4
9D009304  2E100001   SLTIU S0, S0, 1
154:                                     pflag = true;
155:                                 }
156:                             } else {
157:                                 if (data[i] == ']') {
9D009268  2412005D   ADDIU S2, ZERO, 93
9D009308  818C0000   LB T4, 0(T4)
9D00930C  55920026   BNEL T4, S2, 0x9D0093A8
9D009310  24420001   ADDIU V0, V0, 1
158:                                     // Let's Go
159:                                     pval = 0;
9D009328  0000A821   ADDU S5, ZERO, ZERO
9D00932C  008C9821   ADDU S3, A0, T4
160:                                     l = 0;
161:                                     for (j = (k + 1); j < (i - 1); j++) {
9D009314  25AC0001   ADDIU T4, T5, 1
9D009318  2457FFFF   ADDIU S7, V0, -1
9D00931C  0197982A   SLT S3, T4, S7
9D009320  12600020   BEQ S3, ZERO, 0x9D0093A4
9D009324  25BE0008   ADDIU S8, T5, 8
9D009384  258C0001   ADDIU T4, T4, 1
9D009388  0197982A   SLT S3, T4, S7
9D00938C  1660FFE7   BNE S3, ZERO, 0x9D00932C
9D009390  0015A900   SLL S5, S5, 4
9D009394  0B4024EA   J 0x9D0093A8
9D009398  24420001   ADDIU V0, V0, 1
9D00939C  00406821   ADDU T5, V0, ZERO
162:                                         if ((data[j] < '0') && (data[j] > 'F')) {
163:                                             *hostnum = 0;
164:                                             return N_HOST_FAIL;
165:                                         } else {
166:                                             if ((data[j] >= 'A') && (data[j] <= 'F')) {
9D009330  82730000   LB S3, 0(S3)
9D009334  327400FF   ANDI S4, S3, 255
9D009338  2696FFBF   ADDIU S6, S4, -65
9D00933C  32D600FF   ANDI S6, S6, 255
9D009340  2ED60006   SLTIU S6, S6, 6
9D009344  52C00003   BEQL S6, ZERO, 0x9D009354
9D009348  2694FFD0   ADDIU S4, S4, -48
9D00934C  0B4024D9   J 0x9D009364
9D009350  2673FFC9   ADDIU S3, S3, -55
167:                                                 n = (uint32_t) (data[j] - 'A') + 10;
168:                                             } else if ((data[j] >= '0') && (data[j] <= '9')) {
9D009354  329400FF   ANDI S4, S4, 255
9D009358  2E94000A   SLTIU S4, S4, 10
9D00935C  1280001C   BEQ S4, ZERO, 0x9D0093D0
9D009360  2673FFD0   ADDIU S3, S3, -48
169:                                                 n = (uint32_t) (data[j] - '0');
170:                                             } else {
171:                                                 *hostnum = 0;
172:                                                 return N_HOST_FAIL;
173:                                             }
174:                                             pval = n | pval;
175:                                             l++;
176:                                             if (l == 8) {
9D009364  159E0007   BNE T4, S8, 0x9D009384
9D009368  02B3A825   OR S5, S5, S3
177:                                                 *hostnum = pval;
9D00936C  ACB50000   SW S5, 0(A1)
178:                                                 *ps = &(data[i + 1]);
9D009370  25080001   ADDIU T0, T0, 1
9D009374  00882021   ADDU A0, A0, T0
9D009378  ACC40000   SW A0, 0(A2)
179:                                                 return N_HOST_COMPLETE;
9D00937C  0B4024F5   J 0x9D0093D4
9D009380  00001021   ADDU V0, ZERO, ZERO
180:                                             } else {
181:                                                 pval <<= 4;
182:                                             }
183:                                         }
184:                                     }
185:                                 }
186:                             }
187:                         }
188:                     }
189:                     return N_HOST_FAIL;
190:                 }
9D0093C8  03E00008   JR RA
9D0093CC  2402FF00   ADDIU V0, ZERO, -256
9D0093D0  2402FF00   ADDIU V0, ZERO, -256
9D0093D4  8FBE0024   LW S8, 36(SP)
9D0093D8  8FB70020   LW S7, 32(SP)
9D0093DC  8FB6001C   LW S6, 28(SP)
9D0093E0  8FB50018   LW S5, 24(SP)
9D0093E4  8FB40014   LW S4, 20(SP)
9D0093E8  8FB30010   LW S3, 16(SP)
9D0093EC  8FB2000C   LW S2, 12(SP)
9D0093F0  8FB10008   LW S1, 8(SP)
9D0093F4  8FB00004   LW S0, 4(SP)
9D0093F8  03E00008   JR RA
9D0093FC  27BD0028   ADDIU SP, SP, 40
191:                 
192:                 enum {
193:                     N_STR_BEGIN = 0,
194:                     N_STR_PROGRESS = 2,
195:                     N_STR_CR = 0x20, //\n
196:                     N_STR_LF = 0x40, //\r
197:                     N_STR_NUL = 0x80,
198:                     N_STR_OK = 0x100,
199:                     N_STR_MES = 0x2000, // [
200:                     N_STR_PROMPT = 0x4000, // >
201:                     N_STR_END = 0x8000,
202:                 };
203:                 
204:                 typedef struct {
205:                     size_t size;
206:                     size_t ptr;
207:                     char *buf;
208:                 } strpacket_t;
209:                 
210:                 uint32_t checkStrType(char c, uint32_t type)
211:                 {
212:                     uint32_t beforetype = type;
213:                     switch (c) {
9D011470  2403000D   ADDIU V1, ZERO, 13
9D011474  10830017   BEQ A0, V1, 0x9D0114D4
9D011478  00A01021   ADDU V0, A1, ZERO
9D01147C  2883000E   SLTI V1, A0, 14
9D011480  10600007   BEQ V1, ZERO, 0x9D0114A0
9D011484  2403005B   ADDIU V1, ZERO, 91
9D011488  1080000D   BEQ A0, ZERO, 0x9D0114C0
9D01148C  2403000A   ADDIU V1, ZERO, 10
9D011490  5083000E   BEQL A0, V1, 0x9D0114CC
9D011494  7C020844   INS V0, ZERO, 1, 1
9D011498  03E00008   JR RA
9D01149C  00000000   NOP
9D0114A0  1083000F   BEQ A0, V1, 0x9D0114E0
9D0114A4  2403005D   ADDIU V1, ZERO, 93
9D0114A8  10830014   BEQ A0, V1, 0x9D0114FC
9D0114AC  2403003E   ADDIU V1, ZERO, 62
9D0114B0  1483FFF9   BNE A0, V1, 0x9D011498
9D0114B4  30A32000   ANDI V1, A1, 8192
9D0114B8  0B404545   J 0x9D011514
9D0114BC  00000000   NOP
214:                     case '\0':
215:                         beforetype = beforetype | N_STR_NUL | N_STR_END;
216:                         beforetype = beforetype & ~N_STR_PROGRESS;
9D0114C0  7C020844   INS V0, ZERO, 1, 1
217:                         break;
9D0114C4  03E00008   JR RA
9D0114C8  34428080   ORI V0, V0, -32640
218:                     case '\n':
219:                         beforetype = beforetype | N_STR_LF | N_STR_END;
220:                         beforetype = beforetype & ~N_STR_PROGRESS;
221:                         break;
9D0114CC  03E00008   JR RA
9D0114D0  34428040   ORI V0, V0, -32704
222:                     case '\r':
223:                         beforetype = beforetype | N_STR_CR;
224:                         beforetype = beforetype & ~N_STR_PROGRESS;
9D0114D4  7C020844   INS V0, ZERO, 1, 1
225:                         break;
9D0114D8  03E00008   JR RA
9D0114DC  34420020   ORI V0, V0, 32
226:                     case '[':
227:                         if ((beforetype & N_STR_PROMPT) == 0) {
9D0114E0  30A34000   ANDI V1, A1, 16384
9D0114E4  1460FFEC   BNE V1, ZERO, 0x9D011498
9D0114E8  30A40100   ANDI A0, A1, 256
228:                             beforetype = beforetype | N_STR_MES;
9D0114EC  34A32000   ORI V1, A1, 8192
9D0114F0  34A22002   ORI V0, A1, 8194
9D0114F4  03E00008   JR RA
9D0114F8  0064100B   MOVN V0, V1, A0
229:                             if ((beforetype & N_STR_OK) == 0) {
230:                                 beforetype = beforetype | N_STR_PROGRESS;
231:                             }
232:                         }
233:                         break;
234:                     case ']':
235:                         if ((beforetype & N_STR_MES) != 0) {
9D0114FC  30A32000   ANDI V1, A1, 8192
9D011500  10600008   BEQ V1, ZERO, 0x9D011524
9D011504  00000000   NOP
236:                             beforetype = beforetype & ~N_STR_PROGRESS;
9D011508  7C020844   INS V0, ZERO, 1, 1
237:                             beforetype = beforetype | N_STR_OK;
9D01150C  03E00008   JR RA
9D011510  34420100   ORI V0, V0, 256
238:                         }
239:                         break;
240:                     case '>':
241:                         if ((beforetype & N_STR_MES) == 0) {
9D011514  14600003   BNE V1, ZERO, 0x9D011524
9D011518  00000000   NOP
242:                             beforetype = beforetype | N_STR_PROMPT | N_STR_OK;
243:                             beforetype = beforetype & ~N_STR_PROGRESS;
9D01151C  7C020844   INS V0, ZERO, 1, 1
9D011520  34424100   ORI V0, V0, 16640
244:                         }
245:                         break;
246:                     default:
247:                         break;
248:                     }
249:                     return beforetype;
250:                 }
9D011524  03E00008   JR RA
9D011528  00000000   NOP
251:                 
252:                 int uartSendData_HK()
253:                 {
9D011744  27BDFFE0   ADDIU SP, SP, -32
9D011748  AFBF001C   SW RA, 28(SP)
9D01174C  AFB10018   SW S1, 24(SP)
9D011750  AFB00014   SW S0, 20(SP)
254:                     BaseType_t stat;
255:                     ssize_t _wlen = 0;
256:                     int i = 0;
257:                     if (xUartSendQueue != NULL) {
9D011754  8F8480EC   LW A0, -32532(GP)
9D011758  10800017   BEQ A0, ZERO, 0x9D0117B8
9D01175C  2785803C   ADDIU A1, GP, -32708
258:                         stat = xQueueReceive(xUartSendQueue, wrTmpUartBuf, cTick500ms);
9D011760  8F868120   LW A2, -32480(GP)
9D011764  0F401E81   JAL xQueueGenericReceive
9D011768  00003821   ADDU A3, ZERO, ZERO
259:                         if (stat == pdTRUE) {
9D01176C  24030001   ADDIU V1, ZERO, 1
9D011770  14430013   BNE V0, V1, 0x9D0117C0
9D011774  8F838104   LW V1, -32508(GP)
260:                             if (xDevHandleUart_Send != DRV_HANDLE_INVALID) {
9D011778  2402FFFF   ADDIU V0, ZERO, -1
9D01177C  10620012   BEQ V1, V0, 0x9D0117C8
9D011780  24110021   ADDIU S1, ZERO, 33
261:                                 _wlen = 0;
262:                                 while (_wlen <= 0) {
263:                                     _wlen = DRV_USART_Write(xDevHandleUart_Send, wrTmpUartBuf, sizeof (char));
9D011784  8F848104   LW A0, -32508(GP)
9D011788  2785803C   ADDIU A1, GP, -32708
9D01178C  0F4022F9   JAL DRV_USART_Write
9D011790  24060001   ADDIU A2, ZERO, 1
9D0117B0  0B4045F6   J 0x9D0117D8
9D0117B4  02001021   ADDU V0, S0, ZERO
264:                                     if (_wlen <= 0) vTaskDelay(cTick100ms);
9D011794  1C40000E   BGTZ V0, 0x9D0117D0
9D011798  00408021   ADDU S0, V0, ZERO
9D01179C  0F405001   JAL vTaskDelay
9D0117A0  8F8480F8   LW A0, -32520(GP)
9D0117A4  2631FFFF   ADDIU S1, S1, -1
265:                                     i++;
266:                                     if (i > 32) break; // Retry 32 times failed.
9D0117A8  5620FFF7   BNEL S1, ZERO, 0x9D011788
9D0117AC  8F848104   LW A0, -32508(GP)
9D0117D0  24020001   ADDIU V0, ZERO, 1
9D0117D4  02001021   ADDU V0, S0, ZERO
267:                                 }
268:                                 return _wlen;
269:                             } else {
270:                                 return -1; // Nothing to SEND
9D0117C8  0B4045F6   J 0x9D0117D8
9D0117CC  2402FFFF   ADDIU V0, ZERO, -1
271:                             }
272:                         } else {
273:                             return -1; // Nothing to SEND
9D0117C0  0B4045F6   J 0x9D0117D8
9D0117C4  2402FFFF   ADDIU V0, ZERO, -1
274:                         }
275:                     }
276:                     return -1;
9D0117B8  0B4045F6   J 0x9D0117D8
9D0117BC  2402FFFF   ADDIU V0, ZERO, -1
277:                 }
9D0117D8  8FBF001C   LW RA, 28(SP)
9D0117DC  8FB10018   LW S1, 24(SP)
9D0117E0  8FB00014   LW S0, 20(SP)
9D0117E4  03E00008   JR RA
9D0117E8  27BD0020   ADDIU SP, SP, 32
278:                 
279:                 void prvReadFromUart_HK(void *pvparameters)
280:                 {
9D00A70C  27BDFFC8   ADDIU SP, SP, -56
9D00A710  AFBF0034   SW RA, 52(SP)
9D00A714  AFB60030   SW S6, 48(SP)
9D00A718  AFB5002C   SW S5, 44(SP)
9D00A71C  AFB40028   SW S4, 40(SP)
9D00A720  AFB30024   SW S3, 36(SP)
9D00A724  AFB20020   SW S2, 32(SP)
9D00A728  AFB1001C   SW S1, 28(SP)
9D00A72C  AFB00018   SW S0, 24(SP)
281:                     size_t _len = 0;
282:                     BaseType_t stat;
283:                     UBaseType_t avail;
284:                     bool b_stat;
285:                     int i = 0;
286:                     int j = 0;
287:                     char c;
288:                     bool nsync = false;
289:                     volatile uint32_t strtype = N_STR_BEGIN;
9D00A730  AFA00010   SW ZERO, 16(SP)
290:                     int sptr = 0;
9D00A734  0000A021   ADDU S4, ZERO, ZERO
291:                     int ssptr;
292:                     while (1) {
293:                         if (xDevHandleUart_Recv != DRV_HANDLE_INVALID) {
9D00A738  2415FFFF   ADDIU S5, ZERO, -1
9D00A74C  8F8480E8   LW A0, -32536(GP)
9D00A750  1095005C   BEQ A0, S5, 0x9D00A8C4
9D00A754  27858040   ADDIU A1, GP, -32704
9D00A8BC  0B4029D4   J 0x9D00A750
9D00A8C0  8F8480E8   LW A0, -32536(GP)
9D00A8CC  0B4029D4   J 0x9D00A750
294:                             _len = DRV_USART_Read(xDevHandleUart_Recv, &(rdTmpUartBuf[0]), sizeof (char));
9D00A758  0F402043   JAL DRV_USART_Read
9D00A75C  24060001   ADDIU A2, ZERO, 1
295:                             if ((_len > 0) && (_len != DRV_USART_READ_ERROR)) {
9D00A760  2443FFFF   ADDIU V1, V0, -1
9D00A764  2C63FFFE   SLTIU V1, V1, -2
9D00A768  10600052   BEQ V1, ZERO, 0x9D00A8B4
9D00A76C  00000000   NOP
296:                                 i = 0;
297:                                 while (i < _len) {
9D00A770  10400025   BEQ V0, ZERO, 0x9D00A808
9D00A774  83848040   LB A0, -32704(GP)
9D00A7F8  1611FFE7   BNE S0, S1, 0x9D00A798
9D00A7FC  02D01021   ADDU V0, S6, S0
9D00A800  0B402A03   J 0x9D00A80C
9D00A804  00000000   NOP
9D00A808  02808021   ADDU S0, S4, ZERO
298:                                     //b_stat = vRingBufferWrite_Char(&xUartRecvRing, rdTmpUartBuf[i]);
299:                                     //if (b_stat) {
300:                                     //   i++;
301:                                     //}
302:                                         rdStrBuf[sptr] = rdTmpUartBuf[i];
9D00A778  02931821   ADDU V1, S4, S3
9D00A77C  A0640000   SB A0, 0(V1)
9D00A798  80440000   LB A0, 0(V0)
9D00A79C  02701021   ADDU V0, S3, S0
9D00A7A0  A0440000   SB A0, 0(V0)
303:                                         sptr++;
9D00A780  26900001   ADDIU S0, S4, 1
9D00A790  0B4029EE   J 0x9D00A7B8
9D00A794  02001021   ADDU V0, S0, ZERO
9D00A7A4  26020001   ADDIU V0, S0, 1
9D00A7B0  0B4029F6   J 0x9D00A7D8
9D00A7B4  00408021   ADDU S0, V0, ZERO
304:                                         if ((sptr + 1) == (sizeof (rdStrBuf) / sizeof (char))) {
9D00A784  2403007F   ADDIU V1, ZERO, 127
9D00A788  16030010   BNE S0, V1, 0x9D00A7CC
9D00A78C  02828821   ADDU S1, S4, V0
9D00A7A8  50540005   BEQL V0, S4, 0x9D00A7C0
9D00A7AC  00531021   ADDU V0, V0, S3
9D00A7B8  02808021   ADDU S0, S4, ZERO
9D00A7D4  2414007F   ADDIU S4, ZERO, 127
305:                                         // Force exit
306:                                             rdStrBuf[sptr] = '\0';
9D00A7BC  00531021   ADDU V0, V0, S3
9D00A7C0  A0400000   SB ZERO, 0(V0)
307:                                             sptr++;
308:                                             break;
9D00A7C4  0B402A03   J 0x9D00A80C
9D00A7C8  26100002   ADDIU S0, S0, 2
9D00A7CC  27968040   ADDIU S6, GP, -32704
9D00A7D0  02D4B023   SUBU S6, S6, S4
309:                                         }
310:                                     strtype = checkStrType(rdTmpUartBuf[i], strtype);
9D00A7D8  8FA50010   LW A1, 16(SP)
9D00A7DC  0F40451C   JAL checkStrType
9D00A7E0  00000000   NOP
9D00A7E4  AFA20010   SW V0, 16(SP)
311:                 
312:                                     if ((strtype & N_STR_END) != 0) {
9D00A7E8  8FA20010   LW V0, 16(SP)
9D00A7EC  30428000   ANDI V0, V0, -32768
9D00A7F0  14400006   BNE V0, ZERO, 0x9D00A80C
9D00A7F4  00000000   NOP
313:                                             break;
314:                                         }
315:                                     i++;
316:                                 }
317:                                 if ((strtype & N_STR_END) != 0) {
9D00A80C  8FA20010   LW V0, 16(SP)
9D00A810  30428000   ANDI V0, V0, -32768
9D00A814  1040001E   BEQ V0, ZERO, 0x9D00A890
9D00A818  2E020080   SLTIU V0, S0, 128
318:                                     ssptr = 0;
319:                                     if ((strtype & N_STR_MES) != 0) {
9D00A81C  8FA20010   LW V0, 16(SP)
9D00A820  30422000   ANDI V0, V0, 8192
9D00A824  10400013   BEQ V0, ZERO, 0x9D00A874
9D00A828  00000000   NOP
320:                                         if ((strtype & N_STR_OK) != 0) {
9D00A82C  8FA20010   LW V0, 16(SP)
9D00A830  30420100   ANDI V0, V0, 256
9D00A834  1040000F   BEQ V0, ZERO, 0x9D00A874
9D00A838  00000000   NOP
321:                                             for (ssptr = 0; ssptr < sptr; ssptr++) {
9D00A83C  1A00000D   BLEZ S0, 0x9D00A874
9D00A840  02402021   ADDU A0, S2, ZERO
9D00A844  02608821   ADDU S1, S3, ZERO
9D00A848  02708021   ADDU S0, S3, S0
9D00A86C  1630FFF7   BNE S1, S0, 0x9D00A84C
9D00A870  02402021   ADDU A0, S2, ZERO
322:                                                 b_stat = false;
323:                                                 do {
324:                                                     b_stat = vRingBufferWrite_Char(&xUartRecvRing, rdStrBuf[ssptr]);
9D00A744  3C12A000   LUI S2, -24576
9D00A748  26520400   ADDIU S2, S2, 1024
9D00A84C  0F40485C   JAL vRingBufferWrite_Char
9D00A850  82250000   LB A1, 0(S1)
9D00A864  0B402A13   J 0x9D00A84C
9D00A868  02402021   ADDU A0, S2, ZERO
325:                                                     if (b_stat) break;
9D00A854  54400005   BNEL V0, ZERO, 0x9D00A86C
9D00A858  26310001   ADDIU S1, S1, 1
326:                                                     vTaskDelay(cTick100ms);
9D00A85C  0F405001   JAL vTaskDelay
9D00A860  8F8480F8   LW A0, -32520(GP)
327:                                                } while (!b_stat);
328:                                             }
329:                                         }
330:                                     }
331:                                     sptr = 0;
9D00A888  0B4029D3   J 0x9D00A74C
9D00A88C  0000A021   ADDU S4, ZERO, ZERO
332:                                     strtype = N_STR_BEGIN;
9D00A874  AFA00010   SW ZERO, 16(SP)
333:                                     memset(rdStrBuf, 0x00, sizeof(rdStrBuf));
9D00A878  02602021   ADDU A0, S3, ZERO
9D00A87C  00002821   ADDU A1, ZERO, ZERO
9D00A880  0F40464F   JAL memset
9D00A884  24060080   ADDIU A2, ZERO, 128
334:                                 }
335:                                 if(sptr >= (sizeof (rdStrBuf) / sizeof (char))) {
9D00A890  1440FFAE   BNE V0, ZERO, 0x9D00A74C
9D00A894  0200A021   ADDU S4, S0, ZERO
336:                                     sptr = 0;
9D00A8AC  0B4029D3   J 0x9D00A74C
9D00A8B0  0000A021   ADDU S4, ZERO, ZERO
337:                                     strtype = N_STR_BEGIN;
9D00A898  AFA00010   SW ZERO, 16(SP)
338:                                     memset(rdStrBuf, 0x00, sizeof(rdStrBuf));
9D00A73C  3C13A000   LUI S3, -24576
9D00A740  26730364   ADDIU S3, S3, 868
9D00A89C  02602021   ADDU A0, S3, ZERO
9D00A8A0  00002821   ADDU A1, ZERO, ZERO
9D00A8A4  0F40464F   JAL memset
9D00A8A8  24060080   ADDIU A2, ZERO, 128
339:                                 }
340:                                 //vTaskDelay(2);
341:                             } else {
342:                                 vTaskDelay(cTick200ms);
9D00A8B4  0F405001   JAL vTaskDelay
9D00A8B8  8F848100   LW A0, -32512(GP)
343:                             }
344:                         } else {
345:                 
346:                             vTaskDelay(cTick500ms);
9D00A8C4  0F405001   JAL vTaskDelay
9D00A8C8  8F848120   LW A0, -32480(GP)
9D00A8CC  0B4029D4   J 0x9D00A750
9D00A8D0  8F8480E8   LW A0, -32536(GP)
347:                         }
348:                     }
349:                 }
350:                 
351:                 void prvWriteToUart_HK(void *pvparameters)
352:                 {
9D014E9C  27BDFFE8   ADDIU SP, SP, -24
9D014EA0  AFBF0014   SW RA, 20(SP)
353:                     int rcount = 0;
354:                     while (1) {
355:                         if (xUartSendQueue != NULL) {
9D014EA4  8F8280EC   LW V0, -32532(GP)
9D014EA8  10400005   BEQ V0, ZERO, 0x9D014EC0
9D014EAC  00000000   NOP
9D014EC8  0B4053AA   J 0x9D014EA8
356:                             uartSendData_HK();
9D014EB0  0F4045D1   JAL uartSendData_HK
9D014EB4  00000000   NOP
9D014EB8  0B4053AA   J 0x9D014EA8
9D014EBC  8F8280EC   LW V0, -32532(GP)
357:                                     //rcount++;
358:                                     //if(rcount >16) {
359:                                     //    rcount = 0;
360:                                     //    vTaskDelay(cTick200ms);
361:                                     //}
362:                         } else {
363:                             vTaskDelay(cTick500ms);
9D014EC0  0F405001   JAL vTaskDelay
9D014EC4  8F848120   LW A0, -32480(GP)
9D014EC8  0B4053AA   J 0x9D014EA8
9D014ECC  8F8280EC   LW V0, -32532(GP)
364:                         }
365:                     }
366:                 }
---  /home/whatisthis/src/DoorBell_PIC32/firmware/src/system_config/default/system_tasks.c  -------------
1:                   /*******************************************************************************
2:                    System Tasks File
3:                   
4:                     File Name:
5:                       system_tasks.c
6:                   
7:                     Summary:
8:                       This file contains source code necessary to maintain system's polled state
9:                       machines.
10:                  
11:                    Description:
12:                      This file contains source code necessary to maintain system's polled state
13:                      machines.  It implements the "SYS_Tasks" function that calls the individual
14:                      "Tasks" functions for all the MPLAB Harmony modules in the system.
15:                  
16:                    Remarks:
17:                      This file requires access to the systemObjects global data structure that
18:                      contains the object handles to all MPLAB Harmony module objects executing
19:                      polled in the system.  These handles are passed into the individual module
20:                      "Tasks" functions to identify the instance of the module to maintain.
21:                   *******************************************************************************/
22:                  
23:                  // DOM-IGNORE-BEGIN
24:                  /*******************************************************************************
25:                  Copyright (c) 2013-2015 released Microchip Technology Inc.  All rights reserved.
26:                  
27:                  Microchip licenses to you the right to use, modify, copy and distribute
28:                  Software only when embedded on a Microchip microcontroller or digital signal
29:                  controller that is integrated into your product or third party product
30:                  (pursuant to the sublicense terms in the accompanying license agreement).
31:                  
32:                  You should refer to the license agreement accompanying this Software for
33:                  additional information regarding your rights and obligations.
34:                  
35:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
36:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
37:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
38:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
39:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
40:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
41:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
42:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
43:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
44:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
45:                   *******************************************************************************/
46:                  // DOM-IGNORE-END
47:                  
48:                  
49:                  // *****************************************************************************
50:                  // *****************************************************************************
51:                  // Section: Included Files
52:                  // *****************************************************************************
53:                  // *****************************************************************************
54:                  
55:                  #include "system_config.h"
56:                  #include "system_definitions.h"
57:                  #include "doorbell.h"
58:                  
59:                  
60:                  // *****************************************************************************
61:                  // *****************************************************************************
62:                  // Section: Local Prototypes
63:                  // *****************************************************************************
64:                  // *****************************************************************************
65:                  
66:                  
67:                   
68:                  static void _SYS_Tasks ( void );
69:                  void _SYS_DMA_Tasks(void);
70:                   
71:                   
72:                  
73:                  static void _DOORBELL_Tasks(void);
74:                  
75:                  
76:                  // *****************************************************************************
77:                  // *****************************************************************************
78:                  // Section: System "Tasks" Routine
79:                  // *****************************************************************************
80:                  // *****************************************************************************
81:                  
82:                  /*******************************************************************************
83:                    Function:
84:                      void SYS_Tasks ( void )
85:                  
86:                    Remarks:
87:                      See prototype in system/common/sys_module.h.
88:                  */
89:                  
90:                  void SYS_Tasks ( void )
91:                  {
9D01245C  27BDFFE0   ADDIU SP, SP, -32
9D012460  AFBF001C   SW RA, 28(SP)
9D012464  AFB00018   SW S0, 24(SP)
92:                      /* Create OS Thread for Sys Tasks. */
93:                      xTaskCreate((TaskFunction_t) _SYS_Tasks,
9D012468  24100001   ADDIU S0, ZERO, 1
9D01246C  AFB00010   SW S0, 16(SP)
9D012470  AFA00014   SW ZERO, 20(SP)
9D012474  3C049D01   LUI A0, -25343
9D012478  24844630   ADDIU A0, A0, 17968
9D01247C  3C059D01   LUI A1, -25343
9D012480  24A551DC   ADDIU A1, A1, 20956
9D012484  24060200   ADDIU A2, ZERO, 512
9D012488  0F40448E   JAL xTaskCreate
9D01248C  00003821   ADDU A3, ZERO, ZERO
94:                                  "Sys Tasks",
95:                                  512, NULL, 1, NULL);
96:                  
97:                   
98:                      /* Create task for DMA system state machine*/
99:                      /* Create OS Thread for SYS_DMA Tasks. */
100:                     xTaskCreate((TaskFunction_t) _SYS_DMA_Tasks,
9D012490  AFB00010   SW S0, 16(SP)
9D012494  AFA00014   SW ZERO, 20(SP)
9D012498  3C049D01   LUI A0, -25343
9D01249C  24845768   ADDIU A0, A0, 22376
9D0124A0  3C059D01   LUI A1, -25343
9D0124A4  24A551E8   ADDIU A1, A1, 20968
9D0124A8  24060180   ADDIU A2, ZERO, 384
9D0124AC  0F40448E   JAL xTaskCreate
9D0124B0  00003821   ADDU A3, ZERO, ZERO
101:                                 "SYS_DMA Tasks",
102:                                 384, NULL, 1, NULL);
103:                 
104:                  
105:                  
106:                 
107:                     /* Create OS Thread for DOORBELL Tasks. */
108:                     xTaskCreate((TaskFunction_t) _DOORBELL_Tasks,
9D0124B4  AFB00010   SW S0, 16(SP)
9D0124B8  AFA00014   SW ZERO, 20(SP)
9D0124BC  3C049D01   LUI A0, -25343
9D0124C0  24845644   ADDIU A0, A0, 22084
9D0124C4  3C059D01   LUI A1, -25343
9D0124C8  24A551F8   ADDIU A1, A1, 20984
9D0124CC  24060400   ADDIU A2, ZERO, 1024
9D0124D0  0F40448E   JAL xTaskCreate
9D0124D4  00003821   ADDU A3, ZERO, ZERO
109:                                 "DOORBELL Tasks",
110:                                 1024, NULL, 1, NULL);
111:                 
112:                     /**************
113:                      * Start RTOS * 
114:                      **************/
115:                     vTaskStartScheduler(); /* This function never returns. */
9D0124D8  0F404A11   JAL vTaskStartScheduler
9D0124DC  00000000   NOP
116:                 }
9D0124E0  8FBF001C   LW RA, 28(SP)
9D0124E4  8FB00018   LW S0, 24(SP)
9D0124E8  03E00008   JR RA
9D0124EC  27BD0020   ADDIU SP, SP, 32
117:                 
118:                 
119:                 /*******************************************************************************
120:                   Function:
121:                     void _SYS_Tasks ( void )
122:                 
123:                   Summary:
124:                     Maintains state machines of system modules.
125:                 */
126:                 static void _SYS_Tasks ( void)
127:                 {
9D014630  27BDFFE0   ADDIU SP, SP, -32
9D014634  AFBF001C   SW RA, 28(SP)
9D014638  AFB10018   SW S1, 24(SP)
9D01463C  AFB00014   SW S0, 20(SP)
128:                     while(1)
129:                     {
130:                         /* Maintain system services */
131:                         SYS_RTCC_Tasks(sysObj.sysRtcc);
9D014640  3C11A000   LUI S1, -24576
9D014644  0F404C3E   JAL SYS_RTCC_Tasks
9D014648  8E241020   LW A0, 4128(S1)
132:                     SYS_MSG_Tasks( (SYS_OBJ_HANDLE) sysObj.sysMsg0 );
9D01464C  26301020   ADDIU S0, S1, 4128
9D014650  0F402161   JAL SYS_MSG_Tasks
9D014654  8E04001C   LW A0, 28(S0)
133:                 
134:                         /* Maintain Device Drivers */
135:                  
136:                  
137:                 
138:                         /* Maintain Middleware */
139:                 
140:                  
141:                     /* USB FS Driver Task Routine */ 
142:                      DRV_USBFS_Tasks(sysObj.drvUSBObject);
9D014658  0F405684   JAL DRV_USBFS_Tasks
9D01465C  8E040020   LW A0, 32(S0)
143:                      
144:                     /* USB Device layer tasks routine */ 
145:                     USB_DEVICE_Tasks(sysObj.usbDevObject0);
9D014660  0F40332D   JAL USB_DEVICE_Tasks
9D014664  8E040024   LW A0, 36(S0)
146:                  
147:                 
148:                         /* Task Delay */
149:                         vTaskDelay(1000 / portTICK_PERIOD_MS);
9D014668  0F405001   JAL vTaskDelay
9D01466C  240400FA   ADDIU A0, ZERO, 250
9D014670  0B405191   J 0x9D014644
9D014674  00000000   NOP
150:                     }
151:                 }
152:                 
153:                 void _SYS_DMA_Tasks(void)
154:                  {
9D015768  27BDFFE8   ADDIU SP, SP, -24
9D01576C  AFBF0014   SW RA, 20(SP)
155:                     while(1)
156:                     {
157:                         vTaskDelay(100 / portTICK_PERIOD_MS);
9D015770  0F405001   JAL vTaskDelay
9D015774  24040019   ADDIU A0, ZERO, 25
9D015778  0B4055DC   J 0x9D015770
9D01577C  00000000   NOP
158:                     }
159:                  }
160:                  
161:                  
162:                 
163:                 
164:                 /*******************************************************************************
165:                   Function:
166:                     void _DOORBELL_Tasks ( void )
167:                 
168:                   Summary:
169:                     Maintains state machine of DOORBELL.
170:                 */
171:                 
172:                 static void _DOORBELL_Tasks(void)
173:                 {
9D015644  27BDFFE8   ADDIU SP, SP, -24
9D015648  AFBF0014   SW RA, 20(SP)
174:                     while(1)
175:                     {
176:                         DOORBELL_Tasks();
9D01564C  0F405549   JAL DOORBELL_Tasks
9D015650  00000000   NOP
177:                         vTaskDelay(100 / portTICK_PERIOD_MS);
9D015654  0F405001   JAL vTaskDelay
9D015658  24040019   ADDIU A0, ZERO, 25
9D01565C  0B405593   J 0x9D01564C
9D015660  00000000   NOP
178:                     }
179:                 }
180:                 
181:                 
182:                 /*******************************************************************************
183:                  End of File
184:                  */
---  /home/whatisthis/src/DoorBell_PIC32/firmware/src/system_config/default/system_interrupt_a.S  -------
                                                  1:     /*******************************************************************************
                                                  2:      System Interrupt Source File
                                                  3:     
                                                  4:       File Name:
                                                  5:         sys_interrupt_a.S
                                                  6:     
                                                  7:       Summary:
                                                  8:         Raw ISR definitions.
                                                  9:     
                                                  10:      Description:
                                                  11:        This file contains a definitions of the raw ISRs required to support the 
                                                  12:        interrupt sub-system.
                                                  13:    *******************************************************************************/
                                                  14:    
                                                  15:    // DOM-IGNORE-BEGIN
                                                  16:    /*******************************************************************************
                                                  17:    Copyright (c) 2011-2014 released Microchip Technology Inc.  All rights reserved.
                                                  18:    
                                                  19:    Microchip licenses to you the right to use, modify, copy and distribute
                                                  20:    Software only when embedded on a Microchip microcontroller or digital signal
                                                  21:    controller that is integrated into your product or third party product
                                                  22:    (pursuant to the sublicense terms in the accompanying license agreement).
                                                  23:    
                                                  24:    You should refer to the license agreement accompanying this Software for
                                                  25:    additional information regarding your rights and obligations.
                                                  26:    
                                                  27:    SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
                                                  28:    EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
                                                  29:    MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
                                                  30:    IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
                                                  31:    CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
                                                  32:    OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
                                                  33:    INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
                                                  34:    CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
                                                  35:    SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
                                                  36:    (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
                                                  37:     *******************************************************************************/
                                                  38:    // DOM-IGNORE-END
                                                  39:    /*
                                                  40:    *********************************************************************************************************
                                                  41:    *                                           INCLUDES
                                                  42:    *********************************************************************************************************
                                                  43:    */
                                                  44:    #include <xc.h>
                                                  45:    
                                                  46:    
                                                  47:    
                                                  48:    #include "ISR_Support.h"
                                                  49:    
                                                  50:    
                                                  51:    /* External Interrupt Instance 0 Interrupt */
                                                  52:       .extern  IntHandlerExternalInterruptInstance0
                                                  53:    
                                                  54:       .section	.vector_3,code, keep
                                                  55:       .equ     __vector_dispatch_3, IntVectorExternalInterruptInstance0
                                                  56:       .global  __vector_dispatch_3
                                                  57:       .set     nomicromips
                                                  58:       .set     noreorder
                                                  59:       .set     nomips16
                                                  60:       .set     noat
                                                  61:       .ent  IntVectorExternalInterruptInstance0
                                                  62:    
                                                  63:    IntVectorExternalInterruptInstance0:
9D01F260  3C1A9D01   LUI K0, -25343               64:        la    $26,  _IntHandlerExternalInterruptInstance0         
9D01F268  03400008   JR K0                        65:        jr    $26
9D01F26C  00000000   NOP                          66:        nop
                                                  67:    	.end	IntVectorExternalInterruptInstance0
                                                  68:    
                                                  69:       .section	.ExternalInterruptInstance0_vector_text, code, keep
                                                  70:       .set     nomicromips
                                                  71:       .set     noreorder
                                                  72:       .set     nomips16
                                                  73:       .set     noat
                                                  74:       .ent  _IntHandlerExternalInterruptInstance0
                                                  75:    
                                                  76:    _IntHandlerExternalInterruptInstance0:
9D00AC4C  401A6800   MFC0 K0, Cause               77:        portSAVE_CONTEXT
9D00AD28  3C169D01   LUI S6, -25343               78:        la    s6,  IntHandlerExternalInterruptInstance0
9D00AD30  02C0F809   JALR S6                      79:        jalr  s6
9D00AD34  00000000   NOP                          80:        nop
9D00AD38  3C16A000   LUI S6, -24576               81:        portRESTORE_CONTEXT
                                                  82:        .end	_IntHandlerExternalInterruptInstance0
                                                  83:    
                                                  84:    
                                                  85:     
                                                  86:    
                                                  87:    /* TMR Instance 0 Interrupt */
                                                  88:       .extern  IntHandlerDrvTmrInstance0
                                                  89:    
                                                  90:       .section	.vector_16,code, keep
                                                  91:       .equ     __vector_dispatch_16, IntVectorDrvTmrInstance0
                                                  92:       .global  __vector_dispatch_16
                                                  93:       .set     nomicromips
                                                  94:       .set     noreorder
                                                  95:       .set     nomips16
                                                  96:       .set     noat
                                                  97:       .ent  IntVectorDrvTmrInstance0
                                                  98:    
                                                  99:    IntVectorDrvTmrInstance0:
9D01F400  3C1A9D01   LUI K0, -25343               100:       la    $26,  _IntHandlerDrvTmrInstance0         
9D01F408  03400008   JR K0                        101:       jr    $26
9D01F40C  00000000   NOP                          102:       nop
                                                  103:   	.end	IntVectorDrvTmrInstance0
                                                  104:   
                                                  105:      .section	.DrvTmrInstance0_vector_text, code, keep
                                                  106:      .set     nomicromips
                                                  107:      .set     noreorder
                                                  108:      .set     nomips16
                                                  109:      .set     noat
                                                  110:      .ent  _IntHandlerDrvTmrInstance0
                                                  111:   
                                                  112:   _IntHandlerDrvTmrInstance0:
9D00AE00  401A6800   MFC0 K0, Cause               113:       portSAVE_CONTEXT
9D00AEDC  3C169D01   LUI S6, -25343               114:       la    s6,  IntHandlerDrvTmrInstance0
9D00AEE4  02C0F809   JALR S6                      115:       jalr  s6
9D00AEE8  00000000   NOP                          116:       nop
9D00AEEC  3C16A000   LUI S6, -24576               117:       portRESTORE_CONTEXT
                                                  118:       .end	_IntHandlerDrvTmrInstance0
                                                  119:   
                                                  120:   
                                                  121:   /* TMR Instance 1 Interrupt */
                                                  122:      .extern  IntHandlerDrvTmrInstance1
                                                  123:   
                                                  124:      .section	.vector_12,code, keep
                                                  125:      .equ     __vector_dispatch_12, IntVectorDrvTmrInstance1
                                                  126:      .global  __vector_dispatch_12
                                                  127:      .set     nomicromips
                                                  128:      .set     noreorder
                                                  129:      .set     nomips16
                                                  130:      .set     noat
                                                  131:      .ent  IntVectorDrvTmrInstance1
                                                  132:   
                                                  133:   IntVectorDrvTmrInstance1:
9D01F380  3C1A9D01   LUI K0, -25343               134:       la    $26,  _IntHandlerDrvTmrInstance1         
9D01F388  03400008   JR K0                        135:       jr    $26
9D01F38C  00000000   NOP                          136:       nop
                                                  137:   	.end	IntVectorDrvTmrInstance1
                                                  138:   
                                                  139:      .section	.DrvTmrInstance1_vector_text, code, keep
                                                  140:      .set     nomicromips
                                                  141:      .set     noreorder
                                                  142:      .set     nomips16
                                                  143:      .set     noat
                                                  144:      .ent  _IntHandlerDrvTmrInstance1
                                                  145:   
                                                  146:   _IntHandlerDrvTmrInstance1:
9D00AFB4  401A6800   MFC0 K0, Cause               147:       portSAVE_CONTEXT
9D00B090  3C169D01   LUI S6, -25343               148:       la    s6,  IntHandlerDrvTmrInstance1
9D00B098  02C0F809   JALR S6                      149:       jalr  s6
9D00B09C  00000000   NOP                          150:       nop
9D00B0A0  3C16A000   LUI S6, -24576               151:       portRESTORE_CONTEXT
                                                  152:       .end	_IntHandlerDrvTmrInstance1
                                                  153:   
                                                  154:   
                                                  155:   /* TMR Instance 2 Interrupt */
                                                  156:      .extern  IntHandlerDrvTmrInstance2
                                                  157:   
                                                  158:      .section	.vector_8,code, keep
                                                  159:      .equ     __vector_dispatch_8, IntVectorDrvTmrInstance2
                                                  160:      .global  __vector_dispatch_8
                                                  161:      .set     nomicromips
                                                  162:      .set     noreorder
                                                  163:      .set     nomips16
                                                  164:      .set     noat
                                                  165:      .ent  IntVectorDrvTmrInstance2
                                                  166:   
                                                  167:   IntVectorDrvTmrInstance2:
9D01F300  3C1A9D01   LUI K0, -25343               168:       la    $26,  _IntHandlerDrvTmrInstance2         
9D01F308  03400008   JR K0                        169:       jr    $26
9D01F30C  00000000   NOP                          170:       nop
                                                  171:   	.end	IntVectorDrvTmrInstance2
                                                  172:   
                                                  173:      .section	.DrvTmrInstance2_vector_text, code, keep
                                                  174:      .set     nomicromips
                                                  175:      .set     noreorder
                                                  176:      .set     nomips16
                                                  177:      .set     noat
                                                  178:      .ent  _IntHandlerDrvTmrInstance2
                                                  179:   
                                                  180:   _IntHandlerDrvTmrInstance2:
9D00B168  401A6800   MFC0 K0, Cause               181:       portSAVE_CONTEXT
9D00B244  3C169D01   LUI S6, -25343               182:       la    s6,  IntHandlerDrvTmrInstance2
9D00B24C  02C0F809   JALR S6                      183:       jalr  s6
9D00B250  00000000   NOP                          184:       nop
9D00B254  3C16A000   LUI S6, -24576               185:       portRESTORE_CONTEXT
                                                  186:       .end	_IntHandlerDrvTmrInstance2
                                                  187:   
                                                  188:   
                                                  189:   
                                                  190:   
                                                  191:   /* USART Instance 0 Interrupt */
                                                  192:   
                                                  193:      .extern  IntHandlerDrvUsartInstance0
                                                  194:   
                                                  195:      .section	.vector_32,code, keep
                                                  196:      .equ     __vector_dispatch_32, IntVectorDrvUsartInstance0
                                                  197:      .global  __vector_dispatch_32
                                                  198:      .set     nomicromips
                                                  199:      .set     noreorder
                                                  200:      .set     nomips16
                                                  201:      .set     noat
                                                  202:      .ent  IntVectorDrvUsartInstance0
                                                  203:   
                                                  204:   IntVectorDrvUsartInstance0:
9D01F600  3C1A9D01   LUI K0, -25343               205:       la    $26,  _IntHandlerDrvUsartInstance0         
9D01F608  03400008   JR K0                        206:       jr    $26
9D01F60C  00000000   NOP                          207:       nop
                                                  208:   	.end	IntVectorDrvUsartInstance0
                                                  209:   
                                                  210:      .section	.DrvUsartInstance0_vector_text, code, keep
                                                  211:      .set     nomicromips
                                                  212:      .set     noreorder
                                                  213:      .set     nomips16
                                                  214:      .set     noat
                                                  215:      .ent  _IntHandlerDrvUsartInstance0
                                                  216:   
                                                  217:   _IntHandlerDrvUsartInstance0:
9D00B31C  401A6800   MFC0 K0, Cause               218:       portSAVE_CONTEXT
9D00B3F8  3C169D01   LUI S6, -25343               219:       la    s6,  IntHandlerDrvUsartInstance0
9D00B400  02C0F809   JALR S6                      220:       jalr  s6
9D00B404  00000000   NOP                          221:       nop
9D00B408  3C16A000   LUI S6, -24576               222:       portRESTORE_CONTEXT
                                                  223:       .end	_IntHandlerDrvUsartInstance0
                                                  224:   
                                                  225:   
                                                  226:   
                                                  227:   /* Sytem DMA Instance 0 Interrupt */
                                                  228:      .extern  IntHandlerSysDmaInstance0
                                                  229:   
                                                  230:      .section	.vector_40,code, keep
                                                  231:      .equ     __vector_dispatch_40, IntVectorSysDmaInstance0
                                                  232:      .global  __vector_dispatch_40
                                                  233:      .set     nomicromips
                                                  234:      .set     noreorder
                                                  235:      .set     nomips16
                                                  236:      .set     noat
                                                  237:      .ent  IntVectorSysDmaInstance0
                                                  238:   
                                                  239:   IntVectorSysDmaInstance0:
9D01F700  3C1A9D01   LUI K0, -25343               240:       la    $26,  _IntHandlerSysDmaInstance0         
9D01F708  03400008   JR K0                        241:       jr    $26
9D01F70C  00000000   NOP                          242:       nop
                                                  243:   	.end	IntVectorSysDmaInstance0
                                                  244:   
                                                  245:      .section	.SysDmaInstance0_vector_text, code, keep
                                                  246:      .set     nomicromips
                                                  247:      .set     noreorder
                                                  248:      .set     nomips16
                                                  249:      .set     noat
                                                  250:      .ent  _IntHandlerSysDmaInstance0
                                                  251:   
                                                  252:   _IntHandlerSysDmaInstance0:
9D00B4D0  401A6800   MFC0 K0, Cause               253:       portSAVE_CONTEXT
9D00B5AC  3C169D01   LUI S6, -25343               254:       la    s6,  IntHandlerSysDmaInstance0
9D00B5B4  02C0F809   JALR S6                      255:       jalr  s6
9D00B5B8  00000000   NOP                          256:       nop
9D00B5BC  3C16A000   LUI S6, -24576               257:       portRESTORE_CONTEXT
                                                  258:       .end	_IntHandlerSysDmaInstance0
                                                  259:   
                                                  260:   
                                                  261:   /* Sytem DMA Instance 1 Interrupt */
                                                  262:      .extern  IntHandlerSysDmaInstance1
                                                  263:   
                                                  264:      .section	.vector_41,code, keep
                                                  265:      .equ     __vector_dispatch_41, IntVectorSysDmaInstance1
                                                  266:      .global  __vector_dispatch_41
                                                  267:      .set     nomicromips
                                                  268:      .set     noreorder
                                                  269:      .set     nomips16
                                                  270:      .set     noat
                                                  271:      .ent  IntVectorSysDmaInstance1
                                                  272:   
                                                  273:   IntVectorSysDmaInstance1:
9D01F720  3C1A9D01   LUI K0, -25343               274:       la    $26,  _IntHandlerSysDmaInstance1         
9D01F728  03400008   JR K0                        275:       jr    $26
9D01F72C  00000000   NOP                          276:       nop
                                                  277:   	.end	IntVectorSysDmaInstance1
                                                  278:   
                                                  279:      .section	.SysDmaInstance1_vector_text, code, keep
                                                  280:      .set     nomicromips
                                                  281:      .set     noreorder
                                                  282:      .set     nomips16
                                                  283:      .set     noat
                                                  284:      .ent  _IntHandlerSysDmaInstance1
                                                  285:   
                                                  286:   _IntHandlerSysDmaInstance1:
9D00B684  401A6800   MFC0 K0, Cause               287:       portSAVE_CONTEXT
9D00B760  3C169D01   LUI S6, -25343               288:       la    s6,  IntHandlerSysDmaInstance1
9D00B768  02C0F809   JALR S6                      289:       jalr  s6
9D00B76C  00000000   NOP                          290:       nop
9D00B770  3C16A000   LUI S6, -24576               291:       portRESTORE_CONTEXT
                                                  292:       .end	_IntHandlerSysDmaInstance1
                                                  293:   
                                                  294:   
                                                  295:   
                                                  296:   /* I2C Instance 0 Interrupt */
                                                  297:   
                                                  298:      .extern  IntHandlerDrvI2CInstance0
                                                  299:   
                                                  300:      .section	.vector_33,code, keep
                                                  301:      .equ     __vector_dispatch_33, IntVectorDrvI2CInstance0
                                                  302:      .global  __vector_dispatch_33
                                                  303:      .set     nomicromips
                                                  304:      .set     noreorder
                                                  305:      .set     nomips16
                                                  306:      .set     noat
                                                  307:      .ent  IntVectorDrvI2CInstance0
                                                  308:   
                                                  309:   IntVectorDrvI2CInstance0:
9D01F620  3C1A9D01   LUI K0, -25343               310:       la    $26,  _IntHandlerDrvI2CInstance0         
9D01F628  03400008   JR K0                        311:       jr    $26
9D01F62C  00000000   NOP                          312:       nop
                                                  313:   	.end	IntVectorDrvI2CInstance0
                                                  314:   
                                                  315:      .section	.DrvI2CInstance0_vector_text, code, keep
                                                  316:      .set     nomicromips
                                                  317:      .set     noreorder
                                                  318:      .set     nomips16
                                                  319:      .set     noat
                                                  320:      .ent  _IntHandlerDrvI2CInstance0
                                                  321:   
                                                  322:   _IntHandlerDrvI2CInstance0:
9D00B838  401A6800   MFC0 K0, Cause               323:       portSAVE_CONTEXT
9D00B914  3C169D01   LUI S6, -25343               324:       la    s6,  IntHandlerDrvI2CInstance0
9D00B91C  02C0F809   JALR S6                      325:       jalr  s6
9D00B920  00000000   NOP                          326:       nop
9D00B924  3C16A000   LUI S6, -24576               327:       portRESTORE_CONTEXT
                                                  328:       .end	_IntHandlerDrvI2CInstance0
                                                  329:   
                                                  330:   
                                                  331:   
                                                  332:   /* USB Device Interrupt */
                                                  333:      .extern  IntHandlerUSBInstance0
                                                  334:   
                                                  335:      .section	.vector_30,code, keep
                                                  336:      .equ     __vector_dispatch_30, IntVectorUSBInstance0
                                                  337:      .global  __vector_dispatch_30
                                                  338:      .set     nomicromips
                                                  339:      .set     noreorder
                                                  340:      .set     nomips16
                                                  341:      .set     noat
                                                  342:      .ent  IntVectorUSBInstance0
                                                  343:   
                                                  344:   IntVectorUSBInstance0:
9D01F5C0  3C1A9D01   LUI K0, -25343               345:       la    $26,  _IntHandlerUSBInstance0         
9D01F5C8  03400008   JR K0                        346:       jr    $26
9D01F5CC  00000000   NOP                          347:       nop
                                                  348:   	.end	IntVectorUSBInstance0
                                                  349:   
                                                  350:      .section	.USBInstance0_vector_text, code, keep
                                                  351:      .set     nomicromips
                                                  352:      .set     noreorder
                                                  353:      .set     nomips16
                                                  354:      .set     noat
                                                  355:      .ent  _IntHandlerUSBInstance0
                                                  356:   
                                                  357:   _IntHandlerUSBInstance0:
9D00B9EC  401A6800   MFC0 K0, Cause               358:       portSAVE_CONTEXT
9D00BAC8  3C169D01   LUI S6, -25343               359:       la    s6,  IntHandlerUSBInstance0
9D00BAD0  02C0F809   JALR S6                      360:       jalr  s6
9D00BAD4  00000000   NOP                          361:       nop
9D00BAD8  3C16A000   LUI S6, -24576               362:       portRESTORE_CONTEXT
                                                  363:       .end	_IntHandlerUSBInstance0
                                                  364:   
                                                  365:   
                                                  366:   
                                                  367:   /*******************************************************************************
                                                  368:    End of File
                                                  369:    */
                                                  370:   
---  /home/whatisthis/src/DoorBell_PIC32/firmware/src/system_config/default/system_interrupt.c  ---------
1:                   /*******************************************************************************
2:                    System Interrupts File
3:                   
4:                     File Name:
5:                       system_interrupt.c
6:                   
7:                     Summary:
8:                       Raw ISR definitions.
9:                   
10:                    Description:
11:                      This file contains a definitions of the raw ISRs required to support the
12:                      interrupt sub-system.
13:                  
14:                    Summary:
15:                      This file contains source code for the interrupt vector functions in the
16:                      system.
17:                  
18:                    Description:
19:                      This file contains source code for the interrupt vector functions in the
20:                      system.  It implements the system and part specific vector "stub" functions
21:                      from which the individual "Tasks" functions are called for any modules
22:                      executing interrupt-driven in the MPLAB Harmony system.
23:                  
24:                    Remarks:
25:                      This file requires access to the systemObjects global data structure that
26:                      contains the object handles to all MPLAB Harmony module objects executing
27:                      interrupt-driven in the system.  These handles are passed into the individual
28:                      module "Tasks" functions to identify the instance of the module to maintain.
29:                   *******************************************************************************/
30:                  
31:                  // DOM-IGNORE-BEGIN
32:                  /*******************************************************************************
33:                  Copyright (c) 2011-2014 released Microchip Technology Inc.  All rights reserved.
34:                  
35:                  Microchip licenses to you the right to use, modify, copy and distribute
36:                  Software only when embedded on a Microchip microcontroller or digital signal
37:                  controller that is integrated into your product or third party product
38:                  (pursuant to the sublicense terms in the accompanying license agreement).
39:                  
40:                  You should refer to the license agreement accompanying this Software for
41:                  additional information regarding your rights and obligations.
42:                  
43:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
44:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
45:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
46:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
47:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
48:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
49:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
50:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
51:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
52:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
53:                   *******************************************************************************/
54:                  // DOM-IGNORE-END
55:                  
56:                  // *****************************************************************************
57:                  // *****************************************************************************
58:                  // Section: Included Files
59:                  // *****************************************************************************
60:                  // *****************************************************************************
61:                  
62:                  #include "system/common/sys_common.h"
63:                  #include "doorbell.h"
64:                  #include "system_definitions.h"
65:                  
66:                  // *****************************************************************************
67:                  // *****************************************************************************
68:                  // Section: System Interrupt Vector Functions
69:                  // *****************************************************************************
70:                  // *****************************************************************************
71:                  
72:                  
73:                  void IntHandlerDrvI2CInstance0(void)
74:                  {
9D015604  27BDFFE8   ADDIU SP, SP, -24
9D015608  AFBF0014   SW RA, 20(SP)
75:                      DRV_I2C_Tasks(sysObj.drvI2C0);
9D01560C  3C02A000   LUI V0, -24576
9D015610  0F400DA9   JAL DRV_I2C_Tasks
9D015614  8C441038   LW A0, 4152(V0)
76:                   
77:                  }
9D015618  8FBF0014   LW RA, 20(SP)
9D01561C  03E00008   JR RA
9D015620  27BD0018   ADDIU SP, SP, 24
78:                       
79:                   
80:                     
81:                  
82:                   
83:                   
84:                   
85:                  
86:                   
87:                  
88:                  
89:                  
90:                  
91:                   void IntHandlerDrvUsartInstance0(void)
92:                  {
9D014C00  27BDFFE8   ADDIU SP, SP, -24
9D014C04  AFBF0014   SW RA, 20(SP)
9D014C08  AFB00010   SW S0, 16(SP)
93:                      DRV_USART_TasksTransmit(sysObj.drvUsart0);
9D014C0C  3C10A000   LUI S0, -24576
9D014C10  26101020   ADDIU S0, S0, 4128
9D014C14  0F4046F5   JAL DRV_USART_TasksTransmit
9D014C18  8E040014   LW A0, 20(S0)
94:                      DRV_USART_TasksError(sysObj.drvUsart0);
9D014C1C  0F40471E   JAL DRV_USART_TasksError
9D014C20  8E040014   LW A0, 20(S0)
95:                      DRV_USART_TasksReceive(sysObj.drvUsart0);
9D014C24  0F4046CC   JAL DRV_USART_TasksReceive
9D014C28  8E040014   LW A0, 20(S0)
96:                  }
9D014C2C  8FBF0014   LW RA, 20(SP)
9D014C30  8FB00010   LW S0, 16(SP)
9D014C34  03E00008   JR RA
9D014C38  27BD0018   ADDIU SP, SP, 24
97:                   
98:                   
99:                   
100:                 
101:                  
102:                 
103:                  
104:                 
105:                  
106:                 
107:                  
108:                 
109:                  
110:                  
111:                 
112:                 void IntHandlerSysDmaInstance0(void)
113:                 {          
9D01544C  27BDFFE8   ADDIU SP, SP, -24
9D015450  AFBF0014   SW RA, 20(SP)
114:                     SYS_DMA_TasksISR(sysObj.sysDma, DMA_CHANNEL_0);
9D015454  3C02A000   LUI V0, -24576
9D015458  8C441024   LW A0, 4132(V0)
9D01545C  0F403F41   JAL SYS_DMA_TasksISR
9D015460  00002821   ADDU A1, ZERO, ZERO
115:                 }
9D015464  8FBF0014   LW RA, 20(SP)
9D015468  03E00008   JR RA
9D01546C  27BD0018   ADDIU SP, SP, 24
116:                 
117:                 void IntHandlerSysDmaInstance1(void)
118:                 {          
9D015470  27BDFFE8   ADDIU SP, SP, -24
9D015474  AFBF0014   SW RA, 20(SP)
119:                     SYS_DMA_TasksISR(sysObj.sysDma, DMA_CHANNEL_1);
9D015478  3C02A000   LUI V0, -24576
9D01547C  8C441024   LW A0, 4132(V0)
9D015480  0F403F41   JAL SYS_DMA_TasksISR
9D015484  24050001   ADDIU A1, ZERO, 1
120:                 }
9D015488  8FBF0014   LW RA, 20(SP)
9D01548C  03E00008   JR RA
9D015490  27BD0018   ADDIU SP, SP, 24
121:                 
122:                 
123:                 void __ISR(_RTCC_VECTOR, ipl2AUTO) _IntHandlerSysRtcc (void)
124:                 {
9D00E5E4  415DE800   RDPGPR SP, SP
9D00E5E8  401B7000   MFC0 K1, EPC
9D00E5EC  401A6002   MFC0 K0, SRSCtl
9D00E5F0  27BDFF90   ADDIU SP, SP, -112
9D00E5F4  AFBB006C   SW K1, 108(SP)
9D00E5F8  401B6000   MFC0 K1, Status
9D00E5FC  AFBA0064   SW K0, 100(SP)
9D00E600  AFBB0068   SW K1, 104(SP)
9D00E604  7C1B7844   INS K1, ZERO, 1, 15
9D00E608  377B0800   ORI K1, K1, 2048
9D00E60C  409B6000   MTC0 K1, Status
9D00E610  AFA30018   SW V1, 24(SP)
9D00E614  AFA20014   SW V0, 20(SP)
9D00E618  8FA30064   LW V1, 100(SP)
9D00E61C  3063000F   ANDI V1, V1, 15
9D00E620  14600011   BNE V1, ZERO, 0x9D00E668
9D00E624  00000000   NOP
9D00E628  AFBF0054   SW RA, 84(SP)
9D00E62C  AFB90050   SW T9, 80(SP)
9D00E630  AFB8004C   SW T8, 76(SP)
9D00E634  AFAF0048   SW T7, 72(SP)
9D00E638  AFAE0044   SW T6, 68(SP)
9D00E63C  AFAD0040   SW T5, 64(SP)
9D00E640  AFAC003C   SW T4, 60(SP)
9D00E644  AFAB0038   SW T3, 56(SP)
9D00E648  AFAA0034   SW T2, 52(SP)
9D00E64C  AFA90030   SW T1, 48(SP)
9D00E650  AFA8002C   SW T0, 44(SP)
9D00E654  AFA70028   SW A3, 40(SP)
9D00E658  AFA60024   SW A2, 36(SP)
9D00E65C  AFA50020   SW A1, 32(SP)
9D00E660  AFA4001C   SW A0, 28(SP)
9D00E664  AFA10010   SW AT, 16(SP)
9D00E668  00001012   MFLO V0
9D00E66C  AFA2005C   SW V0, 92(SP)
9D00E670  00001810   MFHI V1
9D00E674  AFA30058   SW V1, 88(SP)
125:                     SYS_RTCC_Tasks(sysObj.sysRtcc);
9D00E678  3C02A000   LUI V0, -24576
9D00E67C  0F404C3E   JAL SYS_RTCC_Tasks
9D00E680  8C441020   LW A0, 4128(V0)
126:                 }
9D00E684  8FA2005C   LW V0, 92(SP)
9D00E688  00400013   MTLO V0
9D00E68C  8FA30058   LW V1, 88(SP)
9D00E690  00600011   MTHI V1
9D00E694  8FA20064   LW V0, 100(SP)
9D00E698  3042000F   ANDI V0, V0, 15
9D00E69C  14400013   BNE V0, ZERO, 0x9D00E6EC
9D00E6A0  00000000   NOP
9D00E6A4  8FBF0054   LW RA, 84(SP)
9D00E6A8  8FB90050   LW T9, 80(SP)
9D00E6AC  8FB8004C   LW T8, 76(SP)
9D00E6B0  8FAF0048   LW T7, 72(SP)
9D00E6B4  8FAE0044   LW T6, 68(SP)
9D00E6B8  8FAD0040   LW T5, 64(SP)
9D00E6BC  8FAC003C   LW T4, 60(SP)
9D00E6C0  8FAB0038   LW T3, 56(SP)
9D00E6C4  8FAA0034   LW T2, 52(SP)
9D00E6C8  8FA90030   LW T1, 48(SP)
9D00E6CC  8FA8002C   LW T0, 44(SP)
9D00E6D0  8FA70028   LW A3, 40(SP)
9D00E6D4  8FA60024   LW A2, 36(SP)
9D00E6D8  8FA50020   LW A1, 32(SP)
9D00E6DC  8FA4001C   LW A0, 28(SP)
9D00E6E0  8FA30018   LW V1, 24(SP)
9D00E6E4  8FA20014   LW V0, 20(SP)
9D00E6E8  8FA10010   LW AT, 16(SP)
9D00E6EC  41606000   DI ZERO
9D00E6F0  000000C0   EHB
9D00E6F4  8FBA006C   LW K0, 108(SP)
9D00E6F8  8FBB0068   LW K1, 104(SP)
9D00E6FC  409A7000   MTC0 K0, EPC
9D00E700  8FBA0064   LW K0, 100(SP)
9D00E704  27BD0070   ADDIU SP, SP, 112
9D00E708  409A6002   MTC0 K0, SRSCtl
9D00E70C  41DDE800   WRPGPR SP, SP
9D00E710  409B6000   MTC0 K1, Status
9D00E714  42000018   ERET
127:                 void IntHandlerExternalInterruptInstance0(void)
128:                 {
129:                     PLIB_INT_SourceFlagClear(INT_ID_0, INT_SOURCE_EXTERNAL_0);
130:                 }
131:                  
132:                 
133:                 void IntHandlerDrvTmrInstance0(void)
134:                 {
135:                     PLIB_INT_SourceFlagClear(INT_ID_0,INT_SOURCE_TIMER_4);
136:                 }
137:                 void IntHandlerDrvTmrInstance1(void)
138:                 {
9D0151B0  27BDFFE8   ADDIU SP, SP, -24
9D0151B4  AFBF0014   SW RA, 20(SP)
139:                     PLIB_INT_SourceFlagClear(INT_ID_0,INT_SOURCE_TIMER_3);
140:                     DRV_TMR1_Tasks();
9D0151C8  0F404DAA   JAL DRV_TMR1_Tasks
9D0151CC  00000000   NOP
141:                 }
9D0151D0  8FBF0014   LW RA, 20(SP)
9D0151D4  03E00008   JR RA
9D0151D8  27BD0018   ADDIU SP, SP, 24
142:                 void IntHandlerDrvTmrInstance2(void)
143:                 {
144:                     PLIB_INT_SourceFlagClear(INT_ID_0,INT_SOURCE_TIMER_2);
145:                 }
146:                  
147:                 void IntHandlerUSBInstance0(void)
148:                 
149:                 {
9D015624  27BDFFE8   ADDIU SP, SP, -24
9D015628  AFBF0014   SW RA, 20(SP)
150:                     DRV_USBFS_Tasks_ISR(sysObj.drvUSBObject);
9D01562C  3C02A000   LUI V0, -24576
9D015630  0F404B63   JAL DRV_USBFS_Tasks_ISR
9D015634  8C441040   LW A0, 4160(V0)
151:                 }
9D015638  8FBF0014   LW RA, 20(SP)
9D01563C  03E00008   JR RA
9D015640  27BD0018   ADDIU SP, SP, 24
152:                 
153:                 /*******************************************************************************
154:                  End of File
155:                 */
---  /home/whatisthis/src/DoorBell_PIC32/firmware/src/system_config/default/system_init.c  --------------
1:                   /*******************************************************************************
2:                     System Initialization File
3:                   
4:                     File Name:
5:                       system_init.c
6:                   
7:                     Summary:
8:                       This file contains source code necessary to initialize the system.
9:                   
10:                    Description:
11:                      This file contains source code necessary to initialize the system.  It
12:                      implements the "SYS_Initialize" function, defines the configuration bits,
13:                      and allocates any necessary global system resources, such as the
14:                      sysObj structure that contains the object handles to all the MPLAB Harmony
15:                      module objects in the system.
16:                   *******************************************************************************/
17:                  
18:                  // DOM-IGNORE-BEGIN
19:                  /*******************************************************************************
20:                  Copyright (c) 2013-2015 released Microchip Technology Inc.  All rights reserved.
21:                  
22:                  Microchip licenses to you the right to use, modify, copy and distribute
23:                  Software only when embedded on a Microchip microcontroller or digital signal
24:                  controller that is integrated into your product or third party product
25:                  (pursuant to the sublicense terms in the accompanying license agreement).
26:                  
27:                  You should refer to the license agreement accompanying this Software for
28:                  additional information regarding your rights and obligations.
29:                  
30:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
31:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
32:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
33:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
34:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
35:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
36:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
37:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
38:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
39:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
40:                   *******************************************************************************/
41:                  // DOM-IGNORE-END
42:                  
43:                  // *****************************************************************************
44:                  // *****************************************************************************
45:                  // Section: Included Files
46:                  // *****************************************************************************
47:                  // *****************************************************************************
48:                  
49:                  #include "system_config.h"
50:                  #include "system_definitions.h"
51:                  
52:                  
53:                  // ****************************************************************************
54:                  // ****************************************************************************
55:                  // Section: Configuration Bits
56:                  // ****************************************************************************
57:                  // ****************************************************************************
58:                  // <editor-fold defaultstate="collapsed" desc="Configuration Bits">
59:                  
60:                  /*** DEVCFG0 ***/
61:                  
62:                  #pragma config DEBUG =      ON
63:                  #pragma config JTAGEN =     OFF
64:                  #pragma config ICESEL =     ICS_PGx1
65:                  #pragma config PWP =        OFF
66:                  #pragma config BWP =        OFF
67:                  #pragma config CP =         OFF
68:                  
69:                  /*** DEVCFG1 ***/
70:                  
71:                  #pragma config FNOSC =      PRIPLL
72:                  #pragma config FSOSCEN =    ON
73:                  #pragma config IESO =       OFF
74:                  #pragma config POSCMOD =    XT
75:                  #pragma config OSCIOFNC =   OFF
76:                  #pragma config FPBDIV =     DIV_2
77:                  #pragma config FCKSM =      CSDCMD
78:                  #pragma config WDTPS =      PS1048576
79:                  #pragma config FWDTEN =     OFF
80:                  #pragma config WINDIS =     OFF
81:                  #pragma config FWDTWINSZ =  WINSZ_50
82:                  /*** DEVCFG2 ***/
83:                  
84:                  #pragma config FPLLIDIV =   DIV_1
85:                  #pragma config FPLLMUL =    MUL_20
86:                  #pragma config FPLLODIV =   DIV_4
87:                  #pragma config UPLLIDIV =   DIV_1
88:                  #pragma config UPLLEN =     ON
89:                  /*** DEVCFG3 ***/
90:                  
91:                  #pragma config USERID =     0xffff
92:                  #pragma config PMDL1WAY =   ON
93:                  #pragma config IOL1WAY =    ON
94:                  #pragma config FUSBIDIO =   ON
95:                  #pragma config FVBUSONIO =  ON
96:                  // </editor-fold>
97:                  
98:                  // *****************************************************************************
99:                  // *****************************************************************************
100:                 // Section: Driver Initialization Data
101:                 // *****************************************************************************
102:                 // *****************************************************************************
103:                 // <editor-fold defaultstate="collapsed" desc="DRV_I2C Initialization Data">
104:                 // *****************************************************************************
105:                 /* I2C Driver Initialization Data
106:                 */
107:                 
108:                 const DRV_I2C_INIT drvI2C0InitData =
109:                 {
110:                     .i2cId = DRV_I2C_PERIPHERAL_ID_IDX0,
111:                     .i2cMode = DRV_I2C_OPERATION_MODE_IDX0,
112:                     .portSCL = DRV_SCL_PORT_IDX0,
113:                 	.pinSCL  = DRV_SCL_PIN_POSITION_IDX0,
114:                 	.portSDA = DRV_SDA_PORT_IDX0,
115:                 	.pinSDA  = DRV_SDA_PIN_POSITION_IDX0,
116:                     .baudRate = DRV_I2C_BAUD_RATE_IDX0,
117:                     .busspeed = DRV_I2C_SLEW_RATE_CONTROL_IDX0,
118:                     .buslevel = DRV_I2C_SMBus_SPECIFICATION_IDX0,
119:                     .mstrInterruptSource = DRV_I2C_MASTER_INT_SRC_IDX0,
120:                     .errInterruptSource = DRV_I2C_ERR_MX_INT_SRC_IDX0,
121:                 };
122:                 
123:                 
124:                 
125:                 
126:                 // </editor-fold>
127:                 // <editor-fold defaultstate="collapsed" desc="DRV_Timer Initialization Data">
128:                 // </editor-fold>
129:                 // <editor-fold defaultstate="collapsed" desc="DRV_USART Initialization Data">
130:                 
131:                 const DRV_USART_INIT drvUsart0InitData =
132:                 {
133:                     .moduleInit.value = DRV_USART_POWER_STATE_IDX0,
134:                     .usartID = DRV_USART_PERIPHERAL_ID_IDX0, 
135:                     .mode = DRV_USART_OPER_MODE_IDX0,
136:                     .flags = DRV_USART_INIT_FLAGS_IDX0,
137:                     .brgClock = DRV_USART_BRG_CLOCK_IDX0,
138:                     .lineControl = DRV_USART_LINE_CNTRL_IDX0,
139:                     .baud = DRV_USART_BAUD_RATE_IDX0,
140:                     .handshake = DRV_USART_HANDSHAKE_MODE_IDX0,
141:                     .interruptTransmit = DRV_USART_XMIT_INT_SRC_IDX0,
142:                     .interruptReceive = DRV_USART_RCV_INT_SRC_IDX0,
143:                     .interruptError = DRV_USART_ERR_INT_SRC_IDX0,
144:                     .queueSizeTransmit = DRV_USART_XMIT_QUEUE_SIZE_IDX0,
145:                     .queueSizeReceive = DRV_USART_RCV_QUEUE_SIZE_IDX0,
146:                     .dmaChannelTransmit = DMA_CHANNEL_NONE,
147:                     .dmaInterruptTransmit = DRV_USART_XMIT_INT_SRC_IDX0,    
148:                     .dmaChannelReceive = DMA_CHANNEL_NONE,
149:                     .dmaInterruptReceive = DRV_USART_RCV_INT_SRC_IDX0,    
150:                 };
151:                 // </editor-fold>
152:                 // <editor-fold defaultstate="collapsed" desc="DRV_USB Initialization Data">
153:                 /******************************************************
154:                  * USB Driver Initialization
155:                  ******************************************************/
156:                 /****************************************************
157:                  * Endpoint Table needed by the Device Layer.
158:                  ****************************************************/
159:                 uint8_t __attribute__((aligned(512))) endPointTable[DRV_USBFS_ENDPOINTS_NUMBER * 32];
160:                 const DRV_USBFS_INIT drvUSBInit =
161:                 {
162:                     /* Assign the endpoint table */
163:                     .endpointTable= endPointTable,
164:                 
165:                     /* Interrupt Source for USB module */
166:                     .interruptSource = INT_SOURCE_USB_1,
167:                     
168:                     /* System module initialization */
169:                     .moduleInit = {SYS_MODULE_POWER_SLEEP},
170:                     
171:                     .operationMode = DRV_USBFS_OPMODE_DEVICE,
172:                     
173:                     .operationSpeed = USB_SPEED_FULL,
174:                     
175:                     /* Stop in idle */
176:                     .stopInIdle = false,
177:                 
178:                     /* Suspend in sleep */
179:                     .suspendInSleep= true,
180:                 
181:                     /* Identifies peripheral (PLIB-level) ID */
182:                     .usbID = USB_ID_1
183:                 };
184:                 // </editor-fold>
185:                 
186:                 // *****************************************************************************
187:                 // *****************************************************************************
188:                 // Section: System Data
189:                 // *****************************************************************************
190:                 // *****************************************************************************
191:                 
192:                 /* Structure to hold the object handles for the modules in the system. */
193:                 SYSTEM_OBJECTS sysObj;
194:                 
195:                 // *****************************************************************************
196:                 // *****************************************************************************
197:                 // Section: Module Initialization Data
198:                 // *****************************************************************************
199:                 // *****************************************************************************
200:                 //<editor-fold defaultstate="collapsed" desc="SYS_DMA Initialization Data">
201:                 /*** System DMA Initialization Data ***/
202:                 
203:                 const SYS_DMA_INIT sysDmaInit =
204:                 {
205:                 	.sidl = SYS_DMA_SIDL_ENABLE,
206:                 
207:                 };
208:                 // </editor-fold>
209:                 // <editor-fold defaultstate="collapsed" desc="SYS_MSG Initialization Data">
210:                 /*** Message System Initialization Data ***/
211:                 
212:                 static uint16_t queuePriorities0[2] = { 64, 32 };
213:                 SYS_MSG_INIT msg0Init =
214:                 {
215:                     .nMaxMsgsDelivered = 1,
216:                     .nMessagePriorities = 1,
217:                 };
218:                 // </editor-fold>
219:                 
220:                 // *****************************************************************************
221:                 // *****************************************************************************
222:                 // Section: Library/Stack Initialization Data
223:                 // *****************************************************************************
224:                 // *****************************************************************************
225:                 // <editor-fold defaultstate="collapsed" desc="USB Stack Initialization Data">
226:                 
227:                 
228:                 /**************************************************
229:                  * USB Device Function Driver Init Data
230:                  **************************************************/
231:                     const USB_DEVICE_CDC_INIT cdcInit0 =
232:                     {
233:                         .queueSizeRead = 1,
234:                         .queueSizeWrite = 1,
235:                         .queueSizeSerialStateNotification = 1
236:                     };
237:                 /**************************************************
238:                  * USB Device Layer Function Driver Registration 
239:                  * Table
240:                  **************************************************/
241:                 const USB_DEVICE_FUNCTION_REGISTRATION_TABLE funcRegistrationTable[1] =
242:                 {
243:                     /* Function 1 */
244:                     { 
245:                         .configurationValue = 1,    /* Configuration value */ 
246:                         .interfaceNumber = 0,       /* First interfaceNumber of this function */ 
247:                         .speed = USB_SPEED_FULL,    /* Function Speed */ 
248:                         .numberOfInterfaces = 2,    /* Number of interfaces */
249:                         .funcDriverIndex = 0,  /* Index of CDC Function Driver */
250:                         .driver = (void*)USB_DEVICE_CDC_FUNCTION_DRIVER,    /* USB CDC function data exposed to device layer */
251:                         .funcDriverInit = (void*)&cdcInit0    /* Function driver init data */
252:                     },
253:                 };
254:                 
255:                 /*******************************************
256:                  * USB Device Layer Descriptors
257:                  *******************************************/
258:                 /*******************************************
259:                  *  USB Device Descriptor 
260:                  *******************************************/
261:                 const USB_DEVICE_DESCRIPTOR deviceDescriptor =
262:                 {
263:                     0x12,                           // Size of this descriptor in bytes
264:                     USB_DESCRIPTOR_DEVICE,          // DEVICE descriptor type
265:                     0x0200,                         // USB Spec Release Number in BCD format
266:                 	USB_CDC_CLASS_CODE,         // Class Code
267:                     USB_CDC_SUBCLASS_CODE,      // Subclass code
268:                     0x00,                       // Protocol code
269:                     USB_DEVICE_EP0_BUFFER_SIZE,     // Max packet size for EP0, see system_config.h
270:                     0x04D8,                         // Vendor ID
271:                     0x000A,                         // Product ID
272:                     0x0100,                         // Device release number in BCD format
273:                     0x01,                           // Manufacturer string index
274:                     0x02,                           // Product string index
275:                     0x00,                           // Device serial number string index
276:                     0x01                            // Number of possible configurations
277:                 };
278:                 
279:                 
280:                 /*******************************************
281:                  *  USB Full Speed Configuration Descriptor
282:                  *******************************************/
283:                 const uint8_t fullSpeedConfigurationDescriptor[]=
284:                 {
285:                     /* Configuration Descriptor */
286:                 
287:                     0x09,                                               // Size of this descriptor in bytes
288:                     USB_DESCRIPTOR_CONFIGURATION,                       // Descriptor Type
289:                     67,0,                //(67 Bytes)Size of the Config descriptor.e
290:                     2,                                               // Number of interfaces in this cfg
291:                     0x01,                                               // Index value of this configuration
292:                     0x00,                                               // Configuration string index
293:                     USB_ATTRIBUTE_DEFAULT | USB_ATTRIBUTE_SELF_POWERED, // Attributes
294:                     50,                                                 // Max power consumption (2X mA)
295:                     /* Descriptor for Function 1 - CDC     */ 
296:                     
297:                     /* Interface Descriptor */
298:                 
299:                     0x09,                                           // Size of this descriptor in bytes
300:                     USB_DESCRIPTOR_INTERFACE,                       // Descriptor Type
301:                     0,                                  // Interface Number
302:                     0x00,                                           // Alternate Setting Number
303:                     0x01,                                           // Number of endpoints in this interface
304:                     USB_CDC_COMMUNICATIONS_INTERFACE_CLASS_CODE,    // Class code
305:                     USB_CDC_SUBCLASS_ABSTRACT_CONTROL_MODEL,        // Subclass code
306:                     USB_CDC_PROTOCOL_AT_V250,                       // Protocol code
307:                     0x00,                                           // Interface string index
308:                 
309:                     /* CDC Class-Specific Descriptors */
310:                 
311:                     sizeof(USB_CDC_HEADER_FUNCTIONAL_DESCRIPTOR),               // Size of the descriptor
312:                     USB_CDC_DESC_CS_INTERFACE,                                  // CS_INTERFACE
313:                     USB_CDC_FUNCTIONAL_HEADER,                                  // Type of functional descriptor
314:                     0x20,0x01,                                                  // CDC spec version
315:                 
316:                     sizeof(USB_CDC_ACM_FUNCTIONAL_DESCRIPTOR),                  // Size of the descriptor
317:                     USB_CDC_DESC_CS_INTERFACE,                                  // CS_INTERFACE
318:                     USB_CDC_FUNCTIONAL_ABSTRACT_CONTROL_MANAGEMENT,             // Type of functional descriptor
319:                     USB_CDC_ACM_SUPPORT_LINE_CODING_LINE_STATE_AND_NOTIFICATION,// bmCapabilities of ACM
320:                 
321:                     sizeof(USB_CDC_UNION_FUNCTIONAL_DESCRIPTOR_HEADER) + 1,     // Size of the descriptor
322:                     USB_CDC_DESC_CS_INTERFACE,                                  // CS_INTERFACE
323:                     USB_CDC_FUNCTIONAL_UNION,                                   // Type of functional descriptor
324:                     0,                                                       // com interface number
325:                     1,
326:                 
327:                     sizeof(USB_CDC_CALL_MANAGEMENT_DESCRIPTOR),                 // Size of the descriptor
328:                     USB_CDC_DESC_CS_INTERFACE,                                  // CS_INTERFACE
329:                     USB_CDC_FUNCTIONAL_CALL_MANAGEMENT,                         // Type of functional descriptor
330:                     0x00,                                                       // bmCapabilities of CallManagement
331:                     1,                                                       // Data interface number
332:                 
333:                     /* Interrupt Endpoint (IN) Descriptor */
334:                 
335:                     0x07,                           // Size of this descriptor
336:                     USB_DESCRIPTOR_ENDPOINT,        // Endpoint Descriptor
337:                     1 | USB_EP_DIRECTION_IN,    // EndpointAddress ( EP1 IN INTERRUPT)
338:                     USB_TRANSFER_TYPE_INTERRUPT,    // Attributes type of EP (INTERRUPT)
339:                     0x10,0x00,                      // Max packet size of this EP
340:                     0x02,                           // Interval (in ms)
341:                 
342:                     /* Interface Descriptor */
343:                 
344:                     0x09,                               // Size of this descriptor in bytes
345:                     USB_DESCRIPTOR_INTERFACE,           // INTERFACE descriptor type
346:                     1,      // Interface Number
347:                     0x00,                               // Alternate Setting Number
348:                     0x02,                               // Number of endpoints in this interface
349:                     USB_CDC_DATA_INTERFACE_CLASS_CODE,  // Class code
350:                     0x00,                               // Subclass code
351:                     USB_CDC_PROTOCOL_NO_CLASS_SPECIFIC, // Protocol code
352:                     0x00,                               // Interface string index
353:                 
354:                     /* Bulk Endpoint (OUT) Descriptor */
355:                 
356:                     0x07,                       // Size of this descriptor
357:                     USB_DESCRIPTOR_ENDPOINT,    // Endpoint Descriptor
358:                     2 | USB_EP_DIRECTION_OUT,   // EndpointAddress ( EP2 OUT )
359:                 	USB_TRANSFER_TYPE_BULK,     // Attributes type of EP (BULK)
360:                     0x40,0x00,                  // Max packet size of this EP
361:                     0x00,                       // Interval (in ms)
362:                 
363:                      /* Bulk Endpoint (IN)Descriptor */
364:                 
365:                     0x07,                       // Size of this descriptor
366:                     USB_DESCRIPTOR_ENDPOINT,    // Endpoint Descriptor
367:                     2 | USB_EP_DIRECTION_IN,    // EndpointAddress ( EP2 IN )
368:                     0x02,                       // Attributes type of EP (BULK)
369:                     0x40,0x00,                  // Max packet size of this EP
370:                     0x00,                       // Interval (in ms)
371:                 
372:                 
373:                 };
374:                 
375:                 /*******************************************
376:                  * Array of Full speed config descriptors
377:                  *******************************************/
378:                 USB_DEVICE_CONFIGURATION_DESCRIPTORS_TABLE fullSpeedConfigDescSet[1] =
379:                 {
380:                     fullSpeedConfigurationDescriptor
381:                 };
382:                 
383:                 
384:                 /**************************************
385:                  *  String descriptors.
386:                  *************************************/
387:                 
388:                  /*******************************************
389:                  *  Language code string descriptor
390:                  *******************************************/
391:                     const struct
392:                     {
393:                         uint8_t bLength;
394:                         uint8_t bDscType;
395:                         uint16_t string[1];
396:                     }
397:                     sd000 =
398:                     {
399:                         sizeof(sd000),          // Size of this descriptor in bytes
400:                         USB_DESCRIPTOR_STRING,  // STRING descriptor type
401:                         {0x0409}                // Language ID
402:                     };
403:                 /*******************************************
404:                  *  Manufacturer string descriptor
405:                  *******************************************/
406:                     const struct
407:                     {
408:                         uint8_t bLength;        // Size of this descriptor in bytes
409:                         uint8_t bDscType;       // STRING descriptor type
410:                         uint16_t string[25];    // String
411:                     }
412:                     sd001 =
413:                     {
414:                         sizeof(sd001),
415:                         USB_DESCRIPTOR_STRING,
416:                         {'M','i','c','r','o','c','h','i','p',' ','T','e','c','h','n','o','l','o','g','y',' ','I','n','c','.'}
417:                 		
418:                     };
419:                 
420:                 /*******************************************
421:                  *  Product string descriptor
422:                  *******************************************/
423:                     const struct
424:                     {
425:                         uint8_t bLength;        // Size of this descriptor in bytes
426:                         uint8_t bDscType;       // STRING descriptor type
427:                         uint16_t string[22];    // String
428:                     }
429:                     sd002 =
430:                     {
431:                         sizeof(sd002),
432:                         USB_DESCRIPTOR_STRING,
433:                 		{'S','i','m','p','l','e',' ','C','D','C',' ','D','e','v','i','c','e',' ','D','e','m','o'}
434:                     }; 
435:                 
436:                 /***************************************
437:                  * Array of string descriptors
438:                  ***************************************/
439:                 USB_DEVICE_STRING_DESCRIPTORS_TABLE stringDescriptors[3]=
440:                 {
441:                     (const uint8_t *const)&sd000,
442:                     (const uint8_t *const)&sd001,
443:                     (const uint8_t *const)&sd002
444:                 };
445:                 
446:                 /*******************************************
447:                  * USB Device Layer Master Descriptor Table 
448:                  *******************************************/
449:                 const USB_DEVICE_MASTER_DESCRIPTOR usbMasterDescriptor =
450:                 {
451:                     &deviceDescriptor,          /* Full speed descriptor */
452:                     1,                          /* Total number of full speed configurations available */
453:                     fullSpeedConfigDescSet,     /* Pointer to array of full speed configurations descriptors*/
454:                     NULL, 
455:                     0, 
456:                     NULL, 
457:                     3,                          // Total number of string descriptors available.
458:                     stringDescriptors,          // Pointer to array of string descriptors.
459:                     NULL, 
460:                     NULL
461:                 };
462:                 
463:                 
464:                 /****************************************************
465:                  * USB Device Layer Initialization Data
466:                  ****************************************************/
467:                 const USB_DEVICE_INIT usbDevInitData =
468:                 {
469:                     /* System module initialization */
470:                     .moduleInit = {SYS_MODULE_POWER_SLEEP},
471:                     
472:                     /* Number of function drivers registered to this instance of the
473:                        USB device layer */
474:                     .registeredFuncCount = 1,
475:                     
476:                     /* Function driver table registered to this instance of the USB device layer*/
477:                     .registeredFunctions = (USB_DEVICE_FUNCTION_REGISTRATION_TABLE*)funcRegistrationTable,
478:                 
479:                     /* Pointer to USB Descriptor structure */
480:                     .usbMasterDescriptor = (USB_DEVICE_MASTER_DESCRIPTOR*)&usbMasterDescriptor,
481:                 
482:                     /* USB Device Speed */
483:                     .deviceSpeed = USB_SPEED_FULL,
484:                     
485:                     /* Index of the USB Driver to be used by this Device Layer Instance */
486:                     .driverIndex = DRV_USBFS_INDEX_0,
487:                 
488:                     /* Pointer to the USB Driver Functions. */
489:                     .usbDriverInterface = DRV_USBFS_DEVICE_INTERFACE,
490:                     
491:                 };
492:                 // </editor-fold>
493:                 
494:                 // *****************************************************************************
495:                 // *****************************************************************************
496:                 // Section: System Initialization
497:                 // *****************************************************************************
498:                 // *****************************************************************************
499:                 
500:                 /*******************************************************************************
501:                   Function:
502:                     void SYS_Initialize ( void *data )
503:                 
504:                   Summary:
505:                     Initializes the board, services, drivers, application and other modules.
506:                 
507:                   Remarks:
508:                     See prototype in system/common/sys_module.h.
509:                  */
510:                 
511:                 void SYS_Initialize ( void* data )
512:                 {
9D007C68  27BDFFD8   ADDIU SP, SP, -40
9D007C6C  AFBF0024   SW RA, 36(SP)
9D007C70  AFB40020   SW S4, 32(SP)
9D007C74  AFB3001C   SW S3, 28(SP)
9D007C78  AFB20018   SW S2, 24(SP)
9D007C7C  AFB10014   SW S1, 20(SP)
9D007C80  AFB00010   SW S0, 16(SP)
513:                     /* Core Processor Initialization */
514:                     SYS_CLK_Initialize( NULL );
9D007C84  0F404625   JAL SYS_CLK_Initialize
9D007C88  00002021   ADDU A0, ZERO, ZERO
515:                     SYS_DEVCON_Initialize(SYS_DEVCON_INDEX_0, (SYS_MODULE_INIT*)NULL);
9D007C8C  00002021   ADDU A0, ZERO, ZERO
9D007C90  0F405627   JAL SYS_DEVCON_Initialize
9D007C94  00002821   ADDU A1, ZERO, ZERO
516:                     SYS_DEVCON_PerformanceConfig(SYS_CLK_SystemFrequencyGet());
9D007C98  0F405676   JAL SYS_CLK_SystemFrequencyGet
9D007C9C  3C14A000   LUI S4, -24576
9D007CA0  0F40502D   JAL SYS_DEVCON_PerformanceConfig
9D007CA4  00402021   ADDU A0, V0, ZERO
517:                     SYS_PORTS_Initialize();
9D007CA8  0F404395   JAL SYS_PORTS_Initialize
9D007CAC  26921020   ADDIU S2, S4, 4128
518:                 
519:                     /* Initialize Drivers */
520:                     sysObj.drvI2C0 = DRV_I2C_Initialize(DRV_I2C_INDEX_0, (SYS_MODULE_INIT *)&drvI2C0InitData);
9D007CB0  00002021   ADDU A0, ZERO, ZERO
9D007CB4  3C059D01   LUI A1, -25343
9D007CB8  0F40181B   JAL DRV_I2C_Initialize
9D007CBC  24A58B98   ADDIU A1, A1, -29800
9D007CC0  AE420018   SW V0, 24(S2)
521:                 
522:                 
523:                     SYS_INT_VectorPrioritySet(INT_VECTOR_I2C1, INT_PRIORITY_LEVEL1);
524:                     SYS_INT_VectorSubprioritySet(INT_VECTOR_I2C1, INT_SUBPRIORITY_LEVEL0);
525:                 
526:                 
527:                     sysObj.sysDma = SYS_DMA_Initialize((SYS_MODULE_INIT *)&sysDmaInit);
9D007CF8  3C049D01   LUI A0, -25343
9D007CFC  0F404D23   JAL SYS_DMA_Initialize
9D007D00  24848B20   ADDIU A0, A0, -29920
9D007D04  AE420004   SW V0, 4(S2)
528:                     SYS_INT_VectorPrioritySet(INT_VECTOR_DMA0, INT_PRIORITY_LEVEL1);
529:                     SYS_INT_VectorSubprioritySet(INT_VECTOR_DMA0, INT_SUBPRIORITY_LEVEL0);
530:                     SYS_INT_VectorPrioritySet(INT_VECTOR_DMA1, INT_PRIORITY_LEVEL1);
531:                     SYS_INT_VectorSubprioritySet(INT_VECTOR_DMA1, INT_SUBPRIORITY_LEVEL0);
532:                 
533:                     SYS_INT_SourceEnable(INT_SOURCE_DMA_0);
534:                     SYS_INT_SourceEnable(INT_SOURCE_DMA_1);
535:                 
536:                 
537:                     /* Initialize the OC Driver */
538:                     DRV_OC0_Initialize();
9D007D78  0F405168   JAL DRV_OC0_Initialize
9D007D7C  00000000   NOP
539:                     /*Initialize TMR0 */
540:                     DRV_TMR0_Initialize();
9D007D80  0F404C01   JAL DRV_TMR0_Initialize
9D007D84  00000000   NOP
541:                     /*Initialize TMR1 */
542:                     DRV_TMR1_Initialize();
9D007D88  0F404A9C   JAL DRV_TMR1_Initialize
9D007D8C  00000000   NOP
543:                     /*Initialize TMR2 */
544:                     DRV_TMR2_Initialize();
9D007D90  0F404C20   JAL DRV_TMR2_Initialize
9D007D94  00000000   NOP
545:                  
546:                      sysObj.drvUsart0 = DRV_USART_Initialize(DRV_USART_INDEX_0, (SYS_MODULE_INIT *)&drvUsart0InitData);
9D007D98  00002021   ADDU A0, ZERO, ZERO
9D007D9C  3C059D01   LUI A1, -25343
9D007DA0  0F4027EC   JAL DRV_USART_Initialize
9D007DA4  24A58B50   ADDIU A1, A1, -29872
9D007DA8  AE420014   SW V0, 20(S2)
547:                     SYS_INT_VectorPrioritySet(INT_VECTOR_UART1, INT_PRIORITY_LEVEL1);
548:                     SYS_INT_VectorSubprioritySet(INT_VECTOR_UART1, INT_SUBPRIORITY_LEVEL0);
549:                     /* RTCC System Service Initialization Call */
550:                     sysObj.sysRtcc = SYS_RTCC_Initialize( );
9D007DD8  0F403D37   JAL SYS_RTCC_Initialize
9D007DDC  00000000   NOP
9D007DE0  AE821020   SW V0, 4128(S4)
551:                     /* Initialize USB Driver */ 
552:                     sysObj.drvUSBObject = DRV_USBFS_Initialize(DRV_USBFS_INDEX_0, (SYS_MODULE_INIT *) &drvUSBInit);
9D007DE4  00002021   ADDU A0, ZERO, ZERO
9D007DE8  3C059D01   LUI A1, -25343
9D007DEC  0F4035FB   JAL DRV_USBFS_Initialize
9D007DF0  24A58B24   ADDIU A1, A1, -29916
553:                 
554:                     /* Initialize System Services */
555:                 
556:                     /*** Interrupt Service Initialization Code ***/
557:                     SYS_INT_Initialize();
9D007DF4  0F4055E6   JAL SYS_INT_Initialize
9D007DF8  AE420020   SW V0, 32(S2)
558:                 
559:                     /*Setup the INT_SOURCE_EXTERNAL_0 and Enable it*/
560:                     SYS_INT_VectorPrioritySet(INT_VECTOR_INT0, INT_PRIORITY_LEVEL1);
561:                     SYS_INT_VectorSubprioritySet(INT_VECTOR_INT0, INT_SUBPRIORITY_LEVEL0);
562:                     SYS_INT_ExternalInterruptTriggerSet(INT_EXTERNAL_INT_SOURCE0,INT_EDGE_TRIGGER_FALLING);
9D007E2C  24040001   ADDIU A0, ZERO, 1
9D007E30  0F405497   JAL SYS_INT_ExternalInterruptTriggerSet
9D007E34  00002821   ADDU A1, ZERO, ZERO
563:                     SYS_INT_SourceEnable(INT_SOURCE_EXTERNAL_0);
564:                 
565:                 
566:                 
567:                 
568:                 
569:                 
570:                     /*** Message Service Initialization Code ***/
571:                     msg0Init.nQSizes = queuePriorities0;
9D007E40  2782801C   ADDIU V0, GP, -32740
9D007E44  AF828018   SW V0, -32744(GP)
572:                     sysObj.sysMsg0 = SYS_MSG_Initialize(SYS_MSG_0, (SYS_OBJ_HANDLE)&msg0Init);
9D007E48  00002021   ADDU A0, ZERO, ZERO
9D007E4C  0F4034F3   JAL SYS_MSG_Initialize
9D007E50  27858014   ADDIU A1, GP, -32748
9D007E54  AE42001C   SW V0, 28(S2)
573:                 
574:                     /*** Random Service Initialization Code ***/
575:                     SYS_RANDOM_Initialize(0, 0);
9D007E58  00002021   ADDU A0, ZERO, ZERO
9D007E5C  0F404DC5   JAL SYS_RANDOM_Initialize
9D007E60  00002821   ADDU A1, ZERO, ZERO
576:                 
577:                     /* Initialize Middleware */
578:                     /* Set priority of USB interrupt source */
579:                     SYS_INT_VectorPrioritySet(INT_VECTOR_USB1, INT_PRIORITY_LEVEL4);
580:                 
581:                     /* Set Sub-priority of USB interrupt source */
582:                     SYS_INT_VectorSubprioritySet(INT_VECTOR_USB1, INT_SUBPRIORITY_LEVEL0);
583:                 
584:                 
585:                     /* Initialize the USB device layer */
586:                     sysObj.usbDevObject0 = USB_DEVICE_Initialize (USB_DEVICE_INDEX_0 , ( SYS_MODULE_INIT* ) & usbDevInitData);
9D007E94  00002021   ADDU A0, ZERO, ZERO
9D007E98  3C059D01   LUI A1, -25343
9D007E9C  0F403651   JAL USB_DEVICE_Initialize
9D007EA0  24A589D0   ADDIU A1, A1, -30256
587:                 
588:                     /* Initialize the Application */
589:                     DOORBELL_Initialize();
9D007EA4  0F4040EF   JAL DOORBELL_Initialize
9D007EA8  AE420024   SW V0, 36(S2)
590:                 }
9D007EAC  8FBF0024   LW RA, 36(SP)
9D007EB0  8FB40020   LW S4, 32(SP)
9D007EB4  8FB3001C   LW S3, 28(SP)
9D007EB8  8FB20018   LW S2, 24(SP)
9D007EBC  8FB10014   LW S1, 20(SP)
9D007EC0  8FB00010   LW S0, 16(SP)
9D007EC4  03E00008   JR RA
9D007EC8  27BD0028   ADDIU SP, SP, 40
591:                 
592:                 
593:                 /*******************************************************************************
594:                  End of File
595:                 */
596:                 
---  /home/whatisthis/src/DoorBell_PIC32/firmware/src/system_config/default/system_exceptions.c  --------
1:                   /*******************************************************************************
2:                     MPLAB Harmony Exceptions Source File
3:                   
4:                     File Name:
5:                       system_exceptions.c
6:                   
7:                     Summary:
8:                       This file contains a function which overrides the deafult _weak_ exception 
9:                       handler provided by the XC32 compiler.
10:                  
11:                    Description:
12:                      This file redefines the default _weak_  exception handler with a more debug
13:                      friendly one. If an unexpected exception occurs the code will stop in a
14:                      while(1) loop.  The debugger can be halted and two variables _excep_code and
15:                      _except_addr can be examined to determine the cause and address where the
16:                      exception occured.
17:                   *******************************************************************************/
18:                  
19:                  // DOM-IGNORE-BEGIN
20:                  /*******************************************************************************
21:                  Copyright (c) 2013-2015 released Microchip Technology Inc.  All rights reserved.
22:                  
23:                  Microchip licenses to you the right to use, modify, copy and distribute
24:                  Software only when embedded on a Microchip microcontroller or digital signal
25:                  controller that is integrated into your product or third party product
26:                  (pursuant to the sublicense terms in the accompanying license agreement).
27:                  
28:                  You should refer to the license agreement accompanying this Software for
29:                  additional information regarding your rights and obligations.
30:                  
31:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
32:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
33:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
34:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
35:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
36:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
37:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
38:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
39:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
40:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
41:                   *******************************************************************************/
42:                  // DOM-IGNORE-END
43:                  
44:                  
45:                  #include <xc.h>                 /* Defines special funciton registers, CP0 regs  */
46:                  #include "system_config.h"
47:                  #include "system_definitions.h"
48:                  #include "system/debug/sys_debug.h"
49:                  
50:                  
51:                  // *****************************************************************************
52:                  // *****************************************************************************
53:                  // Section: Global Data Definitions
54:                  // *****************************************************************************
55:                  // *****************************************************************************
56:                  
57:                  /*******************************************************************************
58:                    Exception Reason Data
59:                    
60:                    <editor-fold defaultstate="expanded" desc="Exception Reason Data">
61:                    
62:                    Remarks:
63:                      These global static items are used instead of local variables in the 
64:                      _general_exception_handler function because the stack may not be available
65:                      if an exception has occured.
66:                  */
67:                  
68:                  /* Code identifying the cause of the exception (CP0 Cause register). */
69:                  static unsigned int _excep_code;
70:                  
71:                  /* Address of instruction that caused the exception. */
72:                  static unsigned int _excep_addr;
73:                  
74:                  /* Pointer to the string describing the cause of the exception. */
75:                  static char *_cause_str;
76:                  
77:                  /* Array identifying the cause (indexed by _exception_code). */
78:                  static char *cause[] = 
79:                  {
80:                      "Interrupt",
81:                      "Undefined",
82:                      "Undefined",
83:                      "Undefined",
84:                      "Load/fetch address error",
85:                      "Store address error",
86:                      "Instruction bus error",
87:                      "Data bus error",
88:                      "Syscall",
89:                      "Breakpoint",
90:                      "Reserved instruction",
91:                      "Coprocessor unusable",
92:                      "Arithmetic overflow",
93:                      "Trap",
94:                      "Reserved",
95:                      "Reserved",
96:                      "Reserved",
97:                      "Reserved",
98:                      "Reserved"
99:                  };
100:                 
101:                 // </editor-fold>
102:                 
103:                 
104:                 // *****************************************************************************
105:                 // *****************************************************************************
106:                 // Section: Exception Handling
107:                 // *****************************************************************************
108:                 // *****************************************************************************
109:                 
110:                 /*******************************************************************************
111:                   Function:
112:                     void _general_exception_handler ( void )
113:                 
114:                   Summary:
115:                     Overrides the XC32 _weak_ _generic_exception_handler.
116:                     
117:                   Description:
118:                     This function overrides the XC32 default _weak_ _generic_exception_handler.
119:                 
120:                   Remarks:
121:                     Refer to the XC32 User's Guide for additional information.
122:                  */
123:                 
124:                 void _general_exception_handler ( void )
125:                 {
9D014790  27BDFFF8   ADDIU SP, SP, -8
9D014794  AFBF0004   SW RA, 4(SP)
126:                     /* Mask off Mask of the ExcCode Field from the Cause Register
127:                     Refer to the MIPs Software User's manual */
128:                     _excep_code = (_CP0_GET_CAUSE() & 0x0000007C) >> 2;
9D014798  40026800   MFC0 V0, Cause
9D01479C  7C422080   EXT V0, V0, 2, 5
9D0147A0  AF8280E4   SW V0, -32540(GP)
129:                     _excep_addr = _CP0_GET_EPC();
9D0147A4  40027000   MFC0 V0, EPC
9D0147A8  AF8280E0   SW V0, -32544(GP)
130:                     _cause_str  = cause[_excep_code];
9D0147AC  8F8380E4   LW V1, -32540(GP)
9D0147B0  00031880   SLL V1, V1, 2
9D0147B4  3C029D01   LUI V0, -25343
9D0147B8  2442EDD0   ADDIU V0, V0, -4656
9D0147BC  00621021   ADDU V0, V1, V0
9D0147C0  8C420000   LW V0, 0(V0)
9D0147C4  AF8280DC   SW V0, -32548(GP)
131:                 
132:                     SYS_DEBUG_PRINT(SYS_ERROR_ERROR, "\n\rGeneral Exception %s (cause=%d, addr=%x).\n\r", 
133:                                     _cause_str, _excep_code, _excep_addr);
134:                 
135:                     while (1)
136:                     {
137:                         SYS_DEBUG_BreakPoint();
9D0147C8  7000003F   SDBBP 0
9D0147CC  0B4051F2   J 0x9D0147C8
9D0147D0  00000000   NOP
138:                     }
139:                 }
140:                 
141:                 /*******************************************************************************
142:                  End of File
143:                 */
---  /home/whatisthis/src/DoorBell_PIC32/firmware/src/system_config/default/rtos_hooks.c  ---------------
1:                   /*******************************************************************************
2:                    System Tasks File
3:                   
4:                     File Name:
5:                       rtos_hooks.c
6:                   
7:                     Summary:
8:                       This file contains source code necessary for rtos hooks
9:                   
10:                    Description:
11:                  
12:                    Remarks:
13:                   *******************************************************************************/
14:                  
15:                  // DOM-IGNORE-BEGIN
16:                  /*******************************************************************************
17:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
18:                  
19:                  Microchip licenses to you the right to use, modify, copy and distribute
20:                  Software only when embedded on a Microchip microcontroller or digital signal
21:                  controller that is integrated into your product or third party product
22:                  (pursuant to the sublicense terms in the accompanying license agreement).
23:                  
24:                  You should refer to the license agreement accompanying this Software for
25:                  additional information regarding your rights and obligations.
26:                  
27:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
28:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
29:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
30:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
31:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
32:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
33:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
34:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
35:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
36:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
37:                   *******************************************************************************/
38:                  // DOM-IGNORE-END
39:                  #include "FreeRTOS.h"
40:                  #include "task.h"
41:                  
42:                  /*
43:                  *********************************************************************************************************
44:                  *                                          vApplicationStackOverflowHook()
45:                  *
46:                  * Description : Hook function called by FreeRTOS if a stack overflow happens.
47:                  *
48:                  * Argument(s) : none
49:                  *
50:                  * Return(s)   : none
51:                  *
52:                  * Caller(s)   : APP_StateReset()
53:                  *
54:                  * Note(s)     : none.
55:                  *********************************************************************************************************
56:                  */
57:                  void vApplicationStackOverflowHook( TaskHandle_t pxTask, signed char *pcTaskName )
58:                  {
9D015494  27BDFFF8   ADDIU SP, SP, -8
9D015498  AFBF0004   SW RA, 4(SP)
59:                     ( void ) pcTaskName;
60:                     ( void ) pxTask;
61:                  
62:                     /* Run time task stack overflow checking is performed if
63:                     configCHECK_FOR_STACK_OVERFLOW is defined to 1 or 2.  This hook	function is
64:                     called if a task stack overflow is detected.  Note the system/interrupt
65:                     stack is not checked. */
66:                     taskDISABLE_INTERRUPTS();
9D01549C  40026000   MFC0 V0, Status
9D0154A0  7C027A84   INS V0, ZERO, 10, 6
9D0154A4  34420C00   ORI V0, V0, 3072
9D0154A8  40826000   MTC0 V0, Status
9D0154AC  000000C0   EHB
9D0154B0  0B40552C   J 0x9D0154B0
9D0154B4  00000000   NOP
67:                     for( ;; );
68:                  }
69:                  
70:                  /*
71:                  *********************************************************************************************************
72:                  *                                     vApplicationMallocFailedHook()
73:                  *
74:                  * Description : vApplicationMallocFailedHook() will only be called if
75:                  *               configUSE_MALLOC_FAILED_HOOK is set to 1 in FreeRTOSConfig.h.
76:                  *               It is a hook function that will get called if a call to
77:                  *               pvPortMalloc() fails.  pvPortMalloc() is called internally by
78:                  *               the kernel whenever a task, queue, timer or semaphore is
79:                  *               created.  It is also called by various parts of the demo
80:                  *               application.  If heap_1.c or heap_2.c are used, then the size of
81:                  *               the heap available to pvPortMalloc() is defined by
82:                  *               configTOTAL_HEAP_SIZE in FreeRTOSConfig.h, and the
83:                  *               xPortGetFreeHeapSize() API function can be used to query the
84:                  *               size of free heap space that remains (although it does not
85:                  *               provide information on how the remaining heap might be
86:                  *               fragmented).
87:                  *
88:                  * Argument(s) : none
89:                  *
90:                  * Return(s)   : none
91:                  *
92:                  * Caller(s)   : APP_StateReset()
93:                  *
94:                  * Note(s)     : none.
95:                  *********************************************************************************************************
96:                  */
97:                  
98:                  void vApplicationMallocFailedHook( void )
99:                  {
9D0154B8  27BDFFF8   ADDIU SP, SP, -8
9D0154BC  AFBF0004   SW RA, 4(SP)
100:                    /* vApplicationMallocFailedHook() will only be called if
101:                       configUSE_MALLOC_FAILED_HOOK is set to 1 in FreeRTOSConfig.h.  It is a hook
102:                       function that will get called if a call to pvPortMalloc() fails.
103:                       pvPortMalloc() is called internally by the kernel whenever a task, queue,
104:                       timer or semaphore is created.  It is also called by various parts of the
105:                       demo application.  If heap_1.c or heap_2.c are used, then the size of the
106:                       heap available to pvPortMalloc() is defined by configTOTAL_HEAP_SIZE in
107:                       FreeRTOSConfig.h, and the xPortGetFreeHeapSize() API function can be used
108:                       to query the size of free heap space that remains (although it does not
109:                       provide information on how the remaining heap might be fragmented). */
110:                    taskDISABLE_INTERRUPTS();
9D0154C0  40026000   MFC0 V0, Status
9D0154C4  7C027A84   INS V0, ZERO, 10, 6
9D0154C8  34420C00   ORI V0, V0, 3072
9D0154CC  40826000   MTC0 V0, Status
9D0154D0  000000C0   EHB
9D0154D4  0B405535   J 0x9D0154D4
9D0154D8  00000000   NOP
111:                    for( ;; );
112:                 }
113:                 
114:                 
115:                 
116:                 
117:                 
118:                 
119:                 
120:                 /*******************************************************************************
121:                  End of File
122:                  */
123:                 
124:                  
---  /home/whatisthis/src/DoorBell_PIC32/firmware/src/system_config/default/framework/system/wdt/sys_wdt.c
1:                    /*******************************************************************************
2:                     Watchdog Timer System Service Implementation
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       sys_wdt.c
9:                   
10:                    Summary:
11:                      Watchdog Timer (WDT) System Service implementation.
12:                  
13:                    Description:
14:                      The WDT System Service provides a simple interface to manage the
15:                      Watchdog Timer module on Microchip microcontrollers.  This file implements
16:                      the core interface routines for the WDT System Service. While building the
17:                      system service from source, ALWAYS include this file in the build.
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  //DOM-IGNORE-END
44:                  
45:                  // *****************************************************************************
46:                  // *****************************************************************************
47:                  // Section: Include Files
48:                  // *****************************************************************************
49:                  // *****************************************************************************
50:                  
51:                  #include "system/wdt/sys_wdt.h"
52:                  #include "peripheral/wdt/plib_wdt.h"
53:                  
54:                  void SYS_WDT_Enable ( bool windowModeEnable )
55:                  {
56:                  #if defined(PLIB_WDT_ExistsEnableControl)
57:                      /* Enable/disable the watchdog timer. */
58:                      if (true == PLIB_WDT_ExistsEnableControl(WDT_PLIB_ID))
59:                      {
60:                          PLIB_WDT_Enable(WDT_PLIB_ID);
61:                      }
62:                  #endif
63:                  
64:                  #if defined(PLIB_WDT_ExistsWindowEnable)
65:                      /* Enable/disable the watchdog timer window mode. */
66:                      if (true == PLIB_WDT_ExistsWindowEnable(WDT_PLIB_ID))
67:                      {
68:                          if (true == windowModeEnable)
9D015134  10800004   BEQ A0, ZERO, SYS_WDT_Enable::PLIB_WDT_WindowDisable
9D015138  24030002   ADDIU V1, ZERO, 2
69:                          {
70:                              PLIB_WDT_WindowEnable(WDT_PLIB_ID);
71:                          }
72:                          else
73:                          {
74:                              PLIB_WDT_WindowDisable(WDT_PLIB_ID);
75:                          }
76:                      }
77:                  #endif
78:                  }
79:                  
80:                  void SYS_WDT_Disable ( void )
81:                  {
82:                      PLIB_WDT_Disable(WDT_PLIB_ID);
83:                  }
84:                  
85:                  void SYS_WDT_TimerClear ( void )
86:                  {
87:                      #if defined(PLIB_WDT_ExistsTimerClear)
88:                      if(PLIB_WDT_ExistsTimerClear(WDT_PLIB_ID))
89:                      {
90:                          PLIB_WDT_TimerClear(WDT_PLIB_ID);
91:                      }
92:                    #endif
93:                  }
94:                  
95:                  
96:                  /*******************************************************************************
97:                  End of File
98:                  */
---  /home/whatisthis/src/DoorBell_PIC32/firmware/src/system_config/default/framework/system/rtcc/sys_rtcc.c
1:                   // *****************************************************************************
2:                   // *****************************************************************************
3:                   // Section: Included Files
4:                   // *****************************************************************************
5:                   // *****************************************************************************
6:                   
7:                   #include "system_config.h"
8:                   #include "system/rtcc/sys_rtcc.h"
9:                   #include "peripheral/devcon/plib_devcon.h"
10:                  
11:                  // *****************************************************************************
12:                  /* helper union for converting to and from BCD Date
13:                    Each nibble:
14:                      [year10][year1][mnth10][mnth1][day10][day1][DOTW] (Day Of The Week).
15:                  
16:                    Remarks:
17:                      Fill this in manually: date.year10 = 1; or use helper function.
18:                  */
19:                  
20:                  union BCDDateConversion
21:                  {
22:                      SYS_RTCC_BCD_DATE bcd;
23:                      struct
24:                      {
25:                          uint32_t DOTW:8;
26:                          uint32_t day1:4;
27:                          uint32_t day10:4;
28:                          uint32_t mnth1:4;
29:                          uint32_t mnth10 :4;
30:                          uint32_t year1:4;
31:                          uint32_t year10:4;
32:                      } parts;
33:                  };
34:                  
35:                  // *****************************************************************************
36:                  /* helper union for converting to and from BCD time */
37:                  /* 4bits each: [hour10][hour1][mins10][mins1][secs10][secs1] */
38:                  
39:                  union BCDConversion
40:                  {
41:                      SYS_RTCC_BCD_TIME bcd;
42:                      struct
43:                      {
44:                  		uint32_t padding:8;
45:                          uint32_t secs1 :4;
46:                          uint32_t secs10:4;
47:                          uint32_t mins1 :4;
48:                          uint32_t mins10:4;
49:                          uint32_t hour1 :4;
50:                          uint32_t hour10:4;
51:                      } parts;
52:                  };
53:                  
54:                  // *****************************************************************************
55:                  /* Real Time Clock System Service Object
56:                  */
57:                  static SYS_RTCC_OBJECT SysRtccObject;
58:                  
59:                  // *****************************************************************************
60:                  /* Function:
61:                    SYS_RTCC_STATUS SYS_RTCC_Start( void )
62:                  
63:                    Summary:
64:                      Starts the Real Time Clock Calendar.
65:                  
66:                    Description:
67:                      The function starts the RTCC.
68:                  
69:                    Precondition:
70:                      None
71:                  
72:                    Parameters:
73:                      None.
74:                  
75:                    Returns:
76:                      SYS_RTCC_STATUS type (see above).
77:                  
78:                    Remarks:
79:                       If the RTCC was running it continues.
80:                  */
81:                  
82:                  SYS_RTCC_STATUS SYS_RTCC_Start( void )
83:                  {
84:                      PLIB_RTCC_Enable(RTCC_PLIB_ID);
85:                  
86:                      return SYS_RTCC_STATUS_OK;
87:                  }
9D0158BC  03E00008   JR RA
9D0158C0  00001021   ADDU V0, ZERO, ZERO
88:                  
89:                  // *****************************************************************************
90:                  /* Function:
91:                    SYS_RTCC_STATUS SYS_RTCC_Stop( void )
92:                  
93:                    Summary:
94:                      Stops the Real Time Clock Calendar.
95:                  
96:                    Description:
97:                      The function stops the RTCC.
98:                  
99:                    Precondition:
100:                     None.
101:                 
102:                   Parameters:
103:                     None.
104:                 
105:                   Returns:
106:                     SYS_RTCC_STATUS type (see above).
107:                 */
108:                 
109:                 SYS_RTCC_STATUS SYS_RTCC_Stop ( void )
110:                 {
111:                     PLIB_RTCC_Disable(RTCC_PLIB_ID);
112:                 
113:                     return SYS_RTCC_STATUS_OK;
114:                 }
9D0158D0  03E00008   JR RA
9D0158D4  00001021   ADDU V0, ZERO, ZERO
115:                 
116:                 /*
117:                 void DRV_RTCC_ClockOutput ( void )
118:                 {
119:                     PLIB_RTCC_ClockOutputEnable(RTCC_PLIB_ID);
120:                 }
121:                 */
122:                 
123:                 static __inline__ bool __attribute__((always_inline)) _SYS_RTCC_ObjectCheck ( SYS_MODULE_OBJ object )
124:                 {
125:                     // basic sanity check we're the right object
126:                     return (SYS_RTCC_OBJECT*)object == &SysRtccObject;
127:                 }
128:                 
129:                 
130:                 // *****************************************************************************
131:                 /* Function:
132:                   SYS_RTCC_STATUS SYS_RTCC_TimeSet(SYS_RTCC_BCD_TIME  time, bool start)
133:                 
134:                   Summary:
135:                     Sets the Real Time Clock Calendar time.
136:                 
137:                   Description:
138:                     The function sets the time for the RTCC.
139:                 
140:                   Precondition:
141:                     None.
142:                 
143:                   Parameters:
144:                     time    time is in BCD format - see description of SYS_RTCC_BCD_TIME
145:                 
146:                     start   if true, the RTCC is also started
147:                 
148:                   Returns:
149:                     SYS_RTCC_STATUS type (see above).
150:                 */
151:                 
152:                 SYS_RTCC_STATUS SYS_RTCC_TimeSet ( SYS_RTCC_BCD_TIME time, bool start )
153:                 {
154:                     PLIB_RTCC_RTCTimeSet(RTCC_PLIB_ID, time);
155:                 
156:                     if (start)
9D0155CC  10A00003   BEQ A1, ZERO, 0x9D0155DC
9D0155D0  34038000   ORI V1, ZERO, -32768
157:                     {
158:                         SYS_RTCC_Start();
159:                     }
160:                 
161:                     return SYS_RTCC_STATUS_OK;
162:                 }
9D0155DC  03E00008   JR RA
9D0155E0  00001021   ADDU V0, ZERO, ZERO
163:                 
164:                 
165:                 // *****************************************************************************
166:                 /* Function:
167:                   SYS_RTCC_STATUS SYS_RTCC_TimeGet(SYS_RTCC_BCD_TIME  *time)
168:                 
169:                   Summary:
170:                     Gets the Real Time Clock Calendar time.
171:                 
172:                   Description:
173:                     The function gets the time from the RTCC.
174:                 
175:                   Precondition:
176:                     None.
177:                 
178:                   Parameters:
179:                     *time    a pointer to a time type - see description of SYS_RTCC_BCD_TIME
180:                 
181:                 
182:                   Returns:
183:                     SYS_RTCC_STATUS type (see above).
184:                 */
185:                 
186:                 SYS_RTCC_STATUS SYS_RTCC_TimeGet ( SYS_RTCC_BCD_TIME *time )
187:                 {
188:                     *time = (SYS_RTCC_BCD_TIME)PLIB_RTCC_RTCTimeGet(RTCC_PLIB_ID);
9D0156FC  AC820000   SW V0, 0(A0)
189:                 
190:                     return SYS_RTCC_STATUS_OK;
191:                 }
9D015700  03E00008   JR RA
9D015704  00001021   ADDU V0, ZERO, ZERO
192:                 
193:                 
194:                 
195:                 // *****************************************************************************
196:                 /* Function:
197:                   SYS_RTCC_STATUS SYS_RTCC_DateSet(SYS_RTCC_BCD_DATE  date)
198:                 
199:                   Summary:
200:                     Sets the Real Time Clock Calendar date.
201:                 
202:                   Description:
203:                     The function sets the date for the RTCC in BCD format.
204:                 
205:                   Precondition:
206:                     None.
207:                 
208:                   Parameters:
209:                     date    date is in BCD format - see description of SYS_RTCC_BCD_DATE
210:                 
211:                   Returns:
212:                     SYS_RTCC_STATUS type (see above).
213:                 */
214:                 
215:                 SYS_RTCC_STATUS SYS_RTCC_DateSet ( SYS_RTCC_BCD_DATE date )
216:                 {
217:                     PLIB_RTCC_RTCDateSet(RTCC_PLIB_ID, date);
218:                 
219:                     return SYS_RTCC_STATUS_OK;
220:                 }
9D0159AC  03E00008   JR RA
9D0159B0  00001021   ADDU V0, ZERO, ZERO
221:                 
222:                 
223:                 // *****************************************************************************
224:                 /* Function:
225:                   SYS_RTCC_STATUS SYS_RTCC_DateGet(SYS_RTCC_BCD_DATE *date)
226:                 
227:                   Summary:
228:                     Gets the Real Time Clock Calendar date.
229:                 
230:                   Description:
231:                     The function gets the date from the RTCC in BCD format.
232:                 
233:                   Precondition:
234:                     None.
235:                 
236:                   Parameters:
237:                     *date    a pointer to a date type - see description of SYS_RTCC_BCD_DATE
238:                 
239:                   Returns:
240:                     SYS_RTCC_STATUS type (see above).
241:                 */
242:                 
243:                 SYS_RTCC_STATUS SYS_RTCC_DateGet ( SYS_RTCC_BCD_DATE *date )
244:                 {
245:                     *date = (SYS_RTCC_BCD_DATE)PLIB_RTCC_RTCDateGet(RTCC_PLIB_ID);
9D015714  AC820000   SW V0, 0(A0)
246:                 
247:                     return SYS_RTCC_STATUS_OK;
248:                 }
9D015718  03E00008   JR RA
9D01571C  00001021   ADDU V0, ZERO, ZERO
249:                 
250:                 
251:                 // *****************************************************************************
252:                 /* Function:
253:                   SYS_RTCC_STATUS SYS_RTCC_AlarmEnable( void )
254:                 
255:                   Summary:
256:                     Enables RTCC alarm.
257:                 
258:                   Description:
259:                     The function enables the alarm in the RTCC.
260:                 
261:                   Precondition:
262:                     None.
263:                 
264:                   Parameters:
265:                     None.
266:                 
267:                   Returns:
268:                     SYS_RTCC_STATUS type (see above).
269:                 */
270:                 
271:                 SYS_RTCC_STATUS SYS_RTCC_AlarmEnable ( void )
272:                 {
273:                     PLIB_RTCC_AlarmEnable(RTCC_PLIB_ID);
274:                 
275:                     return SYS_RTCC_STATUS_OK;
276:                 }
9D0158E4  03E00008   JR RA
9D0158E8  00001021   ADDU V0, ZERO, ZERO
277:                 
278:                 
279:                 // *****************************************************************************
280:                 /* Function:
281:                   SYS_RTCC_STATUS SYS_RTCC_AlarmDisable( void )
282:                 
283:                   Summary:
284:                     Disables the RTCC alarm.
285:                 
286:                   Description:
287:                     The function disables the alarm in the RTCC.
288:                 
289:                   Precondition:
290:                     None.
291:                 
292:                   Parameters:
293:                     None.
294:                 
295:                   Returns:
296:                     SYS_RTCC_STATUS type (see above).
297:                 */
298:                 
299:                 SYS_RTCC_STATUS SYS_RTCC_AlarmDisable ( void )
300:                 {
301:                     PLIB_RTCC_AlarmDisable(RTCC_PLIB_ID);
302:                 
303:                     return SYS_RTCC_STATUS_OK;
304:                 }
305:                 
306:                 
307:                 
308:                 // *****************************************************************************
309:                 /* Function:
310:                   SYS_RTCC_STATUS SYS_RTCC_AlarmTimeSet(SYS_RTCC_BCD_TIME  time, bool enable)
311:                 
312:                   Summary:
313:                     Sets the Real Time Clock Calendar alarm time.
314:                 
315:                   Description:
316:                     The function sets the time for the RTCC alarm.
317:                 
318:                   Precondition:
319:                     None.
320:                 
321:                   Parameters:
322:                     time    time is in BCD format - see description of SYS_RTCC_BCD_TIME
323:                 
324:                     enable   if true, the alarm is enabled
325:                 
326:                   Returns:
327:                     SYS_RTCC_STATUS type (see above).
328:                 */
329:                 
330:                 SYS_RTCC_STATUS SYS_RTCC_AlarmTimeSet ( SYS_RTCC_BCD_TIME time, bool enable )
331:                 {
332:                     PLIB_RTCC_AlarmTimeSet(RTCC_PLIB_ID, time);
333:                 
334:                     if (enable)
9D0155EC  10A00003   BEQ A1, ZERO, 0x9D0155FC
9D0155F0  34038000   ORI V1, ZERO, -32768
335:                     {
336:                         SYS_RTCC_AlarmEnable();
337:                     }
338:                 
339:                     return SYS_RTCC_STATUS_OK;
340:                 }
9D0155FC  03E00008   JR RA
9D015600  00001021   ADDU V0, ZERO, ZERO
341:                 
342:                 
343:                 
344:                 // *****************************************************************************
345:                 /* Function:
346:                   SYS_RTCC_STATUS SYS_RTCC_AlarmTimeGet(SYS_RTCC_BCD_TIME *time)
347:                 
348:                   Summary:
349:                     Gets the Real Time Clock Calendar alarm time.
350:                 
351:                   Description:
352:                     The function gets the time from the RTCC alarm.
353:                 
354:                   Precondition:
355:                     None.
356:                 
357:                   Parameters:
358:                     *time    a pointer to the time type - see description of SYS_RTCC_BCD_TIME
359:                 
360:                   Returns:
361:                     SYS_RTCC_STATUS type (see above).
362:                 */
363:                 
364:                 SYS_RTCC_STATUS SYS_RTCC_AlarmTimeGet(SYS_RTCC_BCD_TIME *time)
365:                 {
366:                     *time = (SYS_RTCC_BCD_TIME)PLIB_RTCC_AlarmTimeGet(RTCC_PLIB_ID);
367:                 
368:                     return SYS_RTCC_STATUS_OK;
369:                 }
370:                 
371:                 
372:                 
373:                 // *****************************************************************************
374:                 /* Function:
375:                   SYS_RTCC_STATUS SYS_RTCC_AlarmDateSet(SYS_RTCC_BCD_DATE date)
376:                 
377:                   Summary:
378:                     Sets the Real Time Clock Calendar alarm date.
379:                 
380:                   Description:
381:                     The function sets the time for the RTCC alarm. The date for the alarm
382:                     does not include the year. If the year is included it will be ignored.
383:                   Precondition:
384:                     None.
385:                 
386:                   Parameters:
387:                     date    date is in BCD format - see description of SYS_RTCC_BCD_DATE
388:                 
389:                   Returns:
390:                     SYS_RTCC_STATUS type (see above).
391:                 */
392:                 
393:                 SYS_RTCC_STATUS SYS_RTCC_AlarmDateSet ( SYS_RTCC_BCD_DATE date )
394:                 {
395:                   PLIB_RTCC_AlarmDateSet(RTCC_PLIB_ID, date);
396:                     return SYS_RTCC_STATUS_OK;
397:                 }
398:                 
399:                 
400:                 
401:                 // *****************************************************************************
402:                 /* Function:
403:                   SYS_RTCC_STATUS SYS_RTCC_AlarmDateGet(SYS_RTCC_BCD_DATE *date)
404:                 
405:                   Summary:
406:                     Gets the Real Time Clock Calendar alarm date.
407:                 
408:                   Description:
409:                     The function gets the time for the RTCC alarm.
410:                 
411:                   Precondition:
412:                     None.
413:                 
414:                   Parameters:
415:                     *date    pointer to date type - see description of SYS_RTCC_BCD_DATE
416:                 
417:                   Returns:
418:                     SYS_RTCC_STATUS type (see above).
419:                 */
420:                 
421:                 SYS_RTCC_STATUS SYS_RTCC_AlarmDateGet ( SYS_RTCC_BCD_DATE *date )
422:                 {
423:                     *date = (SYS_RTCC_BCD_DATE)(PLIB_RTCC_AlarmDateGet(RTCC_PLIB_ID));
424:                 
425:                     return SYS_RTCC_STATUS_OK;
426:                 }
427:                 
428:                 
429:                 
430:                 // *****************************************************************************
431:                 /* Function:
432:                   SYS_RTCC_ALARM_HANDLE SYS_RTCC_AlarmRegister(SYS_RTCC_ALARM_CALLBACK *callback,
433:                     uintptr_t context );
434:                 
435:                   Summary:
436:                     Sets the callback function for an alarm.
437:                 
438:                   Description:
439:                     This function sets the callback function that will be called when the RTCC
440:                     alarm is reached.
441:                 
442:                   Precondition:
443:                     None.
444:                 
445:                   Parameters:
446:                     *callback   - a pointer to the function to be called when alarm is reached.
447:                                   Use NULL to Un Register the alarm callback
448:                 
449:                     context     - a pointer to user defined data to be used when the callback
450:                                   function is called. NULL can be passed in if no data needed.
451:                 
452:                   Returns:
453:                     SYS_RTCC_ALARM_HANDLE type.
454:                 */
455:                 
456:                 SYS_RTCC_ALARM_HANDLE SYS_RTCC_AlarmRegister ( SYS_RTCC_ALARM_CALLBACK callback, uintptr_t context )
457:                 {
458:                     SYS_RTCC_ALARM_HANDLE funcReturn;
459:                 
460:                     /* - Un-register callback if NULL */
461:                     if (callback == NULL)
462:                     {
463:                         SysRtccObject.callback = NULL;
464:                         SysRtccObject.context = (uintptr_t) NULL;
465:                         SysRtccObject.status = SYS_RTCC_STATUS_OK;
466:                         funcReturn = SYS_RTCC_ALARM_HANDLE_INVALID;
467:                     }
468:                     /* - Save callback and context in local memory */
469:                     SysRtccObject.callback = callback;
9D0156B8  3C03A000   LUI V1, -24576
9D0156BC  24627610   ADDIU V0, V1, 30224
9D0156C0  AC440004   SW A0, 4(V0)
470:                     SysRtccObject.context = context;
9D0156C4  AC450008   SW A1, 8(V0)
471:                     SysRtccObject.status = SYS_RTCC_STATUS_OK;
9D0156C8  AC607610   SW ZERO, 30224(V1)
472:                     SysRtccObject.handle = (SYS_RTCC_ALARM_HANDLE)&SysRtccObject;
473:                     funcReturn =  (SYS_RTCC_ALARM_HANDLE)&SysRtccObject;
474:                 
475:                     return funcReturn;
476:                 }
9D0156CC  03E00008   JR RA
9D0156D0  AC42000C   SW V0, 12(V0)
477:                 
478:                 // *****************************************************************************
479:                 /* Function:
480:                    SYS_MODULE_OBJ SYS_TMR_Initialize ( void )
481:                 
482:                   Summary:
483:                     Initializes hardware and data for the instance of the RTCC module and opens
484:                     the specific module instance.
485:                 
486:                   Description:
487:                     This function initializes hardware for the instance of the RTCC module,
488:                     using the specified hardware initialization data. It also initializes any
489:                     internal data structures.
490:                 
491:                   Parameters:
492:                 
493:                     init    - Pointer to a data structure containing any data necessary
494:                             to initialize the driver. This pointer may be null if no
495:                             data is required because static overrides have been
496:                             provided.
497:                 
498:                   Returns:
499:                     void
500:                 */
501:                 
502:                 
503:                 SYS_MODULE_OBJ SYS_RTCC_Initialize ( void )
504:                 {
505:                     PLIB_DEVCON_SystemUnlock(DEVCON_ID_0); /* Unlock System */
506:                 
507:                     /* Initialize RTCC */
508:                     PLIB_RTCC_WriteEnable(RTCC_PLIB_ID); /* Enable writes to RTCC */
509:                     PLIB_RTCC_Disable(RTCC_PLIB_ID); /* Disable clock to RTCC */
510:                 
511:                     /* wait for clock to stop. Block too long? */
512:                     while (PLIB_RTCC_ClockRunningStatus(RTCC_PLIB_ID)); /* clock disabled? */
9D00F51C  1440FFFD   BNE V0, ZERO, 0x9D00F514
9D00F520  3C02BF80   LUI V0, -16512
513:                 
514:                     /* initialize the time, date and alarm */
515:                     PLIB_RTCC_RTCTimeSet(RTCC_PLIB_ID, 0x23595000); /* Set RTCC time */
516:                     PLIB_RTCC_RTCDateSet(RTCC_PLIB_ID, 0x15010100); /* Set RTCC date */
517:                 
518:                     PLIB_RTCC_AlarmDisable(RTCC_PLIB_ID); /* Disable alarm */
519:                     while (PLIB_RTCC_AlarmSyncStatusGet(RTCC_PLIB_ID))  ; /* Wait for disable */
9D00F550  1440FFFD   BNE V0, ZERO, 0x9D00F548
9D00F554  24020500   ADDIU V0, ZERO, 1280
520:                     PLIB_RTCC_AlarmTimeSet(RTCC_PLIB_ID, 0x00000500);
521:                     PLIB_RTCC_AlarmDateSet(RTCC_PLIB_ID, 0x0001010);
522:                 
523:                     /* repeat forever or 0-255 times */
524:                     PLIB_RTCC_AlarmChimeDisable(RTCC_PLIB_ID);
525:                     PLIB_RTCC_AlarmRepeatCountSet(RTCC_PLIB_ID, 0);
526:                 
527:                     /* enum here to select the alarm mask */
528:                     PLIB_RTCC_AlarmMaskModeSelect(RTCC_PLIB_ID, RTCC_ALARM_EVERY_HOUR);
529:                 
530:                     /* Initialize the output */
531:                     PLIB_RTCC_ClockOutputDisable(RTCC_PLIB_ID); /* Disable RTCC output */
532:                 
533:                     /* Set RTCC clock source (LPRC/SOSC) */
534:                 
535:                     /* Setup RTCC Interrupt */
536:                     PLIB_INT_SourceEnable(INT_ID_0, INT_SOURCE_RTCC);
537:                     PLIB_INT_VectorPrioritySet(INT_ID_0, _RTCC_VECTOR, INT_PRIORITY_LEVEL2);
538:                     PLIB_INT_VectorSubPrioritySet(INT_ID_0,_RTCC_VECTOR, INT_SUBPRIORITY_LEVEL2);
539:                     SysRtccObject.interruptSource = INT_SOURCE_RTCC;
9D00F5D4  3C02A000   LUI V0, -24576
9D00F5D8  24427610   ADDIU V0, V0, 30224
9D00F5DC  2404001E   ADDIU A0, ZERO, 30
9D00F5E0  AC440010   SW A0, 16(V0)
540:                     /* save for checking alarm state */
541:                 
542:                     SYS_RTCC_Start();
543:                 
544:                     return (SYS_MODULE_OBJ)&SysRtccObject;
545:                 }
9D00F5EC  03E00008   JR RA
9D00F5F0  00000000   NOP
546:                 
547:                 
548:                 // *****************************************************************************
549:                 /* Function:
550:                    void SYS_RTCC_Tasks ( SYS_MODULE_OBJ object )
551:                 
552:                 Summary:
553:                 Maintains the system RTCC state machine and implements its ISR.
554:                 
555:                 Description:
556:                 This routine is used to maintain the system RTCC internal state machine and
557:                 implement its ISR for interrupt-driven implementations.
558:                 
559:                 Precondition:
560:                 The SYS_RTCC_Initialize function must have been called.
561:                 
562:                 Parameters:
563:                 object          - SYS RTCC object returned from SYS_RTCC_Initialize
564:                 
565:                 Returns:
566:                 None.
567:                 */
568:                 
569:                 void SYS_RTCC_Tasks ( SYS_MODULE_OBJ object )
570:                 {
9D0130F8  00801021   ADDU V0, A0, ZERO
9D01314C  27BDFFE8   ADDIU SP, SP, -24
9D013150  AFBF0014   SW RA, 20(SP)
571:                     SYS_RTCC_OBJECT *obj = (SYS_RTCC_OBJECT *)object;
572:                 
573:                     if (PLIB_INT_SourceFlagGet(INT_ID_0, obj->interruptSource))
9D0130FC  8C830010   LW V1, 16(A0)
9D013124  10A00010   BEQ A1, ZERO, 0x9D013168
9D013128  00000000   NOP
574:                     {
575:                         PLIB_INT_SourceFlagClear(INT_ID_0, obj->interruptSource);
576:                 
577:                         /* is there a callback to be made? do it */
578:                         if ((obj != NULL) && obj->callback)
9D013138  1040000B   BEQ V0, ZERO, 0x9D013168
9D01313C  00000000   NOP
9D013140  8C430004   LW V1, 4(V0)
9D013144  10600008   BEQ V1, ZERO, 0x9D013168
9D013148  00000000   NOP
579:                         {
580:                             /* must be non-blocking*/
581:                             obj->callback(obj->handle, obj->context);
9D013154  8C44000C   LW A0, 12(V0)
9D013158  0060F809   JALR V1
9D01315C  8C450008   LW A1, 8(V0)
582:                         }
583:                     }
584:                 }
9D013160  8FBF0014   LW RA, 20(SP)
9D013164  27BD0018   ADDIU SP, SP, 24
9D013168  03E00008   JR RA
9D01316C  00000000   NOP
585:                 
586:                 
587:                 // *****************************************************************************
588:                 /* Function:
589:                   uint32_t SYS_RTCC_TimeBCD2Seconds(SYS_RTCC_BCD_TIME time)
590:                 
591:                   Summary:
592:                     Helper function for time.
593:                 
594:                   Description:
595:                     This function returns the number of seconds when given a BCD encoded time
596:                     value. (see SYS_RTCC_BCD_TIME typedef above).
597:                 
598:                   Precondition:
599:                     None.
600:                 
601:                   Parameters:
602:                     time    - a SYS_RTCC_BCD_TIME value.
603:                 
604:                   Returns:
605:                     The number of seconds represented by the BCD value.
606:                 */
607:                 
608:                 uint32_t TimeBCD2Seconds ( SYS_RTCC_BCD_TIME TimeInBCD )
609:                 {
610:                     /* use a union and make the compiler do the work */
611:                     union BCDConversion conversion = {0};
612:                     conversion.bcd = TimeInBCD;
613:                 
614:                     return conversion.parts.hour10 * 36000u + conversion.parts.hour1 * 3600 +
615:                            conversion.parts.mins10 * 600 +    conversion.parts.mins1 * 60 +
616:                            conversion.parts.secs10 * 10 +     conversion.parts.secs1;
617:                 }
618:                 
619:                 
620:                 
621:                 // *****************************************************************************
622:                 /* Function:
623:                   SYS_RTCC_BCD_TIME SYS_RTCC_TimeSeconds2BCD(uint32_t seconds)
624:                 
625:                   Summary:
626:                     Helper function for time.
627:                 
628:                   Description:
629:                     This function returns the BCD encoded time
630:                     value for the given number of seconds.
631:                 
632:                   Precondition:
633:                     None.
634:                 
635:                   Parameters:
636:                     seconds    - number of seconds to convert.
637:                 
638:                   Returns:
639:                     A SYS_RTCC_BCD_TIME type value in BCD of the number of seconds given.
640:                 */
641:                 
642:                 SYS_RTCC_BCD_TIME TimeSeconds2BCD ( uint32_t seconds )
643:                 {
644:                     union BCDConversion conversion = {0};
645:                 
646:                     /* limit and decompose seconds to BCD */
647:                     seconds %= 360000ul;
648:                     conversion.parts.hour10 = seconds / 36000u;
649:                     seconds %= 36000u;
650:                     conversion.parts.hour1  = seconds / 3600;
651:                     seconds %= 3600;
652:                     conversion.parts.mins10 = seconds / 600;
653:                     seconds %= 600;
654:                     conversion.parts.mins1  = seconds / 60;
655:                     seconds %= 60;
656:                     conversion.parts.secs10 = seconds / 10;
657:                     seconds %= 10;
658:                     conversion.parts.secs1  = seconds;
659:                 
660:                     return conversion.bcd;
661:                 }
662:                 
---  /home/whatisthis/src/DoorBell_PIC32/firmware/src/system_config/default/framework/system/reset/src/sys_reset.c
1:                   /*******************************************************************************
2:                     Reset Service Implementation
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       sys_reset.c
9:                   
10:                    Summary:
11:                      Reset Service interface implementation.
12:                  
13:                    Description:
14:                      The RESET system service provides a simple interface to manage the DEVICE
15:                      RESET on Microchip microcontrollers. This file Implements the core
16:                      interface routines for the RESET system service. While building the system
17:                      service from source, ALWAYS include this file in the build.
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  //DOM-IGNORE-END
44:                  // *****************************************************************************
45:                  // *****************************************************************************
46:                  // Section: Macro Definitions
47:                  // *****************************************************************************
48:                  // *****************************************************************************
49:                  
50:                  // *****************************************************************************
51:                  // *****************************************************************************
52:                  // Section: Included Files
53:                  // *****************************************************************************
54:                  // *****************************************************************************
55:                  #include <stdlib.h>
56:                  #include <string.h>
57:                  #include <stdint.h>
58:                  #include <stdbool.h>
59:                  #include <stddef.h>
60:                  #include "system/reset/sys_reset.h"
61:                  #include <sys/appio.h>
62:                  #include "system/system.h"
63:                  #include "system/devcon/sys_devcon.h"
64:                  #include "peripheral/devcon/plib_devcon.h"
65:                  
66:                  // *****************************************************************************
67:                  /* Function:
68:                      RESET_REASON SYS_RESET_ReasonGet( void )
69:                  
70:                    Summary:
71:                      Returns the reason for the reset.
72:                  
73:                    Description:
74:                      This function identifies the reason that the most recent reset occurred.
75:                  
76:                    PreCondition:
77:                      None.
78:                  
79:                    Parameters:
80:                      None.
81:                  
82:                    Returns:
83:                      A value identifying the reason for the most recent reset.
84:                  
85:                    Example:
86:                      <code>
87:                      RESET_REASON reasonType;
88:                      reasonType = SYS_RESET_ReasonGet();
89:                      </code>
90:                  
91:                    Remarks:
92:                      None.
93:                  */
94:                  
95:                  RESET_REASON SYS_RESET_ReasonGet( void )
96:                  {
97:                  	RESET_REASON resetReason;
98:                  	resetReason = PLIB_RESET_ReasonGet ( RESET_ID_0 );
99:                  	return resetReason;
100:                 }
9D01598C  03E00008   JR RA
9D015990  304202D3   ANDI V0, V0, 723
101:                 
102:                 
103:                 // *****************************************************************************
104:                 /* Function:
105:                      void SYS_RESET_ReasonClear( RESET_REASON reason )
106:                 
107:                    Summary:
108:                     Clears the status flag for the specified reset reason.
109:                 
110:                    Description:
111:                     This function clears the specified status flag(s) that were previously set
112:                     by the processor to identify the reason for the most recent reset.
113:                 
114:                   PreCondition:
115:                     Hardware should have set the reset reason.
116:                 
117:                   Parameters:
118:                     reason          - One of the possible values of the enum RESET_REASON
119:                 
120:                    Returns:
121:                      None.
122:                 
123:                    Example:
124:                     <code>
125:                     // To clear a single reset reason,
126:                     SYS_RESET_ReasonClear( RESET_REASON_MCLR );
127:                 
128:                     // To clear more than one reason,
129:                     SYS_RESET_ReasonClear( RESET_REASON_MCLR|RESET_REASON_POWERON );
130:                 
131:                     // To clear all the reasons,
132:                     SYS_RESET_ReasonClear( RESET_REASON_ALL );
133:                     </code>
134:                 
135:                    Remarks:
136:                     None.
137:                 */
138:                 
139:                 void SYS_RESET_ReasonClear( RESET_REASON reason )
140:                 {
141:                 	PLIB_RESET_ReasonClear( RESET_ID_0, reason );
142:                 }
143:                 
144:                 // *****************************************************************************
145:                 /* Function:
146:                     void SYS_RESET_SoftwareReset( void )
147:                 
148:                   Summary:
149:                     Triggers a software reset.
150:                 
151:                   Description:
152:                     This function triggers a processor.
153:                 
154:                   PreCondition:
155:                     None.
156:                 
157:                   Parameters:
158:                     None.
159:                 
160:                   Returns:
161:                     None.
162:                 
163:                   Example:
164:                     <code>
165:                     SYS_RESET_SoftwareReset();
166:                     </code>
167:                 
168:                   Remarks:
169:                     The software reset feature must be supported by the processor in use.
170:                 */
171:                 void SYS_RESET_SoftwareReset( void )
172:                 {
173:                     PLIB_DEVCON_SystemUnlock(DEVCON_ID_0);
174:                 	#if defined(PLIB_RESET_ExistsSoftwareResetTrigger)
175:                     if (PLIB_RESET_ExistsSoftwareResetTrigger(RESET_ID_0))
176:                 	{
177:                         PLIB_RESET_SoftwareResetEnable(RESET_ID_0);
178:                 	}
179:                 	#endif
180:                 }
181:                 
182:                 // *****************************************************************************
183:                 /* Function:
184:                    void SYS_RESET_NMIDelayCountSet( RESET_NMI_COUNT_TYPE nmi_count )
185:                 
186:                   Summary:
187:                     Sets the Delay for WDT/DMT NMI reset events.
188:                 
189:                   Description:
190:                     This function sets the NMI counter value, that is equivalent to number of
191:                     SYSCLK cycles before a device Reset to occur when a WDT/DMT NMI event is triggered.
192:                     This NMI reset counter is only applicable to these two specific NMI events only.
193:                 
194:                   Precondition:
195:                     None.
196:                 
197:                   Parameters:
198:                 	nmi_count - NMI counter value.
199:                 
200:                   Returns:
201:                     None
202:                 
203:                   Example:
204:                     <code>
205:                      SYS_RESET_NMIDelayCountSet( 0x54 );
206:                     </code>
207:                 
208:                   Remarks:
209:                     The NMI feature must be supported by the processor in use.
210:                  */
211:                 
212:                 void  SYS_RESET_NMIDelayCountSet( RESET_NMI_COUNT_TYPE nmi_count )
213:                 {
214:                     PLIB_DEVCON_SystemUnlock(DEVCON_ID_0);
215:                 
216:                     #if defined(PLIB_RESET_ExistsNmiCounter)
217:                     if (PLIB_RESET_ExistsNmiCounter(RESET_ID_0))
218:                         PLIB_RESET_NmiCounterValueSet( RESET_ID_0,  nmi_count);
219:                     #endif
220:                 
221:                     PLIB_DEVCON_SystemLock(DEVCON_ID_0);
222:                 
223:                 }
---  /home/whatisthis/src/DoorBell_PIC32/firmware/src/system_config/default/framework/system/ports/src/sys_ports_static.c
1:                   /*******************************************************************************
2:                     SYS PORTS Static Functions for PORTS System Service
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       sys_ports_static.c
9:                   
10:                    Summary:
11:                      SYS PORTS static function implementations for the Ports System Service.
12:                  
13:                    Description:
14:                      The Ports System Service provides a simple interface to manage the ports
15:                      on Microchip microcontrollers. This file defines the static implementation for the 
16:                      Ports System Service.
17:                      
18:                    Remarks:
19:                      Static functions incorporate all system ports configuration settings as
20:                      determined by the user via the Microchip Harmony Configurator GUI.  It provides 
21:                      static version of the routines, eliminating the need for an object ID or 
22:                      object handle.
23:                  
24:                  *******************************************************************************/
25:                  
26:                  //DOM-IGNORE-BEGIN
27:                  /*******************************************************************************
28:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
29:                  
30:                  Microchip licenses to you the right to use, modify, copy and distribute
31:                  Software only when embedded on a Microchip microcontroller or digital signal
32:                  controller that is integrated into your product or third party product
33:                  (pursuant to the sublicense terms in the accompanying license agreement).
34:                  
35:                  You should refer to the license agreement accompanying this Software for
36:                  additional information regarding your rights and obligations.
37:                  
38:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
39:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
40:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
41:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
42:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
43:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
44:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
45:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
46:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
47:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
48:                  *******************************************************************************/
49:                  //DOM-IGNORE-END
50:                  
51:                  #include "system_config.h"
52:                  #include "system/ports/sys_ports.h"
53:                  #include "peripheral/devcon/plib_devcon.h"
54:                  #include "peripheral/ports/plib_ports.h"
55:                  #include "peripheral/int/plib_int.h"
56:                  
57:                  /******************************************************************************
58:                    Function:
59:                      SYS_PORTS_Initialize(void)
60:                  
61:                    Summary:
62:                      Initializes Ports System Service
63:                  
64:                    Description:
65:                      This function initializes different port pins/channels to the desired state.
66:                      It also remaps the pins to the desired specific function.
67:                  
68:                    Remarks:
69:                      None.
70:                  */
71:                  void SYS_PORTS_Initialize(void)
72:                  {
73:                  
74:                      /* PORT A Initialization */
75:                      PLIB_PORTS_OpenDrainEnable(PORTS_ID_0, PORT_CHANNEL_A, SYS_PORT_A_ODC);
76:                      PLIB_PORTS_Write( PORTS_ID_0, PORT_CHANNEL_A,  SYS_PORT_A_LAT);
77:                      PLIB_PORTS_DirectionOutputSet( PORTS_ID_0, PORT_CHANNEL_A,  SYS_PORT_A_TRIS ^ 0xFFFF);
78:                      PLIB_PORTS_ChangeNoticePerPortTurnOn(PORTS_ID_0, PORT_CHANNEL_A);
79:                      PLIB_PORTS_ChannelModeSelect(PORTS_ID_0, PORT_CHANNEL_A, SYS_PORT_A_ANSEL ^ 0xFFFF, PORTS_PIN_MODE_DIGITAL);
80:                      PLIB_PORTS_ChannelChangeNoticeEnable(PORTS_ID_0, PORT_CHANNEL_A, SYS_PORT_A_CNEN);
81:                      PLIB_PORTS_ChannelChangeNoticePullUpEnable(PORTS_ID_0, PORT_CHANNEL_A, SYS_PORT_A_CNPU);
82:                      PLIB_PORTS_ChannelChangeNoticePullDownEnable(PORTS_ID_0, PORT_CHANNEL_A, SYS_PORT_A_CNPD);
83:                      
84:                      /* PORT B Initialization */
85:                      PLIB_PORTS_OpenDrainEnable(PORTS_ID_0, PORT_CHANNEL_B, SYS_PORT_B_ODC);
86:                      PLIB_PORTS_Write( PORTS_ID_0, PORT_CHANNEL_B,  SYS_PORT_B_LAT);
87:                      PLIB_PORTS_DirectionOutputSet( PORTS_ID_0, PORT_CHANNEL_B,  SYS_PORT_B_TRIS ^ 0xFFFF);
88:                      PLIB_PORTS_ChangeNoticePerPortTurnOn(PORTS_ID_0, PORT_CHANNEL_B);
89:                      PLIB_PORTS_ChannelModeSelect(PORTS_ID_0, PORT_CHANNEL_B, SYS_PORT_B_ANSEL ^ 0xFFFF, PORTS_PIN_MODE_DIGITAL);
90:                      PLIB_PORTS_ChannelChangeNoticeEnable(PORTS_ID_0, PORT_CHANNEL_B, SYS_PORT_B_CNEN);
91:                      PLIB_PORTS_ChannelChangeNoticePullUpEnable(PORTS_ID_0, PORT_CHANNEL_B, SYS_PORT_B_CNPU);
92:                      PLIB_PORTS_ChannelChangeNoticePullDownEnable(PORTS_ID_0, PORT_CHANNEL_B, SYS_PORT_B_CNPD);
93:                  
94:                  
95:                      /* PPS Input Remapping */
96:                      PLIB_PORTS_RemapInput(PORTS_ID_0, INPUT_FUNC_T2CK, INPUT_PIN_RPA0 );
97:                  
98:                      /* PPS Output Remapping */
99:                      PLIB_PORTS_RemapOutput(PORTS_ID_0, OUTPUT_FUNC_OC2, OUTPUT_PIN_RPA1 );
100:                 
101:                     
102:                 }
103:                 
104:                 /******************************************************************************
105:                   Function:
106:                     PORTS_DATA_TYPE SYS_PORTS_Read( PORTS_MODULE_ID index, PORTS_CHANNEL channel )
107:                 
108:                   Summary:
109:                     Reads the data from the I/O port.
110:                 
111:                   Description:
112:                     This function reads the data from the I/O port.
113:                 
114:                   Remarks:
115:                     None.
116:                 */
117:                 
118:                 PORTS_DATA_TYPE SYS_PORTS_Read( PORTS_MODULE_ID index, PORTS_CHANNEL channel )
119:                 {
120:                     return PLIB_PORTS_Read( index, channel );
121:                 }
122:                 
123:                 
124:                 /******************************************************************************
125:                   Function:
126:                     void SYS_PORTS_Write( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
127:                                       		PORTS_DATA_TYPE value )
128:                 
129:                   Summary:
130:                     Writes the data from the I/O port.
131:                 
132:                   Description:
133:                     This function writes the data to the I/O port.
134:                 
135:                   Remarks:
136:                     None.
137:                 */
138:                 
139:                 void SYS_PORTS_Write( PORTS_MODULE_ID index,
140:                                       PORTS_CHANNEL channel,
141:                                       PORTS_DATA_TYPE value )
142:                 {
143:                     PLIB_PORTS_Write( index, channel, value );
144:                 }
145:                 
146:                 /******************************************************************************
147:                   Function:
148:                     PORTS_DATA_TYPE SYS_PORTS_LatchedGet( PORTS_MODULE_ID index, PORTS_CHANNEL channel )
149:                 
150:                   Summary:
151:                     Reads the data driven on the I/O port.
152:                 
153:                   Description:
154:                     This function reads the data driven on the I/O port.
155:                 
156:                   Remarks:
157:                     None.
158:                 */
159:                 
160:                 PORTS_DATA_TYPE SYS_PORTS_LatchedGet( PORTS_MODULE_ID index, PORTS_CHANNEL channel )
161:                 {
162:                     SYS_ASSERT(false, "This API is not supported on this device");
163:                     /* TODO: Call corresponding PLIB API */
164:                     return 0;
165:                 }
166:                 
167:                 /******************************************************************************
168:                   Function:
169:                     void SYS_PORTS_Set( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
170:                 	                         PORTS_DATA_TYPE value,
171:                                          PORTS_DATA_MASK mask )
172:                 
173:                   Summary:
174:                     Sets the selected digital port/latch based on the mask.
175:                 
176:                   Description:
177:                     This function sets the selected digital port/latch relative to the mask.
178:                 
179:                   Remarks:
180:                     None.
181:                 */
182:                 
183:                 void SYS_PORTS_Set( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
184:                                     PORTS_DATA_TYPE value,
185:                                     PORTS_DATA_MASK mask )
186:                 {
187:                     PLIB_PORTS_Set( index, channel, value, mask );
188:                 }
189:                 
190:                 
191:                 /******************************************************************************
192:                   Function:
193:                     void SYS_PORTS_Clear ( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
194:                                            PORTS_DATA_MASK clearMask )
195:                 
196:                   Summary:
197:                     Clears the selected digital port.
198:                 
199:                   Description:
200:                     This function clears the selected digital port.
201:                 
202:                   Remarks:
203:                     None.
204:                 */
205:                 
206:                 void SYS_PORTS_Clear ( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
207:                                            PORTS_DATA_MASK clearMask )
208:                 {
209:                     PLIB_PORTS_Clear ( index, channel, clearMask );
210:                 }
211:                 
212:                 
213:                 /******************************************************************************
214:                   Function:
215:                     void SYS_PORTS_DirectionSelect( PORTS_MODULE_ID index,
216:                 								SYS_PORTS_PIN_DIRECTION pinDir,
217:                 								PORTS_CHANNEL channel,
218:                 								PORTS_DATA_MASK mask )
219:                   Summary:
220:                     Enables the direction for the selected port.
221:                 
222:                   Description:
223:                     This function enables the direction for the selected port.
224:                 
225:                   Remarks:
226:                     None.
227:                 */
228:                 
229:                 void SYS_PORTS_DirectionSelect( PORTS_MODULE_ID index,
230:                                              SYS_PORTS_PIN_DIRECTION pinDir,
231:                                              PORTS_CHANNEL channel,
232:                                              PORTS_DATA_MASK mask )
233:                 {
234:                     if (pinDir == SYS_PORTS_DIRECTION_INPUT)
235:                     {
236:                         PLIB_PORTS_DirectionInputSet(index, channel, mask);
237:                     }
238:                     else
239:                     {
240:                         PLIB_PORTS_DirectionOutputSet(index, channel, mask);
241:                     }
242:                 }
243:                 
244:                 
245:                 /******************************************************************************
246:                   Function:
247:                     PORTS_DATA_MASK SYS_PORTS_DirectionGet( PORTS_MODULE_ID index,
248:                                                             PORTS_CHANNEL channel )
249:                 
250:                   Summary:
251:                     Reads the port direction for the selected port.
252:                 
253:                   Description:
254:                     This function reads the port direction for the selected port.
255:                 
256:                   Remarks:
257:                     None.
258:                 */
259:                 
260:                 PORTS_DATA_MASK SYS_PORTS_DirectionGet( PORTS_MODULE_ID index, PORTS_CHANNEL channel )
261:                 {
262:                     return PLIB_PORTS_DirectionGet( index, channel );
263:                 }
264:                 
265:                 
266:                 /******************************************************************************
267:                   Function:
268:                     void SYS_PORTS_Toggle( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
269:                                            PORTS_DATA_MASK toggleMask )
270:                 
271:                   Summary:
272:                     Toggles the selected digital port pins.
273:                 
274:                   Description:
275:                     This function toggles the selected digital port pins.
276:                 
277:                   Remarks:
278:                     None.
279:                 */
280:                 
281:                 void SYS_PORTS_Toggle( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
282:                                        PORTS_DATA_MASK toggleMask )
283:                 {
284:                     PLIB_PORTS_Toggle( index, channel, toggleMask );
285:                 }
286:                 
287:                 
288:                 /******************************************************************************
289:                   Function:
290:                     void SYS_PORTS_OpenDrainEnable( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
291:                                                      PORTS_DATA_MASK mask )
292:                 
293:                   Summary:
294:                     Enables the open drain functionality for the selected port.
295:                 
296:                   Description:
297:                     This function enables the open drain functionality for the selected port.
298:                 
299:                   Remarks:
300:                     None.
301:                 */
302:                 
303:                 void SYS_PORTS_OpenDrainEnable( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
304:                                                 PORTS_DATA_MASK mask )
305:                 {
306:                 #if defined(PLIB_PORTS_ExistsPortsOpenDrain)
307:                     if(PLIB_PORTS_ExistsPortsOpenDrain(index))
308:                     {
309:                         PLIB_PORTS_OpenDrainEnable( index, channel, mask );
310:                     }
311:                 #endif
312:                 }
313:                 
314:                 
315:                 /******************************************************************************
316:                   Function:
317:                     void SYS_PORTS_OpenDrainDisable( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
318:                                                      PORTS_DATA_MASK mask )
319:                 
320:                   Summary:
321:                     Disables the open drain functionality for the selected port.
322:                 
323:                   Description:
324:                     This function disables the open drain functionality for the selected port.
325:                 
326:                   Remarks:
327:                     None.
328:                 */
329:                 
330:                 void SYS_PORTS_OpenDrainDisable( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
331:                                                  PORTS_DATA_MASK mask )
332:                 {
333:                 #if defined(PLIB_PORTS_ExistsPortsOpenDrain)
334:                     if(PLIB_PORTS_ExistsPortsOpenDrain(index))
335:                     {
336:                         PLIB_PORTS_OpenDrainDisable( index, channel, mask );
337:                     }
338:                 #endif
339:                 }
340:                 
341:                 // *****************************************************************************
342:                 /* Function:
343:                     PORTS_DATA_TYPE SYS_PORTS_InterruptStatusGet
344:                     ( 
345:                         PORTS_MODULE_ID index, 
346:                         PORTS_CHANNEL channel 
347:                     )
348:                 
349:                   Summary:
350:                     Reads the data from the I/O port.
351:                 	<p><b>Implementation:</b> Dynamic</p>
352:                 
353:                   Description:
354:                     This function reads the data from the I/O port.
355:                 
356:                 */
357:                 
358:                 PORTS_DATA_TYPE SYS_PORTS_InterruptStatusGet
359:                 ( 
360:                     PORTS_MODULE_ID index, 
361:                     PORTS_CHANNEL channel 
362:                 )
363:                 {
364:                     SYS_ASSERT(false, "This API is not supported on this device");
365:                     return 0;
366:                 }
367:                 
368:                 // *****************************************************************************
369:                 // *****************************************************************************
370:                 // Section: SYS Change Notification Pins Routines
371:                 // *****************************************************************************
372:                 // *****************************************************************************
373:                 
374:                 /******************************************************************************
375:                   Function:
376:                     void SYS_PORTS_ChangeNotificationGlobalEnable( PORTS_MODULE_ID index )
377:                 
378:                   Summary:
379:                     Globally enables the change notification.
380:                 
381:                   Description:
382:                     This function globally enables the change notification.
383:                 
384:                   Remarks:
385:                     None.
386:                 */
387:                 
388:                 void SYS_PORTS_ChangeNotificationGlobalEnable( PORTS_MODULE_ID index )
389:                 {
390:                 #if defined(PLIB_PORTS_ExistsChangeNotice)
391:                     if(PLIB_PORTS_ExistsChangeNotice(index))
392:                     {
393:                         PLIB_PORTS_ChangeNoticeEnable( index );
394:                     }
395:                 #endif
396:                 }
397:                 
398:                 /******************************************************************************
399:                   Function:
400:                     void SYS_PORTS_ChangeNotificationGlobalDisable( PORTS_MODULE_ID index )
401:                 
402:                   Summary:
403:                     Globally disables the change notification.
404:                 
405:                   Description:
406:                     This function globally disables the change notification.
407:                 
408:                   Remarks:
409:                     None.
410:                 */
411:                 
412:                 void SYS_PORTS_ChangeNotificationGlobalDisable( PORTS_MODULE_ID index )
413:                 {
414:                 #if defined(PLIB_PORTS_ExistsChangeNotice)
415:                     if(PLIB_PORTS_ExistsChangeNotice(index))
416:                     {
417:                         PLIB_PORTS_ChangeNoticeDisable( index );
418:                     }
419:                 #endif
420:                 }
421:                 
422:                 /******************************************************************************
423:                   Function:
424:                     void SYS_PORTS_GlobalChangeNotificationDisable( PORTS_MODULE_ID index )
425:                 
426:                   Summary:
427:                     Globally disables the change notification for the selected port.
428:                 
429:                   Description:
430:                     This function globally disables the change notification for the selected port.
431:                 
432:                   Remarks:
433:                     None.
434:                 */
435:                 
436:                 void SYS_PORTS_GlobalChangeNotificationDisable( PORTS_MODULE_ID index )
437:                 {
438:                 #if defined(PLIB_PORTS_ExistsChangeNotice)
439:                     if(PLIB_PORTS_ExistsChangeNotice(index))
440:                     {
441:                         PLIB_PORTS_ChangeNoticeDisable( index );
442:                     }
443:                 #endif
444:                 }
445:                 
446:                 
447:                 /******************************************************************************
448:                   Function:
449:                     void SYS_PORTS_ChangeNotificationEnable( PORTS_MODULE_ID index,
450:                                                              PORTS_CHANGE_NOTICE_PIN pinNum,
451:                                                              SYS_PORTS_PULLUP_PULLDOWN_STATUS value )
452:                 
453:                   Summary:
454:                     Enables the change notification for the selected port.
455:                 
456:                   Description:
457:                     This function enables the change notification for the selected port.
458:                 
459:                   Remarks:
460:                     None.
461:                 */
462:                 
463:                 void SYS_PORTS_ChangeNotificationEnable( PORTS_MODULE_ID index,
464:                                                          PORTS_CHANGE_NOTICE_PIN pinNum,
465:                                                          SYS_PORTS_PULLUP_PULLDOWN_STATUS value )
466:                 {
467:                 #if defined(PLIB_PORTS_ExistsChangeNoticePullUp)
468:                     if(PLIB_PORTS_ExistsChangeNoticePullUp(index))
469:                     {
470:                         switch(value)
471:                         {
472:                             case SYS_PORTS_PULLUP_DISABLE:
473:                                 PLIB_PORTS_ChangeNoticePullUpDisable(index, pinNum);
474:                                 break;
475:                             case SYS_PORTS_PULLUP_ENABLE:
476:                                 PLIB_PORTS_ChangeNoticePullUpEnable(index, pinNum);
477:                                 break;
478:                         }
479:                     }
480:                 #endif
481:                 
482:                 #if defined(PLIB_PORTS_ExistsPinChangeNotice)
483:                     if(PLIB_PORTS_ExistsPinChangeNotice(index))
484:                     {
485:                         PLIB_PORTS_PinChangeNoticeEnable( index, pinNum );
486:                     }
487:                 #endif
488:                 }
489:                 
490:                 
491:                 /******************************************************************************
492:                   Function:
493:                     void SYS_PORTS_ChangeNotificationDisable( PORTS_MODULE_ID index,
494:                                                               PORTS_CHANGE_NOTICE_PIN pinNum )
495:                 
496:                   Summary:
497:                     Disables the change notification for the selected port.
498:                 
499:                   Description:
500:                     This function disables the change notification for the selected port.
501:                 
502:                   Remarks:
503:                     None.
504:                 */
505:                 
506:                 void SYS_PORTS_ChangeNotificationDisable( PORTS_MODULE_ID index,
507:                                                           PORTS_CHANGE_NOTICE_PIN pinNum )
508:                 {
509:                 #if defined(PLIB_PORTS_ExistsPinChangeNotice)
510:                     if(PLIB_PORTS_ExistsPinChangeNotice(index))
511:                     {
512:                         PLIB_PORTS_PinChangeNoticeDisable( index, pinNum );
513:                     }
514:                 #endif
515:                 }
516:                 
517:                 
518:                 /******************************************************************************
519:                   Function:
520:                     void SYS_PORTS_ChangeNotificationInIdleModeEnable( PORTS_MODULE_ID index )
521:                 
522:                   Summary:
523:                     Enables the change notification for the selected port in Sleep or Idle mode.
524:                 
525:                   Description:
526:                     This function enables the change notification for the selected port in Sleep
527:                     or Idle mode.
528:                 
529:                   Remarks:
530:                     None.
531:                 */
532:                 
533:                 void SYS_PORTS_ChangeNotificationInIdleModeEnable( PORTS_MODULE_ID index )
534:                 {
535:                 #if defined(PLIB_PORTS_ExistsChangeNoticeInIdle)
536:                     if(PLIB_PORTS_ExistsChangeNoticeInIdle(index))
537:                     {
538:                         PLIB_PORTS_ChangeNoticeInIdleEnable( index );
539:                     }
540:                 #endif
541:                 }
542:                 
543:                 
544:                 // *****************************************************************************
545:                 /* Function:
546:                     void SYS_PORTS_ChangeNotificationInIdleModeDisable( PORTS_MODULE_ID index)
547:                 
548:                   Summary:
549:                     Disables the change notification for the selected port in Sleep or Idle mode.
550:                 
551:                   Description:
552:                     This function disables the change notification for the selected port in Sleep
553:                     or Idle mode.
554:                 
555:                   Remarks:
556:                     None.
557:                 */
558:                 
559:                 void SYS_PORTS_ChangeNotificationInIdleModeDisable( PORTS_MODULE_ID index )
560:                 {
561:                 #if defined(PLIB_PORTS_ExistsChangeNoticeInIdle)
562:                     if(PLIB_PORTS_ExistsChangeNoticeInIdle(index))
563:                     {
564:                         PLIB_PORTS_ChangeNoticeInIdleDisable( index );
565:                     }
566:                 #endif
567:                 }
568:                 
569:                 
570:                 // *****************************************************************************
571:                 /* Function:
572:                     void SYS_PORTS_ChangeNotificationPullUpEnable ( PORTS_MODULE_ID         index,
573:                                                                     PORTS_CHANGE_NOTICE_PIN pinNum )
574:                 
575:                   Summary:
576:                     Enables weak pull-up on change notification pin.
577:                 
578:                   Description:
579:                     This function enables weak pull-up on change notification pin.
580:                 
581:                   Remarks:
582:                     None.
583:                 */
584:                 
585:                 void SYS_PORTS_ChangeNotificationPullUpEnable ( PORTS_MODULE_ID         index,
586:                                                                 PORTS_CHANGE_NOTICE_PIN pinNum )
587:                 {
588:                 #if defined(PLIB_PORTS_ExistsChangeNoticePullUp)
589:                     if(PLIB_PORTS_ExistsChangeNoticePullUp(index))
590:                     {
591:                         PLIB_PORTS_ChangeNoticePullUpEnable ( index, pinNum );
592:                     }
593:                 #endif
594:                 }
595:                 
596:                 
597:                 // *****************************************************************************
598:                 /* Function:
599:                     void SYS_PORTS_ChangeNotificationPullUpDisable ( PORTS_MODULE_ID         index,
600:                                                                     PORTS_CHANGE_NOTICE_PIN pinNum )
601:                 
602:                   Summary:
603:                     Disables pull-up on input change.
604:                 
605:                   Description:
606:                     This function disables pull-up on input change.
607:                 
608:                   Remarks:
609:                     None.
610:                 */
611:                 
612:                 void SYS_PORTS_ChangeNotificationPullUpDisable ( PORTS_MODULE_ID         index,
613:                                                                 PORTS_CHANGE_NOTICE_PIN pinNum )
614:                 {
615:                 #if defined(PLIB_PORTS_ExistsChangeNoticePullUp)
616:                     if(PLIB_PORTS_ExistsChangeNoticePullUp(index))
617:                     {
618:                         PLIB_PORTS_ChangeNoticePullUpDisable ( index, pinNum );
619:                     }
620:                 #endif
621:                 }
622:                 
623:                 
624:                 // *****************************************************************************
625:                 // *****************************************************************************
626:                 // Section: SYS PORT PINS Control Routines
627:                 // *****************************************************************************
628:                 // *****************************************************************************
629:                 
630:                 // *****************************************************************************
631:                 /* Function:
632:                     void SYS_PORTS_PinModeSelect ( PORTS_MODULE_ID index, PORTS_ANALOG_PIN pin,
633:                     								PORTS_PIN_MODE mode)
634:                 
635:                   Summary:
636:                     Enables the selected pin as analog or digital.
637:                 
638:                   Description:
639:                     This function enables the selected pin as analog or digital.
640:                 
641:                  Remarks:
642:                     None.
643:                 */
644:                 
645:                 void SYS_PORTS_PinModeSelect ( PORTS_MODULE_ID index, PORTS_ANALOG_PIN pin,
646:                 								PORTS_PIN_MODE mode)
647:                 {
648:                 #if defined(PLIB_PORTS_ExistsPinMode)
649:                     if(PLIB_PORTS_ExistsPinMode(index))
650:                     {
651:                         PLIB_PORTS_PinModeSelect ( index, pin, mode);
652:                     }
653:                 #endif
654:                 }
655:                 
656:                 
657:                 // *****************************************************************************
658:                 /* Function:
659:                     void SYS_PORTS_PinWrite ( PORTS_MODULE_ID index,
660:                                               PORTS_CHANNEL channel,
661:                                               PORTS_BIT_POS bitPos
662:                                               bool value )
663:                   Summary:
664:                     Writes the selected digital pin.
665:                 
666:                   Description:
667:                     This function writes the selected digital pin.
668:                 
669:                   Remarks:
670:                     None.
671:                 */
672:                 
673:                 void SYS_PORTS_PinWrite ( PORTS_MODULE_ID index,
674:                                           PORTS_CHANNEL channel,
675:                                           PORTS_BIT_POS bitPos,
676:                                           bool value )
677:                 {
678:                     PLIB_PORTS_PinWrite ( index, channel, bitPos, value );
679:                 }
680:                 
681:                 
682:                 // *****************************************************************************
683:                 /* Function:
684:                     bool SYS_PORTS_PinLatchedGet ( PORTS_MODULE_ID index,
685:                                              PORTS_CHANNEL channel,
686:                                              PORTS_BIT_POS bitPos )
687:                 
688:                   Summary:
689:                     Reads the data driven on selected digital pin.
690:                 
691:                   Description:
692:                     This function reads the driven data on selected digital pin.
693:                 
694:                   Remarks:
695:                     None.
696:                 */
697:                 
698:                 bool SYS_PORTS_PinLatchedGet ( PORTS_MODULE_ID index,
699:                                          PORTS_CHANNEL channel,
700:                                          PORTS_BIT_POS bitPos )
701:                 {
702:                     SYS_ASSERT(false, "This API is not supported on this device");
703:                     /* TODO: Call corresponding PLIB API */
704:                     return false;
705:                 }
706:                 
707:                 
708:                 // *****************************************************************************
709:                 /* Function:
710:                     bool SYS_PORTS_PinRead ( PORTS_MODULE_ID index,
711:                                              PORTS_CHANNEL channel,
712:                                              PORTS_BIT_POS bitPos )
713:                 
714:                   Summary:
715:                     Reads the selected digital pin.
716:                 
717:                   Description:
718:                     This function reads the selected digital pin.
719:                 
720:                   Remarks:
721:                     None.
722:                 */
723:                 
724:                 bool SYS_PORTS_PinRead ( PORTS_MODULE_ID index,
725:                                          PORTS_CHANNEL channel,
726:                                          PORTS_BIT_POS bitPos )
727:                 {
728:                     return PLIB_PORTS_PinGet ( index, channel, bitPos );
729:                 }
9D0151A8  03E00008   JR RA
9D0151AC  30420001   ANDI V0, V0, 1
730:                 
731:                 
732:                 // *****************************************************************************
733:                 /* Function:
734:                     void SYS_PORTS_PinToggle ( PORTS_MODULE_ID index,
735:                                                PORTS_CHANNEL channel,
736:                                                PORTS_BIT_POS bitPos )
737:                 
738:                   Summary:
739:                     Toggles the selected digital pin.
740:                 
741:                   Description:
742:                     This function toggles the selected digital pin.
743:                 
744:                   Remarks:
745:                     None.
746:                 */
747:                 
748:                 void SYS_PORTS_PinToggle ( PORTS_MODULE_ID index,
749:                                            PORTS_CHANNEL channel,
750:                                            PORTS_BIT_POS bitPos )
751:                 {
752:                     PLIB_PORTS_PinToggle ( index, channel, bitPos );
753:                 }
754:                 
755:                 
756:                 // *****************************************************************************
757:                 /* Function:
758:                     void SYS_PORTS_PinSet( PORTS_MODULE_ID index,
759:                                            PORTS_CHANNEL channel,
760:                                            PORTS_BIT_POS bitPos )
761:                 
762:                   Summary:
763:                     Sets the selected digital pin/latch.
764:                 
765:                   Description:
766:                     This function sets the selected digital pin/latch.
767:                 
768:                   Remarks:
769:                     None.
770:                 */
771:                 
772:                 void SYS_PORTS_PinSet( PORTS_MODULE_ID index,
773:                                        PORTS_CHANNEL channel,
774:                                        PORTS_BIT_POS bitPos )
775:                 {
776:                     PLIB_PORTS_PinSet( index, channel, bitPos );
777:                 }
778:                 
779:                 
780:                 // *****************************************************************************
781:                 /* Function:
782:                     void SYS_PORTS_PinClear ( PORTS_MODULE_ID index,
783:                                               PORTS_CHANNEL channel,
784:                                               PORTS_BIT_POS bitPos )
785:                 
786:                   Summary:
787:                     Clears the selected digital pin.
788:                 
789:                   Description:
790:                     This function clears the selected digital pin.
791:                 
792:                   Remarks:
793:                     None.
794:                 */
795:                 
796:                 void SYS_PORTS_PinClear ( PORTS_MODULE_ID index,
797:                                           PORTS_CHANNEL channel,
798:                                           PORTS_BIT_POS bitPos )
799:                 {
800:                     PLIB_PORTS_PinClear ( index, channel, bitPos );
801:                 }
802:                 
803:                 
804:                 // *****************************************************************************
805:                 /* Function:
806:                     void SYS_PORTS_PinDirectionSelect ( PORTS_MODULE_ID index,
807:                                                      SYS_PORTS_PIN_DIRECTION pinDir,
808:                                                      PORTS_CHANNEL channel,
809:                                                      PORTS_BIT_POS bitPos )
810:                   Summary:
811:                     Enables the direction for the selected pin.
812:                 
813:                   Description:
814:                     This function enables the direction for the selected pin.
815:                 
816:                   Remarks:
817:                     None.
818:                 */
819:                 
820:                 void SYS_PORTS_PinDirectionSelect ( PORTS_MODULE_ID index,
821:                                                  SYS_PORTS_PIN_DIRECTION pinDir,
822:                                                  PORTS_CHANNEL channel,
823:                                                  PORTS_BIT_POS bitPos )
824:                 {
825:                     if (pinDir == SYS_PORTS_DIRECTION_OUTPUT)
826:                     {
827:                         PLIB_PORTS_PinDirectionOutputSet(index, channel, bitPos);
828:                     }
829:                     else
830:                     {
831:                         PLIB_PORTS_PinDirectionInputSet(index, channel, bitPos);
832:                     }
833:                 }
834:                 
835:                 
836:                 // *****************************************************************************
837:                 /* Function:
838:                     void SYS_PORTS_PinOpenDrainEnable ( PORTS_MODULE_ID index,
839:                                                         PORTS_CHANNEL channel,
840:                                                         PORTS_BIT_POS bitPos )
841:                 
842:                   Summary:
843:                     Enables the open-drain functionality for the selected pin.
844:                 
845:                   Description:
846:                     This function enables the open-drain functionality for the selected pin.
847:                 
848:                   Remarks:
849:                     None.
850:                 */
851:                 
852:                 void SYS_PORTS_PinOpenDrainEnable ( PORTS_MODULE_ID index,
853:                                                     PORTS_CHANNEL channel,
854:                                                     PORTS_BIT_POS bitPos )
855:                 {
856:                 #if defined(PLIB_PORTS_ExistsPortsOpenDrain)
857:                     if(PLIB_PORTS_ExistsPortsOpenDrain(index))
858:                     {
859:                         PLIB_PORTS_PinOpenDrainEnable ( index, channel, bitPos );
860:                     }
861:                 #endif
862:                 }
863:                 
864:                 
865:                 // *****************************************************************************
866:                 /* Function:
867:                     void SYS_PORTS_PinOpenDrainDisable ( PORTS_MODULE_ID index,
868:                                                          PORTS_CHANNEL channel,
869:                                                          PORTS_BIT_POS bitPos )
870:                 
871:                   Summary:
872:                     Disables the open-drain functionality for the selected pin.
873:                 
874:                   Description:
875:                     This function disables the open-drain functionality for the selected pin.
876:                 
877:                   Remarks:
878:                     None.
879:                 */
880:                 
881:                 void SYS_PORTS_PinOpenDrainDisable ( PORTS_MODULE_ID index,
882:                                                      PORTS_CHANNEL channel,
883:                                                      PORTS_BIT_POS bitPos )
884:                 {
885:                 #if defined(PLIB_PORTS_ExistsPortsOpenDrain)
886:                     if(PLIB_PORTS_ExistsPortsOpenDrain(index))
887:                     {
888:                         PLIB_PORTS_PinOpenDrainDisable ( index, channel, bitPos );
889:                     }
890:                 #endif
891:                 }
892:                 
893:                 
894:                 // *****************************************************************************
895:                 /* Function:
896:                     void SYS_PORTS_PinPullUpEnable ( PORTS_MODULE_ID index, 
897:                                                         PORTS_CHANNEL channel,
898:                                                         PORTS_BIT_POS bitPos )
899:                 
900:                   Summary:
901:                     Enables the pull-up functionality for the selected pin.
902:                 	<p><b>Implementation:</b> Dynamic</p>
903:                 
904:                   Description:
905:                     This function enables the pull-up functionality for the selected pin.
906:                 
907:                   Remarks:
908:                     Not all features are available on all devices. Refer to the specific device
909:                     data sheet for availability.
910:                 */
911:                 
912:                 void SYS_PORTS_PinPullUpEnable ( PORTS_MODULE_ID index, 
913:                                                     PORTS_CHANNEL channel,
914:                                                     PORTS_BIT_POS bitPos )
915:                 {
916:                     SYS_ASSERT(false, "This API is not supported on this device");
917:                     return;
918:                 }
919:                 
920:                 
921:                 // *****************************************************************************
922:                 /* Function:
923:                     void SYS_PORTS_PinPullUpDisable ( PORTS_MODULE_ID index, 
924:                                                          PORTS_CHANNEL channel,
925:                                                          PORTS_BIT_POS bitPos )
926:                 
927:                   Summary:
928:                     Disables the pull-up functionality for the selected pin.
929:                 	<p><b>Implementation:</b> Dynamic</p>
930:                 
931:                   Description:
932:                     This function disables the pull-up functionality for the selected pin.
933:                 
934:                   Remarks:
935:                     Not all features are available on all devices. Refer to the specific device
936:                     data sheet for availability.
937:                 */
938:                 
939:                 void SYS_PORTS_PinPullUpDisable ( PORTS_MODULE_ID index, 
940:                                                      PORTS_CHANNEL channel,
941:                                                      PORTS_BIT_POS bitPos )
942:                 {
943:                     SYS_ASSERT(false, "This API is not supported on this device");
944:                     return;
945:                 }
946:                 
947:                 
948:                 // *****************************************************************************
949:                 /* Function:
950:                     void SYS_PORTS_PinPullDownEnable ( PORTS_MODULE_ID index, 
951:                                                         PORTS_CHANNEL channel,
952:                                                         PORTS_BIT_POS bitPos )
953:                 
954:                   Summary:
955:                     Enables the pull-down functionality for the selected pin.
956:                 	<p><b>Implementation:</b> Dynamic</p>
957:                 
958:                   Description:
959:                     This function enables the pull-down functionality for the selected pin.
960:                 
961:                   Remarks:
962:                     Not all features are available on all devices. Refer to the specific device
963:                     data sheet for availability.
964:                 */
965:                 
966:                 void SYS_PORTS_PinPullDownEnable ( PORTS_MODULE_ID index, 
967:                                                     PORTS_CHANNEL channel,
968:                                                     PORTS_BIT_POS bitPos )
969:                 {
970:                     SYS_ASSERT(false, "This API is not supported on this device");
971:                     return;
972:                 }
973:                 
974:                 
975:                 // *****************************************************************************
976:                 /* Function:
977:                     void SYS_PORTS_PinPullDownDisable ( PORTS_MODULE_ID index, 
978:                                                          PORTS_CHANNEL channel,
979:                                                          PORTS_BIT_POS bitPos )
980:                 
981:                   Summary:
982:                     Disables the pull-down functionality for the selected pin.
983:                 	<p><b>Implementation:</b> Dynamic</p>
984:                 
985:                   Description:
986:                     This function disables the pull-down functionality for the selected pin.
987:                 
988:                   Remarks:
989:                     Not all features are available on all devices. Refer to the specific device
990:                     data sheet for availability.
991:                 */
992:                 
993:                 void SYS_PORTS_PinPullDownDisable ( PORTS_MODULE_ID index, 
994:                                                      PORTS_CHANNEL channel,
995:                                                      PORTS_BIT_POS bitPos )
996:                 {
997:                     SYS_ASSERT(false, "This API is not supported on this device");
998:                     return;
999:                 }
1000:                                                     
1001:                                                     
1002:                /******************************************************************************
1003:                  Function:
1004:                    void SYS_PORTS_InterruptEnable
1005:                    (
1006:                        PORTS_MODULE_ID index,
1007:                        PORTS_CHANNEL channel,
1008:                        PORTS_BIT_POS bitPos,
1009:                        PORTS_PIN_INTERRUPT_TYPE pinInterruptType
1010:                    )
1011:                
1012:                  Summary:
1013:                    Enables the change notification interrupt for the selected port pin.
1014:                
1015:                  Description:
1016:                    This function enables the change notification interrupt of selected type
1017:                    for the selected port pin.
1018:                
1019:                  Remarks:
1020:                    None.
1021:                */
1022:                void SYS_PORTS_InterruptEnable
1023:                (
1024:                    PORTS_MODULE_ID index,
1025:                    PORTS_CHANNEL channel,
1026:                    PORTS_BIT_POS bitPos,
1027:                    PORTS_PIN_INTERRUPT_TYPE pinInterruptType
1028:                )
1029:                {
1030:                    SYS_ASSERT(false, "This API is not supported on this device");
1031:                    return;
1032:                }
1033:                
1034:                
1035:                // *****************************************************************************
1036:                /* Function:
1037:                    void SYS_PORTS_RemapInput( PORTS_MODULE_ID      index,
1038:                							  PORTS_REMAP_INPUT_FUNCTION function,
1039:                							  PORTS_REMAP_INPUT_PIN      remapPin )
1040:                
1041:                  Summary:
1042:                    Input/Output (I/O) function remapping.
1043:                
1044:                  Description:
1045:                    This function controls the I/O function remapping.
1046:                
1047:                  Precondition:
1048:                    None.
1049:                */	
1050:                void SYS_PORTS_RemapInput( PORTS_MODULE_ID      index,
1051:                						   PORTS_REMAP_INPUT_FUNCTION function,
1052:                						   PORTS_REMAP_INPUT_PIN      remapPin )
1053:                {
1054:                #if defined(PLIB_PORTS_ExistsRemapInput)
1055:                    if(PLIB_PORTS_ExistsRemapInput(index))
1056:                    {
1057:                        PLIB_DEVCON_SystemUnlock(DEVCON_ID_0);
1058:                        PLIB_DEVCON_DeviceRegistersUnlock(DEVCON_ID_0, DEVCON_PPS_REGISTERS);
1059:                        PLIB_PORTS_RemapInput( index, function, remapPin);
1060:                    }
1061:                #endif
1062:                }
1063:                
1064:                // *****************************************************************************
1065:                /* Function:
1066:                    void SYS_PORTS_RemapOutput( PORTS_MODULE_ID      index,
1067:                                                      PORTS_REMAP_OUTPUT_FUNCTION function,
1068:                                                      PORTS_REMAP_OUTPUT_PIN      remapPin )
1069:                
1070:                  Summary:
1071:                    Input/Output (I/O) function remapping.
1072:                
1073:                  Description:
1074:                    This function controls the I/O function remapping.
1075:                
1076:                  Precondition:
1077:                    None.
1078:                */
1079:                void SYS_PORTS_RemapOutput( PORTS_MODULE_ID      index,
1080:                						    PORTS_REMAP_OUTPUT_FUNCTION function,
1081:                						    PORTS_REMAP_OUTPUT_PIN      remapPin )
1082:                {
1083:                #if defined(PLIB_PORTS_ExistsRemapOutput)
1084:                    if(PLIB_PORTS_ExistsRemapOutput(index))
1085:                    {
1086:                        PLIB_DEVCON_SystemUnlock(DEVCON_ID_0);
1087:                        PLIB_DEVCON_DeviceRegistersUnlock(DEVCON_ID_0, DEVCON_PPS_REGISTERS);
1088:                        PLIB_PORTS_RemapOutput( index, function, remapPin);
1089:                    }
1090:                #endif
1091:                }
1092:                
1093:                /*******************************************************************************
1094:                 End of File
1095:                */
---  /home/whatisthis/src/DoorBell_PIC32/firmware/src/system_config/default/framework/system/devcon/src/sys_devcon_pic32mx.c
1:                   /*******************************************************************************
2:                     Device Control System Service Implementation
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       sys_devcon.c
9:                   
10:                    Summary:
11:                      Device Control System Service implementation.
12:                  
13:                    Description:
14:                      The DEVCON system service provides a simple interface to manage the Device 
15:                      Control module on Microchip microcontrollers. This file Implements the core
16:                      interface routines for the Device Control system service. While building 
17:                      the system service from source, ALWAYS include this file in the build.
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  //DOM-IGNORE-END
44:                  
45:                  
46:                  // *****************************************************************************
47:                  // *****************************************************************************
48:                  // Section: Included Files
49:                  // *****************************************************************************
50:                  // *****************************************************************************
51:                  
52:                  #include "sys_devcon_local.h"
53:                  #include "peripheral/int/plib_int.h"
54:                  #include "peripheral/osc/plib_osc.h"
55:                  #include "peripheral/pcache/plib_pcache.h"
56:                  #include "peripheral/bmx/plib_bmx.h"
57:                  
58:                  // *****************************************************************************
59:                  // *****************************************************************************
60:                  // Section: File Scope or Global Constants
61:                  // *****************************************************************************
62:                  // *****************************************************************************
63:                  
64:                  // *****************************************************************************
65:                  // *****************************************************************************
66:                  // Section: Variable Definitions
67:                  // *****************************************************************************
68:                  // *****************************************************************************
69:                  //
70:                  #ifndef PLIB_PCACHE_PREFETCH_ENABLE_ALL
71:                  #define PLIB_PCACHE_PREFETCH_ENABLE_ALL 3
72:                  #endif
73:                  
74:                  // *****************************************************************************
75:                  /* Function:
76:                      void SYS_DEVCON_PerformanceConfig( void )
77:                  
78:                    Summary:
79:                      Configures the PFM wait states and prefetch (cache) module for maximum 
80:                      performance.
81:                  
82:                    Description:
83:                      This function configures the PFM wait states and prefetch (cache) module 
84:                      for maximum performance.
85:                  
86:                    Remarks:
87:                      None.
88:                  */
89:                  
90:                  void __attribute__((nomips16)) SYS_DEVCON_PerformanceConfig( unsigned int sysclk )
91:                  {
9D0140B4  27BDFFF8   ADDIU SP, SP, -8
9D0140B8  AFBF0004   SW RA, 4(SP)
92:                      bool int_flag = false;
93:                      register unsigned long tmp = 0;
94:                  
95:                      /* Set kseg0 coherency algorithm to "cacheable, non-coherent, write-back, 
96:                       * write-allocate. This is needed for the prefetch buffer */
97:                      asm("mfc0 %0,$16,0" :  "=r"(tmp));
9D0140BC  40028000   MFC0 V0, Config
98:                      tmp = (tmp & ~7) | 3;
9D0140C0  7C021004   INS V0, ZERO, 0, 3
9D0140C4  34420003   ORI V0, V0, 3
99:                      asm("mtc0 %0,$16,0" :: "r" (tmp));
9D0140C8  40828000   MTC0 V0, Config
100:                 
101:                     /* Set the PFM wait states based on the system clock */
102:                     #if defined(PLIB_PCACHE_ExistsWaitState)
103:                     if (PLIB_PCACHE_ExistsWaitState(PCACHE_ID_0))
104:                     {
105:                         int ws; /* number of wait states */
106:                         if (sysclk <= 30000000)
107:                             ws = 0;
108:                         else if (sysclk <= 60000000)
109:                             ws = 1;
110:                         else if (sysclk <= 80000000)
111:                             ws = 2;
112:                         else
113:                             ws = 3;
114:                         /* Interrupts must be disabled when changing wait states */
115:                         int_flag = (bool)(PLIB_INT_GetStateAndDisable( INT_ID_0 ) & 0x01);
116:                 
117:                         PLIB_PCACHE_WaitStateSet(PCACHE_ID_0, ws);
118:                 
119:                         if (int_flag)
120:                         {
121:                             PLIB_INT_Enable(INT_ID_0);
122:                             int_flag = false;
123:                         }
124:                     }
125:                     #endif // defined(PLIB_PCACHE_ExistsWaitState)
126:                 
127:                     /* Interrupts must be disabled when enabling the Prefetch Cache Module */
128:                     int_flag = (bool)(PLIB_INT_GetStateAndDisable( INT_ID_0 ) & 0x01);
9D0140E4  30820001   ANDI V0, A0, 1
129:                 
130:                     /* Enable Prefetch Cache Module */
131:                     #if defined(PLIB_PCACHE_ExistsPrefetchEnable)
132:                     if (PLIB_PCACHE_ExistsPrefetchEnable(PCACHE_ID_0))
133:                     {
134:                         PLIB_PCACHE_PrefetchEnableSet(PCACHE_ID_0, PLIB_PCACHE_PREFETCH_ENABLE_ALL);
135:                     }
136:                     #endif
137:                 
138:                     /* Set the SRAM wait states to zero */
139:                     #if defined (PLIB_BMX_ExistsDataRamWaitState)
140:                     if (PLIB_BMX_ExistsDataRamWaitState(BMX_ID_0))
141:                     {
142:                         PLIB_BMX_DataRamWaitStateSet(BMX_ID_0, PLIB_BMX_DATA_RAM_WAIT_ZERO);
143:                     }            
144:                     #endif
145:                     if (int_flag)
9D0140E8  10400006   BEQ V0, ZERO, 0x9D014104
9D0140EC  8FBF0004   LW RA, 4(SP)
146:                     {
147:                         PLIB_INT_Enable(INT_ID_0);
148:                     }
149:                 }
9D014100  8FBF0004   LW RA, 4(SP)
9D014104  03E00008   JR RA
9D014108  27BD0008   ADDIU SP, SP, 8
150:                 
151:                 /*******************************************************************************
152:                  End of File
153:                 */
154:                 
---  /home/whatisthis/src/DoorBell_PIC32/firmware/src/system_config/default/framework/system/devcon/src/sys_devcon.c
1:                   /*******************************************************************************
2:                     Device Control System Service Implementation
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       sys_devcon.c
9:                   
10:                    Summary:
11:                      Device Control System Service implementation.
12:                  
13:                    Description:
14:                      The DEVCON system service provides a simple interface to manage the Device 
15:                      Control module on PIC32M Microchip microcontrollers. This file Implements 
16:                      the core interface routines for the Device Control system service.  While 
17:                      building the system service from source, ALWAYS include this file in the 
18:                      build for PIC32M devices.
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  //DOM-IGNORE-END
45:                  
46:                  
47:                  // *****************************************************************************
48:                  // *****************************************************************************
49:                  // Section: Included Files
50:                  // *****************************************************************************
51:                  // *****************************************************************************
52:                  
53:                  #include "system/devcon/src/sys_devcon_local.h"
54:                  #include "peripheral/int/plib_int.h"
55:                  #include "peripheral/devcon/plib_devcon.h"
56:                  #include "peripheral/osc/plib_osc.h"
57:                  
58:                  // *****************************************************************************
59:                  // *****************************************************************************
60:                  // Section: File Scope or Global Constants
61:                  // *****************************************************************************
62:                  // *****************************************************************************
63:                  
64:                  // *****************************************************************************
65:                  // *****************************************************************************
66:                  // Section: Variable Definitions
67:                  // *****************************************************************************
68:                  // *****************************************************************************
69:                  
70:                  /* System Device Control Instance */
71:                  SYS_DEVCON_OBJECT sysDevconObj;
72:                  
73:                  
74:                  // *****************************************************************************
75:                  // *****************************************************************************
76:                  // Section: SYS DEVCON Module Initialization Routines
77:                  // *****************************************************************************
78:                  // *****************************************************************************
79:                  
80:                  // *****************************************************************************
81:                  /* Function:
82:                      SYS_MODULE_OBJ SYS_DEVCON_Initialize( const SYS_MODULE_INDEX           index,
83:                                                         const SYS_MODULE_INIT * const    init )
84:                  
85:                    Summary:
86:                      Initializes data for the instance of the Device Control module and opens
87:                      the specific module instance.
88:                  
89:                    Description:
90:                      This function initializes the instance of the Device Control module,
91:                      using the specified initialization data. It also initializes any
92:                      internal data structures.
93:                  
94:                    Remarks:
95:                      This routine should only be called once during system initialization
96:                      unless SYS_DEVCON_Deinitialize is first called to deinitialize the device
97:                      instance before reinitializing it. If the system was already initialized
98:                      it safely returns without causing any disturbance.
99:                  */
100:                 
101:                 SYS_MODULE_OBJ SYS_DEVCON_Initialize( const SYS_MODULE_INDEX index,
102:                                                    const SYS_MODULE_INIT * const init )
103:                 {
104:                     sysDevconObj.status = SYS_STATUS_READY;
9D01589C  24020002   ADDIU V0, ZERO, 2
9D0158A0  AF828170   SW V0, -32400(GP)
105:                 
106:                     sysDevconObj.state = SYS_DEVCON_STATE_READY;
9D0158A4  AF80816C   SW ZERO, -32404(GP)
107:                 
108:                     return (SYS_MODULE_OBJ)SYS_DEVCON_INDEX_0;
109:                 }
9D0158A8  03E00008   JR RA
9D0158AC  00001021   ADDU V0, ZERO, ZERO
110:                 
111:                 
112:                 // *****************************************************************************
113:                 /* Function:
114:                     void SYS_DEVCON_Reinitialize( SYS_MODULE_OBJ                  object,
115:                                                const SYS_MODULE_INIT * const   init )
116:                 
117:                    Summary:
118:                     Reinitializes and refreshes the hardware for the instance of the Device 
119:                     Control module.
120:                 
121:                    Description:
122:                     This function reinitializes the instance of the Device Control module using 
123:                     the supplied data. It modifies the internal data structure.
124:                 
125:                    Remarks:
126:                     This operation uses the same initialization data structure as the
127:                     SYS_DEVCON_Initialize operation. This operation can be used to change the
128:                     power state of a DEVCON module. This function can be called multiple times
129:                     to reinitialize the module. This operation uses the same initialization
130:                     data structure as the Initialize operation. This operation can also be
131:                     used to refresh the hardware registers as defined by the initialization
132:                     data.
133:                 */
134:                 
135:                 void SYS_DEVCON_Reinitialize( SYS_MODULE_OBJ object,
136:                                            const SYS_MODULE_INIT * const init )
137:                 {
138:                     sysDevconObj.status = SYS_STATUS_READY;
139:                 
140:                     sysDevconObj.state = SYS_DEVCON_STATE_READY;
141:                 }
142:                 
143:                 
144:                 // *****************************************************************************
145:                 /* Function:
146:                     void SYS_DEVCON_Deinitialize( SYS_MODULE_OBJ object )
147:                 
148:                   Summary:
149:                     Deinitializes the specific module instance of the DEVCON module
150:                 
151:                   Description:
152:                     This function deinitializes the specific module instance disabling its operation 
153:                     (and any hardware for driver modules). Resets all of the internal data
154:                     structures and fields for the specified instance to the default settings.
155:                 
156:                   Remarks:
157:                     Once the Initialize operation has been called, the Deinitialize
158:                     operation must be called before the Initialize operation can be called
159:                     again.
160:                 */
161:                 
162:                 void SYS_DEVCON_Deinitialize( SYS_MODULE_OBJ object )
163:                 {
164:                     sysDevconObj.status = SYS_STATUS_UNINITIALIZED;
165:                 }
166:                 
167:                 
168:                 // *****************************************************************************
169:                 /* Function:
170:                     SYS_STATUS SYS_DEVCON_Status( SYS_MODULE_OBJ object )
171:                 
172:                   Summary:
173:                     Returns status of the specific instance of the Device Control module.
174:                 
175:                   Description:
176:                     This function returns the status of the specific module instance.
177:                 
178:                   Remarks:
179:                     None.
180:                 */
181:                 
182:                 SYS_STATUS SYS_DEVCON_Status( SYS_MODULE_OBJ object )
183:                 {
184:                     return sysDevconObj.status; 
185:                 }
186:                 
187:                 
188:                 // *****************************************************************************
189:                 /* Function:
190:                     void SYS_DEVCON_Tasks( SYS_MODULE_OBJ object )
191:                 
192:                   Summary:
193:                     Maintains the system Device Control state machine.
194:                 
195:                   Description:
196:                     This function is used to maintain the system Device Control internal state machine.
197:                 
198:                   Remarks:
199:                     This function is normally not called directly by an application.  It is
200:                     called by the system's Tasks routine (SYS_Tasks) or by the appropriate raw
201:                     ISR.
202:                 */
203:                 
204:                 void SYS_DEVCON_Tasks( SYS_MODULE_OBJ object )
205:                 {
206:                     switch (sysDevconObj.state)
207:                     {
208:                         case SYS_DEVCON_STATE_INIT:
209:                         case SYS_DEVCON_STATE_BUSY:
210:                         case SYS_DEVCON_STATE_READY:
211:                         default:
212:                             break;
213:                     }
214:                 }
215:                 
216:                     
217:                 // *****************************************************************************
218:                 // *****************************************************************************
219:                 // Section: SYS DEVCON Client Setup Routines
220:                 // *****************************************************************************
221:                 // *****************************************************************************
222:                 
223:                 // *****************************************************************************
224:                 /* Function:
225:                     void SYS_DEVCON_SystemUnlock( void )
226:                 
227:                   Summary:
228:                     Performs a system unlock sequence by writing to the SYSKEY register.
229:                 
230:                   Description:
231:                     Performs a system unlock sequence by writing to the SYSKEY register. A 
232:                     system unlock sequence is required before performing certain actions such
233:                     as changing a clock frequency or IO unlocking.
234:                 
235:                   Remarks:
236:                     None.
237:                 */
238:                 
239:                 void SYS_DEVCON_SystemUnlock( void )
240:                 {
9D01405C  27BDFFF8   ADDIU SP, SP, -8
9D014060  AFBF0004   SW RA, 4(SP)
241:                     bool int_flag = false;
242:                 
243:                     int_flag = (bool)(PLIB_INT_GetStateAndDisable( INT_ID_0 ) & 0x01);
9D01408C  30620001   ANDI V0, V1, 1
244:                 
245:                     PLIB_DEVCON_SystemUnlock(DEVCON_ID_0);
246:                 
247:                     if (int_flag)
9D014090  10400006   BEQ V0, ZERO, 0x9D0140AC
9D014094  8FBF0004   LW RA, 4(SP)
248:                     {
249:                         PLIB_INT_Enable(INT_ID_0);
250:                     }
251:                 }
9D0140A8  8FBF0004   LW RA, 4(SP)
9D0140AC  03E00008   JR RA
9D0140B0  27BD0008   ADDIU SP, SP, 8
252:                 
253:                 
254:                 // *****************************************************************************
255:                 /* Function:
256:                     void SYS_DEVCON_SystemLock( void )
257:                 
258:                   Summary:
259:                     Performs a system lock sequence by writing to the SYSKEY register.
260:                 
261:                   Description:
262:                     Performs a system lock sequence by writing to the SYSKEY register. A 
263:                     system lock sequence is required after performing the action that required
264:                     a system lock sequence.
265:                 
266:                   Remarks:
267:                     None.
268:                 */
269:                 
270:                 void SYS_DEVCON_SystemLock( void )
271:                 {
9D0145E8  27BDFFF8   ADDIU SP, SP, -8
9D0145EC  AFBF0004   SW RA, 4(SP)
272:                     bool int_flag = false;
273:                    
274:                     int_flag = (bool)(PLIB_INT_GetStateAndDisable( INT_ID_0 ) & 0x01);
9D014608  30420001   ANDI V0, V0, 1
275:                 
276:                     PLIB_DEVCON_SystemLock(DEVCON_ID_0);
277:                 
278:                     if (int_flag)
9D01460C  10400006   BEQ V0, ZERO, 0x9D014628
9D014610  8FBF0004   LW RA, 4(SP)
279:                     {
280:                         PLIB_INT_Enable(INT_ID_0);
281:                     }
282:                 }
9D014624  8FBF0004   LW RA, 4(SP)
9D014628  03E00008   JR RA
9D01462C  27BD0008   ADDIU SP, SP, 8
283:                 
284:                 
285:                 // *****************************************************************************
286:                 /* Function:
287:                     void SYS_DEVCON_JTAGEnable( void )
288:                 
289:                   Summary:
290:                     Enables the JTAG port on the device.
291:                 
292:                   Description:
293:                     Enables the JTAG port on the device.
294:                 
295:                   Remarks:
296:                     None.
297:                 */
298:                 
299:                 void SYS_DEVCON_JTAGEnable( void )
300:                 {
301:                     PLIB_DEVCON_JTAGPortEnable(DEVCON_ID_0);
302:                 }
303:                 
304:                 
305:                 // *****************************************************************************
306:                 /* Function:
307:                     void SYS_DEVCON_JTAGDisable( void )
308:                 
309:                   Summary:
310:                     Disables the JTAG port on the device.
311:                 
312:                   Description:
313:                     Disables the JTAG port on the device.
314:                 
315:                   Remarks:
316:                     None.
317:                 */
318:                 
319:                 void SYS_DEVCON_JTAGDisable( void )
320:                 {
321:                     PLIB_DEVCON_JTAGPortDisable(DEVCON_ID_0);
322:                 }
323:                 
324:                 
325:                 // *****************************************************************************
326:                 /* Function:
327:                     void SYS_DEVCON_TraceEnable( void )
328:                 
329:                   Summary:
330:                     Enables the Trace output port on the device.
331:                 
332:                   Description:
333:                     Enables the Trace output port on the device.
334:                 
335:                   Remarks:
336:                     None.
337:                 */
338:                 
339:                 void SYS_DEVCON_TraceEnable( void )
340:                 {
341:                     #if defined PLIB_DEVCON_ExistsTraceOutput
342:                         if(PLIB_DEVCON_ExistsTraceOutput(DEVCON_ID_0))
343:                         {
344:                             PLIB_DEVCON_TraceOutputEnable(DEVCON_ID_0);
345:                         }
346:                     #endif
347:                 }
348:                 
349:                 
350:                 // *****************************************************************************
351:                 /* Function:
352:                     void SYS_DEVCON_TraceDisable( void )
353:                 
354:                   Summary:
355:                     Disables the Trace output port on the device.
356:                 
357:                   Description:
358:                     Disables the Trace output port on the device.
359:                 
360:                   Remarks:
361:                     None.
362:                 */
363:                 
364:                 void SYS_DEVCON_TraceDisable( void )
365:                 {
366:                     #if defined PLIB_DEVCON_ExistsTraceOutput
367:                     if(PLIB_DEVCON_ExistsTraceOutput(DEVCON_ID_0))
368:                     {
369:                         PLIB_DEVCON_TraceOutputDisable(DEVCON_ID_0);
370:                     }
371:                     #endif
372:                 }
373:                 
374:                 
375:                 // *****************************************************************************
376:                 /* Function:
377:                     void SYS_DEVCON_PowerModeEnter(SYS_POWER_MODE pwrMode)
378:                 
379:                   Summary:
380:                     Puts the device in a low-power state.
381:                 
382:                   Description:
383:                     This function puts the device in a low-power state.
384:                 
385:                   Remarks:
386:                     None.
387:                 */
388:                 
389:                 void __attribute__((nomips16)) SYS_DEVCON_PowerModeEnter( SYS_POWER_MODE pwrMode )
390:                 {
391:                     OSC_OPERATION_ON_WAIT op = SYS_POWER_MODE_IDLE;
392:                 
393:                     switch (pwrMode)
394:                     {
395:                         case SYS_POWER_MODE_IDLE:
396:                             op = OSC_ON_WAIT_IDLE;
397:                             break;
398:                         case SYS_POWER_MODE_SLEEP:
399:                             op = OSC_ON_WAIT_SLEEP;
400:                             break;
401:                         default:
402:                             break;
403:                     }
404:                 
405:                     
406:                     #if defined PLIB_OSC_ExistsOnWaitAction
407:                     if(PLIB_OSC_ExistsOnWaitAction(OSC_ID_0))
408:                     {
409:                         SYS_DEVCON_SystemUnlock();
410:                         PLIB_OSC_OnWaitActionSet (OSC_ID_0, op);
411:                         SYS_DEVCON_SystemLock();
412:                     }
413:                     #endif
414:                     asm volatile ( "wait" );
415:                 }
416:                 
417:                 
418:                 /*******************************************************************************
419:                  End of File
420:                 */
421:                 
---  /home/whatisthis/src/DoorBell_PIC32/firmware/src/system_config/default/framework/system/clk/src/sys_clk_pic32mx.c
1:                   /*******************************************************************************
2:                     SYS CLK Static Functions for Clock System Service
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       sys_clk_static.c
9:                   
10:                    Summary:
11:                      SYS CLK static function implementations for the Clock System Service.
12:                  
13:                    Description:
14:                      The Clock System Service provides a simple interface to manage the oscillators
15:                      on Microchip microcontrollers. This file defines the static implementation for the 
16:                      Clock System Service.
17:                      
18:                    Remarks:
19:                      Static functions incorporate all system clock configuration settings as
20:                      determined by the user via the Microchip Harmony Configurator GUI.  It provides 
21:                      static version of the routines, eliminating the need for an object ID or 
22:                      object handle.
23:                      
24:                      Static single-open interfaces also eliminate the need for the open handle.
25:                  *******************************************************************************/
26:                  
27:                  //DOM-IGNORE-BEGIN
28:                  /*******************************************************************************
29:                  Copyright (c) 2014 released Microchip Technology Inc.  All rights reserved.
30:                  
31:                  Microchip licenses to you the right to use, modify, copy and distribute
32:                  Software only when embedded on a Microchip microcontroller or digital signal
33:                  controller that is integrated into your product or third party product
34:                  (pursuant to the sublicense terms in the accompanying license agreement).
35:                  
36:                  You should refer to the license agreement accompanying this Software for
37:                  additional information regarding your rights and obligations.
38:                  
39:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
40:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
41:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
42:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
43:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
44:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
45:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
46:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
47:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
48:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
49:                  *******************************************************************************/
50:                  //DOM-IGNORE-END
51:                  
52:                  // *****************************************************************************
53:                  // *****************************************************************************
54:                  // Section: Include Files
55:                  // *****************************************************************************
56:                  // *****************************************************************************
57:                  
58:                  #include "system_config.h"
59:                  #include "system_definitions.h"
60:                  #include "peripheral/osc/plib_osc.h"
61:                  #include "system/devcon/sys_devcon.h"
62:                  
63:                  // *****************************************************************************
64:                  // *****************************************************************************
65:                  // Section: File Scope Functions
66:                  // *****************************************************************************
67:                  // *****************************************************************************
68:                  
69:                  // *****************************************************************************
70:                  /* Function:
71:                      void SYS_CLK_Static_Initialize ( const SYS_CLK_INIT const * clkInit )
72:                  
73:                    Summary:
74:                      Initializes hardware and internal data structure of the System Clock.
75:                  
76:                    Description:
77:                      This function initializes the hardware and internal data structure of System
78:                      Clock Service.
79:                  
80:                    Remarks:
81:                      This is configuration values for the static version of the Clock System Service 
82:                      module is determined by the user via the Microchip Harmony Configurator GUI.
83:                      This template will build a sys_clk_static.h and sys_clk_static.c file with 
84:                      the configuration per the user's choice.
85:                  
86:                      The objective is to eliminate the user's need to be knowledgeable in the function of
87:                      the 'configuration bits' to configure the system oscillators. 
88:                  */
89:                  
90:                  void SYS_CLK_Initialize( const SYS_CLK_INIT const * clkInit )
91:                  {
9D011894  27BDFFE8   ADDIU SP, SP, -24
9D011898  AFBF0014   SW RA, 20(SP)
92:                      SYS_DEVCON_SystemUnlock ( );
9D01189C  0F405017   JAL SYS_DEVCON_SystemUnlock
9D0118A0  00000000   NOP
93:                      
94:                      PLIB_OSC_FRCDivisorSelect( OSC_ID_0, OSC_FRC_DIV_2);
95:                  
96:                  
97:                  
98:                  
99:                      /* Enable Peripheral Bus 1 */
100:                     PLIB_OSC_PBClockDivisorSet (OSC_ID_0, 0, 2 );
101:                 
102:                  
103:                     /* Enable and configure REFCLKO1*/
104:                     
105:                     /* ROSEL USB PLL UPLL */
106:                     PLIB_OSC_ReferenceOscBaseClockSelect ( OSC_ID_0, OSC_REFERENCE_1, 6 );
107:                     /* RODIV */
108:                     PLIB_OSC_ReferenceOscDivisorValueSet ( OSC_ID_0, OSC_REFERENCE_1, 6 );
109:                     /* ROTRIM */
110:                     PLIB_OSC_ReferenceOscTrimSet ( OSC_ID_0, OSC_REFERENCE_1, 0 );
111:                 
112:                     PLIB_OSC_ReferenceOscEnable ( OSC_ID_0, OSC_REFERENCE_1 );
113:                     /* Disable REFCLK1_OE*/
114:                     PLIB_OSC_ReferenceOutputDisable ( OSC_ID_0, OSC_REFERENCE_1 );
115:                 
116:                     SYS_DEVCON_SystemLock ( );
9D011928  0F40517A   JAL SYS_DEVCON_SystemLock
9D01192C  00000000   NOP
117:                 }
9D011930  8FBF0014   LW RA, 20(SP)
118:                 
119:                 //******************************************************************************
120:                 /* Function:
121:                     inline uint32_t SYS_CLK_SystemFrequencyGet ( void )
122:                 
123:                   Summary:
124:                     Gets the system clock frequency in Hertz.
125:                 
126:                   Description:
127:                     This function gets the System clock frequency in Hertz.
128:                 
129:                   Precondition:
130:                     None.
131:                 
132:                   Parameters:
133:                     None.
134:                 
135:                   Returns:
136:                     System clock frequency in Hertz.
137:                 
138:                   Example:
139:                     <code>
140:                     uint32_t sysClockHz;
141:                 
142:                     sysClockHz = SYS_CLK_SystemFrequencyGet ( );
143:                     </code>
144:                 
145:                   Remarks:
146:                  */
147:                 
148:                 inline uint32_t SYS_CLK_SystemFrequencyGet ( void )
149:                 {
150:                     return SYS_CLK_FREQ;
151:                 }
9D0159D8  3C020131   LUI V0, 305
9D0159DC  03E00008   JR RA
9D0159E0  24422D00   ADDIU V0, V0, 11520
152:                 
153:                 //******************************************************************************
154:                 /* Function:
155:                     inline uint32_t SYS_CLK_PeripheralFrequencyGet ( CLK_BUSES_PERIPHERAL peripheralBus )
156:                 
157:                   Summary:
158:                     Gets the selected clock peripheral bus frequency in Hertz.
159:                 
160:                   Description:
161:                     This function gets the selected peripheral bus clock frequency in Hertz.
162:                 
163:                   Precondition:
164:                     None.
165:                 
166:                   Parameters:
167:                 	peripheralBus - Reference clock bus selection. One of the possible value from
168:                 				CLK_BUSES_PERIPHERAL enum. For devices that do not have multiple
169:                 				clock channels for Reference clock, CLK_BUS_PERIPHERAL_1 should be
170:                 				the selection.
171:                 
172:                   Returns:
173:                     Clock frequency in Hertz.
174:                 
175:                   Example:
176:                     <code>
177:                     unsigned long peripheralClockHz;
178:                 
179:                     peripheralClockHz = SYS_CLK_PeripheralFrequencyGet ( CLK_BUS_PERIPHERAL_5 );
180:                     </code>
181:                 
182:                   Remarks:
183:                 	Most of the devices doesn't have multiple Peripheral clock buses. In that case, 
184:                 	pass CLK_USB_PERIPHERAL_1 as the bus number.
185:                  */
186:                 
187:                 inline uint32_t SYS_CLK_PeripheralFrequencyGet ( CLK_BUSES_PERIPHERAL peripheralBus )
188:                 {
189:                     return SYS_CLK_BUS_PERIPHERAL_1;
190:                 }
9D0159E4  3C020098   LUI V0, 152
191:                 
192:                 
193:                 //******************************************************************************
194:                 /* Function:
195:                     inline uint32_t SYS_CLK_ReferenceFrequencyGet ( CLK_BUSES_REFERENCE referenceBus )
196:                 
197:                   Summary:
198:                     Gets the selected Reference clock bus frequency in Hertz.
199:                 
200:                   Description:
201:                     This function gets frequency of the selected Reference clock bus in Hertz.
202:                 
203:                   Precondition:
204:                     None.
205:                 
206:                   Parameters:
207:                 	peripheralBus - Reference clock bus selection. One of the possible value from
208:                 				CLK_BUSES_REFERENCE enum. For devices that do not have multiple
209:                 				clock channels for Reference clock, CLK_BUS_REFERENCE_1 should be
210:                 				the selection.
211:                 
212:                   Returns:
213:                     Clock frequency in Hz.
214:                 
215:                   Example:
216:                     <code>
217:                     unsigned long sysClockOutputHz;
218:                 
219:                     sysClockOutputHz = SYS_CLK_ReferenceFrequencyGet ( CLK_BUS_REFERENCE_3 );
220:                     </code>
221:                 
222:                   Remarks:
223:                     None.
224:                  */
225:                 
226:                 inline uint32_t SYS_CLK_ReferenceFrequencyGet ( CLK_BUSES_REFERENCE referenceBus )
227:                 {
228:                     return SYS_CLK_BUS_REFERENCE_1;
229:                 
230:                 
231:                 }
232:                 
233:                 /******************************************************************************
234:                   Function:
235:                     void SYS_CLK_SecondaryOscillatorEnable ( void )
236:                 
237:                   Summary:
238:                     Enables the secondary oscillator.
239:                 
240:                   Description:
241:                     This function enables the secondary oscillator.
242:                 
243:                   Remarks:
244:                     For more details refer sys_clk.h.
245:                 */
246:                 
247:                 void SYS_CLK_SecondaryOscillatorEnable ( void )
248:                 {
249:                     /* Check for secondary oscillator status */
250:                     if (!PLIB_OSC_SecondaryIsEnabled(OSC_ID_0))
251:                     {    
252:                         /* Unlock and enable secondary oscillator */
253:                         SYS_DEVCON_SystemUnlock();
254:                         
255:                         PLIB_OSC_SecondaryEnable(OSC_ID_0);
256:                         
257:                         SYS_DEVCON_SystemLock();
258:                     }
259:                 }
260:                 
261:                 /******************************************************************************
262:                   Function:
263:                     void SYS_CLK_SecondaryOscillatorDisable ( void )
264:                 
265:                   Summary:
266:                     Disables the secondary oscillator.
267:                 
268:                   Description:
269:                     This function disables the secondary oscillator.
270:                 
271:                   Remarks:
272:                     For more details refer sys_clk.h.
273:                 */
274:                 
275:                 void SYS_CLK_SecondaryOscillatorDisable ( void )
276:                 {
277:                     /* Check for secondary oscillator status */
278:                     if (PLIB_OSC_SecondaryIsEnabled(OSC_ID_0))
279:                     {    
280:                         /* Unlock and disable secondary oscillator*/
281:                         SYS_DEVCON_SystemUnlock();
282:                         
283:                         PLIB_OSC_SecondaryDisable(OSC_ID_0);
284:                         
285:                         SYS_DEVCON_SystemLock();
286:                     }
287:                 }
288:                 
289:                 /******************************************************************************
290:                   Function:
291:                     bool SYS_CLK_SecondaryOscillatorIsEnabled ( void )
292:                 
293:                   Summary:
294:                     Identifies whether secondary oscillator is enabled or disabled.
295:                 
296:                   Description:
297:                     This function identifies whether the secondary oscillator is enabled or 
298:                     disabled.
299:                     
300:                   Remarks:
301:                     For more details refer sys_clk.h.
302:                 */
303:                 
304:                 bool SYS_CLK_SecondaryOscillatorIsEnabled ( void )
305:                 {
306:                     return (PLIB_OSC_SecondaryIsEnabled(OSC_ID_0));
307:                 }
---  /home/whatisthis/src/DoorBell_PIC32/firmware/src/system_config/default/framework/driver/tmr/src/drv_tmr_static.c
1:                   /*******************************************************************************
2:                     Timer Static Driver File
3:                   
4:                     File Name:
5:                       drv_tmr_static.c
6:                   
7:                     Company:
8:                       Microchip Technology Inc.   
9:                   
10:                    Summary:
11:                      Timer driver implementation for the static single instance driver.
12:                  
13:                    Description:
14:                      The Timer device driver provides a simple interface to manage the Timer
15:                      modules on Microchip microcontrollers.
16:                      
17:                    Remarks:
18:                      None
19:                   *******************************************************************************/
20:                  
21:                  /*******************************************************************************
22:                  Copyright (c) 2014 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublTMRense terms in the accompanying lTMRense agreement).
28:                  
29:                  You should refer to the lTMRense agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTTMRULAR PURPOSE.
35:                  IN NO EVENT SHALL MTMRROCHIP OR ITS LTMRENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRTMRT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVTMRES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                   *******************************************************************************/
43:                  
44:                  // *****************************************************************************
45:                  // *****************************************************************************
46:                  // Header Includes
47:                  // *****************************************************************************
48:                  // *****************************************************************************
49:                  #include "driver/tmr/drv_tmr_static.h"
50:                  #include "driver/tmr/src/drv_tmr_variant_mapping.h"
51:                  
52:                  typedef struct
53:                  {
54:                      DRV_TMR_CALLBACK alarmFunc;  // For alarm registering
55:                      uint32_t alarmCount;    // For AlarmHasElapsed function
56:                      bool    alarmEnabled;   // For Enable/Disable function
57:                      bool    alarmPeriodic;      // Keep Alarm enabled or disable it
58:                      uintptr_t   alarmContext;   // For Alarm Callback
59:                      uint32_t    alarmPeriod;    // For Period Set/Get
60:                  } DRV_TMR_ALARM_OBJ;
61:                  
62:                  static bool _DRV_TMR_ClockSourceSet(TMR_MODULE_ID timerId, DRV_TMR_CLK_SOURCES clockSource)
63:                  {
64:                      bool clockSet = true;
65:                      /* Clock Source Selection */
66:                      if(clockSource == DRV_TMR_CLKSOURCE_INTERNAL)
67:                      {
68:                          if ( PLIB_TMR_ExistsClockSource ( timerId ) )
69:                          {               
70:                              PLIB_TMR_ClockSourceSelect ( timerId, TMR_CLOCK_SOURCE_PERIPHERAL_CLOCK );           
71:                          }
72:                          else
73:                          {
74:                              /* If clock source feature doesn't exist for any specific timer module instance,
75:                              then by default internal peripheral clock is considered as timer source, so do nothing */ 
76:                          }
77:                      }
78:                      /* External Synchronous Clock Source Selection */
79:                      else if(!(clockSource & 0x10))
80:                      {
81:                          if ( PLIB_TMR_ExistsClockSource ( timerId ) )
82:                          {               
83:                              if ( PLIB_TMR_ExistsClockSourceSync ( timerId )  )
84:                              {
85:                                  PLIB_TMR_ClockSourceSelect ( timerId, (TMR_CLOCK_SOURCE)(clockSource & 0x0F) );                
86:                                  PLIB_TMR_ClockSourceExternalSyncEnable ( timerId );                    
87:                              }
88:                              /* If Synchronization feature doesn't exist for any specific timer module 
89:                              instance with external clock source then it is synchronous by default */
90:                              else if (clockSource == DRV_TMR_CLKSOURCE_EXTERNAL_SYNCHRONOUS)
91:                              {
92:                                  PLIB_TMR_ClockSourceSelect ( timerId, TMR_CLOCK_SOURCE_EXTERNAL_INPUT_PIN );
93:                              }
94:                              else
95:                              {
96:                                  clockSet = false;
97:                              }  
98:                          }
99:                          else
100:                         {
101:                             clockSet = false;
102:                         }        
103:                     }
104:                     /* External Asynchronous Clock Source Selection */
105:                     else if(clockSource & 0x10)
106:                     {
107:                         if ( PLIB_TMR_ExistsClockSourceSync ( timerId ) )
108:                         {
109:                             PLIB_TMR_ClockSourceSelect ( timerId, (TMR_CLOCK_SOURCE)(clockSource & 0x0F) );
110:                             PLIB_TMR_ClockSourceExternalSyncDisable ( timerId );
111:                         }
112:                         else
113:                         {
114:                             clockSet = false;
115:                         }        
116:                     }
117:                     
118:                     return clockSet;
119:                 }
120:                 
121:                 // Prescaler selection
122:                 static bool _DRV_TMR_ClockPrescaleSet(TMR_MODULE_ID timerId, TMR_PRESCALE  prescale)
123:                 {
124:                     if( PLIB_TMR_ExistsPrescale( timerId ) )
125:                     {
126:                         PLIB_TMR_PrescaleSelect( timerId , prescale );
127:                         return true;
128:                     }
129:                     return false;
130:                 }
131:                 
132:                 
133:                 // *****************************************************************************
134:                 // *****************************************************************************
135:                 // Section: Instance 0 static driver data
136:                 // *****************************************************************************
137:                 // *****************************************************************************
138:                 
139:                 static bool                   DRV_TMR0_Running;
140:                 
141:                 // *****************************************************************************
142:                 // *****************************************************************************
143:                 // Section: Instance 0 static driver functions
144:                 // *****************************************************************************
145:                 // *****************************************************************************
146:                 void DRV_TMR0_Initialize(void)
147:                 {   
148:                     /* Initialize Timer Instance0 */
149:                     /* Disable Timer */
150:                     PLIB_TMR_Stop(TMR_ID_4);
151:                     /* Select clock source */
152:                     PLIB_TMR_ClockSourceSelect ( TMR_ID_4, TMR_CLOCK_SOURCE_PERIPHERAL_CLOCK );
153:                     /* Select prescalar value */
154:                     PLIB_TMR_PrescaleSelect(TMR_ID_4, TMR_PRESCALE_VALUE_64);
155:                     /* Enable 16 bit mode */
156:                     PLIB_TMR_Mode16BitEnable(TMR_ID_4);
157:                     /* Clear counter */ 
158:                     PLIB_TMR_Counter16BitClear(TMR_ID_4);
159:                     /*Set period */ 
160:                     PLIB_TMR_Period16BitSet(TMR_ID_4, 1250);
161:                     /* Setup Interrupt */   
162:                     PLIB_INT_VectorPrioritySet(INT_ID_0, INT_VECTOR_T4, INT_PRIORITY_LEVEL1);
163:                     PLIB_INT_VectorSubPrioritySet(INT_ID_0, INT_VECTOR_T4, INT_SUBPRIORITY_LEVEL0);          
164:                 }
165:                 
166:                 static void _DRV_TMR0_Resume(bool resume)
167:                 {
168:                     if (resume)
169:                     {
170:                         PLIB_INT_SourceFlagClear(INT_ID_0, INT_SOURCE_TIMER_4);
171:                         PLIB_INT_SourceEnable(INT_ID_0, INT_SOURCE_TIMER_4);
172:                         PLIB_TMR_Start(TMR_ID_4);
173:                     }
174:                 }
175:                 
176:                 bool DRV_TMR0_Start(void)
177:                 {
178:                     /* Start Timer*/
179:                     _DRV_TMR0_Resume(true);
180:                     DRV_TMR0_Running = true;
9D014DB4  24020001   ADDIU V0, ZERO, 1
9D014DB8  A38280DA   SB V0, -32550(GP)
181:                     
182:                     return true;
183:                 }
9D014DBC  03E00008   JR RA
9D014DC0  24020001   ADDIU V0, ZERO, 1
184:                 
185:                 static bool _DRV_TMR0_Suspend(void)
186:                 {
187:                     if (DRV_TMR0_Running)
9D014B88  938280DA   LBU V0, -32550(GP)
9D014B8C  10400007   BEQ V0, ZERO, DRV_TMR0_Stop::PLIB_INT_SourceFlagClear
9D014B90  3C030008   LUI V1, 8
188:                     {
189:                         PLIB_INT_SourceDisable(INT_ID_0, INT_SOURCE_TIMER_4);
190:                         PLIB_TMR_Stop(TMR_ID_4);
191:                         return (true);
192:                     }
193:                     
194:                     return (false);
195:                 }
196:                 
197:                 void DRV_TMR0_Stop(void)
198:                 {
199:                     _DRV_TMR0_Suspend();
200:                     PLIB_INT_SourceFlagClear(INT_ID_0, INT_SOURCE_TIMER_4);
201:                     DRV_TMR0_Running = false;
9D014BBC  03E00008   JR RA
9D014BC0  A38080DA   SB ZERO, -32550(GP)
202:                 }
203:                 
204:                 DRV_TMR_CLIENT_STATUS DRV_TMR0_ClientStatus ( void )
205:                 {
206:                     if (DRV_TMR0_Running)
207:                         return DRV_TMR_CLIENT_STATUS_RUNNING;
208:                     else
209:                         return DRV_TMR_CLIENT_STATUS_READY;
210:                 }
211:                 
212:                 void DRV_TMR0_CounterValueSet(uint32_t value)
213:                 {
214:                     /* Set 16-bit counter value*/
215:                     PLIB_TMR_Counter16BitSet(TMR_ID_4, (uint16_t)value);
216:                 }
217:                 
218:                 uint32_t DRV_TMR0_CounterValueGet(void)
219:                 {
220:                     /* Get 16-bit counter value*/
221:                     return (uint32_t) PLIB_TMR_Counter16BitGet(TMR_ID_4);
222:                 }
9D015844  03E00008   JR RA
9D015848  3042FFFF   ANDI V0, V0, -1
223:                 
224:                 void DRV_TMR0_CounterClear(void)
225:                 {
226:                     /* Clear 16-bit counter value*/
227:                     PLIB_TMR_Counter16BitClear(TMR_ID_4);
228:                 }
229:                 
230:                 DRV_TMR_OPERATION_MODE DRV_TMR0_DividerRangeGet
231:                 (
232:                 	DRV_TMR_DIVIDER_RANGE * pDivRange
233:                 )
234:                 {
235:                 	if(pDivRange)
236:                 	{
237:                         pDivRange->dividerMax = DRV_TIMER_DIVIDER_MAX_16BIT;
238:                         pDivRange->dividerMin = DRV_TIMER_DIVIDER_MIN_16BIT;
239:                 		pDivRange->dividerStep = 1;
240:                 		return DRV_TMR_OPERATION_MODE_16_BIT;
241:                 	}
242:                 	return DRV_TMR_OPERATION_MODE_NONE;
243:                 }
244:                 
245:                 uint32_t DRV_TMR0_CounterFrequencyGet(void)
246:                 {
247:                     uint32_t prescale, tmrBaseFreq;
248:                     
249:                     tmrBaseFreq = SYS_CLK_PeripheralFrequencyGet ( CLK_BUS_FOR_TIMER_PERIPHERAL );
250:                     prescale = PLIB_TMR_PrescaleGet(TMR_ID_4);
251:                     return ( tmrBaseFreq / prescale );
252:                 }
253:                 
254:                 TMR_PRESCALE DRV_TMR0_PrescalerGet(void)
255:                 {
256:                     uint16_t prescale_value;
257:                     /* Call the PLIB directly */
258:                     prescale_value = PLIB_TMR_PrescaleGet(TMR_ID_4);
259:                     
260:                     switch(prescale_value)
261:                     {
262:                         case 1: return TMR_PRESCALE_VALUE_1;
263:                         case 2: return TMR_PRESCALE_VALUE_2;
264:                         case 4: return TMR_PRESCALE_VALUE_4;
265:                         case 8: return TMR_PRESCALE_VALUE_8;
266:                         case 16: return TMR_PRESCALE_VALUE_16;
267:                         case 32: return TMR_PRESCALE_VALUE_32;
268:                         case 64: return TMR_PRESCALE_VALUE_64;
269:                         case 256: return TMR_PRESCALE_VALUE_256;
270:                         default: return TMR_PRESCALE_VALUE_1;
271:                     }
272:                 }
273:                 
274:                 void DRV_TMR0_PeriodValueSet(uint32_t value)
275:                 {
276:                     /* Set 16-bit counter value*/
277:                     PLIB_TMR_Period16BitSet(TMR_ID_4, (uint16_t)value);
278:                 }
279:                 
280:                 uint32_t DRV_TMR0_PeriodValueGet(void)
281:                 {
282:                     /* Get 16-bit counter value*/
283:                     return (uint32_t) PLIB_TMR_Period16BitGet(TMR_ID_4);
284:                 }
285:                 
286:                 void DRV_TMR0_StopInIdleDisable(void)
287:                 {
288:                     PLIB_TMR_StopInIdleDisable(TMR_ID_4);
289:                 }
290:                 
291:                 void DRV_TMR0_StopInIdleEnable(void)
292:                 {
293:                     PLIB_TMR_StopInIdleDisable(TMR_ID_4);
294:                 }
295:                 
296:                 bool DRV_TMR0_ClockSet
297:                 (
298:                     DRV_TMR_CLK_SOURCES clockSource,
299:                     TMR_PRESCALE        preScale
300:                 )
301:                 {
302:                     bool success = false;
303:                     bool resume = _DRV_TMR0_Suspend();
304:                     
305:                     if (_DRV_TMR_ClockSourceSet(TMR_ID_4, clockSource) &&
306:                         _DRV_TMR_ClockPrescaleSet(TMR_ID_4, preScale))
307:                     {
308:                         success = true;
309:                     }
310:                     
311:                     _DRV_TMR0_Resume(resume);
312:                     return success;
313:                 }
314:                 
315:                 // *****************************************************************************
316:                 // *****************************************************************************
317:                 // Section: Instance 1 static driver data
318:                 // *****************************************************************************
319:                 // *****************************************************************************
320:                 
321:                 static DRV_TMR_ALARM_OBJ      DRV_TMR1_DATA;
322:                 static bool                   DRV_TMR1_Running;
323:                 
324:                 // *****************************************************************************
325:                 // *****************************************************************************
326:                 // Section: Instance 1 static driver functions
327:                 // *****************************************************************************
328:                 // *****************************************************************************
329:                 void DRV_TMR1_Initialize(void)
330:                 {   
331:                     /* Initialize Timer Instance1 */
332:                     /* Disable Timer */
333:                     PLIB_TMR_Stop(TMR_ID_3);
334:                     /* Select clock source */
335:                     PLIB_TMR_ClockSourceSelect ( TMR_ID_3, TMR_CLOCK_SOURCE_PERIPHERAL_CLOCK );
336:                     /* Select prescalar value */
337:                     PLIB_TMR_PrescaleSelect(TMR_ID_3, TMR_PRESCALE_VALUE_1);
338:                     /* Enable 16 bit mode */
339:                     PLIB_TMR_Mode16BitEnable(TMR_ID_3);
340:                     /* Clear counter */ 
341:                     PLIB_TMR_Counter16BitClear(TMR_ID_3);
342:                     /*Set period */ 
343:                     PLIB_TMR_Period16BitSet(TMR_ID_3, 625);
344:                     /* Initialize the data structure */
345:                     DRV_TMR1_DATA.alarmFunc = NULL;
9D012AA4  3C02A000   LUI V0, -24576
9D012AA8  AC4075FC   SW ZERO, 30204(V0)
346:                     DRV_TMR1_DATA.alarmCount = 0;
9D012AAC  244275FC   ADDIU V0, V0, 30204
9D012AB0  AC400004   SW ZERO, 4(V0)
347:                     DRV_TMR1_DATA.alarmEnabled = false;
9D012AB4  A0400008   SB ZERO, 8(V0)
348:                     DRV_TMR1_DATA.alarmPeriodic = false;
9D012AB8  A0400009   SB ZERO, 9(V0)
9D012ABC  3C02BF88   LUI V0, -16504
9D012AC0  24421090   ADDIU V0, V0, 4240
9D012AC4  8C430030   LW V1, 48(V0)
9D012AC8  7C032084   INS V1, ZERO, 2, 3
9D012ACC  AC430030   SW V1, 48(V0)
9D012AD0  8C430030   LW V1, 48(V0)
9D012AD4  34630004   ORI V1, V1, 4
9D012AD8  AC430030   SW V1, 48(V0)
9D012ADC  8C430030   LW V1, 48(V0)
9D012AE0  7C030804   INS V1, ZERO, 0, 2
9D012AE4  AC430030   SW V1, 48(V0)
9D012AE8  8C430030   LW V1, 48(V0)
9D012AEC  AC430030   SW V1, 48(V0)
9D012AF0  03E00008   JR RA
9D012AF4  00000000   NOP
349:                     /* Setup Interrupt */   
350:                     PLIB_INT_VectorPrioritySet(INT_ID_0, INT_VECTOR_T3, INT_PRIORITY_LEVEL1);
351:                     PLIB_INT_VectorSubPrioritySet(INT_ID_0, INT_VECTOR_T3, INT_SUBPRIORITY_LEVEL0);          
352:                 }
353:                 
354:                 static void _DRV_TMR1_Resume(bool resume)
355:                 {
356:                     if (resume)
357:                     {
358:                         PLIB_INT_SourceFlagClear(INT_ID_0, INT_SOURCE_TIMER_3);
359:                         PLIB_INT_SourceEnable(INT_ID_0, INT_SOURCE_TIMER_3);
360:                         PLIB_TMR_Start(TMR_ID_3);
361:                     }
362:                 }
363:                 
364:                 bool DRV_TMR1_Start(void)
365:                 {
366:                     /* Start Timer*/
367:                     _DRV_TMR1_Resume(true);
368:                     DRV_TMR1_Running = true;
9D014DEC  24020001   ADDIU V0, ZERO, 1
9D014DF0  A38280D9   SB V0, -32551(GP)
369:                     
370:                     return true;
371:                 }
9D014DF4  03E00008   JR RA
9D014DF8  24020001   ADDIU V0, ZERO, 1
372:                 
373:                 static bool _DRV_TMR1_Suspend(void)
374:                 {
375:                     if (DRV_TMR1_Running)
9D014FD4  938380D9   LBU V1, -32551(GP)
9D014FD8  10600009   BEQ V1, ZERO, 0x9D015000
9D014FDC  00001021   ADDU V0, ZERO, ZERO
376:                     {
377:                         PLIB_INT_SourceDisable(INT_ID_0, INT_SOURCE_TIMER_3);
378:                         PLIB_TMR_Stop(TMR_ID_3);
379:                         return (true);
9D014FFC  24020001   ADDIU V0, ZERO, 1
380:                     }
381:                     
382:                     return (false);
383:                 }
9D015000  03E00008   JR RA
9D015004  00000000   NOP
384:                 
385:                 void DRV_TMR1_Stop(void)
386:                 {
9D0150F8  27BDFFE8   ADDIU SP, SP, -24
9D0150FC  AFBF0014   SW RA, 20(SP)
387:                     _DRV_TMR1_Suspend();
9D015100  0F4053F5   JAL _DRV_TMR1_Suspend
9D015104  00000000   NOP
388:                     PLIB_INT_SourceFlagClear(INT_ID_0, INT_SOURCE_TIMER_3);
389:                     DRV_TMR1_Running = false;
9D015118  A38080D9   SB ZERO, -32551(GP)
390:                 }
9D01511C  8FBF0014   LW RA, 20(SP)
9D015120  03E00008   JR RA
9D015124  27BD0018   ADDIU SP, SP, 24
391:                 
392:                 DRV_TMR_CLIENT_STATUS DRV_TMR1_ClientStatus ( void )
393:                 {
394:                     if (DRV_TMR1_Running)
395:                         return DRV_TMR_CLIENT_STATUS_RUNNING;
396:                     else
397:                         return DRV_TMR_CLIENT_STATUS_READY;
398:                 }
399:                 
400:                 void DRV_TMR1_CounterValueSet(uint32_t value)
401:                 {
402:                     /* Set 16-bit counter value*/
403:                     PLIB_TMR_Counter16BitSet(TMR_ID_3, (uint16_t)value);
404:                 }
405:                 
406:                 uint32_t DRV_TMR1_CounterValueGet(void)
407:                 {
408:                     /* Get 16-bit counter value*/
409:                     return (uint32_t) PLIB_TMR_Counter16BitGet(TMR_ID_3);
410:                 }
9D01586C  03E00008   JR RA
9D015870  3042FFFF   ANDI V0, V0, -1
411:                 
412:                 void DRV_TMR1_CounterClear(void)
413:                 {
414:                     /* Clear 16-bit counter value*/
415:                     PLIB_TMR_Counter16BitClear(TMR_ID_3);
416:                 }
417:                 
418:                 DRV_TMR_OPERATION_MODE DRV_TMR1_DividerRangeGet
419:                 (
420:                 	DRV_TMR_DIVIDER_RANGE * pDivRange
421:                 )
422:                 {
423:                 	if(pDivRange)
424:                 	{
425:                         pDivRange->dividerMax = DRV_TIMER_DIVIDER_MAX_16BIT;
426:                         pDivRange->dividerMin = DRV_TIMER_DIVIDER_MIN_16BIT;
427:                 		pDivRange->dividerStep = 1;
428:                 		return DRV_TMR_OPERATION_MODE_16_BIT;
429:                 	}
430:                 	return DRV_TMR_OPERATION_MODE_NONE;
431:                 }
432:                 
433:                 uint32_t DRV_TMR1_CounterFrequencyGet(void)
434:                 {
435:                     uint32_t prescale, tmrBaseFreq;
436:                     
437:                     tmrBaseFreq = SYS_CLK_PeripheralFrequencyGet ( CLK_BUS_FOR_TIMER_PERIPHERAL );
438:                     prescale = PLIB_TMR_PrescaleGet(TMR_ID_3);
439:                     return ( tmrBaseFreq / prescale );
440:                 }
441:                 
442:                 TMR_PRESCALE DRV_TMR1_PrescalerGet(void)
443:                 {
444:                     uint16_t prescale_value;
445:                     /* Call the PLIB directly */
446:                     prescale_value = PLIB_TMR_PrescaleGet(TMR_ID_3);
447:                     
448:                     switch(prescale_value)
449:                     {
450:                         case 1: return TMR_PRESCALE_VALUE_1;
451:                         case 2: return TMR_PRESCALE_VALUE_2;
452:                         case 4: return TMR_PRESCALE_VALUE_4;
453:                         case 8: return TMR_PRESCALE_VALUE_8;
454:                         case 16: return TMR_PRESCALE_VALUE_16;
455:                         case 32: return TMR_PRESCALE_VALUE_32;
456:                         case 64: return TMR_PRESCALE_VALUE_64;
457:                         case 256: return TMR_PRESCALE_VALUE_256;
458:                         default: return TMR_PRESCALE_VALUE_1;
459:                     }
460:                 }
461:                 
462:                 void DRV_TMR1_PeriodValueSet(uint32_t value)
463:                 {
464:                     /* Set 16-bit counter value*/
465:                     PLIB_TMR_Period16BitSet(TMR_ID_3, (uint16_t)value);
466:                 }
467:                 
468:                 uint32_t DRV_TMR1_PeriodValueGet(void)
469:                 {
470:                     /* Get 16-bit counter value*/
471:                     return (uint32_t) PLIB_TMR_Period16BitGet(TMR_ID_3);
472:                 }
473:                 
474:                 void DRV_TMR1_StopInIdleDisable(void)
475:                 {
476:                     PLIB_TMR_StopInIdleDisable(TMR_ID_3);
477:                 }
478:                 
479:                 void DRV_TMR1_StopInIdleEnable(void)
480:                 {
481:                     PLIB_TMR_StopInIdleDisable(TMR_ID_3);
482:                 }
483:                 
484:                 bool DRV_TMR1_ClockSet
485:                 (
486:                     DRV_TMR_CLK_SOURCES clockSource,
487:                     TMR_PRESCALE        preScale
488:                 )
489:                 {
490:                     bool success = false;
491:                     bool resume = _DRV_TMR1_Suspend();
492:                     
493:                     if (_DRV_TMR_ClockSourceSet(TMR_ID_3, clockSource) &&
494:                         _DRV_TMR_ClockPrescaleSet(TMR_ID_3, preScale))
495:                     {
496:                         success = true;
497:                     }
498:                     
499:                     _DRV_TMR1_Resume(resume);
500:                     return success;
501:                 }
502:                 
503:                 bool DRV_TMR1_AlarmRegister
504:                 (
505:                     uint32_t divider, 
506:                     bool isPeriodic, 
507:                     uintptr_t context, 
508:                     DRV_TMR_CALLBACK callBack 
509:                 )
510:                 {
511:                     bool success = (divider >= DRV_TIMER_DIVIDER_MIN_16BIT && 
512:                                     divider <= DRV_TIMER_DIVIDER_MAX_16BIT);
513:                     if (success)
514:                     {
515:                         PLIB_INT_SourceDisable(INT_ID_0, INT_SOURCE_TIMER_3);
516:                         PLIB_TMR_Stop(TMR_ID_3);
517:                         PLIB_TMR_Period16BitSet(TMR_ID_3, (uint16_t)divider - 1);
518:                         DRV_TMR1_DATA.alarmPeriodic = isPeriodic;
519:                         DRV_TMR1_DATA.alarmContext = context;
520:                         DRV_TMR1_DATA.alarmFunc = callBack;
521:                         return (success);
522:                     }
523:                     else
524:                         return false;
525:                 }
526:                 
527:                 void DRV_TMR1_AlarmEnable(bool enable)
528:                 {
529:                     if (DRV_TMR1_DATA.alarmFunc != NULL)
530:                     {
531:                         DRV_TMR1_DATA.alarmEnabled = enable;
532:                         PLIB_INT_SourceEnable(INT_ID_0, INT_SOURCE_TIMER_3);
533:                     }
534:                 }
535:                 
536:                 bool DRV_TMR1_AlarmDisable(void)
537:                 {
538:                     bool retVal = DRV_TMR1_DATA.alarmEnabled;
9D015428  3C03A000   LUI V1, -24576
9D01542C  246375FC   ADDIU V1, V1, 30204
9D015430  90620008   LBU V0, 8(V1)
539:                         PLIB_INT_SourceDisable(INT_ID_0, INT_SOURCE_TIMER_3);
540:                     DRV_TMR1_DATA.alarmEnabled = false;
541:                     
542:                     return retVal;
543:                 }
9D015444  03E00008   JR RA
9D015448  A0600008   SB ZERO, 8(V1)
544:                 
545:                 void DRV_TMR1_AlarmPeriodSet(uint32_t value)
546:                 {
547:                     bool resume = _DRV_TMR1_Suspend();
548:                     DRV_TMR1_DATA.alarmPeriod = value;
549:                     PLIB_TMR_Period16BitSet(TMR_ID_3, (uint16_t)value);
550:                     _DRV_TMR1_Resume(resume);
551:                 }
552:                 
553:                 uint32_t DRV_TMR1_AlarmPeriodGet(void)
554:                 {
555:                     return PLIB_TMR_Period16BitGet(TMR_ID_3);
556:                 }
557:                 
558:                 void DRV_TMR1_AlarmDeregister(void)
559:                 {
560:                     DRV_TMR1_DATA.alarmEnabled = false;
561:                     DRV_TMR1_DATA.alarmFunc = NULL;
562:                 }
563:                 
564:                 uint32_t DRV_TMR1_AlarmHasElapsed(void)
565:                 {
566:                     uint32_t alarmCountTemp = DRV_TMR1_DATA.alarmCount;
567:                     
568:                     DRV_TMR1_DATA.alarmCount = 0;
569:                     return (alarmCountTemp);
570:                 }
571:                 
572:                 void DRV_TMR1_Tasks(void)
573:                 {
9D0136C4  27BDFFE8   ADDIU SP, SP, -24
9D0136C8  AFBF0014   SW RA, 20(SP)
9D0136CC  AFB00010   SW S0, 16(SP)
574:                     if (DRV_TMR1_DATA.alarmEnabled &&
9D0136A8  3C02A000   LUI V0, -24576
9D0136AC  90427604   LBU V0, 30212(V0)
9D0136B0  10400016   BEQ V0, ZERO, 0x9D01370C
9D0136B4  3C02A000   LUI V0, -24576
9D0136BC  10400013   BEQ V0, ZERO, 0x9D01370C
9D0136C0  00000000   NOP
575:                         (DRV_TMR1_DATA.alarmFunc != NULL))
9D0136B8  8C4275FC   LW V0, 30204(V0)
576:                     {	
577:                 		DRV_TMR1_DATA.alarmCount++;
9D0136D0  3C10A000   LUI S0, -24576
9D0136D4  261075FC   ADDIU S0, S0, 30204
9D0136D8  8E050004   LW A1, 4(S0)
9D0136DC  24A50001   ADDIU A1, A1, 1
9D0136E0  AE050004   SW A1, 4(S0)
578:                         DRV_TMR1_DATA.alarmFunc(
9D0136E4  0040F809   JALR V0
9D0136E8  8E04000C   LW A0, 12(S0)
579:                             DRV_TMR1_DATA.alarmContext, 
580:                             DRV_TMR1_DATA.alarmCount);
581:                         if (!DRV_TMR1_DATA.alarmPeriodic)
9D0136EC  92020009   LBU V0, 9(S0)
9D0136F0  14400004   BNE V0, ZERO, 0x9D013704
9D0136F4  8FBF0014   LW RA, 20(SP)
582:                         {
583:                             DRV_TMR1_AlarmDisable();
9D0136F8  0F40550A   JAL DRV_TMR1_AlarmDisable
9D0136FC  00000000   NOP
584:                         }
585:                     }
586:                 }
9D013700  8FBF0014   LW RA, 20(SP)
9D013704  8FB00010   LW S0, 16(SP)
9D013708  27BD0018   ADDIU SP, SP, 24
9D01370C  03E00008   JR RA
9D013710  00000000   NOP
587:                 // *****************************************************************************
588:                 // *****************************************************************************
589:                 // Section: Instance 2 static driver data
590:                 // *****************************************************************************
591:                 // *****************************************************************************
592:                 
593:                 static bool                   DRV_TMR2_Running;
594:                 
595:                 // *****************************************************************************
596:                 // *****************************************************************************
597:                 // Section: Instance 2 static driver functions
598:                 // *****************************************************************************
599:                 // *****************************************************************************
600:                 void DRV_TMR2_Initialize(void)
601:                 {   
602:                     /* Initialize Timer Instance2 */
603:                     /* Disable Timer */
604:                     PLIB_TMR_Stop(TMR_ID_2);
605:                     /* Select clock source */
606:                     PLIB_TMR_ClockSourceSelect ( TMR_ID_2, TMR_CLOCK_SOURCE_EXTERNAL_INPUT_PIN);
607:                     /* Select prescalar value */
608:                     PLIB_TMR_PrescaleSelect(TMR_ID_2, TMR_PRESCALE_VALUE_1);
609:                     /* Enable 16 bit mode */
610:                     PLIB_TMR_Mode16BitEnable(TMR_ID_2);
611:                     /* Clear counter */ 
612:                     PLIB_TMR_Counter16BitClear(TMR_ID_2);
613:                     /*Set period */ 
614:                     PLIB_TMR_Period16BitSet(TMR_ID_2, 32768);
615:                     /* Setup Interrupt */   
616:                     PLIB_INT_VectorPrioritySet(INT_ID_0, INT_VECTOR_T2, INT_PRIORITY_LEVEL1);
617:                     PLIB_INT_VectorSubPrioritySet(INT_ID_0, INT_VECTOR_T2, INT_SUBPRIORITY_LEVEL0);          
618:                 }
619:                 
620:                 static void _DRV_TMR2_Resume(bool resume)
621:                 {
622:                     if (resume)
623:                     {
624:                         PLIB_INT_SourceFlagClear(INT_ID_0, INT_SOURCE_TIMER_2);
625:                         PLIB_INT_SourceEnable(INT_ID_0, INT_SOURCE_TIMER_2);
626:                         PLIB_TMR_Start(TMR_ID_2);
627:                     }
628:                 }
629:                 
630:                 bool DRV_TMR2_Start(void)
631:                 {
632:                     /* Start Timer*/
633:                     _DRV_TMR2_Resume(true);
634:                     DRV_TMR2_Running = true;
9D014E24  24020001   ADDIU V0, ZERO, 1
9D014E28  A38280D8   SB V0, -32552(GP)
635:                     
636:                     return true;
637:                 }
9D014E2C  03E00008   JR RA
9D014E30  24020001   ADDIU V0, ZERO, 1
638:                 
639:                 static bool _DRV_TMR2_Suspend(void)
640:                 {
641:                     if (DRV_TMR2_Running)
9D014BC4  938280D8   LBU V0, -32552(GP)
9D014BC8  10400007   BEQ V0, ZERO, DRV_TMR2_Stop::PLIB_INT_SourceFlagClear
9D014BCC  24030200   ADDIU V1, ZERO, 512
642:                     {
643:                         PLIB_INT_SourceDisable(INT_ID_0, INT_SOURCE_TIMER_2);
644:                         PLIB_TMR_Stop(TMR_ID_2);
645:                         return (true);
646:                     }
647:                     
648:                     return (false);
649:                 }
650:                 
651:                 void DRV_TMR2_Stop(void)
652:                 {
653:                     _DRV_TMR2_Suspend();
654:                     PLIB_INT_SourceFlagClear(INT_ID_0, INT_SOURCE_TIMER_2);
655:                     DRV_TMR2_Running = false;
9D014BF8  03E00008   JR RA
9D014BFC  A38080D8   SB ZERO, -32552(GP)
656:                 }
657:                 
658:                 DRV_TMR_CLIENT_STATUS DRV_TMR2_ClientStatus ( void )
659:                 {
660:                     if (DRV_TMR2_Running)
661:                         return DRV_TMR_CLIENT_STATUS_RUNNING;
662:                     else
663:                         return DRV_TMR_CLIENT_STATUS_READY;
664:                 }
665:                 
666:                 void DRV_TMR2_CounterValueSet(uint32_t value)
667:                 {
668:                     /* Set 16-bit counter value*/
669:                     PLIB_TMR_Counter16BitSet(TMR_ID_2, (uint16_t)value);
670:                 }
671:                 
672:                 uint32_t DRV_TMR2_CounterValueGet(void)
673:                 {
674:                     /* Get 16-bit counter value*/
675:                     return (uint32_t) PLIB_TMR_Counter16BitGet(TMR_ID_2);
676:                 }
9D015894  03E00008   JR RA
9D015898  3042FFFF   ANDI V0, V0, -1
677:                 
678:                 void DRV_TMR2_CounterClear(void)
679:                 {
680:                     /* Clear 16-bit counter value*/
681:                     PLIB_TMR_Counter16BitClear(TMR_ID_2);
682:                 }
683:                 
684:                 DRV_TMR_OPERATION_MODE DRV_TMR2_DividerRangeGet
685:                 (
686:                 	DRV_TMR_DIVIDER_RANGE * pDivRange
687:                 )
688:                 {
689:                 	if(pDivRange)
690:                 	{
691:                         pDivRange->dividerMax = DRV_TIMER_DIVIDER_MAX_16BIT;
692:                         pDivRange->dividerMin = DRV_TIMER_DIVIDER_MIN_16BIT;
693:                 		pDivRange->dividerStep = 1;
694:                 		return DRV_TMR_OPERATION_MODE_16_BIT;
695:                 	}
696:                 	return DRV_TMR_OPERATION_MODE_NONE;
697:                 }
698:                 
699:                 uint32_t DRV_TMR2_CounterFrequencyGet(void)
700:                 {
701:                     return 0;
702:                 }
703:                 
704:                 TMR_PRESCALE DRV_TMR2_PrescalerGet(void)
705:                 {
706:                     uint16_t prescale_value;
707:                     /* Call the PLIB directly */
708:                     prescale_value = PLIB_TMR_PrescaleGet(TMR_ID_2);
709:                     
710:                     switch(prescale_value)
711:                     {
712:                         case 1: return TMR_PRESCALE_VALUE_1;
713:                         case 2: return TMR_PRESCALE_VALUE_2;
714:                         case 4: return TMR_PRESCALE_VALUE_4;
715:                         case 8: return TMR_PRESCALE_VALUE_8;
716:                         case 16: return TMR_PRESCALE_VALUE_16;
717:                         case 32: return TMR_PRESCALE_VALUE_32;
718:                         case 64: return TMR_PRESCALE_VALUE_64;
719:                         case 256: return TMR_PRESCALE_VALUE_256;
720:                         default: return TMR_PRESCALE_VALUE_1;
721:                     }
722:                 }
723:                 
724:                 void DRV_TMR2_PeriodValueSet(uint32_t value)
725:                 {
726:                     /* Set 16-bit counter value*/
727:                     PLIB_TMR_Period16BitSet(TMR_ID_2, (uint16_t)value);
728:                 }
729:                 
730:                 uint32_t DRV_TMR2_PeriodValueGet(void)
731:                 {
732:                     /* Get 16-bit counter value*/
733:                     return (uint32_t) PLIB_TMR_Period16BitGet(TMR_ID_2);
734:                 }
735:                 
736:                 void DRV_TMR2_StopInIdleDisable(void)
737:                 {
738:                     PLIB_TMR_StopInIdleDisable(TMR_ID_2);
739:                 }
740:                 
741:                 void DRV_TMR2_StopInIdleEnable(void)
742:                 {
743:                     PLIB_TMR_StopInIdleDisable(TMR_ID_2);
744:                 }
745:                 
746:                 bool DRV_TMR2_ClockSet
747:                 (
748:                     DRV_TMR_CLK_SOURCES clockSource,
749:                     TMR_PRESCALE        preScale
750:                 )
751:                 {
752:                     bool success = false;
753:                     bool resume = _DRV_TMR2_Suspend();
754:                     
755:                     if (_DRV_TMR_ClockSourceSet(TMR_ID_2, clockSource) &&
756:                         _DRV_TMR_ClockPrescaleSet(TMR_ID_2, preScale))
757:                     {
758:                         success = true;
759:                     }
760:                     
761:                     _DRV_TMR2_Resume(resume);
762:                     return success;
763:                 }
764:                 
765:                  
766:                  
767:                 /*******************************************************************************
768:                  End of File
769:                 */
---  /home/whatisthis/src/DoorBell_PIC32/firmware/src/system_config/default/framework/driver/tmr/src/drv_tmr_mapping.c
1:                   /*******************************************************************************
2:                     Timer Driver Interface Mapping Dynamic APIs to Static APIs           
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       drv_tmr_mapping.h
9:                   
10:                    Summary:
11:                      This file allows maintaining a single set of APIs for all Timer transactions  
12:                      by making the type of implementation transparent to the application. In case
13:                      where static implementation of Timer driver is selected, this file maps the 
14:                      API functions to a particular driver instance-specific static implementation
15:                      function, eliminating unnecessary dynamic parameters. 
16:                  *******************************************************************************/
17:                  
18:                  //DOM-IGNORE-BEGIN
19:                  /*******************************************************************************
20:                  Copyright (c) 2015 released Microchip Technology Inc.  All rights reserved.
21:                  
22:                  Microchip licenses to you the right to use, modify, copy and distribute
23:                  Software only when embedded on a Microchip microcontroller or digital signal
24:                  controller that is integrated into your product or third party product
25:                  (pursuant to the sublicense terms in the accompanying license agreement).
26:                  
27:                  You should refer to the license agreement accompanying this Software for
28:                  additional information regarding your rights and obligations.
29:                  
30:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
31:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
32:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
33:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
34:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
35:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
36:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
37:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
38:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
39:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
40:                  *******************************************************************************/
41:                  //DOM-IGNORE-END
42:                  
43:                  #include "driver/tmr/drv_tmr.h"
44:                  #include "driver/tmr/drv_tmr_static.h"
45:                  
46:                  // *****************************************************************************
47:                  // *****************************************************************************
48:                  // Section: Driver System Interface Function Definitions
49:                  // *****************************************************************************
50:                  // *****************************************************************************
51:                  
52:                  // *****************************************************************************
53:                  /* Function:
54:                      SYS_MODULE_OBJ DRV_TMR_Initialize 
55:                      ( 
56:                          const SYS_MODULE_INDEX drvIndex,
57:                          const SYS_MODULE_INIT * const init 
58:                      )
59:                  
60:                    Summary:
61:                      Initializes the Timer driver.
62:                  
63:                    Description:
64:                      This function initializes the Timer driver, making it ready for clients to
65:                      open and use it.
66:                  
67:                    Remarks:
68:                      Refer to drv_tmr.h for usage information.
69:                  */
70:                  
71:                  SYS_MODULE_OBJ DRV_TMR_Initialize 
72:                  ( 
73:                      const SYS_MODULE_INDEX drvIndex,
74:                      const SYS_MODULE_INIT  * const init 
75:                  )
76:                  {
77:                  	SYS_MODULE_OBJ sysObj;
78:                  	
79:                  	switch (drvIndex)
80:                      {
81:                                  case DRV_TMR_INDEX_0:
82:                          {
83:                              DRV_TMR0_Initialize();
84:                  			sysObj = (SYS_MODULE_OBJ)DRV_TMR_INDEX_0;
85:                              break;
86:                          }
87:                          case DRV_TMR_INDEX_1:
88:                          {
89:                              DRV_TMR1_Initialize();
90:                  			sysObj = (SYS_MODULE_OBJ)DRV_TMR_INDEX_1;
91:                              break;
92:                          }
93:                          case DRV_TMR_INDEX_2:
94:                          {
95:                              DRV_TMR2_Initialize();
96:                  			sysObj = (SYS_MODULE_OBJ)DRV_TMR_INDEX_2;
97:                              break;
98:                          }
99:                          default:
100:                         {
101:                 			sysObj = SYS_MODULE_OBJ_INVALID;
102:                             break;
103:                         }
104:                     }
105:                 	return sysObj;
106:                 }
107:                 
108:                 // *****************************************************************************
109:                 /* Function:
110:                     void DRV_TMR_Deinitialize ( SYS_MODULE_OBJ object )
111:                 
112:                   Summary:
113:                     Deinitializes the specified instance of the Timer driver.
114:                 
115:                   Description:
116:                     Deinitializes the specified instance of the Timer driver, disabling
117:                     its operation (and any hardware). All internal data is invalidated.
118:                 
119:                   Remarks:
120:                     Refer to drv_tmr.h for usage information.
121:                 */
122:                 
123:                 void DRV_TMR_Deinitialize ( SYS_MODULE_OBJ object )
124:                 {
125:                 	switch (object)
126:                     {
127:                         case DRV_TMR_INDEX_0:
128:                         {
129:                             DRV_TMR0_DeInitialize();
130:                             break;
131:                         }
132:                         case DRV_TMR_INDEX_1:
133:                         {
134:                             DRV_TMR1_DeInitialize();
135:                             break;
136:                         }
137:                         case DRV_TMR_INDEX_2:
138:                         {
139:                             DRV_TMR2_DeInitialize();
140:                             break;
141:                         }
142:                         default:
143:                         {
144:                             break;
145:                         }
146:                     }
147:                 }
148:                 
149:                 // *****************************************************************************
150:                 /* Function:
151:                     SYS_STATUS DRV_TMR_Status ( SYS_MODULE_OBJ object )
152:                 
153:                   Summary:
154:                     Provides the current status of the Timer driver.
155:                 
156:                   Description:
157:                     This function provides the current status of the Timer driver.
158:                 
159:                   Remarks:
160:                     Refer to drv_tmr.h for usage information.
161:                 */
162:                 
163:                 SYS_STATUS DRV_TMR_Status ( SYS_MODULE_OBJ object )
164:                 {
165:                 	SYS_STATUS returnValue;
166:                 	
167:                 	switch (object)
168:                     {
169:                         case DRV_TMR_INDEX_0:
170:                         {
171:                             returnValue = DRV_TMR0_Status();
172:                             break;
173:                         }
174:                         case DRV_TMR_INDEX_1:
175:                         {
176:                             returnValue = DRV_TMR1_Status();
177:                             break;
178:                         }
179:                         case DRV_TMR_INDEX_2:
180:                         {
181:                             returnValue = DRV_TMR2_Status();
182:                             break;
183:                         }
184:                         default:
185:                         {
186:                             break;
187:                         }
188:                     }
189:                 	return returnValue;
190:                 }
191:                 
192:                 // *****************************************************************************
193:                 /* Function:
194:                     void DRV_TMR_Tasks ( SYS_MODULE_OBJ object )
195:                 
196:                   Summary:
197:                     Maintains the driver's state machine.
198:                 
199:                   Description:
200:                     This function is used to maintain the driver's internal state machine and
201:                     processes the timer events.
202:                 
203:                   Remarks:
204:                     Refer to drv_tmr.h for usage information.
205:                 */
206:                 
207:                 void DRV_TMR_Tasks ( SYS_MODULE_OBJ object )
208:                 {
209:                 	switch (object)
210:                     {
211:                         case DRV_TMR_INDEX_0:
212:                         {
213:                             DRV_TMR0_Tasks();
214:                             break;
215:                         }
216:                         case DRV_TMR_INDEX_1:
217:                         {
218:                             DRV_TMR1_Tasks();
219:                             break;
220:                         }
221:                         case DRV_TMR_INDEX_2:
222:                         {
223:                             DRV_TMR2_Tasks();
224:                             break;
225:                         }
226:                         default:
227:                         {
228:                             break;
229:                         }
230:                     }
231:                 }
232:                 
233:                 // *****************************************************************************
234:                 // *****************************************************************************
235:                 // Section: TMR Driver Client Functions
236:                 // *****************************************************************************
237:                 // *****************************************************************************
238:                 
239:                 // *****************************************************************************
240:                 /* Function:
241:                     DRV_HANDLE DRV_TMR_Open 
242:                     ( 
243:                         const SYS_MODULE_INDEX index,
244:                         const DRV_IO_INTENT    intent
245:                     )
246:                 
247:                   Summary:
248:                     Opens the specified Timer driver instance and returns a handle to it.
249:                   
250:                   Description:
251:                     This function opens the specified Timer driver instance and provides a
252:                     handle that must be provided to all other client-level operations to
253:                     identify the caller and the instance of the driver.  Timer driver does not
254:                     support multiple clients. If two tasks want to use the timer, one should
255:                     wait until the other one gets closed. 
256:                 
257:                   Remarks:
258:                     Refer to drv_tmr.h for usage information.
259:                 */
260:                 
261:                 DRV_HANDLE DRV_TMR_Open 
262:                 ( 
263:                     const SYS_MODULE_INDEX index, 
264:                     const DRV_IO_INTENT intent 
265:                 )
266:                 {
267:                     switch (index)
9D0155A4  24020001   ADDIU V0, ZERO, 1
9D0155A8  10820004   BEQ A0, V0, 0x9D0155BC
9D0155AC  38840002   XORI A0, A0, 2
268:                     {
269:                         case DRV_TMR_INDEX_0:
270:                         {
271:                             return (DRV_HANDLE)DRV_TMR_INDEX_0;
9D0155B0  24020002   ADDIU V0, ZERO, 2
9D0155B4  03E00008   JR RA
9D0155B8  0004100B   MOVN V0, ZERO, A0
272:                             break;
273:                         }
274:                         case DRV_TMR_INDEX_1:
275:                         {
276:                             return (DRV_HANDLE)DRV_TMR_INDEX_1;
277:                             break;
278:                         }
279:                         case DRV_TMR_INDEX_2:
280:                         {
281:                             return (DRV_HANDLE)DRV_TMR_INDEX_2;
282:                             break;
283:                         }
284:                         default:
285:                         {
286:                             break;
287:                         }
288:                     }
289:                     
290:                     return (DRV_HANDLE)NULL;
291:                 }
9D0155BC  03E00008   JR RA
9D0155C0  24020001   ADDIU V0, ZERO, 1
292:                 
293:                 // *****************************************************************************
294:                 /* Function:
295:                     void DRV_TMR_Close ( DRV_HANDLE handle )
296:                 
297:                   Summary:
298:                     Closes an opened instance of the Timer driver.
299:                 
300:                   Description:
301:                     This function closes an opened instance of the Timer driver, invalidating
302:                     the handle.
303:                   
304:                   Remarks:
305:                     Refer to drv_tmr.h for usage information.
306:                 */
307:                 
308:                 void DRV_TMR_Close ( DRV_HANDLE handle )
309:                 {
9D013D30  27BDFFE8   ADDIU SP, SP, -24
310:                     switch (handle)
9D013D34  24020001   ADDIU V0, ZERO, 1
9D013D38  1082000B   BEQ A0, V0, DRV_TMR_Close::DRV_TMR1_Close
9D013D3C  AFBF0014   SW RA, 20(SP)
9D013D40  10800005   BEQ A0, ZERO, DRV_TMR_Close::DRV_TMR0_Close
9D013D44  24020002   ADDIU V0, ZERO, 2
9D013D48  1082000B   BEQ A0, V0, DRV_TMR_Close::DRV_TMR2_Close
9D013D4C  8FBF0014   LW RA, 20(SP)
9D013D50  0B404F61   J 0x9D013D84
9D013D54  00000000   NOP
311:                     {
312:                         case DRV_TMR_INDEX_0:
313:                         {
314:                             DRV_TMR0_Close();
315:                             break;
316:                         }
317:                         case DRV_TMR_INDEX_1:
318:                         {
319:                             DRV_TMR1_Close();
320:                             break;
321:                         }
322:                         case DRV_TMR_INDEX_2:
323:                         {
324:                             DRV_TMR2_Close();
325:                             break;
326:                         }
327:                         default:
328:                         {
329:                             break;
330:                         }
331:                     }
332:                 }
9D013D60  0B404F61   J 0x9D013D84
9D013D64  8FBF0014   LW RA, 20(SP)
9D013D70  0B404F61   J 0x9D013D84
9D013D74  8FBF0014   LW RA, 20(SP)
9D013D80  8FBF0014   LW RA, 20(SP)
9D013D84  03E00008   JR RA
9D013D88  27BD0018   ADDIU SP, SP, 24
333:                 
334:                 // *****************************************************************************
335:                 /* Function:
336:                     DRV_TMR_CLIENT_STATUS DRV_TMR_ClientStatus ( DRV_HANDLE handle )
337:                 
338:                   Summary:
339:                     Gets the status of the client operation.
340:                 
341:                   Description:
342:                     This function gets the status of the recently completed client level
343:                     operation.
344:                 
345:                   Remarks:
346:                     Refer to drv_tmr.h for usage information.
347:                 */
348:                 
349:                 DRV_TMR_CLIENT_STATUS DRV_TMR_ClientStatus 
350:                 ( DRV_HANDLE handle )
351:                 {
352:                     switch (handle)
353:                     {
354:                         case DRV_TMR_INDEX_0:
355:                         {
356:                             return DRV_TMR0_ClientStatus();
357:                             break;
358:                         }
359:                         case DRV_TMR_INDEX_1:
360:                         {
361:                             return DRV_TMR1_ClientStatus();
362:                             break;
363:                         }
364:                         case DRV_TMR_INDEX_2:
365:                         {
366:                             return DRV_TMR2_ClientStatus();
367:                             break;
368:                         }
369:                         default:
370:                         {
371:                             break;
372:                         }
373:                     }
374:                 
375:                     return DRV_TMR_CLIENT_STATUS_INVALID;
376:                 }
377:                 
378:                 // *****************************************************************************
379:                 // *****************************************************************************
380:                 // Section: TMR Driver Counter functions
381:                 // *****************************************************************************
382:                 // *****************************************************************************
383:                 
384:                 // *****************************************************************************
385:                 /* Function:
386:                     void DRV_TMR_CounterValueSet ( DRV_HANDLE handle, uint32_t counterPeriod )
387:                 
388:                   Summary:
389:                     Updates the Timer's counter register.
390:                 
391:                   Description:
392:                     This function updates the Timer's value in the counter register.
393:                 
394:                   Remarks:
395:                     Refer to drv_tmr.h for usage information.
396:                 */
397:                 
398:                 void DRV_TMR_CounterValueSet ( DRV_HANDLE handle, uint32_t counterPeriod )
399:                 {
9D013D8C  27BDFFE8   ADDIU SP, SP, -24
400:                     switch (handle)
9D013D90  24020001   ADDIU V0, ZERO, 1
9D013D94  1082000B   BEQ A0, V0, 0x9D013DC4
9D013D98  AFBF0014   SW RA, 20(SP)
9D013D9C  10800005   BEQ A0, ZERO, 0x9D013DB4
9D013DA0  24020002   ADDIU V0, ZERO, 2
9D013DA4  1082000B   BEQ A0, V0, 0x9D013DD4
9D013DA8  8FBF0014   LW RA, 20(SP)
9D013DAC  0B404F78   J 0x9D013DE0
9D013DB0  00000000   NOP
401:                     {
402:                         case DRV_TMR_INDEX_0:
403:                         {
404:                             DRV_TMR0_CounterValueSet(counterPeriod);
9D013DB4  0F405609   JAL DRV_TMR0_CounterValueSet
9D013DB8  00A02021   ADDU A0, A1, ZERO
405:                             break;
9D013DBC  0B404F78   J 0x9D013DE0
9D013DC0  8FBF0014   LW RA, 20(SP)
406:                         }
407:                         case DRV_TMR_INDEX_1:
408:                         {
409:                             DRV_TMR1_CounterValueSet(counterPeriod);
9D013DC4  0F405613   JAL DRV_TMR1_CounterValueSet
9D013DC8  00A02021   ADDU A0, A1, ZERO
410:                             break;
9D013DCC  0B404F78   J 0x9D013DE0
9D013DD0  8FBF0014   LW RA, 20(SP)
411:                         }
412:                         case DRV_TMR_INDEX_2:
413:                         {
414:                             DRV_TMR2_CounterValueSet(counterPeriod);
9D013DD4  0F40561D   JAL DRV_TMR2_CounterValueSet
9D013DD8  00A02021   ADDU A0, A1, ZERO
415:                             break;
416:                         }
417:                         default:
418:                         {
419:                             break;
420:                         }
421:                     }
422:                 }
9D013DDC  8FBF0014   LW RA, 20(SP)
9D013DE0  03E00008   JR RA
9D013DE4  27BD0018   ADDIU SP, SP, 24
423:                 
424:                 // *****************************************************************************
425:                 /* Function:
426:                     uint32_t DRV_TMR_CounterValueGet ( DRV_HANDLE handle )
427:                 
428:                   Summary:
429:                     Reads the Timer's counter register.
430:                 
431:                   Description:
432:                     This function returns the Timer's value in the counter register.
433:                 
434:                   Remarks:
435:                     Refer to drv_tmr.h for usage information.
436:                 */
437:                 
438:                 uint32_t DRV_TMR_CounterValueGet ( DRV_HANDLE handle )
439:                 {
9D01384C  27BDFFE8   ADDIU SP, SP, -24
440:                     switch (handle)
9D013850  24020001   ADDIU V0, ZERO, 1
9D013854  1082000C   BEQ A0, V0, 0x9D013888
9D013858  AFBF0014   SW RA, 20(SP)
9D01385C  10800006   BEQ A0, ZERO, 0x9D013878
9D013860  00000000   NOP
9D013864  24020002   ADDIU V0, ZERO, 2
9D013868  1082000B   BEQ A0, V0, 0x9D013898
9D01386C  00000000   NOP
441:                     {
442:                         case DRV_TMR_INDEX_0:
443:                         {
444:                             return DRV_TMR0_CounterValueGet();
9D013878  0F40560E   JAL DRV_TMR0_CounterValueGet
9D01387C  00000000   NOP
9D013880  0B404E2B   J 0x9D0138AC
9D013884  8FBF0014   LW RA, 20(SP)
445:                             break;
446:                         }
447:                         case DRV_TMR_INDEX_1:
448:                         {
449:                             return DRV_TMR1_CounterValueGet();
9D013888  0F405618   JAL DRV_TMR1_CounterValueGet
9D01388C  00000000   NOP
9D013890  0B404E2B   J 0x9D0138AC
9D013894  8FBF0014   LW RA, 20(SP)
450:                             break;
451:                         }
452:                         case DRV_TMR_INDEX_2:
453:                         {
454:                             return DRV_TMR2_CounterValueGet();
9D013898  0F405622   JAL DRV_TMR2_CounterValueGet
9D01389C  00000000   NOP
9D0138A0  0B404E2B   J 0x9D0138AC
9D0138A4  8FBF0014   LW RA, 20(SP)
455:                             break;
456:                         }
457:                         default:
458:                         {
459:                             break;
460:                         }
461:                     }
462:                 
463:                     return 0;
9D013870  0B404E2A   J 0x9D0138A8
9D013874  00001021   ADDU V0, ZERO, ZERO
464:                 }
9D0138A8  8FBF0014   LW RA, 20(SP)
9D0138AC  03E00008   JR RA
9D0138B0  27BD0018   ADDIU SP, SP, 24
465:                 
466:                 // *****************************************************************************
467:                 /* Function:
468:                     void DRV_TMR_CounterClear ( DRV_HANDLE handle )
469:                 
470:                   Summary:
471:                     Clears the Timer's counter register.
472:                 
473:                   Description:
474:                     This function clears the Timer's value in the counter register.
475:                 
476:                   Remarks:
477:                     Refer to drv_tmr.h for usage information.
478:                 */
479:                 
480:                 void DRV_TMR_CounterClear ( DRV_HANDLE handle )
481:                 {
9D013DE8  27BDFFE8   ADDIU SP, SP, -24
482:                     switch (handle)
9D013DEC  24020001   ADDIU V0, ZERO, 1
9D013DF0  1082000B   BEQ A0, V0, 0x9D013E20
9D013DF4  AFBF0014   SW RA, 20(SP)
9D013DF8  10800005   BEQ A0, ZERO, 0x9D013E10
9D013DFC  24020002   ADDIU V0, ZERO, 2
9D013E00  1082000B   BEQ A0, V0, 0x9D013E30
9D013E04  8FBF0014   LW RA, 20(SP)
9D013E08  0B404F8F   J 0x9D013E3C
9D013E0C  00000000   NOP
483:                     {
484:                         case DRV_TMR_INDEX_0:
485:                         {
486:                             DRV_TMR0_CounterClear();
9D013E10  0F405655   JAL DRV_TMR0_CounterClear
9D013E14  00000000   NOP
487:                             break;
9D013E18  0B404F8F   J 0x9D013E3C
9D013E1C  8FBF0014   LW RA, 20(SP)
488:                         }
489:                         case DRV_TMR_INDEX_1:
490:                         {
491:                             DRV_TMR1_CounterClear();
9D013E20  0F405659   JAL DRV_TMR1_CounterClear
9D013E24  00000000   NOP
492:                             break;
9D013E28  0B404F8F   J 0x9D013E3C
9D013E2C  8FBF0014   LW RA, 20(SP)
493:                         }
494:                         case DRV_TMR_INDEX_2:
495:                         {
496:                             DRV_TMR2_CounterClear();
9D013E30  0F40565D   JAL DRV_TMR2_CounterClear
9D013E34  00000000   NOP
497:                             break;
498:                         }
499:                         default:
500:                         {
501:                             break;
502:                         }
503:                     }
504:                 }
9D013E38  8FBF0014   LW RA, 20(SP)
9D013E3C  03E00008   JR RA
9D013E40  27BD0018   ADDIU SP, SP, 24
505:                 
506:                 // *****************************************************************************
507:                 // *****************************************************************************
508:                 // Section: TMR Driver Alarm functions
509:                 // *****************************************************************************
510:                 // *****************************************************************************
511:                 
512:                 // *****************************************************************************
513:                 /* Function:
514:                     bool DRV_TMR_AlarmRegister 
515:                     ( 
516:                         DRV_HANDLE handle, 
517:                         uint32_t divider, 
518:                         bool isPeriodic, 
519:                         uintptr_t context, 
520:                         DRV_TMR_CALLBACK callBack 
521:                     )
522:                 
523:                   Summary:
524:                     Sets up an alarm.
525:                 
526:                   Description:
527:                     This function sets up an alarm, allowing the client to receive a callback
528:                     from the driver when the timer counter reaches zero.  Alarms can be one-shot
529:                     or periodic.  A periodic alarm will reload the timer and generate alarm
530:                     until stopped.  The alarm frequency is: DRV_TMR_CounterFrequencyGet() /
531:                     divider;
532:                 
533:                   Remarks:
534:                     Refer to drv_tmr.h for usage information.
535:                 */
536:                 
537:                 bool DRV_TMR_AlarmRegister 
538:                 (
539:                     DRV_HANDLE handle, 
540:                     uint32_t divider, 
541:                     bool isPeriodic, 
542:                     uintptr_t context, 
543:                     DRV_TMR_CALLBACK callBack 
544:                 )
545:                 {
546:                     switch (handle)
547:                     {
548:                         case DRV_TMR_INDEX_1:
549:                         {
550:                             return DRV_TMR1_AlarmRegister(divider, isPeriodic, context, callBack);
551:                             break;
552:                         }
553:                         default:
554:                         {
555:                             break;
556:                         }
557:                     }
558:                 
559:                     return false;
560:                 }
561:                 
562:                 // *****************************************************************************
563:                 /* Function:
564:                     bool DRV_TMR_AlarmDisable ( DRV_HANDLE handle);
565:                 
566:                   Summary:
567:                     Disables an alarm signal.
568:                 
569:                   Description:
570:                     This function allows the client to disable an alarm generation.
571:                     Use DRV_TMR_AlarmEnable to re-enable.
572:                 
573:                   Remarks:
574:                     Refer to drv_tmr.h for usage information.
575:                 */
576:                 
577:                 bool DRV_TMR_AlarmDisable ( DRV_HANDLE handle)
578:                 {
579:                     switch (handle)
580:                     {
581:                         case DRV_TMR_INDEX_1:
582:                         {
583:                             return DRV_TMR1_AlarmDisable();
584:                             break;
585:                         }
586:                         default:
587:                         {
588:                             break;
589:                         }
590:                     }
591:                 
592:                     return false;
593:                 }
594:                 
595:                 // *****************************************************************************
596:                 /* Function:
597:                     void DRV_TMR_AlarmEnable ( DRV_HANDLE handle, bool enable );
598:                 
599:                   Summary:
600:                     Re-enables an alarm signal.
601:                 
602:                   Description:
603:                     This function allows the client to re-enable an alarm after it has been
604:                     disabled by a DRV_TMR_AlarmDisable call.
605:                 
606:                   Remarks:
607:                     Refer to drv_tmr.h for usage information.
608:                 */
609:                 
610:                 void DRV_TMR_AlarmEnable ( DRV_HANDLE handle, bool enable )
611:                 {
612:                     switch (handle)
613:                     {
614:                         case DRV_TMR_INDEX_1:
615:                         {
616:                             DRV_TMR1_AlarmEnable(enable);
617:                             break;
618:                         }
619:                         default:
620:                         {
621:                             break;
622:                         }
623:                     }
624:                 }
625:                 
626:                 // *****************************************************************************
627:                 /* Function:
628:                     void DRV_TMR_AlarmPeriodSet ( DRV_HANDLE handle, uint32_t value )
629:                 
630:                   Summary:
631:                     Updates the Timer's period.
632:                 
633:                   Description:
634:                     This function updates the Timer's period.
635:                 
636:                   Remarks:
637:                     Refer to drv_tmr.h for usage information.
638:                 */
639:                 
640:                 void DRV_TMR_AlarmPeriodSet ( DRV_HANDLE handle, uint32_t value )
641:                 {
642:                     switch (handle)
643:                     {
644:                         case DRV_TMR_INDEX_1:
645:                         {
646:                             DRV_TMR1_AlarmPeriodSet(value);
647:                             break;
648:                         }
649:                         default:
650:                         {
651:                             break;
652:                         }
653:                     }
654:                 }
655:                 
656:                 // *****************************************************************************
657:                 /* Function:
658:                     uint32_t DRV_TMR_AlarmPeriodGet ( DRV_HANDLE handle )
659:                 
660:                   Summary:
661:                     Provides the Timer's period.
662:                 
663:                   Description:
664:                     This function gets the Timer's period.
665:                 
666:                   Remarks:
667:                     Refer to drv_tmr.h for usage information.
668:                 */
669:                 
670:                 uint32_t DRV_TMR_AlarmPeriodGet ( DRV_HANDLE handle )
671:                 {
672:                     switch (handle)
673:                     {
674:                         case DRV_TMR_INDEX_1:
675:                         {
676:                             return DRV_TMR1_AlarmPeriodGet();
677:                             break;
678:                         }
679:                         default:
680:                         {
681:                             break;
682:                         }
683:                     }
684:                 
685:                     return 0;
686:                 }
687:                 
688:                 // *****************************************************************************
689:                 /* Function:
690:                     void DRV_TMR_AlarmDeregister ( DRV_HANDLE handle )
691:                 
692:                   Summary:
693:                     Removes a previously set alarm.
694:                 
695:                   Description:
696:                     This function removes a previously set alarm.
697:                 
698:                   Remarks:
699:                     Refer to drv_tmr.h for usage information.
700:                 */
701:                 
702:                 void DRV_TMR_AlarmDeregister ( DRV_HANDLE handle )
703:                 {
704:                     switch (handle)
705:                     {
706:                         case DRV_TMR_INDEX_1:
707:                         {
708:                             DRV_TMR1_AlarmDeregister();
709:                             break;
710:                         }
711:                         default:
712:                         {
713:                             break;
714:                         }
715:                     }
716:                 }
717:                 
718:                 // *****************************************************************************
719:                 // *****************************************************************************
720:                 // Section: TMR Driver Operation Control functions
721:                 // *****************************************************************************
722:                 // *****************************************************************************
723:                 
724:                 // *****************************************************************************
725:                 /* Function:
726:                     bool DRV_TMR_Start ( DRV_HANDLE handle )
727:                 
728:                   Summary:
729:                     Starts the Timer counting.
730:                 
731:                   Description:
732:                     This function starts the Timer counting.
733:                 
734:                   Remarks:
735:                     Refer to drv_tmr.h for usage information.
736:                 */
737:                 
738:                 bool DRV_TMR_Start ( DRV_HANDLE handle )
739:                 {
9D0138B4  27BDFFE8   ADDIU SP, SP, -24
740:                     switch (handle)
9D0138B8  24020001   ADDIU V0, ZERO, 1
9D0138BC  1082000C   BEQ A0, V0, 0x9D0138F0
9D0138C0  AFBF0014   SW RA, 20(SP)
9D0138C4  10800006   BEQ A0, ZERO, 0x9D0138E0
9D0138C8  00000000   NOP
9D0138CC  24020002   ADDIU V0, ZERO, 2
9D0138D0  1082000B   BEQ A0, V0, 0x9D013900
9D0138D4  00000000   NOP
741:                     {
742:                         case DRV_TMR_INDEX_0:
743:                         {
744:                             return DRV_TMR0_Start();
9D0138E0  0F405363   JAL DRV_TMR0_Start
9D0138E4  00000000   NOP
9D0138E8  0B404E45   J 0x9D013914
9D0138EC  8FBF0014   LW RA, 20(SP)
745:                             break;
746:                         }
747:                         case DRV_TMR_INDEX_1:
748:                         {
749:                             return DRV_TMR1_Start();
9D0138F0  0F405371   JAL DRV_TMR1_Start
9D0138F4  00000000   NOP
9D0138F8  0B404E45   J 0x9D013914
9D0138FC  8FBF0014   LW RA, 20(SP)
750:                             break;
751:                         }
752:                         case DRV_TMR_INDEX_2:
753:                         {
754:                             return DRV_TMR2_Start();
9D013900  0F40537F   JAL DRV_TMR2_Start
9D013904  00000000   NOP
9D013908  0B404E45   J 0x9D013914
9D01390C  8FBF0014   LW RA, 20(SP)
755:                             break;
756:                         }
757:                         default:
758:                         {
759:                             break;
760:                         }
761:                     }
762:                 
763:                     return false;
9D0138D8  0B404E44   J 0x9D013910
9D0138DC  00001021   ADDU V0, ZERO, ZERO
764:                 }
9D013910  8FBF0014   LW RA, 20(SP)
9D013914  03E00008   JR RA
9D013918  27BD0018   ADDIU SP, SP, 24
765:                 
766:                 // *****************************************************************************
767:                 /* Function:
768:                     void DRV_TMR_Stop ( DRV_HANDLE handle )
769:                 
770:                   Summary:
771:                     Stops the Timer from counting.
772:                 
773:                   Description:
774:                     This function stops the running Timer from counting.
775:                 
776:                   Remarks:
777:                     Refer to drv_tmr.h for usage information.
778:                 */
779:                 
780:                 void DRV_TMR_Stop ( DRV_HANDLE handle )
781:                 {
9D013E44  27BDFFE8   ADDIU SP, SP, -24
782:                     switch (handle)
9D013E48  24020001   ADDIU V0, ZERO, 1
9D013E4C  1082000B   BEQ A0, V0, 0x9D013E7C
9D013E50  AFBF0014   SW RA, 20(SP)
9D013E54  10800005   BEQ A0, ZERO, 0x9D013E6C
9D013E58  24020002   ADDIU V0, ZERO, 2
9D013E5C  1082000B   BEQ A0, V0, 0x9D013E8C
9D013E60  8FBF0014   LW RA, 20(SP)
9D013E64  0B404FA6   J 0x9D013E98
9D013E68  00000000   NOP
783:                     {
784:                         case DRV_TMR_INDEX_0:
785:                         {
786:                             DRV_TMR0_Stop();
9D013E6C  0F4052E2   JAL DRV_TMR0_Stop
9D013E70  00000000   NOP
787:                             break;
9D013E74  0B404FA6   J 0x9D013E98
9D013E78  8FBF0014   LW RA, 20(SP)
788:                         }
789:                         case DRV_TMR_INDEX_1:
790:                         {
791:                             DRV_TMR1_Stop();
9D013E7C  0F40543E   JAL DRV_TMR1_Stop
9D013E80  00000000   NOP
792:                             break;
9D013E84  0B404FA6   J 0x9D013E98
9D013E88  8FBF0014   LW RA, 20(SP)
793:                         }
794:                         case DRV_TMR_INDEX_2:
795:                         {
796:                             DRV_TMR2_Stop();
9D013E8C  0F4052F1   JAL DRV_TMR2_Stop
9D013E90  00000000   NOP
797:                             break;
798:                         }
799:                         default:
800:                         {
801:                             break;
802:                         }
803:                     }
804:                 }
9D013E94  8FBF0014   LW RA, 20(SP)
9D013E98  03E00008   JR RA
9D013E9C  27BD0018   ADDIU SP, SP, 24
805:                 
806:                 // *****************************************************************************
807:                 /* Function:
808:                     uint32_t DRV_TMR_AlarmHasElapsed ( DRV_HANDLE handle )
809:                 
810:                   Summary:
811:                     Provides the status of Timer's period elapse.
812:                 
813:                   Description:
814:                     This function returns the number of times Timer's period has elapsed since
815:                     last call to this API has made. On calling this API, the internally
816:                     maintained counter will be cleared and count will be started again from next
817:                     elapse.
818:                 
819:                   Remarks:
820:                     Refer to drv_tmr.h for usage information.
821:                 */
822:                 
823:                 uint32_t DRV_TMR_AlarmHasElapsed ( DRV_HANDLE handle )
824:                 {
825:                     switch (handle)
826:                     {
827:                         case DRV_TMR_INDEX_1:
828:                         {
829:                             return DRV_TMR1_AlarmHasElapsed();
830:                             break;
831:                         }
832:                         default:
833:                         {
834:                             break;
835:                         }
836:                     }
837:                 
838:                     return 0;
839:                 }
840:                 
841:                 // *****************************************************************************
842:                 /* Function:
843:                     DRV_TMR_OPERATION_MODE DRV_TMR_OperationModeGet(DRV_HANDLE handle)
844:                 
845:                   Summary:
846:                     This function gets the currently selected operation mode.
847:                 
848:                   Description:
849:                     This function gets the currently selected 16/32 bit operation mode.
850:                 
851:                   Remarks:
852:                     Refer to drv_tmr.h for usage information.
853:                 */
854:                 
855:                 DRV_TMR_OPERATION_MODE DRV_TMR_OperationModeGet(DRV_HANDLE handle)
856:                 {
857:                     switch (handle)
858:                     {
859:                         case DRV_TMR_INDEX_0:
860:                         {
861:                             return DRV_TMR0_OperationModeGet();
862:                             break;
863:                         }
864:                         case DRV_TMR_INDEX_1:
865:                         {
866:                             return DRV_TMR1_OperationModeGet();
867:                             break;
868:                         }
869:                         case DRV_TMR_INDEX_2:
870:                         {
871:                             return DRV_TMR2_OperationModeGet();
872:                             break;
873:                         }
874:                         default:
875:                         {
876:                             break;
877:                         }
878:                     }
879:                 
880:                     return DRV_TMR_OPERATION_MODE_NONE;
881:                 }
882:                 
883:                 // *****************************************************************************
884:                 // *****************************************************************************
885:                 // Section: TMR Driver Miscellaneous information functions
886:                 // *****************************************************************************
887:                 // *****************************************************************************
888:                 
889:                 // *****************************************************************************
890:                 /* Function:
891:                     bool DRV_TMR_ClockSet 
892:                     ( 
893:                         DRV_HANDLE handle, 
894:                         DRV_TMR_CLK_SOURCES clockSource, 
895:                         TMR_PRESCALE  preScale 
896:                     )
897:                 
898:                   Summary:
899:                     Sets the timers clock by selecting the source and prescaler.
900:                 
901:                   Description:
902:                     This function sets the timers clock by selecting the source and prescaler.
903:                 
904:                   Remarks:
905:                     Refer to drv_tmr.h for usage information.
906:                 */
907:                 
908:                 bool DRV_TMR_ClockSet 
909:                 ( 
910:                     DRV_HANDLE handle, 
911:                     DRV_TMR_CLK_SOURCES clockSource, 
912:                     TMR_PRESCALE  preScale 
913:                 )
914:                 {
915:                     switch (handle)
916:                     {
917:                         case DRV_TMR_INDEX_0:
918:                         {
919:                             return DRV_TMR0_ClockSet(clockSource, preScale);
920:                             break;
921:                         }
922:                         case DRV_TMR_INDEX_1:
923:                         {
924:                             return DRV_TMR1_ClockSet(clockSource, preScale);
925:                             break;
926:                         }
927:                         case DRV_TMR_INDEX_2:
928:                         {
929:                             return DRV_TMR2_ClockSet(clockSource, preScale);
930:                             break;
931:                         }
932:                         default:
933:                         {
934:                             break;
935:                         }
936:                     }
937:                 
938:                     return false;
939:                 }
940:                 
941:                 // *****************************************************************************
942:                 /* Function:
943:                     TMR_PRESCALE DRV_TMR_PrescalerGet ( DRV_HANDLE handle )
944:                 
945:                   Summary:
946:                     This function gets the currently selected prescaler.
947:                 
948:                   Description:
949:                     This function gets the currently selected prescaler.
950:                 
951:                   Remarks:
952:                     Refer to drv_tmr.h for usage information.
953:                 */
954:                 
955:                 TMR_PRESCALE DRV_TMR_PrescalerGet ( DRV_HANDLE handle )
956:                 {
957:                     switch (handle)
958:                     {
959:                         case DRV_TMR_INDEX_0:
960:                         {
961:                             return DRV_TMR0_PrescalerGet();
962:                             break;
963:                         }
964:                         case DRV_TMR_INDEX_1:
965:                         {
966:                             return DRV_TMR1_PrescalerGet();
967:                             break;
968:                         }
969:                         case DRV_TMR_INDEX_2:
970:                         {
971:                             return DRV_TMR2_PrescalerGet();
972:                             break;
973:                         }
974:                         default:
975:                         {
976:                             break;
977:                         }
978:                     }
979:                 
980:                     return -1;
981:                 }
982:                 
983:                 // *****************************************************************************
984:                 /* Function:
985:                     bool DRV_TMR_GateModeSet ( DRV_HANDLE handle )
986:                 
987:                   Summary:
988:                     Enables the Gate mode.
989:                 
990:                   Description:
991:                     This function enables the Gated mode of Timer. User can measure the duration
992:                     of an external signal in this mode. Once the Gate mode is enabled, Timer
993:                     will start on the raising edge of the external signal. It will keep counting
994:                     until the next falling edge. 
995:                 
996:                   Remarks:
997:                     Refer to drv_tmr.h for usage information.
998:                 */
999:                 
1000:                bool DRV_TMR_GateModeSet ( DRV_HANDLE handle )
1001:                {
1002:                    switch (handle)
1003:                    {
1004:                        default:
1005:                        {
1006:                            break;
1007:                        }
1008:                    }
1009:                
1010:                    return false;
1011:                }
1012:                
1013:                // *****************************************************************************
1014:                /* Function:
1015:                    bool DRV_TMR_GateModeClear ( DRV_HANDLE handle )
1016:                
1017:                  Summary:
1018:                    Enables the Gate mode.
1019:                
1020:                  Description:
1021:                    This function enables the Gated mode of Timer. User can measure the duration
1022:                    of an external signal in this mode. Once the Gate mode is enabled, Timer
1023:                    will start on the raising edge of the external signal. It will keep counting
1024:                    until the next falling edge. 
1025:                
1026:                  Remarks:
1027:                    Refer to drv_tmr.h for usage information.
1028:                */
1029:                
1030:                bool DRV_TMR_GateModeClear ( DRV_HANDLE handle )
1031:                {
1032:                    switch (handle)
1033:                    {
1034:                        default:
1035:                        {
1036:                            break;
1037:                        }
1038:                    }
1039:                
1040:                    return false;
1041:                }
1042:                
1043:                // *****************************************************************************
1044:                /* Function:
1045:                    uint32_t DRV_TMR_CounterFrequencyGet ( DRV_HANDLE handle )
1046:                
1047:                  Summary:
1048:                    Provides the Timer input frequency.
1049:                
1050:                  Description:
1051:                    This function provides the Timer input frequency. Input frequency is the
1052:                    clock to the Timer register and it is considering the prescaler divisor. 
1053:                
1054:                  Remarks:
1055:                    Refer to drv_tmr.h for usage information.
1056:                */
1057:                
1058:                uint32_t DRV_TMR_CounterFrequencyGet ( DRV_HANDLE handle )
1059:                {
1060:                    switch (handle)
1061:                    {
1062:                        case DRV_TMR_INDEX_0:
1063:                        {
1064:                            return DRV_TMR0_CounterFrequencyGet();
1065:                            break;
1066:                        }
1067:                        case DRV_TMR_INDEX_1:
1068:                        {
1069:                            return DRV_TMR1_CounterFrequencyGet();
1070:                            break;
1071:                        }
1072:                        case DRV_TMR_INDEX_2:
1073:                        {
1074:                            return DRV_TMR2_CounterFrequencyGet();
1075:                            break;
1076:                        }
1077:                        default:
1078:                        {
1079:                            break;
1080:                        }
1081:                    }
1082:                
1083:                    return 0;
1084:                }
1085:                
1086:                // *****************************************************************************
1087:                /* Function:
1088:                    DRV_TMR_OPERATION_MODE DRV_TMR_DividerRangeGet 
1089:                    ( 
1090:                        DRV_HANDLE handle, 
1091:                        DRV_TMR_DIVIDER_RANGE* pDivRange
1092:                    )
1093:                
1094:                  Summary:
1095:                    Returns the Timer divider values.
1096:                
1097:                  Description:
1098:                    This function provides the Timer operating mode and divider range.
1099:                
1100:                  Remarks:
1101:                    Refer to drv_tmr.h for usage information.
1102:                */
1103:                
1104:                DRV_TMR_OPERATION_MODE DRV_TMR_DividerRangeGet 
1105:                ( 
1106:                    DRV_HANDLE handle,
1107:                    DRV_TMR_DIVIDER_RANGE* pDivRange
1108:                )
1109:                {
1110:                    switch (handle)
1111:                    {
1112:                        case DRV_TMR_INDEX_0:
1113:                        {
1114:                            return DRV_TMR0_DividerRangeGet(pDivRange);
1115:                            break;
1116:                        }
1117:                        case DRV_TMR_INDEX_1:
1118:                        {
1119:                            return DRV_TMR1_DividerRangeGet(pDivRange);
1120:                            break;
1121:                        }
1122:                        case DRV_TMR_INDEX_2:
1123:                        {
1124:                            return DRV_TMR2_DividerRangeGet(pDivRange);
1125:                            break;
1126:                        }
1127:                        default:
1128:                        {
1129:                            break;
1130:                        }
1131:                    }
1132:                
1133:                    return DRV_TMR_OPERATION_MODE_NONE;
1134:                }
1135:                
---  /home/whatisthis/src/DoorBell_PIC32/firmware/src/system_config/default/framework/driver/tmr/drv_tmr_static.h
1:                   /*******************************************************************************
2:                     Timer Driver Interface Declarations for Static Single Instance Driver
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       drv_tmr_static.h
9:                   
10:                    Summary:
11:                      Timer driver interface declarations for the static single instance driver.
12:                  
13:                    Description:
14:                      The Timer device driver provides a simple interface to manage the Timer
15:                      modules on Microchip microcontrollers. This file defines the interface
16:                      Declarations for the TMR driver.
17:                      
18:                    Remarks:
19:                      Static interfaces incorporate the driver instance number within the names
20:                      of the routines, eliminating the need for an object ID or object handle.
21:                      
22:                      Static single-open interfaces also eliminate the need for the open handle.
23:                  *******************************************************************************/
24:                  
25:                  //DOM-IGNORE-BEGIN
26:                  /*******************************************************************************
27:                  Copyright (c) 2014 released Microchip Technology Inc.  All rights reserved.
28:                  
29:                  Microchip licenses to you the right to use, modify, copy and distribute
30:                  Software only when embedded on a Microchip microcontroller or digital signal
31:                  controller that is integrated into your product or third party product
32:                  (pursuant to the sublicense terms in the accompanying license agreement).
33:                  
34:                  You should refer to the license agreement accompanying this Software for
35:                  additional information regarding your rights and obligations.
36:                  
37:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
38:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
39:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTOCULAR PURPOSE.
40:                  IN NO EVENT SHALL MOCROCHIP OR ITS LOCENSORS BE LIABLE OR OBLIGATED UNDER
41:                  CONTRACT, NEGLIGENCE, STROCT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
42:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
43:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
44:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
45:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVOCES, OR ANY CLAIMS BY THIRD PARTIES
46:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
47:                  *******************************************************************************/
48:                  //DOM-IGNORE-END
49:                  
50:                  #ifndef _DRV_TMR_STATIC_H
51:                  #define _DRV_TMR_STATIC_H
52:                  // *****************************************************************************
53:                  // *****************************************************************************
54:                  // Section: Include Headers
55:                  // *****************************************************************************
56:                  // *****************************************************************************
57:                  #include <stdint.h>
58:                  #include "driver/tmr/drv_tmr.h"
59:                  #include "peripheral/tmr/plib_tmr.h"
60:                  #include "peripheral/int/plib_int.h"
61:                  
62:                  // maximum divider value for 32 bit operation mode
63:                  #define     DRV_TIMER_DIVIDER_MAX_32BIT     0xffffffff
64:                  
65:                  // minimum divider value for 32 bit operation mode
66:                  #define     DRV_TIMER_DIVIDER_MIN_32BIT     0x2
67:                  
68:                  // maximum divider value for 16 bit operation mode
69:                  #define     DRV_TIMER_DIVIDER_MAX_16BIT     0x10000
70:                  
71:                  // minimum divider value for 16 bit operation mode
72:                  #define     DRV_TIMER_DIVIDER_MIN_16BIT     0x2
73:                  
74:                  
75:                  // *****************************************************************************
76:                  // *****************************************************************************
77:                  // Section: Interface Headers for Instance 0 for the static driver
78:                  // *****************************************************************************
79:                  // *****************************************************************************
80:                  
81:                  void DRV_TMR0_Initialize(void);
82:                  bool DRV_TMR0_Start(void);
83:                  void DRV_TMR0_Stop(void);
84:                  static inline void DRV_TMR0_DeInitialize(void)
85:                  {
86:                  	DRV_TMR0_Stop();
87:                  }
88:                  static inline SYS_STATUS DRV_TMR0_Status(void)
89:                  {
90:                  	/* Return the status as ready always */
91:                      return SYS_STATUS_READY; 
92:                  }
93:                  static inline void DRV_TMR0_Open(void) {}
94:                  DRV_TMR_CLIENT_STATUS DRV_TMR0_ClientStatus ( void );
95:                  static inline DRV_TMR_OPERATION_MODE DRV_TMR0_OperationModeGet(void)
96:                  {
97:                      return DRV_TMR_OPERATION_MODE_16_BIT;
98:                  }
99:                  static inline void DRV_TMR0_Close(void) 
100:                 {
101:                     DRV_TMR0_Stop();
9D013D58  0F4052E2   JAL DRV_TMR0_Stop
9D013D5C  00000000   NOP
102:                 }
103:                 bool DRV_TMR0_ClockSet
104:                 (
105:                     DRV_TMR_CLK_SOURCES clockSource, 
106:                     TMR_PRESCALE  prescale 
107:                 );
108:                 void DRV_TMR0_CounterValueSet(uint32_t value);
109:                 uint32_t DRV_TMR0_CounterValueGet(void);
110:                 void DRV_TMR0_CounterClear(void);
111:                 TMR_PRESCALE DRV_TMR0_PrescalerGet(void);
112:                 void DRV_TMR0_PeriodValueSet(uint32_t value);
113:                 uint32_t DRV_TMR0_PeriodValueGet(void);
114:                 void DRV_TMR0_StopInIdleDisable(void);
115:                 void DRV_TMR0_StopInIdleEnable(void);
116:                 static inline void DRV_TMR0_Tasks(void) {}
117:                 uint32_t DRV_TMR0_CounterFrequencyGet(void);
118:                 DRV_TMR_OPERATION_MODE DRV_TMR0_DividerRangeGet
119:                 (
120:                     DRV_TMR_DIVIDER_RANGE * pDivRange
121:                 );
122:                 // *****************************************************************************
123:                 // *****************************************************************************
124:                 // Section: Interface Headers for Instance 1 for the static driver
125:                 // *****************************************************************************
126:                 // *****************************************************************************
127:                 
128:                 void DRV_TMR1_Initialize(void);
129:                 bool DRV_TMR1_Start(void);
130:                 void DRV_TMR1_Stop(void);
131:                 static inline void DRV_TMR1_DeInitialize(void)
132:                 {
133:                 	DRV_TMR1_Stop();
134:                 }
135:                 static inline SYS_STATUS DRV_TMR1_Status(void)
136:                 {
137:                 	/* Return the status as ready always */
138:                     return SYS_STATUS_READY; 
139:                 }
140:                 static inline void DRV_TMR1_Open(void) {}
141:                 DRV_TMR_CLIENT_STATUS DRV_TMR1_ClientStatus ( void );
142:                 static inline DRV_TMR_OPERATION_MODE DRV_TMR1_OperationModeGet(void)
143:                 {
144:                     return DRV_TMR_OPERATION_MODE_16_BIT;
145:                 }
146:                 static inline void DRV_TMR1_Close(void) 
147:                 {
148:                     DRV_TMR1_Stop();
9D013D68  0F40543E   JAL DRV_TMR1_Stop
9D013D6C  00000000   NOP
149:                 }
150:                 bool DRV_TMR1_ClockSet
151:                 (
152:                     DRV_TMR_CLK_SOURCES clockSource, 
153:                     TMR_PRESCALE  prescale 
154:                 );
155:                 void DRV_TMR1_CounterValueSet(uint32_t value);
156:                 uint32_t DRV_TMR1_CounterValueGet(void);
157:                 void DRV_TMR1_CounterClear(void);
158:                 TMR_PRESCALE DRV_TMR1_PrescalerGet(void);
159:                 void DRV_TMR1_PeriodValueSet(uint32_t value);
160:                 uint32_t DRV_TMR1_PeriodValueGet(void);
161:                 void DRV_TMR1_StopInIdleDisable(void);
162:                 void DRV_TMR1_StopInIdleEnable(void);
163:                 bool DRV_TMR1_AlarmRegister(
164:                     uint32_t divider, 
165:                     bool isPeriodic, 
166:                     uintptr_t context, 
167:                     DRV_TMR_CALLBACK callBack 
168:                 );
169:                 bool DRV_TMR1_AlarmDisable(void);
170:                 void DRV_TMR1_AlarmEnable(bool enable);
171:                 void DRV_TMR1_AlarmPeriodSet(uint32_t value);
172:                 uint32_t DRV_TMR1_AlarmPeriodGet(void);
173:                 void DRV_TMR1_AlarmDeregister(void);
174:                 uint32_t DRV_TMR1_AlarmHasElapsed(void);
175:                 void DRV_TMR1_Tasks(void);
176:                 uint32_t DRV_TMR1_CounterFrequencyGet(void);
177:                 DRV_TMR_OPERATION_MODE DRV_TMR1_DividerRangeGet
178:                 (
179:                     DRV_TMR_DIVIDER_RANGE * pDivRange
180:                 );
181:                 // *****************************************************************************
182:                 // *****************************************************************************
183:                 // Section: Interface Headers for Instance 2 for the static driver
184:                 // *****************************************************************************
185:                 // *****************************************************************************
186:                 
187:                 void DRV_TMR2_Initialize(void);
188:                 bool DRV_TMR2_Start(void);
189:                 void DRV_TMR2_Stop(void);
190:                 static inline void DRV_TMR2_DeInitialize(void)
191:                 {
192:                 	DRV_TMR2_Stop();
193:                 }
194:                 static inline SYS_STATUS DRV_TMR2_Status(void)
195:                 {
196:                 	/* Return the status as ready always */
197:                     return SYS_STATUS_READY; 
198:                 }
199:                 static inline void DRV_TMR2_Open(void) {}
200:                 DRV_TMR_CLIENT_STATUS DRV_TMR2_ClientStatus ( void );
201:                 static inline DRV_TMR_OPERATION_MODE DRV_TMR2_OperationModeGet(void)
202:                 {
203:                     return DRV_TMR_OPERATION_MODE_16_BIT;
204:                 }
205:                 static inline void DRV_TMR2_Close(void) 
206:                 {
207:                     DRV_TMR2_Stop();
9D013D78  0F4052F1   JAL DRV_TMR2_Stop
9D013D7C  00000000   NOP
208:                 }
209:                 bool DRV_TMR2_ClockSet
210:                 (
211:                     DRV_TMR_CLK_SOURCES clockSource, 
212:                     TMR_PRESCALE  prescale 
213:                 );
214:                 void DRV_TMR2_CounterValueSet(uint32_t value);
215:                 uint32_t DRV_TMR2_CounterValueGet(void);
216:                 void DRV_TMR2_CounterClear(void);
217:                 TMR_PRESCALE DRV_TMR2_PrescalerGet(void);
218:                 void DRV_TMR2_PeriodValueSet(uint32_t value);
219:                 uint32_t DRV_TMR2_PeriodValueGet(void);
220:                 void DRV_TMR2_StopInIdleDisable(void);
221:                 void DRV_TMR2_StopInIdleEnable(void);
222:                 static inline void DRV_TMR2_Tasks(void) {}
223:                 uint32_t DRV_TMR2_CounterFrequencyGet(void);
224:                 DRV_TMR_OPERATION_MODE DRV_TMR2_DividerRangeGet
225:                 (
226:                     DRV_TMR_DIVIDER_RANGE * pDivRange
227:                 );
228:                 #endif // #ifndef _DRV_TMR_STATIC_H
229:                 
230:                 /*******************************************************************************
231:                  End of File
232:                 */
---  /home/whatisthis/src/DoorBell_PIC32/firmware/src/system_config/default/framework/driver/oc/src/drv_oc_mapping.c
1:                   /*******************************************************************************
2:                     OC Driver Dynamic to Static mapping
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       drv_oc_mapping.c
9:                   
10:                    Summary:
11:                      Source code for the OC driver dynamic APIs to static API mapping.
12:                  
13:                    Description:
14:                      This file contains code that maps dynamic APIs to static whenever
15:                      the static mode of the driver is selected..
16:                  
17:                    Remarks:
18:                      Static interfaces incorporate the driver instance number within the names
19:                      of the routines, eliminating the need for an object ID or object handle.
20:                  
21:                      Static single-open interfaces also eliminate the need for the open handle.
22:                  *******************************************************************************/
23:                  
24:                  //DOM-IGNORE-BEGIN
25:                  /*******************************************************************************
26:                  Copyright (c) 2015 released Microchip Technology Inc.  All rights reserved.
27:                  
28:                  Microchip licenses to you the right to use, modify, copy and distribute
29:                  Software only when embedded on a Microchip microcontroller or digital signal
30:                  controller that is integrated into your product or third party product
31:                  (pursuant to the sublicense terms in the accompanying license agreement).
32:                  
33:                  You should refer to the license agreement accompanying this Software for
34:                  additional information regarding your rights and obligations.
35:                  
36:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
37:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
38:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTOCULAR PURPOSE.
39:                  IN NO EVENT SHALL MOCROCHIP OR ITS LOCENSORS BE LIABLE OR OBLIGATED UNDER
40:                  CONTRACT, NEGLIGENCE, STROCT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
41:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
42:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
43:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
44:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVOCES, OR ANY CLAIMS BY THIRD PARTIES
45:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
46:                  *******************************************************************************/
47:                  //DOM-IGNORE-END
48:                  
49:                  // *****************************************************************************
50:                  // *****************************************************************************
51:                  // Section: Included Files
52:                  // *****************************************************************************
53:                  // *****************************************************************************
54:                  #include "system_config.h"
55:                  #include "system_definitions.h"
56:                  
57:                  
58:                  SYS_MODULE_OBJ DRV_OC_Initialize(const SYS_MODULE_INDEX index,const SYS_MODULE_INIT * const init)
59:                  {
60:                      SYS_MODULE_OBJ returnValue = index;
61:                  
62:                      switch(index)
63:                      {
64:                          case DRV_OC_INDEX_0:
65:                          {
66:                              DRV_OC0_Initialize();
67:                              break;
68:                          }
69:                          default:
70:                          {
71:                              returnValue = SYS_MODULE_OBJ_INVALID;
72:                              break;
73:                          }
74:                      }
75:                      return returnValue;
76:                  }
77:                  
78:                  DRV_HANDLE DRV_OC_Start(const SYS_MODULE_INDEX drvIndex, const DRV_IO_INTENT intent)
79:                  {
9D014FA8  27BDFFE8   ADDIU SP, SP, -24
9D014FAC  AFBF0014   SW RA, 20(SP)
80:                      SYS_MODULE_OBJ returnValue = drvIndex;
81:                  
82:                      switch(drvIndex)
9D014FA0  14800007   BNE A0, ZERO, 0x9D014FC0
9D014FA4  00000000   NOP
83:                      {
84:                          case DRV_OC_INDEX_0:
85:                          {
86:                              DRV_OC0_Start();
9D014FB0  0F4055FA   JAL DRV_OC0_Start
9D014FB4  00000000   NOP
87:                              break;
9D014FB8  0B4053F2   J 0x9D014FC8
9D014FBC  00001021   ADDU V0, ZERO, ZERO
88:                          }
89:                          default:
90:                          {
91:                              returnValue = SYS_MODULE_OBJ_INVALID;
9D014FC0  03E00008   JR RA
9D014FC4  2402FFFF   ADDIU V0, ZERO, -1
92:                              break;
93:                          }
94:                      }
95:                      return returnValue;
96:                  }
9D014FC8  8FBF0014   LW RA, 20(SP)
9D014FCC  03E00008   JR RA
9D014FD0  27BD0018   ADDIU SP, SP, 24
97:                  
98:                  
99:                  void DRV_OC_Stop(DRV_HANDLE handle)
100:                 {
9D015304  27BDFFE8   ADDIU SP, SP, -24
9D015308  AFBF0014   SW RA, 20(SP)
101:                     switch(handle)
9D0152FC  14800007   BNE A0, ZERO, 0x9D01531C
9D015300  00000000   NOP
102:                     {
103:                         case DRV_OC_INDEX_0:
104:                         {
105:                             DRV_OC0_Stop();
9D01530C  0F4055FF   JAL DRV_OC0_Stop
9D015310  00000000   NOP
106:                             break;
107:                         }
108:                         default:
109:                         {
110:                             break;
111:                         }
112:                     }
113:                 }
9D015314  8FBF0014   LW RA, 20(SP)
9D015318  27BD0018   ADDIU SP, SP, 24
9D01531C  03E00008   JR RA
9D015320  00000000   NOP
114:                 
115:                 void DRV_OC_CompareValuesSingleSet(DRV_HANDLE handle, uint32_t compareValue)
116:                 {
117:                     /* This API is supported only when selected instance of the OC driver is 
118:                      * configured for the Single Compare match modes. */
119:                 
120:                     switch(handle)
121:                     {
122:                         default:
123:                         {
124:                             SYS_ASSERT(false, "The selected instance of the OC driver is not configured for the Single Compare match mode");
125:                             break;
126:                         }
127:                     }
128:                 }
129:                 
130:                 void DRV_OC_CompareValuesDualSet(DRV_HANDLE handle, uint32_t priVal, uint32_t secVal)
131:                 {
132:                     /* This API is supported only when selected instance of the OC driver is 
133:                      * configured for the Dual Compare match modes. */
134:                 
135:                     switch(handle)
136:                     {
137:                         default:
138:                         {
139:                             SYS_ASSERT(false, "The selected instance of the OC driver is not configured for the Dual Compare match mode");
140:                             break;
141:                         }
142:                     }
143:                 }
144:                 
145:                 void DRV_OC_PulseWidthSet(DRV_HANDLE handle, uint32_t pulseWidth)
146:                 {
9D01532C  27BDFFE8   ADDIU SP, SP, -24
9D015330  AFBF0014   SW RA, 20(SP)
147:                     /* This API is supported only when selected instance of the OC driver is 
148:                      * configured for the Dual Compare match modes. */
149:                 
150:                     switch(handle)
9D015324  14800007   BNE A0, ZERO, 0x9D015344
9D015328  00000000   NOP
151:                     {
152:                         case DRV_OC_INDEX_0:
153:                         {
154:                             DRV_OC0_PulseWidthSet(pulseWidth);
9D015334  0F405604   JAL DRV_OC0_PulseWidthSet
9D015338  00A02021   ADDU A0, A1, ZERO
155:                             break;
156:                         }
157:                         default:
158:                         {
159:                             SYS_ASSERT(false, "The selected instance of the OC driver is not configured for the PWM mode");
160:                             break;
161:                         }
162:                     }
163:                 }
9D01533C  8FBF0014   LW RA, 20(SP)
9D015340  27BD0018   ADDIU SP, SP, 24
9D015344  03E00008   JR RA
9D015348  00000000   NOP
164:                 
165:                 bool DRV_OC_FaultHasOccurred(DRV_HANDLE handle)
166:                 {
167:                     bool returnValue = true;  // Default state of buffer is empty.
168:                 
169:                     switch(handle)
170:                     {
171:                         case DRV_OC_INDEX_0:
172:                         {
173:                             returnValue = DRV_OC0_FaultHasOccurred();
174:                             break;
175:                         }
176:                         default:
177:                         {
178:                             break;
179:                         }
180:                     }
181:                     return returnValue;
182:                 }
183:                 
184:                 /*******************************************************************************
185:                  End of File
186:                 */
---  /home/whatisthis/src/DoorBell_PIC32/firmware/src/sounder.c  ----------------------------------------
1:                   
2:                   /*
3:                    * Sounder routine
4:                    * (C) 2017 K.Ohta <whatisthis.sowhat _at_ gmail.com>
5:                    */
6:                   #include <stddef.h>                     // Defines NULL
7:                   #include <stdbool.h>                    // Defines true
8:                   #include <stdlib.h>                     // Defines EXIT_FAILURE
9:                   #include "system/common/sys_module.h"
10:                  #include "doorbell.h"   // SYS function prototypes
11:                  #include "lm01_drv.h"
12:                  #include "pca9655.c"
13:                  #include "ringbuffer.h"
14:                  
15:                  /* Kernel includes. */
16:                  #include "FreeRTOS.h"
17:                  #include "task.h"
18:                  #include "queue.h"
19:                  #include "timers.h"
20:                  
21:                  
22:                  QueueHandle_t xSoundCmdQueue;
23:                  QueueHandle_t xSoundQueue;
24:                  TimerHandle_t xSoundTimer;
25:                  const uint16_t sound_level_table[32] = {
26:                      0, 5, 10, 15, 20, 25, 30, 35,
27:                      41, 47, 53, 60, 67, 74, 81, 88,
28:                      95, 103, 111, 119, 127, 136, 145, 154,
29:                      164, 174, 185, 196, 208, 220, 235, 255
30:                  };
31:                  
32:                  uint16_t __attribute__((coherent)) __attribute__((aligned(16))) sample_buffer[SOUND_LENGTH + 32]; // 0.2sec
33:                  
34:                  
35:                  #define TEST_FREQ 440
36:                  #define SAMPLE_FREQ 16000
37:                  
38:                  typedef struct {
39:                      uint32_t freq; // Hz
40:                      uint32_t envelope_pitch; // Tick. 1Tick = 16KHz.
41:                      uint32_t howlong;
42:                      uint32_t noise_freq;
43:                      int16_t vol;
44:                      int16_t env_tmp_vol;
45:                      uint8_t env_pos;
46:                      uint8_t env_type;
47:                      bool noise_on;
48:                      bool env_on;
49:                      uint32_t rmod;
50:                      bool ponoff;
51:                  } SOUND_PSG_EMU_T;
52:                  
53:                  typedef struct {
54:                      char *mmlbase;
55:                      uint32_t mmlpos;
56:                      bool sound_stop; // Sound = true, stop = false;
57:                      bool is_eof; // Ended?
58:                      bool is_end; // Rendering end.
59:                      uint32_t tempo; // Txx :
60:                      uint32_t octave;
61:                      uint32_t sound_length;
62:                      uint32_t stop_length;
63:                      uint32_t tmp_sound_length;
64:                      SOUND_PSG_EMU_T regs;
65:                  } SOUND_MML_T;
66:                  
67:                  /*
68:                   * MML SYNTAX from "FM-7 F-BASIC Grammer book (???)" 
69:                   * By FUJITSU LIMITED, Apr. 1984, at PAGE 3-137 to 3-144.
70:                   */
71:                  const char test_mml1[] = "O4CDEFGO5ABC";
72:                  //const char test_mml1[] = "O4CR16DR16ER16FR16GO5ABC";
73:                  
74:                  static SOUND_MML_T mmldata[3];
75:                  
76:                  static uint32_t render_op(int16_t *data, SOUND_MML_T *regs, uint32_t samples)
77:                  {
78:                      uint32_t rp = 0;
79:                      int16_t *p = data;
80:                      int i;
81:                      bool onoff = true;
82:                  
83:                      if (regs == NULL) return samples;
9D0124F0  10A00021   BEQ A1, ZERO, 0x9D012578
9D0124F4  00C01021   ADDU V0, A2, ZERO
84:                      uint32_t freq = regs->regs.freq;
9D0124F8  8CAC0020   LW T4, 32(A1)
85:                      uint16_t vol = regs->regs.vol;
9D0124FC  94AB0030   LHU T3, 48(A1)
86:                  
87:                      rp = regs->regs.rmod;
88:                      onoff = regs->regs.ponoff;
9D012500  90AA003C   LBU T2, 60(A1)
89:                      {
90:                          // First
91:                          if (onoff) {
9D012504  11400004   BEQ T2, ZERO, 0x9D012518
9D012508  8CA30038   LW V1, 56(A1)
92:                              *p += vol;
9D01250C  94860000   LHU A2, 0(A0)
9D012510  01663021   ADDU A2, T3, A2
9D012514  A4860000   SH A2, 0(A0)
93:                          } else {
94:                              *p += 0;
95:                          }
96:                          onoff = !onoff;
97:                      }
98:                      for (i = 0; i < samples; i++) {
9D012518  10400015   BEQ V0, ZERO, 0x9D012570
9D01251C  394A0001   XORI T2, T2, 1
9D012520  00406821   ADDU T5, V0, ZERO
9D012524  00003821   ADDU A3, ZERO, ZERO
9D012564  24E70001   ADDIU A3, A3, 1
9D012568  14EDFFEF   BNE A3, T5, 0x9D012528
9D01256C  006C1821   ADDU V1, V1, T4
99:                          if (rp >= (SAMPLE_FREQ / 2)) {
9D012528  2C681F40   SLTIU T0, V1, 8000
9D01252C  15000003   BNE T0, ZERO, 0x9D01253C
9D012530  94880000   LHU T0, 0(A0)
100:                             rp -= (SAMPLE_FREQ / 2);
9D012534  2463E0C0   ADDIU V1, V1, -8000
101:                             onoff = !onoff;
9D012538  394A0001   XORI T2, T2, 1
102:                         }
103:                         *p += ((onoff) ? vol : 0);
9D01253C  00004821   ADDU T1, ZERO, ZERO
9D012540  016A480B   MOVN T1, T3, T2
9D012544  01284021   ADDU T0, T1, T0
9D012548  01004821   ADDU T1, T0, ZERO
9D01254C  7C084620   SEH T0, T0
9D012550  29080259   SLTI T0, T0, 601
9D012554  51000001   BEQL T0, ZERO, 0x9D01255C
9D012558  24090258   ADDIU T1, ZERO, 600
9D01255C  A4890000   SH T1, 0(A0)
104:                         if (*p > 600) *p = 600;
105:                         p++; // Saturation
9D012560  24840002   ADDIU A0, A0, 2
106:                         rp += freq;
107:                     }
108:                 
109:                     regs->regs.rmod = rp;
9D012570  ACA30038   SW V1, 56(A1)
110:                     regs->regs.ponoff = onoff;
9D012574  A0AA003C   SB T2, 60(A1)
111:                     return samples;
112:                 
113:                 }
9D012578  03E00008   JR RA
9D01257C  00000000   NOP
114:                 
115:                 static uint32_t render_sound(int16_t *data, SOUND_MML_T *regs, uint32_t samples)
116:                 {
117:                     regs->regs.freq = TEST_FREQ;
118:                     return render_op(data, regs, samples);
119:                 }
120:                 
121:                 const uint32_t note_std_o4[] = {
122:                     440000, 493883, 523251, 587330, 659255, 698456, 783991, // A B C D E F G
123:                 };
124:                 const uint32_t note_upper_o4[] = {
125:                     466164, 493883, 554365, 622254, 659255, 739989, 830609, // A# B C# D# E F# G#
126:                 };
127:                 
128:                 const uint32_t note_lower_o4[] = {
129:                     415305, 466164, 523251, 554365, 622254, 698456, 739989, // Ab(G#), Bb C Db Eb F Gb
130:                 };
131:                 
132:                 static bool pre_render(int16_t *head_data, SOUND_MML_T *regs, uint32_t *ps, uint32_t *p_left, uint32_t max_samples)
133:                 {
134:                     uint32_t p_samples;
135:                     uint32_t n_samples;
136:                     uint32_t left;
137:                     if ((regs == NULL) || (ps == NULL) || (p_left == NULL)) return false;
138:                     p_samples = *ps;
139:                     left = *p_left;
140:                     if (regs->tmp_sound_length > 0) {
9D0018B8  8E13001C   LW S3, 28(S0)
9D0018BC  12600014   BEQ S3, ZERO, 0x9D001910
9D0018C0  2E620330   SLTIU V0, S3, 816
141:                         if (left > regs->tmp_sound_length) {
9D0018C4  50400005   BEQL V0, ZERO, render_mml
9D0018C8  2673FCD0   ADDIU S3, S3, -816
142:                             n_samples = regs->tmp_sound_length;
143:                             left -= regs->tmp_sound_length;
9D0018CC  24110330   ADDIU S1, ZERO, 816
9D0018D0  02338823   SUBU S1, S1, S3
144:                             regs->tmp_sound_length = 0;
9D0018D4  0B40063A   J 0x9D0018E8
9D0018D8  AE00001C   SW ZERO, 28(S0)
145:                         } else {
146:                             n_samples = left;
9D0018E4  24130330   ADDIU S3, ZERO, 816
147:                             regs->tmp_sound_length -= left;
9D0018DC  AE13001C   SW S3, 28(S0)
148:                             left = 0;
9D0018E0  00008821   ADDU S1, ZERO, ZERO
149:                         }
150:                         if (regs->sound_stop != 0) {
9D0018E8  92020008   LBU V0, 8(S0)
9D0018EC  54400007   BNEL V0, ZERO, 0x9D00190C
9D0018F0  0011882B   SLTU S1, ZERO, S1
151:                             // Skip
152:                             p_samples += n_samples;
153:                         } else {
154:                             p_samples += render_op(head_data, regs, n_samples);
9D0018F4  8FA40038   LW A0, 56(SP)
9D0018F8  02002821   ADDU A1, S0, ZERO
9D0018FC  0F40493C   JAL render_op
9D001900  02603021   ADDU A2, S3, ZERO
9D001904  00409821   ADDU S3, V0, ZERO
155:                         }
156:                         if (left == 0) {
9D001908  0011882B   SLTU S1, ZERO, S1
9D00190C  AFB10044   SW S1, 68(SP)
157:                             *ps = p_samples;
158:                             *p_left = 0;
159:                             return false;
160:                         }
161:                         *p_left = left;
162:                         *ps = p_samples;
163:                         return true;
164:                     }
165:                 }
166:                 
167:                 static bool render_mml_core(int16_t *head_data, SOUND_MML_T *regs, uint32_t *psndptr, uint32_t max_samples, uint32_t mml_len)
168:                 {
169:                     uint32_t mmlptr;
170:                     uint32_t sndptr;
171:                     char head_char;
172:                     char *p;
173:                     char note;
174:                     uint32_t basefreq = 1;
9D00219C  24060001   ADDIU A2, ZERO, 1
9D0021A0  AFA60048   SW A2, 72(SP)
175:                     bool b_note = false;
176:                     bool loopval;
177:                     bool need_next = false;
178:                     size_t nlen;
179:                     uint32_t left = max_samples;
180:                     int extra_length;
181:                     long longval;
182:                     long tlval;
183:                     uint32_t n_samples;
184:                     char nbuf[8];
185:                     int nptr = 0;
186:                     int i;
187:                     if ((regs == NULL) || (psndptr == NULL)) return false; // Not continue.    
188:                     sndptr = *psndptr;
189:                     mmlptr = regs->mmlpos;
190:                     if (sndptr >= max_samples) return false;
9D0019CC  0262102B   SLTU V0, S3, V0
9D0019D0  10400202   BEQ V0, ZERO, 0x9D0021DC
9D0019D4  8E110004   LW S1, 4(S0)
191:                     if (mmlptr >= mml_len) return false;
9D0019D8  0232102B   SLTU V0, S1, S2
9D0019DC  104001FF   BEQ V0, ZERO, 0x9D0021DC
9D0019E0  3C06A000   LUI A2, -24576
192:                 
193:                     p = &(regs->mmlbase[mmlptr]);
9D0019E4  8CC27428   LW V0, 29736(A2)
9D0019E8  00511021   ADDU V0, V0, S1
194:                     head_char = *p;
9D0019EC  80460000   LB A2, 0(V0)
195:                 
196:                     if ((head_char >= 'A') && (head_char <= 'G')) {
9D0019F0  30C300FF   ANDI V1, A2, 255
9D0019F4  2464FFBF   ADDIU A0, V1, -65
9D0019F8  308400FF   ANDI A0, A0, 255
9D0019FC  2C840007   SLTIU A0, A0, 7
9D001A00  5080000D   BEQL A0, ZERO, render_mml
9D001A04  2463FF9F   ADDIU V1, V1, -97
197:                         basefreq = note_std_o4[head_char - 'A'];
9D001A08  24C5FFBF   ADDIU A1, A2, -65
9D001A0C  00052880   SLL A1, A1, 2
9D001A10  3C079D01   LUI A3, -25343
9D001A14  24E41AC4   ADDIU A0, A3, 6852
9D001A18  00A42021   ADDU A0, A1, A0
9D001A1C  8C840000   LW A0, 0(A0)
9D001A20  AFA40048   SW A0, 72(SP)
198:                         need_next = true;
199:                         b_note = true;
9D001A2C  24090001   ADDIU T1, ZERO, 1
9D001A30  0B40086A   J 0x9D0021A8
9D001A34  AFA90040   SW T1, 64(SP)
200:                         note = head_char - 'A' + 'a';
9D001A24  24630020   ADDIU V1, V1, 32
9D001A28  7C033420   SEB A2, V1
201:                     } else if ((head_char >= 'a') && (head_char <= 'g')) {
9D001A38  306300FF   ANDI V1, V1, 255
9D001A3C  2C630007   SLTIU V1, V1, 7
9D001A40  5060000B   BEQL V1, ZERO, render_mml
9D001A44  7C062944   INS A2, ZERO, 5, 1
202:                         basefreq = note_std_o4[head_char - 'a'];
9D001A48  24C4FF9F   ADDIU A0, A2, -97
9D001A4C  00042080   SLL A0, A0, 2
9D001A50  3C059D01   LUI A1, -25343
9D001A54  24A31AC4   ADDIU V1, A1, 6852
9D001A58  00831821   ADDU V1, A0, V1
9D001A5C  8C630000   LW V1, 0(V1)
9D001A60  AFA30048   SW V1, 72(SP)
203:                         need_next = true;
204:                         b_note = true;
9D001A64  24070001   ADDIU A3, ZERO, 1
9D001A68  0B40086A   J 0x9D0021A8
9D001A6C  AFA70040   SW A3, 64(SP)
205:                         note = head_char;
206:                     } else if ((head_char == 'R') || (head_char == 'r')) {
9D001A70  24030052   ADDIU V1, ZERO, 82
9D001A74  10C301C8   BEQ A2, V1, render_mml
9D001A78  24030056   ADDIU V1, ZERO, 86
207:                         need_next = true;
208:                         b_note = false;
9D002198  AFA00040   SW ZERO, 64(SP)
209:                         note = 0;
9D0021A4  00003021   ADDU A2, ZERO, ZERO
210:                     } else if ((head_char == 'V') || (head_char == 'v')) { // Volume
9D001A7C  14C30035   BNE A2, V1, render_mml
9D001A80  24030054   ADDIU V1, ZERO, 84
211:                         memset(nbuf, 0x00, sizeof (nbuf));
9D001A84  AFA0002C   SW ZERO, 44(SP)
212:                         nptr = 0;
213:                         mmlptr++;
9D001A88  26230001   ADDIU V1, S1, 1
214:                         p++;
215:                         for (; mmlptr < mml_len; mmlptr++, p++) {
9D001A8C  0072202B   SLTU A0, V1, S2
9D001A90  10800022   BEQ A0, ZERO, 0x9D001B1C
9D001A94  AFA00030   SW ZERO, 48(SP)
9D001AB4  26230002   ADDIU V1, S1, 2
9D001AB8  0072202B   SLTU A0, V1, S2
9D001ABC  50800018   BEQL A0, ZERO, render_mml
9D001AC0  00608821   ADDU S1, V1, ZERO
9D001ADC  26310003   ADDIU S1, S1, 3
9D001AE0  0232182B   SLTU V1, S1, S2
9D001AE4  1060000A   BEQ V1, ZERO, render_mml
9D001AE8  A3A4002D   SB A0, 45(SP)
9D001B04  02201821   ADDU V1, S1, ZERO
9D001B08  0B4006C8   J render_mml
9D001B0C  00608821   ADDU S1, V1, ZERO
9D001B10  02201821   ADDU V1, S1, ZERO
9D001B14  0B4006C8   J render_mml
9D001B18  00608821   ADDU S1, V1, ZERO
9D001B1C  00608821   ADDU S1, V1, ZERO
216:                             head_char = *p;
9D001A98  80440001   LB A0, 1(V0)
9D001AC4  80440002   LB A0, 2(V0)
9D001AEC  80420003   LB V0, 3(V0)
217:                             if ((*p >= '0') && (*p <= '9')) {
9D001A9C  2485FFD0   ADDIU A1, A0, -48
9D001AA0  30A500FF   ANDI A1, A1, 255
9D001AA4  2CA5000A   SLTIU A1, A1, 10
9D001AA8  50A0001D   BEQL A1, ZERO, render_mml
9D001AAC  00608821   ADDU S1, V1, ZERO
9D001AC8  2485FFD0   ADDIU A1, A0, -48
9D001ACC  30A500FF   ANDI A1, A1, 255
9D001AD0  2CA5000A   SLTIU A1, A1, 10
9D001AD4  50A00012   BEQL A1, ZERO, render_mml
9D001AD8  00608821   ADDU S1, V1, ZERO
9D001AF0  2443FFD0   ADDIU V1, V0, -48
9D001AF4  306300FF   ANDI V1, V1, 255
9D001AF8  2C63000A   SLTIU V1, V1, 10
9D001AFC  54600008   BNEL V1, ZERO, render_mml
9D001B00  A3A2002E   SB V0, 46(SP)
218:                                 nbuf[nptr] = head_char;
9D001AB0  A3A4002C   SB A0, 44(SP)
219:                                 nptr++;
220:                             } else {
221:                                 break;
222:                             }
223:                             if (nptr > 2) break;
224:                         }
225:                         nlen = strlen(nbuf);
226:                         longval = strtol(nbuf, NULL, 10);
9D001B20  27A4002C   ADDIU A0, SP, 44
9D001B24  00002821   ADDU A1, ZERO, ZERO
9D001B28  0F403020   JAL strtol
9D001B2C  2406000A   ADDIU A2, ZERO, 10
227:                         if ((longval >= 0) && (longval < 16)) {
9D001B30  2C430010   SLTIU V1, V0, 16
9D001B34  5060014A   BEQL V1, ZERO, 0x9D002060
9D001B38  AE110004   SW S1, 4(S0)
228:                             regs->regs.vol = sound_level_table[longval << 1];
9D0019A8  3C029D01   LUI V0, -25343
9D0019AC  24421AF0   ADDIU V0, V0, 6896
9D0019B0  AFA20054   SW V0, 84(SP)
9D001B3C  00021080   SLL V0, V0, 2
9D001B40  8FA90054   LW T1, 84(SP)
9D001B44  00491021   ADDU V0, V0, T1
9D001B48  94420000   LHU V0, 0(V0)
9D001B4C  0B400817   J 0x9D00205C
9D001B50  A6020030   SH V0, 48(S0)
229:                         }
230:                     } else if ((head_char == 'T') || (head_char == 't')) { //Tempo
9D001B54  14C30032   BNE A2, V1, render_mml
9D001B58  2403004C   ADDIU V1, ZERO, 76
231:                         memset(nbuf, 0x00, sizeof (nbuf));
9D001B5C  AFA0002C   SW ZERO, 44(SP)
9D001B60  AFA00030   SW ZERO, 48(SP)
232:                         nptr = 0;
233:                         mmlptr++;
9D001B64  26230001   ADDIU V1, S1, 1
9D001B94  0B4006F0   J 0x9D001BC0
9D001B98  00608821   ADDU S1, V1, ZERO
9D001BD8  0B4006F9   J 0x9D001BE4
9D001BDC  00608821   ADDU S1, V1, ZERO
9D001BE0  00608821   ADDU S1, V1, ZERO
234:                         p++;
235:                         for (; mmlptr < mml_len; mmlptr++, p++) {
9D001B68  0072282B   SLTU A1, V1, S2
9D001B6C  10A0001A   BEQ A1, ZERO, 0x9D001BD8
9D001B70  24440001   ADDIU A0, V0, 1
9D001BC0  26310001   ADDIU S1, S1, 1
9D001BC4  0232182B   SLTU V1, S1, S2
9D001BC8  1460FFF4   BNE V1, ZERO, render_mml
9D001BCC  24840001   ADDIU A0, A0, 1
236:                             head_char = *p;
9D001B74  80420001   LB V0, 1(V0)
9D001B9C  80830000   LB V1, 0(A0)
237:                             if ((head_char >= '0') && (head_char <= '9')) {
9D001B78  2445FFD0   ADDIU A1, V0, -48
9D001B7C  30A500FF   ANDI A1, A1, 255
9D001B80  2CA5000A   SLTIU A1, A1, 10
9D001B84  10A00016   BEQ A1, ZERO, render_mml
9D001B88  26250004   ADDIU A1, S1, 4
9D001BA0  2466FFD0   ADDIU A2, V1, -48
9D001BA4  30C600FF   ANDI A2, A2, 255
9D001BA8  2CC6000A   SLTIU A2, A2, 10
9D001BAC  50C0000E   BEQL A2, ZERO, 0x9D001BE8
9D001BB0  27A4002C   ADDIU A0, SP, 44
238:                                 nbuf[nptr] = head_char;
9D001B8C  A3A2002C   SB V0, 44(SP)
9D001B90  27A2002C   ADDIU V0, SP, 44
9D001BB4  A0430001   SB V1, 1(V0)
239:                                 nptr++;
240:                             } else {
241:                                 break;
242:                             }
243:                             if (nptr > 3) break;
9D001BB8  1225000A   BEQ S1, A1, 0x9D001BE4
9D001BBC  24420001   ADDIU V0, V0, 1
244:                         }
245:                         nlen = strlen(nbuf);
246:                         longval = strtol(nbuf, NULL, 10);
9D001BD0  0B4006FA   J 0x9D001BE8
9D001BD4  27A4002C   ADDIU A0, SP, 44
9D001BE4  27A4002C   ADDIU A0, SP, 44
9D001BE8  00002821   ADDU A1, ZERO, ZERO
9D001BEC  0F403020   JAL strtol
9D001BF0  2406000A   ADDIU A2, ZERO, 10
247:                         if ((longval >= 32) && (longval < 255)) {
9D001BF4  2443FFE0   ADDIU V1, V0, -32
9D001BF8  2C6300DF   SLTIU V1, V1, 223
9D001BFC  50600118   BEQL V1, ZERO, 0x9D002060
9D001C00  AE110004   SW S1, 4(S0)
248:                             regs->tempo = (60 * 16000 * 4) / longval;
9D001C04  3C03003A   LUI V1, 58
9D001C08  34639800   ORI V1, V1, -26624
9D001C0C  0062001A   DIV V1, V0
9D001C10  004001F4   TEQ V0, ZERO
9D001C14  00001012   MFLO V0
9D001C18  0B400817   J 0x9D00205C
9D001C1C  AE02000C   SW V0, 12(S0)
249:                         }
250:                     } else if ((head_char == 'L') || (head_char == 'l')) { // Length
9D001C20  14C3003D   BNE A2, V1, render_mml
9D001C24  2403004F   ADDIU V1, ZERO, 79
251:                         memset(nbuf, 0x00, sizeof (nbuf));
9D001C28  AFA0002C   SW ZERO, 44(SP)
9D001C2C  AFA00030   SW ZERO, 48(SP)
252:                         nptr = 0;
253:                         mmlptr++;
9D001C30  263E0001   ADDIU S8, S1, 1
254:                         p++;
9D001C34  24430001   ADDIU V1, V0, 1
9D001C38  AFA3003C   SW V1, 60(SP)
255:                         for (; mmlptr < mml_len; mmlptr++, p++) {
9D001C3C  03D2182B   SLTU V1, S8, S2
9D001C40  1060001B   BEQ V1, ZERO, 0x9D001CB0
9D001C44  00000000   NOP
9D001C98  27DE0001   ADDIU S8, S8, 1
9D001C9C  8FA5003C   LW A1, 60(SP)
9D001CA0  24A50001   ADDIU A1, A1, 1
9D001CA4  03D2182B   SLTU V1, S8, S2
9D001CA8  1460FFF1   BNE V1, ZERO, 0x9D001C70
9D001CAC  AFA5003C   SW A1, 60(SP)
256:                             head_char = *p;
9D001C48  80420001   LB V0, 1(V0)
9D001C70  8FA4003C   LW A0, 60(SP)
9D001C74  80830000   LB V1, 0(A0)
257:                             if ((head_char >= '0') && (head_char <= '9')) {
9D001C4C  2443FFD0   ADDIU V1, V0, -48
9D001C50  306300FF   ANDI V1, V1, 255
9D001C54  2C63000A   SLTIU V1, V1, 10
9D001C58  10600015   BEQ V1, ZERO, 0x9D001CB0
9D001C5C  00000000   NOP
9D001C78  2464FFD0   ADDIU A0, V1, -48
9D001C7C  308400FF   ANDI A0, A0, 255
9D001C80  2C84000A   SLTIU A0, A0, 10
9D001C84  1080000A   BEQ A0, ZERO, 0x9D001CB0
9D001C88  00000000   NOP
258:                                 nbuf[nptr] = head_char;
9D001C60  A3A2002C   SB V0, 44(SP)
9D001C64  27A2002C   ADDIU V0, SP, 44
9D001C68  0B400726   J 0x9D001C98
9D001C6C  26310005   ADDIU S1, S1, 5
9D001C8C  A0430001   SB V1, 1(V0)
259:                                 nptr++;
260:                             } else {
261:                                 break;
262:                             }
263:                             if (nptr > 4) break;
9D001C90  13D10007   BEQ S8, S1, 0x9D001CB0
9D001C94  24420001   ADDIU V0, V0, 1
264:                         }
265:                         nlen = strlen(nbuf);
9D001CB0  0F403499   JAL strlen
9D001CB4  27A4002C   ADDIU A0, SP, 44
9D001CB8  00402821   ADDU A1, V0, ZERO
266:                         extra_length = 0;
267:                         do {
268:                             if (*p != '.') break;
9D001CBC  2404002E   ADDIU A0, ZERO, 46
9D001CC0  8FA6003C   LW A2, 60(SP)
9D001CC4  80C30000   LB V1, 0(A2)
9D001CC8  14640006   BNE V1, A0, 0x9D001CE4
9D001CCC  00000000   NOP
269:                             extra_length++;
270:                             p++;
9D001CD0  24C60001   ADDIU A2, A2, 1
271:                             mmlptr++;
9D001CD4  27DE0001   ADDIU S8, S8, 1
272:                         } while (mmlptr < mml_len);
9D001CD8  03D2182B   SLTU V1, S8, S2
9D001CDC  1460FFF8   BNE V1, ZERO, 0x9D001CC0
9D001CE0  AFA6003C   SW A2, 60(SP)
273:                         longval = 4;
9D001D04  24030004   ADDIU V1, ZERO, 4
9D001D08  0064100A   MOVZ V0, V1, A0
274:                         if (nlen > 0) {
9D001CE4  10A00009   BEQ A1, ZERO, 0x9D001D0C
9D001CE8  24020004   ADDIU V0, ZERO, 4
275:                             tlval = strtol(nbuf, NULL, 10);
9D001CEC  27A4002C   ADDIU A0, SP, 44
9D001CF0  00002821   ADDU A1, ZERO, ZERO
9D001CF4  0F403020   JAL strtol
9D001CF8  2406000A   ADDIU A2, ZERO, 10
276:                             if ((tlval > 0) && (tlval <= 64)) {
9D001CFC  2444FFFF   ADDIU A0, V0, -1
9D001D00  2C840040   SLTIU A0, A0, 64
277:                                 longval = tlval;
278:                             }
279:                         }
280:                 
281:                         regs->sound_length = longval;
9D001D0C  AE020014   SW V0, 20(S0)
9D001D10  0B400817   J 0x9D00205C
9D001D14  03C08821   ADDU S1, S8, ZERO
282:                     } else if ((head_char == 'O') || (head_char == 'o')) { //Octave
9D001D18  54C300D1   BNEL A2, V1, 0x9D002060
9D001D1C  AE110004   SW S1, 4(S0)
283:                         memset(nbuf, 0x00, sizeof (nbuf));
9D001D20  AFA0002C   SW ZERO, 44(SP)
284:                         nptr = 0;
285:                         mmlptr++;
9D001D24  263E0001   ADDIU S8, S1, 1
286:                         p++;
287:                         for (; mmlptr < mml_len; mmlptr++, p++) {
9D001D28  03D2182B   SLTU V1, S8, S2
9D001D2C  1060001D   BEQ V1, ZERO, 0x9D001DA4
9D001D30  AFA00030   SW ZERO, 48(SP)
9D001D50  263E0002   ADDIU S8, S1, 2
9D001D54  03D2182B   SLTU V1, S8, S2
9D001D58  10600014   BEQ V1, ZERO, 0x9D001DAC
9D001D5C  00002821   ADDU A1, ZERO, ZERO
9D001D7C  263E0003   ADDIU S8, S1, 3
9D001D80  03D2182B   SLTU V1, S8, S2
9D001D84  10600009   BEQ V1, ZERO, 0x9D001DAC
9D001D88  00000000   NOP
288:                             head_char = *p;
9D001D34  80430001   LB V1, 1(V0)
9D001D60  80430002   LB V1, 2(V0)
9D001D8C  80420003   LB V0, 3(V0)
289:                             if ((head_char >= '0') && (head_char <= '9')) {
9D001D38  2464FFD0   ADDIU A0, V1, -48
9D001D3C  308400FF   ANDI A0, A0, 255
9D001D40  2C84000A   SLTIU A0, A0, 10
9D001D44  10800018   BEQ A0, ZERO, 0x9D001DA8
9D001D48  27A4002C   ADDIU A0, SP, 44
9D001D64  2464FFD0   ADDIU A0, V1, -48
9D001D68  308400FF   ANDI A0, A0, 255
9D001D6C  2C84000A   SLTIU A0, A0, 10
9D001D70  1080000E   BEQ A0, ZERO, 0x9D001DAC
9D001D74  27A4002C   ADDIU A0, SP, 44
9D001D90  2443FFD0   ADDIU V1, V0, -48
9D001D94  306300FF   ANDI V1, V1, 255
9D001D98  2C63000A   SLTIU V1, V1, 10
9D001D9C  54600002   BNEL V1, ZERO, 0x9D001DA8
9D001DA0  A3A2002E   SB V0, 46(SP)
290:                                 nbuf[nptr++] = head_char;
9D001D4C  A3A3002C   SB V1, 44(SP)
9D001D78  A3A3002D   SB V1, 45(SP)
291:                             } else {
292:                                 break;
293:                             }
294:                             if (nptr > 2) break;
295:                         }
296:                         nlen = strlen(nbuf);
297:                         longval = strtol(nbuf, NULL, 10);
9D001DA4  27A4002C   ADDIU A0, SP, 44
9D001DA8  00002821   ADDU A1, ZERO, ZERO
9D001DAC  0F403020   JAL strtol
9D001DB0  2406000A   ADDIU A2, ZERO, 10
298:                         if ((longval >= 1) && (longval < 12)) {
9D001DB4  2443FFFF   ADDIU V1, V0, -1
9D001DB8  2C63000B   SLTIU V1, V1, 11
9D001DBC  106000A7   BEQ V1, ZERO, 0x9D00205C
9D001DC0  03C08821   ADDU S1, S8, ZERO
299:                             regs->octave = longval;
9D001DC4  0B400817   J 0x9D00205C
9D001DC8  AE020010   SW V0, 16(S0)
300:                         }
301:                     }
302:                 
303:                     if (need_next) {
304:                         loopval = true;
305:                         do {
306:                             mmlptr++;
9D001DCC  26310001   ADDIU S1, S1, 1
307:                             p++;
308:                             if (mmlptr >= mml_len) break;
9D001DD0  0232182B   SLTU V1, S1, S2
9D001DD4  106000FD   BEQ V1, ZERO, render_mml
9D001DD8  24420001   ADDIU V0, V0, 1
309:                             head_char = *p;
9D001DDC  80430000   LB V1, 0(V0)
310:                             if ((head_char >= 'A') && (head_char <= 'G')) break; // Next
9D001DE0  2409FFDF   ADDIU T1, ZERO, -33
9D001DE4  00692024   AND A0, V1, T1
9D001DE8  2484FFBF   ADDIU A0, A0, -65
9D001DEC  308400FF   ANDI A0, A0, 255
9D001DF0  2C840007   SLTIU A0, A0, 7
9D001DF4  548000F0   BNEL A0, ZERO, render_mml
9D001DF8  AFA0002C   SW ZERO, 44(SP)
311:                             if ((head_char >= 'a') && (head_char <= 'g')) break; // Next
312:                             switch (head_char) {
9D001DFC  50650006   BEQL V1, A1, 0x9D001E18
9D001E00  8FA30040   LW V1, 64(SP)
9D001E04  50670013   BEQL V1, A3, render_mml
9D001E08  8FA90040   LW T1, 64(SP)
9D001E0C  546800EA   BNEL V1, T0, render_mml
9D001E10  AFA0002C   SW ZERO, 44(SP)
9D0021A8  2405002B   ADDIU A1, ZERO, 43
9D0021AC  2407002D   ADDIU A3, ZERO, 45
9D0021B0  0B400773   J render_mml
9D0021B4  24080023   ADDIU T0, ZERO, 35
313:                             case '#':
314:                             case '+':
315:                                 if ((b_note) && (note >= 'a') && (note <= 'g')) {
9D001E14  8FA30040   LW V1, 64(SP)
9D001E18  5060FFED   BEQL V1, ZERO, 0x9D001DD0
9D001E1C  26310001   ADDIU S1, S1, 1
9D001E20  24C3FF9F   ADDIU V1, A2, -97
9D001E24  306300FF   ANDI V1, V1, 255
9D001E28  2C630007   SLTIU V1, V1, 7
9D001E2C  5060FFE8   BEQL V1, ZERO, 0x9D001DD0
9D001E30  26310001   ADDIU S1, S1, 1
316:                                     basefreq = note_upper_o4[note - 'a'];
9D001994  24421AA8   ADDIU V0, V0, 6824
9D001998  AFA2004C   SW V0, 76(SP)
9D001E34  24C3FF9F   ADDIU V1, A2, -97
9D001E38  00031880   SLL V1, V1, 2
9D001E3C  8FA4004C   LW A0, 76(SP)
9D001E40  00641821   ADDU V1, V1, A0
9D001E44  8C630000   LW V1, 0(V1)
9D001E48  AFA30048   SW V1, 72(SP)
317:                                     note = 0;
9D001E4C  0B400773   J render_mml
9D001E50  00003021   ADDU A2, ZERO, ZERO
318:                                 }
319:                                 break;
320:                             case '-':
321:                                 if ((b_note) && (note >= 'a') && (note <= 'g')) {
9D001E54  5120FFDE   BEQL T1, ZERO, 0x9D001DD0
9D001E58  26310001   ADDIU S1, S1, 1
9D001E5C  24C3FF9F   ADDIU V1, A2, -97
9D001E60  306300FF   ANDI V1, V1, 255
9D001E64  2C630007   SLTIU V1, V1, 7
9D001E68  5060FFD9   BEQL V1, ZERO, 0x9D001DD0
9D001E6C  26310001   ADDIU S1, S1, 1
322:                                     basefreq = note_lower_o4[note - 'a'];
9D00199C  3C029D01   LUI V0, -25343
9D0019A0  24421A8C   ADDIU V0, V0, 6796
9D0019A4  AFA20050   SW V0, 80(SP)
9D001E70  24C3FF9F   ADDIU V1, A2, -97
9D001E74  00031880   SLL V1, V1, 2
9D001E78  8FA40050   LW A0, 80(SP)
9D001E7C  00641821   ADDU V1, V1, A0
9D001E80  8C630000   LW V1, 0(V1)
9D001E84  AFA30048   SW V1, 72(SP)
323:                                     note = 0;
9D001E88  0B400773   J render_mml
9D001E8C  00003021   ADDU A2, ZERO, ZERO
324:                                 }
325:                                 break;
326:                                 //case '.':
327:                                 //    extra_length++;
328:                                 //    break;
329:                             default:
330:                                 loopval = false;
331:                                 break;
332:                             }
333:                         } while (loopval);
334:                         // Check length
335:                         extra_length = 0;
9D0021BC  0000F021   ADDU S8, ZERO, ZERO
9D0021D4  0B4007B8   J 0x9D001EE0
9D0021D8  0000F021   ADDU S8, ZERO, ZERO
336:                         nptr = 0;
9D0021C0  00002021   ADDU A0, ZERO, ZERO
337:                         memset(nbuf, 0x00, sizeof (nbuf));
9D0021B8  AFA00030   SW ZERO, 48(SP)
9D0021CC  AFA0002C   SW ZERO, 44(SP)
9D0021D0  AFA00030   SW ZERO, 48(SP)
338:                         for (; mmlptr < mml_len; mmlptr++, p++) {
9D001ED0  26310001   ADDIU S1, S1, 1
9D001ED4  0232182B   SLTU V1, S1, S2
9D001ED8  1460FFED   BNE V1, ZERO, render_mml
9D001EDC  24420001   ADDIU V0, V0, 1
339:                             head_char = *p;
9D001E90  80430000   LB V1, 0(V0)
340:                             if ((head_char >= '0') && (head_char <= '9')) {
9D001E94  2465FFD0   ADDIU A1, V1, -48
9D001E98  30A500FF   ANDI A1, A1, 255
9D001E9C  2CA5000A   SLTIU A1, A1, 10
9D001EA0  10A00005   BEQ A1, ZERO, render_mml
9D001EA4  27A70018   ADDIU A3, SP, 24
341:                                 nbuf[nptr] = head_char;
9D001EA8  00E42821   ADDU A1, A3, A0
9D001EAC  A0A30014   SB V1, 20(A1)
342:                                 nptr++;
9D001EB0  0B4007B1   J 0x9D001EC4
9D001EB4  24840001   ADDIU A0, A0, 1
343:                             } else if (head_char == '.') {
9D001EB8  14660009   BNE V1, A2, 0x9D001EE0
9D001EBC  00000000   NOP
9D0021C4  0B4007A4   J render_mml
9D0021C8  2406002E   ADDIU A2, ZERO, 46
344:                                 extra_length++;
9D001EC0  27DE0001   ADDIU S8, S8, 1
345:                             } else {
346:                                 break;
347:                             }
348:                             if (nptr >= 6) break; // Force exit
9D001EC4  28830006   SLTI V1, A0, 6
9D001EC8  10600005   BEQ V1, ZERO, 0x9D001EE0
9D001ECC  00000000   NOP
349:                         }
350:                         nlen = strlen(nbuf);
9D001EE0  0F403499   JAL strlen
9D001EE4  27A4002C   ADDIU A0, SP, 44
351:                         longval = regs->sound_length * 16;
9D001EF0  0B4007C6   J 0x9D001F18
9D001EF4  00031100   SLL V0, V1, 4
352:                         if (nlen > 0) {
9D001EE8  14400003   BNE V0, ZERO, render_mml
9D001EEC  8E030014   LW V1, 20(S0)
353:                             longval = strtol(nbuf, NULL, 10);
9D001EF8  27A4002C   ADDIU A0, SP, 44
9D001EFC  00002821   ADDU A1, ZERO, ZERO
9D001F00  0F403020   JAL strtol
9D001F04  2406000A   ADDIU A2, ZERO, 10
354:                             if ((longval > 0) && (longval <= 64)) {
9D001F08  2444FFFF   ADDIU A0, V0, -1
9D001F0C  2C840040   SLTIU A0, A0, 64
355:                                 longval = longval * 16;
9D001F10  00021900   SLL V1, V0, 4
9D001F14  0064100B   MOVN V0, V1, A0
356:                             }
357:                         }
358:                         for (i = 0; i < extra_length; i++) {
9D001F18  1BC0000A   BLEZ S8, 0x9D001F44
9D001F1C  00001821   ADDU V1, ZERO, ZERO
9D001F38  24630001   ADDIU V1, V1, 1
9D001F3C  147EFFFA   BNE V1, S8, 0x9D001F28
9D001F40  00821023   SUBU V0, A0, V0
359:                             longval = (longval * 2) / 3;
9D001F20  3C055555   LUI A1, 21845
9D001F24  24A55556   ADDIU A1, A1, 21846
9D001F28  00021040   SLL V0, V0, 1
9D001F2C  00450018   MULT 0, V0, A1
9D001F30  00002010   MFHI A0
9D001F34  000217C3   SRA V0, V0, 31
360:                         }
361:                         if (b_note) {
9D001F44  8FA30040   LW V1, 64(SP)
9D001F48  50600011   BEQL V1, ZERO, render_mml
9D001F4C  AE00001C   SW ZERO, 28(S0)
362:                             regs->tmp_sound_length = regs->tempo / (longval / 16);
9D001F50  2443000F   ADDIU V1, V0, 15
9D001F54  28440000   SLTI A0, V0, 0
9D001F58  0064100B   MOVN V0, V1, A0
9D001F5C  00021103   SRA V0, V0, 4
9D001F60  8E03000C   LW V1, 12(S0)
9D001F64  0062001B   DIVU V1, V0
9D001F68  004001F4   TEQ V0, ZERO
9D001F6C  00001012   MFLO V0
9D001F70  AE02001C   SW V0, 28(S0)
363:                             regs->stop_length = 0;
9D001F74  AE000018   SW ZERO, 24(S0)
364:                         } else {
365:                             regs->tmp_sound_length = 0;
366:                             regs->stop_length = regs->tempo / (longval / 16);
9D001F90  2443000F   ADDIU V1, V0, 15
9D001F94  28440000   SLTI A0, V0, 0
9D001F98  0064100B   MOVN V0, V1, A0
9D001F9C  00021103   SRA V0, V0, 4
9D001FA0  8E03000C   LW V1, 12(S0)
9D001FA4  0062001B   DIVU V1, V0
9D001FA8  004001F4   TEQ V0, ZERO
9D001FAC  00001012   MFLO V0
367:                         }
368:                         // Calc Frequency
369:                         if (b_note) {
370:                             if (regs->octave < 4) {
9D001F78  8E020010   LW V0, 16(S0)
9D001F7C  2C430004   SLTIU V1, V0, 4
9D001F80  5460000D   BNEL V1, ZERO, render_mml
9D001F84  24030004   ADDIU V1, ZERO, 4
371:                                 basefreq = basefreq >> (4 - regs->octave);
9D001FB8  00621023   SUBU V0, V1, V0
9D001FBC  8FA40048   LW A0, 72(SP)
9D001FC0  00441806   SRLV V1, A0, V0
372:                                 basefreq = basefreq / 1000;
9D001FC4  3C021062   LUI V0, 4194
9D001FC8  24424DD3   ADDIU V0, V0, 19923
9D001FCC  00620019   MULTU 0, V1, V0
9D001FD0  00001010   MFHI V0
9D001FD4  0B400807   J 0x9D00201C
9D001FD8  00021182   SRL V0, V0, 6
373:                             } else if (regs->octave > 4) {
9D001F88  0B4007F7   J render_mml
9D001F8C  2C430005   SLTIU V1, V0, 5
9D001FDC  5460000A   BNEL V1, ZERO, render_mml
9D001FE0  3C021062   LUI V0, 4194
374:                                 basefreq = basefreq << (regs->octave - 4);
9D001FE4  2442FFFC   ADDIU V0, V0, -4
9D001FE8  8FA40048   LW A0, 72(SP)
9D001FEC  00441804   SLLV V1, A0, V0
375:                                 basefreq = basefreq / 1000;
9D001FF0  3C021062   LUI V0, 4194
9D001FF4  24424DD3   ADDIU V0, V0, 19923
9D001FF8  00620019   MULTU 0, V1, V0
9D001FFC  00001010   MFHI V0
9D002000  0B400807   J 0x9D00201C
9D002004  00021182   SRL V0, V0, 6
376:                             } else {
377:                                 basefreq = basefreq / 1000;
9D002008  24424DD3   ADDIU V0, V0, 19923
9D00200C  8FA30048   LW V1, 72(SP)
9D002010  00620019   MULTU 0, V1, V0
9D002014  00001010   MFHI V0
9D002018  00021182   SRL V0, V0, 6
378:                             }
379:                             regs->regs.freq = basefreq;
9D00201C  AE020020   SW V0, 32(S0)
380:                             // Do Sound
381:                             if (regs->tmp_sound_length > left) {
9D002020  8E02001C   LW V0, 28(S0)
9D002024  8FA4003C   LW A0, 60(SP)
9D002028  0044F02B   SLTU S8, V0, A0
9D00202C  005E200B   MOVN A0, V0, S8
9D002030  0080F021   ADDU S8, A0, ZERO
382:                                 n_samples = left;
383:                                 left = 0;
384:                             } else {
385:                                 n_samples = regs->tmp_sound_length;
386:                                 left -= regs->tmp_sound_length;
387:                             }
388:                             sndptr += render_op(&(head_data[sndptr]), regs, n_samples);
9D002038  8FA50038   LW A1, 56(SP)
9D00203C  00A42021   ADDU A0, A1, A0
9D002040  02002821   ADDU A1, S0, ZERO
9D002044  0F40493C   JAL render_op
9D002048  03C03021   ADDU A2, S8, ZERO
9D00204C  02629821   ADDU S3, S3, V0
389:                             regs->tmp_sound_length -= n_samples;
9D002050  8E02001C   LW V0, 28(S0)
9D002054  005EF023   SUBU S8, V0, S8
9D002058  AE1E001C   SW S8, 28(S0)
390:                         } else {
391:                             sndptr += n_samples;
392:                             regs->stop_length -= n_samples;
9D001FB0  0B400817   J 0x9D00205C
9D001FB4  AE020018   SW V0, 24(S0)
393:                         }
394:                     }
395:                     *psndptr = sndptr;
396:                     regs->mmlpos = mmlptr;
9D00205C  AE110004   SW S1, 4(S0)
397:                     return true;
398:                 }
399:                 
400:                 static uint32_t render_mml(int16_t *head_data, SOUND_MML_T *regs, uint32_t max_samples)
401:                 {
402:                     uint32_t left = max_samples;
403:                     uint32_t p_samples = 0;
404:                     size_t mmllen;
405:                     uint32_t mmlpos;
406:                     int i, j;
407:                     char *p;
408:                     char note = 0x00;
409:                     if (head_data == NULL) return 0;
410:                     if (regs == NULL) return max_samples;
411:                     if (regs->mmlbase == NULL) return max_samples;
9D00189C  3C03A000   LUI V1, -24576
9D0018A0  8C627428   LW V0, 29736(V1)
9D0018A4  1040024D   BEQ V0, ZERO, 0x9D0021DC
9D0018A8  00000000   NOP
412:                     if (regs->is_end) return 0;
9D0018AC  9202000A   LBU V0, 10(S0)
9D0018B0  14400250   BNE V0, ZERO, 0x9D0021F4
9D0018B4  00000000   NOP
413:                 
414:                     if (!pre_render(&(head_data[p_samples]), regs, &p_samples, &left, max_samples)) {
9D001910  8FA40044   LW A0, 68(SP)
9D001914  1480000B   BNE A0, ZERO, render_mml
9D001918  92020009   LBU V0, 9(S0)
415:                         if (regs->is_eof) { // EOF and END
9D00191C  104001DE   BEQ V0, ZERO, 0x9D002098
9D001920  00000000   NOP
416:                             if ((regs->tmp_sound_length == 0) && (regs->stop_length == 0)) {
9D001924  8E02001C   LW V0, 28(S0)
9D001928  144001DB   BNE V0, ZERO, 0x9D002098
9D00192C  00000000   NOP
9D001930  8E020018   LW V0, 24(S0)
9D001934  144001D8   BNE V0, ZERO, 0x9D002098
9D001938  24020001   ADDIU V0, ZERO, 1
417:                                 //memset(&(head_data[p_samples]), 0x00, max_samples * sizeof(int16_t));
418:                                 regs->is_end = true;
9D00193C  0B400826   J 0x9D002098
9D001940  A202000A   SB V0, 10(S0)
419:                             }
420:                         }
421:                         return p_samples;
422:                     }
423:                     if (regs->is_eof) { // EOF and END
9D001944  10400009   BEQ V0, ZERO, render_mml
9D001948  3C05A000   LUI A1, -24576
424:                         if ((regs->tmp_sound_length == 0) && (regs->stop_length == 0)) {
9D00194C  8E02001C   LW V0, 28(S0)
9D001950  14400006   BNE V0, ZERO, render_mml
9D001954  00000000   NOP
9D001958  8E020018   LW V0, 24(S0)
9D00195C  14400003   BNE V0, ZERO, render_mml
9D001960  24020001   ADDIU V0, ZERO, 1
425:                             //memset(&(head_data[p_samples]), 0x00, max_samples * sizeof(int16_t));
426:                             regs->is_end = true;
9D001964  0B400826   J 0x9D002098
9D001968  A202000A   SB V0, 10(S0)
427:                             return p_samples;
428:                         }
429:                     }
430:                 
431:                     mmllen = strlen(regs->mmlbase);
9D00196C  0F403499   JAL strlen
9D001970  8CA47428   LW A0, 29736(A1)
9D001974  00409021   ADDU S2, V0, ZERO
432:                     p = regs->mmlbase;
433:                     mmlpos = regs->mmlpos;
434:                     if (mmllen <= regs->mmlpos) {
9D001978  8E020004   LW V0, 4(S0)
9D00197C  0052102B   SLTU V0, V0, S2
9D001980  144001BF   BNE V0, ZERO, 0x9D002080
9D001984  2E620330   SLTIU V0, S3, 816
435:                         regs->is_eof = true;
9D001988  24020001   ADDIU V0, ZERO, 1
9D00198C  0B40081F   J render_mml
9D001990  A2020009   SB V0, 9(S0)
436:                         //return max_samples;
437:                     }
438:                 
439:                     while (p_samples < max_samples) {
9D00207C  2E620330   SLTIU V0, S3, 816
9D002080  1440FE44   BNE V0, ZERO, render_mml
9D002084  3C029D01   LUI V0, -25343
9D002088  0B400826   J 0x9D002098
9D00208C  00000000   NOP
9D002090  5440FE49   BNEL V0, ZERO, 0x9D0019B8
9D002094  92020009   LBU V0, 9(S0)
440:                         left = max_samples - p_samples;
9D0019C0  24020330   ADDIU V0, ZERO, 816
9D0019C4  00531023   SUBU V0, V0, S3
9D0019C8  AFA2003C   SW V0, 60(SP)
441:                         if (!(regs->is_eof)) {
9D0019B4  92020009   LBU V0, 9(S0)
9D0019B8  544001AA   BNEL V0, ZERO, 0x9D002064
9D0019BC  8E020004   LW V0, 4(S0)
442:                             if (!render_mml_core(&(head_data[p_samples]), regs, &p_samples, left, mmllen)) {
9D002034  00132080   SLL A0, S3, 2
443:                                 return max_samples;
444:                             }
445:                         }
446:                         mmlpos = regs->mmlpos;
447:                         if (mmlpos >= mmllen) {
9D002060  8E020004   LW V0, 4(S0)
9D002064  0052102B   SLTU V0, V0, S2
9D002068  14400009   BNE V0, ZERO, 0x9D002090
9D00206C  2E620330   SLTIU V0, S3, 816
448:                             regs->is_eof = true;
9D002070  24020001   ADDIU V0, ZERO, 1
9D002074  0B400826   J 0x9D002098
9D002078  A2020009   SB V0, 9(S0)
449:                             return p_samples;
450:                         }
451:                     }
452:                     return p_samples;
453:                 }
454:                 
455:                 static int s_count;
456:                 static uint32_t sound_rd_ptr;
457:                 static uint32_t sound_wr_ptr;
458:                 static int sound_data_length;
459:                 static bool sound_pending;
460:                 static int play_slot;
461:                 static int render_slot;
462:                 
463:                 static void add_sound(SYS_DMA_CHANNEL_HANDLE handle, uint32_t sp, uint32_t len)
464:                 {
465:                     static const uint32_t nlen = SOUND_LENGTH;
466:                     uint32_t sl = nlen - sp;
467:                     if (nlen <= sp) return;
9D0020B0  2E230640   SLTIU V1, S1, 1600
468:                     if (len > nlen) len = nlen;
469:                 #if 0
470:                     if (len > sl) {
471:                         SYS_DMA_ChannelTransferAdd(handle, (const void *) (&(sample_buffer[sp])), sl * sizeof (int16_t), (const void *) (&OC2RS), sizeof (int16_t), sizeof (int16_t));
472:                         SYS_DMA_ChannelTransferAdd(handle, (const void *) (&(sample_buffer[0])), (len - sl) * sizeof (int16_t), (const void *) (&OC2RS), sizeof (int16_t), sizeof (int16_t));
473:                     } else {
474:                         SYS_DMA_ChannelTransferAdd(handle, (const void *) (&(sample_buffer[sp])), len * sizeof (int16_t), (const void *) (&OC2RS), sizeof (int16_t), sizeof (int16_t));
475:                     }
476:                 #else
477:                     SYS_DMA_ChannelTransferAdd(handle, (const void *) (&(sample_buffer[sp])), len * sizeof (int16_t), (const void *) (&OC2RS), sizeof (int16_t), sizeof (int16_t));
9D0020CC  00112840   SLL A1, S1, 1
478:                 #endif
479:                     taskENTER_CRITICAL();
9D0020F0  0F405144   JAL vTaskEnterCritical
480:                     sp = sp + len;
481:                     if (sp >= nlen) sp = sp - nlen;
9D0020F8  2E230640   SLTIU V1, S1, 1600
482:                     sound_rd_ptr = sp;
9D002104  AF918054   SW S1, -32684(GP)
483:                     sound_data_length -= ((int) len);
9D002108  8F828050   LW V0, -32688(GP)
484:                     if (sound_data_length < 0) sound_data_length = 0;
485:                     taskEXIT_CRITICAL();
9D002118  0F404EA8   JAL vTaskExitCritical
486:                 }
487:                 
488:                 void sndDmaEventHandler(SYS_DMA_TRANSFER_EVENT event, SYS_DMA_CHANNEL_HANDLE handle, uintptr_t contextHandle)
489:                 {
9D014264  27BDFFE8   ADDIU SP, SP, -24
9D014268  AFBF0014   SW RA, 20(SP)
490:                     static const int nlen = SOUND_LENGTH;
491:                     int alen;
492:                     int dlen;
493:                     uint32_t dp;
494:                     switch (event) {
9D01425C  14800011   BNE A0, ZERO, 0x9D0142A4
9D014260  00000000   NOP
495:                     case SYS_DMA_TRANSFER_EVENT_COMPLETE:
496:                         taskENTER_CRITICAL();
9D01426C  0F405144   JAL vTaskEnterCritical
9D014270  00000000   NOP
497:                         dlen = sound_data_length;
498:                         dp = sound_rd_ptr;
499:                         alen = SOUND_LENGTH - sound_rd_ptr;
500:                         sound_data_length += (sizeof (sample_buffer) / (2 * sizeof (int16_t)));
9D014274  8F828050   LW V0, -32688(GP)
9D014278  24420330   ADDIU V0, V0, 816
9D014288  0B4050A5   J 0x9D014294
9D01428C  AF828050   SW V0, -32688(GP)
501:                         if (sound_data_length >= (sizeof (sample_buffer) / sizeof (int16_t))) {
9D01427C  2C430660   SLTIU V1, V0, 1632
9D014280  50600003   BEQL V1, ZERO, 0x9D014290
9D014284  24020660   ADDIU V0, ZERO, 1632
502:                             sound_data_length = sizeof (sample_buffer) / sizeof (int16_t);
9D014290  AF828050   SW V0, -32688(GP)
503:                         }
504:                         taskEXIT_CRITICAL();
9D014294  0F404EA8   JAL vTaskExitCritical
9D014298  00000000   NOP
505:                         //}
506:                         break;
507:                     default:
508:                         break;
509:                     }
510:                 }
9D01429C  8FBF0014   LW RA, 20(SP)
9D0142A0  27BD0018   ADDIU SP, SP, 24
9D0142A4  03E00008   JR RA
9D0142A8  00000000   NOP
511:                 
512:                 extern PCA9655_t ioexpander1_data;
513:                 
514:                 static void sound_stop(int *state, DRV_HANDLE *ptHandle, DRV_HANDLE *poHandle, SYS_DMA_CHANNEL_HANDLE *pdHandle)
515:                 {
9D00FC08  27BDFFD0   ADDIU SP, SP, -48
9D00FC0C  AFBF002C   SW RA, 44(SP)
9D00FC10  AFB60028   SW S6, 40(SP)
9D00FC14  AFB50024   SW S5, 36(SP)
9D00FC18  AFB40020   SW S4, 32(SP)
9D00FC1C  AFB3001C   SW S3, 28(SP)
9D00FC20  AFB20018   SW S2, 24(SP)
9D00FC24  AFB10014   SW S1, 20(SP)
9D00FC28  AFB00010   SW S0, 16(SP)
9D00FC2C  0080B021   ADDU S6, A0, ZERO
9D00FC30  00A09821   ADDU S3, A1, ZERO
9D00FC34  00C09021   ADDU S2, A2, ZERO
9D00FC38  00E0A021   ADDU S4, A3, ZERO
516:                     DRV_HANDLE tHandle = *ptHandle;
9D00FC3C  8CB10000   LW S1, 0(A1)
517:                     DRV_HANDLE oHandle = *poHandle;
9D00FC40  8CD50000   LW S5, 0(A2)
518:                     SYS_DMA_CHANNEL_HANDLE dHandle = *pdHandle;
519:                     //DMACONbits.ON = 0;
520:                     //DMACONbits.SUSPEND = 1;
521:                     //RPA1Rbits.RPA1R = 0b0000; // Sound OFF
522:                 
523:                     if (tHandle != DRV_HANDLE_INVALID) {
9D00FC44  2402FFFF   ADDIU V0, ZERO, -1
9D00FC48  12220006   BEQ S1, V0, 0x9D00FC64
9D00FC4C  8CF00000   LW S0, 0(A3)
524:                         DRV_TMR_Stop(tHandle);
9D00FC50  0F404F91   JAL DRV_TMR_Stop
9D00FC54  02202021   ADDU A0, S1, ZERO
525:                         DRV_TMR_Close(tHandle);
9D00FC58  0F404F4C   JAL DRV_TMR_Close
9D00FC5C  02202021   ADDU A0, S1, ZERO
526:                     }
527:                     if (oHandle != DRV_HANDLE_INVALID) {
9D00FC60  2402FFFF   ADDIU V0, ZERO, -1
9D00FC64  12A20004   BEQ S5, V0, 0x9D00FC78
9D00FC68  00000000   NOP
528:                         DRV_OC_Stop(oHandle);
9D00FC6C  0F4054BF   JAL DRV_OC_Stop
9D00FC70  02A02021   ADDU A0, S5, ZERO
529:                         DRV_OC_Close(oHandle);
530:                     }
531:                     if (dHandle != SYS_DMA_CHANNEL_HANDLE_INVALID) {
9D00FC74  2402FFFF   ADDIU V0, ZERO, -1
9D00FC78  12020014   BEQ S0, V0, 0x9D00FCCC
9D00FC7C  24020001   ADDIU V0, ZERO, 1
532:                         SYS_DMA_ChannelForceAbort(dHandle);
9D00FC80  0F405339   JAL SYS_DMA_ChannelForceAbort
9D00FC84  02002021   ADDU A0, S0, ZERO
533:                         SYS_DMA_ChannelDisable(dHandle);
9D00FC88  0F40532B   JAL SYS_DMA_ChannelDisable
9D00FC8C  02002021   ADDU A0, S0, ZERO
534:                         SYS_DMA_ChannelRelease(dHandle);
9D00FC90  0F403389   JAL SYS_DMA_ChannelRelease
9D00FC94  02002021   ADDU A0, S0, ZERO
535:                         SYS_PORTS_PinWrite(PORTS_ID_0, PORT_CHANNEL_B, 3, false); // Audio OFF
9D00FC98  00002021   ADDU A0, ZERO, ZERO
9D00FC9C  24050001   ADDIU A1, ZERO, 1
9D00FCA0  24060003   ADDIU A2, ZERO, 3
9D00FCA4  0F404EC0   JAL SYS_PORTS_PinWrite
9D00FCA8  00003821   ADDU A3, ZERO, ZERO
536:                         DRV_PCA9655_SetPort(&ioexpander1_data, 5, false); // FALSE
9D00FCAC  3C04A000   LUI A0, -24576
9D00FCB0  24840B68   ADDIU A0, A0, 2920
9D00FCB4  24050005   ADDIU A1, ZERO, 5
9D00FCB8  0F402FB9   JAL DRV_PCA9655_SetPort
9D00FCBC  00003021   ADDU A2, ZERO, ZERO
537:                         *pdHandle = SYS_DMA_CHANNEL_HANDLE_INVALID;
9D00FCC0  2402FFFF   ADDIU V0, ZERO, -1
9D00FCC4  AE820000   SW V0, 0(S4)
538:                     }
539:                     *state = C_SOUND_INIT;
9D00FCC8  24020001   ADDIU V0, ZERO, 1
9D00FCCC  AEC20000   SW V0, 0(S6)
540:                     *ptHandle = DRV_HANDLE_INVALID;
9D00FCD0  2402FFFF   ADDIU V0, ZERO, -1
9D00FCD4  AE620000   SW V0, 0(S3)
541:                     *poHandle = DRV_HANDLE_INVALID;
9D00FCD8  AE420000   SW V0, 0(S2)
542:                 
543:                 }
9D00FCDC  8FBF002C   LW RA, 44(SP)
9D00FCE0  8FB60028   LW S6, 40(SP)
9D00FCE4  8FB50024   LW S5, 36(SP)
9D00FCE8  8FB40020   LW S4, 32(SP)
9D00FCEC  8FB3001C   LW S3, 28(SP)
9D00FCF0  8FB20018   LW S2, 24(SP)
9D00FCF4  8FB10014   LW S1, 20(SP)
9D00FCF8  8FB00010   LW S0, 16(SP)
9D00FCFC  03E00008   JR RA
9D00FD00  27BD0030   ADDIU SP, SP, 48
544:                 
545:                 void prvSound(void *pvParameters)
546:                 {
9D001554  27BDFF80   ADDIU SP, SP, -128
9D001558  AFBF007C   SW RA, 124(SP)
9D00155C  AFBE0078   SW S8, 120(SP)
9D001560  AFB70074   SW S7, 116(SP)
9D001564  AFB60070   SW S6, 112(SP)
9D001568  AFB5006C   SW S5, 108(SP)
9D00156C  AFB40068   SW S4, 104(SP)
9D001570  AFB30064   SW S3, 100(SP)
9D001574  AFB20060   SW S2, 96(SP)
9D001578  AFB1005C   SW S1, 92(SP)
9D00157C  AFB00058   SW S0, 88(SP)
547:                     int CmdQueue;
548:                     int state = C_SOUND_STOP;
9D001580  AFA0001C   SW ZERO, 28(SP)
549:                     int16_t *p;
550:                     sndData_t dq;
551:                     int nlen;
552:                     uint32_t ptr;
553:                     bool onoff;
554:                     uint32_t rmod;
555:                     uint32_t rlen;
556:                     int i;
557:                     bool pending;
558:                     bool b_cont;
559:                 
560:                     play_slot = 0;
9D001584  AF808048   SW ZERO, -32696(GP)
561:                     render_slot = 1;
9D001588  24100001   ADDIU S0, ZERO, 1
562:                     taskENTER_CRITICAL();
9D00158C  0F405144   JAL vTaskEnterCritical
9D001590  AF908044   SW S0, -32700(GP)
563:                     s_count = 0;
9D001594  AF808058   SW ZERO, -32680(GP)
564:                     sound_rd_ptr = 0;
9D001598  AF808054   SW ZERO, -32684(GP)
565:                     sound_data_length = 0;
9D00159C  AF808050   SW ZERO, -32688(GP)
566:                     sound_pending = true;
567:                 
568:                     taskEXIT_CRITICAL();
9D0015A0  0F404EA8   JAL vTaskExitCritical
9D0015A4  A390804C   SB S0, -32692(GP)
569:                     p = sample_buffer;
570:                     DRV_HANDLE tHandle = DRV_HANDLE_INVALID;
9D0015A8  2402FFFF   ADDIU V0, ZERO, -1
9D0015AC  AFA20020   SW V0, 32(SP)
571:                     DRV_HANDLE oHandle = DRV_HANDLE_INVALID;
9D0015B0  AFA20024   SW V0, 36(SP)
572:                     SYS_DMA_CHANNEL_HANDLE dHandle = SYS_DMA_CHANNEL_HANDLE_INVALID;
9D0015B4  AFA20028   SW V0, 40(SP)
573:                 
574:                     //DRV_PCA9655_SetPort(&ioexpander1_data, 4, false); // Audio OFF: Must call from housekeeping at initialize.
575:                 
576:                     memset(sample_buffer, 0x00, sizeof (sample_buffer));
9D0015B8  3C04A000   LUI A0, -24576
9D0015BC  24841050   ADDIU A0, A0, 4176
9D0015C0  00002821   ADDU A1, ZERO, ZERO
9D0015C4  0F40464F   JAL memset
9D0015C8  24060CC0   ADDIU A2, ZERO, 3264
577:                     rmod = 0;
578:                     onoff = true;
579:                     nlen = SOUND_LENGTH;
580:                     state = C_SOUND_PLAY;
9D0015CC  24020003   ADDIU V0, ZERO, 3
9D0015D0  AFA2001C   SW V0, 28(SP)
581:                     //dHandle = SYS_DMA_ChannelAllocate(DMA_CHANNEL_0);
582:                     //rlen = render_sound(sample_buffer, nlen, 255, &rmod, &onoff);
583:                     while (1) {
584:                         // Wait Queue
585:                         CmdQueue = C_SOUND_INIT;
9D0015F4  24110001   ADDIU S1, ZERO, 1
9D0015F8  AFB10018   SW S1, 24(SP)
9D002164  0B40057E   J 0x9D0015F8
9D002168  24110001   ADDIU S1, ZERO, 1
9D002174  0B40057E   J 0x9D0015F8
9D002178  24110001   ADDIU S1, ZERO, 1
9D00217C  02001021   ADDU V0, S0, ZERO
9D002204  0B40057F   J 0x9D0015FC
586:                         if (xQueueReceive(xSoundCmdQueue, (void *) (&CmdQueue), 0) == pdPASS) {
9D0015FC  8F848154   LW A0, -32428(GP)
9D001600  27A50018   ADDIU A1, SP, 24
9D001604  00003021   ADDU A2, ZERO, ZERO
9D001608  0F401E81   JAL xQueueGenericReceive
9D00160C  00003821   ADDU A3, ZERO, ZERO
9D001610  1451007D   BNE V0, S1, 0x9D001808
9D001614  24020003   ADDIU V0, ZERO, 3
587:                             switch (CmdQueue) {
9D001618  8FA20018   LW V0, 24(SP)
9D00161C  24030002   ADDIU V1, ZERO, 2
9D001620  10430007   BEQ V0, V1, 0x9D001640
9D001624  24030004   ADDIU V1, ZERO, 4
9D001628  10430072   BEQ V0, V1, 0x9D0017F4
9D00162C  27A4001C   ADDIU A0, SP, 28
9D001630  14400075   BNE V0, ZERO, 0x9D001808
9D001634  24020003   ADDIU V0, ZERO, 3
588:                             case C_SOUND_START:
589:                                 DMACONbits.ON = 1;
9D0015D4  3C14BF88   LUI S4, -16504
9D001640  96823000   LHU V0, 12288(S4)
9D001644  24030001   ADDIU V1, ZERO, 1
9D001648  7C627BC4   INS V0, V1, 15, 1
9D00164C  A6823000   SH V0, 12288(S4)
590:                                 DMACONbits.SUSPEND = 0;
9D001650  96823000   LHU V0, 12288(S4)
9D001654  7C026304   INS V0, ZERO, 12, 1
9D001658  A6823000   SH V0, 12288(S4)
591:                                 RPA1Rbits.RPA1R = 0b0101; // Sound ON / OC2
9D00165C  3C02BF81   LUI V0, -16511
9D001660  9043FB04   LBU V1, -1276(V0)
9D001664  24040005   ADDIU A0, ZERO, 5
9D001668  7C831804   INS V1, A0, 0, 4
9D00166C  A043FB04   SB V1, -1276(V0)
592:                                 memset(sample_buffer, 0x00, sizeof (sample_buffer));
9D0015D8  3C17A000   LUI S7, -24576
9D0015DC  26F71050   ADDIU S7, S7, 4176
9D0015E0  3C02A000   LUI V0, -24576
9D0015E4  24507428   ADDIU S0, V0, 29736
9D0015E8  261600C0   ADDIU S6, S0, 192
9D001670  02E02021   ADDU A0, S7, ZERO
9D001674  00002821   ADDU A1, ZERO, ZERO
9D001678  0F40464F   JAL memset
9D00167C  24060CC0   ADDIU A2, ZERO, 3264
593:                                 dHandle = SYS_DMA_ChannelAllocate(DMA_CHANNEL_0);
9D001680  0F404EF0   JAL SYS_DMA_ChannelAllocate
9D001684  00002021   ADDU A0, ZERO, ZERO
9D001688  AFA20028   SW V0, 40(SP)
594:                                 tHandle = DRV_TMR_Open(DRV_TMR_INDEX_1, DRV_IO_INTENT_EXCLUSIVE);
9D00168C  24040001   ADDIU A0, ZERO, 1
9D001690  0F405569   JAL DRV_TMR_Open
9D001694  24050008   ADDIU A1, ZERO, 8
9D001698  AFA20020   SW V0, 32(SP)
595:                                 oHandle = DRV_OC_Open(DRV_OC_INDEX_0, DRV_IO_INTENT_READWRITE | DRV_IO_INTENT_EXCLUSIVE);
596:                                 if (tHandle != DRV_HANDLE_INVALID) {
9D00169C  2403FFFF   ADDIU V1, ZERO, -1
9D0016A0  1043000E   BEQ V0, V1, 0x9D0016DC
9D0016A4  AFA00024   SW ZERO, 36(SP)
597:                                     DRV_TMR_CounterClear(tHandle);
9D0016A8  0F404F7A   JAL DRV_TMR_CounterClear
9D0016AC  00402021   ADDU A0, V0, ZERO
598:                                     DRV_TMR_CounterValueSet(tHandle, 1000);
9D0016B0  8FA40020   LW A0, 32(SP)
9D0016B4  0F404F63   JAL DRV_TMR_CounterValueSet
9D0016B8  240503E8   ADDIU A1, ZERO, 1000
599:                                     DRV_TMR_Start(tHandle);
9D0016BC  0F404E2D   JAL DRV_TMR_Start
9D0016C0  8FA40020   LW A0, 32(SP)
600:                                 }
601:                                 if (oHandle != DRV_HANDLE_INVALID) {
9D0016C4  8FA40024   LW A0, 36(SP)
9D0016C8  2402FFFF   ADDIU V0, ZERO, -1
9D0016CC  5082000B   BEQL A0, V0, 0x9D0016FC
9D0016D0  8FA40028   LW A0, 40(SP)
9D0016D4  0B4005B8   J 0x9D0016E0
9D0016D8  00000000   NOP
9D0016DC  00002021   ADDU A0, ZERO, ZERO
602:                                     DRV_OC_PulseWidthSet(oHandle, 10);
9D0016E0  0F4054C9   JAL DRV_OC_PulseWidthSet
9D0016E4  2405000A   ADDIU A1, ZERO, 10
603:                                     DRV_OC_Start(DRV_OC_INDEX_0, DRV_IO_INTENT_READWRITE);
9D0016E8  00002021   ADDU A0, ZERO, ZERO
9D0016EC  0F4053E8   JAL DRV_OC_Start
9D0016F0  24050003   ADDIU A1, ZERO, 3
604:                                 }
605:                                 if (dHandle != SYS_DMA_CHANNEL_HANDLE_INVALID) {
9D0016F4  8FA40028   LW A0, 40(SP)
9D0016F8  2402FFFF   ADDIU V0, ZERO, -1
9D0016FC  508202A0   BEQL A0, V0, 0x9D002180
9D001700  02001021   ADDU V0, S0, ZERO
606:                                     SYS_DMA_ChannelTransferAdd(dHandle, (const void *) (sample_buffer), sizeof (sample_buffer), (const void *) (&OC2RS), sizeof (int16_t), sizeof (int16_t));
9D001704  24020002   ADDIU V0, ZERO, 2
9D001708  AFA20010   SW V0, 16(SP)
9D00170C  AFA20014   SW V0, 20(SP)
9D001710  02E02821   ADDU A1, S7, ZERO
9D001714  24060CC0   ADDIU A2, ZERO, 3264
9D001718  3C07BF80   LUI A3, -16512
9D00171C  0F4035A4   JAL SYS_DMA_ChannelTransferAdd
9D001720  24E73220   ADDIU A3, A3, 12832
607:                                     SYS_DMA_ChannelSetup(dHandle, SYS_DMA_CHANNEL_OP_MODE_BASIC, DMA_TRIGGER_TIMER_3);
9D001724  8FA40028   LW A0, 40(SP)
9D001728  24050001   ADDIU A1, ZERO, 1
9D00172C  0F4033E4   JAL SYS_DMA_ChannelSetup
9D001730  2406000E   ADDIU A2, ZERO, 14
608:                                     SYS_DMA_ChannelEnable(dHandle);
9D001734  0F40531D   JAL SYS_DMA_ChannelEnable
9D001738  8FA40028   LW A0, 40(SP)
609:                                     SYS_DMA_ChannelTransferEventHandlerSet(dHandle, (const SYS_DMA_CHANNEL_TRANSFER_EVENT_HANDLER) (&sndDmaEventHandler), 0);
9D00173C  8FA40028   LW A0, 40(SP)
9D001740  3C059D01   LUI A1, -25343
9D001744  24A5425C   ADDIU A1, A1, 16988
9D001748  0F405551   JAL SYS_DMA_ChannelTransferEventHandlerSet
9D00174C  00003021   ADDU A2, ZERO, ZERO
610:                                     //SYS_PORTS_PinWrite(PORTS_ID_0, PORT_CHANNEL_B, 3, true); // Audio ON
611:                                     DRV_PCA9655_SetPort(&ioexpander1_data, 5, true); // Audio ON
9D001750  3C04A000   LUI A0, -24576
9D001754  24840B68   ADDIU A0, A0, 2920
9D001758  24050005   ADDIU A1, ZERO, 5
9D00175C  0F402FB9   JAL DRV_PCA9655_SetPort
9D001760  24060001   ADDIU A2, ZERO, 1
612:                                     state = C_SOUND_PLAY;
9D001764  24020003   ADDIU V0, ZERO, 3
9D001768  0B40085F   J 0x9D00217C
9D00176C  AFA2001C   SW V0, 28(SP)
613:                                 }
614:                             {
615:                                 // INIT MML.
616:                                 for (i = 0; i < 3; i++) {
9D0017C4  5456FFEB   BNEL V0, S6, 0x9D001774
9D0017C8  A0400009   SB ZERO, 9(V0)
617:                                     mmldata[i].is_eof = false;
9D001770  A0400009   SB ZERO, 9(V0)
618:                                     mmldata[i].is_end = false;
9D001774  A040000A   SB ZERO, 10(V0)
619:                                     mmldata[i].mmlbase = test_mml1; // ToDo: Change this.
9D0015EC  3C159D01   LUI S5, -25343
9D0015F0  26B51AE0   ADDIU S5, S5, 6880
9D001778  AC550000   SW S5, 0(V0)
620:                                     mmldata[i].mmlpos = 0;
9D00177C  AC400004   SW ZERO, 4(V0)
621:                                     mmldata[i].sound_length = 4;
9D001780  AC430014   SW V1, 20(V0)
9D002180  24030004   ADDIU V1, ZERO, 4
622:                                     mmldata[i].tempo = (60 * 16000 * 4) / 64; // T=64 OK?
9D001784  AC47000C   SW A3, 12(V0)
9D002184  3407EA60   ORI A3, ZERO, -5536
623:                                     mmldata[i].octave = 4;
9D001788  AC430010   SW V1, 16(V0)
624:                                     mmldata[i].sound_stop = 0;
9D00178C  A0400008   SB ZERO, 8(V0)
625:                                     mmldata[i].tmp_sound_length = 4;
9D001790  AC43001C   SW V1, 28(V0)
626:                                     mmldata[i].regs.env_on = false;
9D001794  A0400037   SB ZERO, 55(V0)
627:                                     mmldata[i].regs.noise_on = false;
9D001798  A0400036   SB ZERO, 54(V0)
628:                                     mmldata[i].regs.freq = 440;
9D00179C  AC440020   SW A0, 32(V0)
9D002188  240401B8   ADDIU A0, ZERO, 440
629:                                     mmldata[i].regs.howlong = 0;
9D0017A0  AC400028   SW ZERO, 40(V0)
630:                                     mmldata[i].regs.vol = sound_level_table[30];
9D0017A4  A4460030   SH A2, 48(V0)
9D00218C  240600EB   ADDIU A2, ZERO, 235
631:                                     mmldata[i].regs.noise_freq = 440;
9D0017A8  AC44002C   SW A0, 44(V0)
632:                                     mmldata[i].regs.env_tmp_vol = 31;
9D0017AC  A4450032   SH A1, 50(V0)
9D002190  0B4005DC   J 0x9D001770
9D002194  2405001F   ADDIU A1, ZERO, 31
633:                                     mmldata[i].regs.env_pos = 0;
9D0017B0  A0400034   SB ZERO, 52(V0)
634:                                     mmldata[i].regs.env_type = 0;
9D0017B4  A0400035   SB ZERO, 53(V0)
635:                                     mmldata[i].regs.ponoff = false;
9D0017B8  A040003C   SB ZERO, 60(V0)
636:                                     mmldata[i].regs.rmod = 0;
9D0017BC  AC400038   SW ZERO, 56(V0)
9D0017C0  24420040   ADDIU V0, V0, 64
637:                                 }
638:                                 taskENTER_CRITICAL();
9D0017CC  0F405144   JAL vTaskEnterCritical
9D0017D0  00000000   NOP
639:                                 play_slot = 0;
9D0017D4  AF808048   SW ZERO, -32696(GP)
640:                                 render_slot = 1;
9D0017D8  24020001   ADDIU V0, ZERO, 1
9D0017DC  AF828044   SW V0, -32700(GP)
641:                                 sound_data_length = sizeof (sample_buffer) / sizeof (int16_t);
9D0017E0  24020660   ADDIU V0, ZERO, 1632
642:                                 taskEXIT_CRITICAL();
9D0017E4  0F404EA8   JAL vTaskExitCritical
9D0017E8  AF828050   SW V0, -32688(GP)
643:                             }
644:                                 break;
9D0017EC  0B400602   J 0x9D001808
9D0017F0  24020003   ADDIU V0, ZERO, 3
645:                             case C_SOUND_ABORT:
646:                             case C_SOUND_STOP:
647:                                 sound_stop(&state, &tHandle, &oHandle, &dHandle);
9D001638  0B4005FE   J 0x9D0017F8
9D00163C  27A50020   ADDIU A1, SP, 32
9D0017F4  27A50020   ADDIU A1, SP, 32
9D0017F8  27A60024   ADDIU A2, SP, 36
9D0017FC  0F403F02   JAL sound_stop
9D001800  27A70028   ADDIU A3, SP, 40
648:                                 break;
649:                             default:
650:                                 break;
651:                             }
652:                         }
653:                         if (state == C_SOUND_PLAY) {
9D001804  24020003   ADDIU V0, ZERO, 3
9D001808  8FA3001C   LW V1, 28(SP)
9D00180C  14620257   BNE V1, V0, 0x9D00216C
9D001810  2402FFFF   ADDIU V0, ZERO, -1
654:                             if (dHandle == SYS_DMA_CHANNEL_HANDLE_INVALID) {
9D001814  8FA30028   LW V1, 40(SP)
9D001818  14620005   BNE V1, V0, 0x9D001830
9D00181C  00000000   NOP
655:                                 vTaskDelay(cTick100ms);
9D001820  0F405001   JAL vTaskDelay
9D001824  8F8480F8   LW A0, -32520(GP)
9D001828  0B40057E   J 0x9D0015F8
9D00182C  24110001   ADDIU S1, ZERO, 1
656:                             } else {
657:                                 taskENTER_CRITICAL();
9D001830  0F405144   JAL vTaskEnterCritical
9D001834  00000000   NOP
658:                                 i = (int) sound_data_length;
659:                                 pending = sound_pending;
660:                                 taskEXIT_CRITICAL();
9D001838  0F404EA8   JAL vTaskExitCritical
9D00183C  00000000   NOP
661:                                 b_cont = mmldata[0].is_end; // ToDo
662:                                 //if(pending) {
663:                                 if (!b_cont) {
9D001840  9202000A   LBU V0, 10(S0)
9D001844  14400240   BNE V0, ZERO, 0x9D002148
9D001848  27A4001C   ADDIU A0, SP, 28
664:                                     int sl;
665:                                     taskENTER_CRITICAL();
9D00184C  0F405144   JAL vTaskEnterCritical
9D001850  00000000   NOP
666:                                     sl = sound_data_length;
667:                                     taskEXIT_CRITICAL();
9D001854  0F404EA8   JAL vTaskExitCritical
9D001858  8F918050   LW S1, -32688(GP)
668:                                     if (sl > 0) {
9D00185C  1A20FF65   BLEZ S1, 0x9D0015F4
9D001860  8F838044   LW V1, -32700(GP)
669:                                         s_count = (sizeof (sample_buffer) * render_slot) / (2 * sizeof (int16_t));
9D001864  00032180   SLL A0, V1, 6
9D001868  00031200   SLL V0, V1, 8
9D00186C  00441023   SUBU V0, V0, A0
9D001870  00021900   SLL V1, V0, 4
9D001874  00431021   ADDU V0, V0, V1
9D001878  00021082   SRL V0, V0, 2
9D00187C  AF828058   SW V0, -32680(GP)
670:                                         memset(&(sample_buffer[s_count]), 0x00, sizeof (sample_buffer) / 2);
9D001880  00021040   SLL V0, V0, 1
9D001884  02E21021   ADDU V0, S7, V0
9D001888  AFA20038   SW V0, 56(SP)
9D00188C  00402021   ADDU A0, V0, ZERO
9D001890  00002821   ADDU A1, ZERO, ZERO
9D001894  0F40464F   JAL memset
9D001898  24060660   ADDIU A2, ZERO, 1632
671:                                         rlen = render_mml(&(sample_buffer[s_count]), &(mmldata[0]), (sizeof (sample_buffer) / (2 * sizeof (int16_t))));
672:                                         uint32_t sp, sr;
673:                                         taskENTER_CRITICAL();
9D002098  0F405144   JAL vTaskEnterCritical
9D00209C  00000000   NOP
9D0021DC  0F405144   JAL vTaskEnterCritical
9D0021E0  00000000   NOP
9D0021F4  0F405144   JAL vTaskEnterCritical
9D0021F8  24110001   ADDIU S1, ZERO, 1
674:                                         sp = s_count;
675:                                         sr = rlen;
676:                                         taskEXIT_CRITICAL();
9D0020A0  0F404EA8   JAL vTaskExitCritical
9D0020A4  8F918058   LW S1, -32680(GP)
9D0021E4  0F404EA8   JAL vTaskExitCritical
9D0021E8  8F918058   LW S1, -32680(GP)
9D0021EC  0B40082C   J add_sound
9D0021F0  24020330   ADDIU V0, ZERO, 816
9D0021FC  0F404EA8   JAL vTaskExitCritical
9D002200  00000000   NOP
677:                                         if (rlen > 0) {
9D0020A8  1260FD52   BEQ S3, ZERO, 0x9D0015F4
9D0020AC  02601021   ADDU V0, S3, ZERO
678:                                             //sr = sr + rlen;
679:                                             //char sbuf[32];
680:                                             //snprintf(sbuf, 32, "THROW %d BYTES", rlen);
681:                                             //printLog(0, "DEBUG", sbuf, LOG_TYPE_MESSAGE, NULL, 0);
682:                                             if (sr > nlen) sr = nlen;
683:                                             add_sound(dHandle, sp, sr);
684:                                             taskENTER_CRITICAL();
9D002120  0F405144   JAL vTaskEnterCritical
9D002124  24110001   ADDIU S1, ZERO, 1
685:                                             sound_pending = false;
686:                                             taskEXIT_CRITICAL();
9D002128  0F404EA8   JAL vTaskExitCritical
9D00212C  A380804C   SB ZERO, -32692(GP)
687:                                             render_slot += 1;
9D002130  8F828044   LW V0, -32700(GP)
9D002134  24420001   ADDIU V0, V0, 1
9D00213C  0003100A   MOVZ V0, ZERO, V1
9D002140  0B40057E   J 0x9D0015F8
9D002144  AF828044   SW V0, -32700(GP)
688:                                             if (render_slot >= 2) render_slot = 0;
9D002138  28430002   SLTI V1, V0, 2
689:                                         }
690:                                     } else {
691:                                        // vTaskDelay(cTick100ms / 4);
692:                                     }
693:                                 } else {
694:                                     sound_stop(&state, &tHandle, &oHandle, &dHandle);
9D002148  27A50020   ADDIU A1, SP, 32
9D00214C  27A60024   ADDIU A2, SP, 36
9D002150  0F403F02   JAL sound_stop
9D002154  27A70028   ADDIU A3, SP, 40
695:                                     vTaskDelay(cTick100ms / 4);
9D002158  8F8480F8   LW A0, -32520(GP)
9D00215C  0F405001   JAL vTaskDelay
9D002160  00042082   SRL A0, A0, 2
696:                                 }
697:                             }
698:                         } else {
699:                             vTaskDelay(cTick100ms);
9D00216C  0F405001   JAL vTaskDelay
9D002170  8F8480F8   LW A0, -32520(GP)
9D002174  0B40057E   J 0x9D0015F8
9D002178  24110001   ADDIU S1, ZERO, 1
9D00217C  02001021   ADDU V0, S0, ZERO
9D002180  24030004   ADDIU V1, ZERO, 4
9D002184  3407EA60   ORI A3, ZERO, -5536
9D002188  240401B8   ADDIU A0, ZERO, 440
9D00218C  240600EB   ADDIU A2, ZERO, 235
9D002190  0B4005DC   J 0x9D001770
9D002194  2405001F   ADDIU A1, ZERO, 31
9D002198  AFA00040   SW ZERO, 64(SP)
9D00219C  24060001   ADDIU A2, ZERO, 1
9D0021A0  AFA60048   SW A2, 72(SP)
9D0021A4  00003021   ADDU A2, ZERO, ZERO
9D0021A8  2405002B   ADDIU A1, ZERO, 43
9D0021AC  2407002D   ADDIU A3, ZERO, 45
9D0021B0  0B400773   J render_mml
9D0021B4  24080023   ADDIU T0, ZERO, 35
9D0021B8  AFA00030   SW ZERO, 48(SP)
9D0021BC  0000F021   ADDU S8, ZERO, ZERO
9D0021C0  00002021   ADDU A0, ZERO, ZERO
9D0021C4  0B4007A4   J render_mml
9D0021C8  2406002E   ADDIU A2, ZERO, 46
9D0021CC  AFA0002C   SW ZERO, 44(SP)
9D0021D0  AFA00030   SW ZERO, 48(SP)
9D0021D4  0B4007B8   J 0x9D001EE0
9D0021D8  0000F021   ADDU S8, ZERO, ZERO
9D0021DC  0F405144   JAL vTaskEnterCritical
9D0021E0  00000000   NOP
9D0021E4  0F404EA8   JAL vTaskExitCritical
9D0021E8  8F918058   LW S1, -32680(GP)
9D0021EC  0B40082C   J add_sound
9D0021F0  24020330   ADDIU V0, ZERO, 816
9D0021F4  0F405144   JAL vTaskEnterCritical
9D0021F8  24110001   ADDIU S1, ZERO, 1
9D0021FC  0F404EA8   JAL vTaskExitCritical
9D002200  00000000   NOP
9D002204  0B40057F   J 0x9D0015FC
9D002208  AFB10018   SW S1, 24(SP)
700:                         }
701:                     }
702:                 
703:                 }
---  /home/whatisthis/src/DoorBell_PIC32/firmware/src/rtcc_app.c  ---------------------------------------
1:                   /*
2:                    * Manipulate RTCC .
3:                    * (C) 2017 Kyuma Ohta <whatisthis.sowhat _at_ gmail.com >
4:                    * This is part of "DoorBell_PIC32" . You must have MPLAB HARMONY to use this routines.
5:                    * License : Apache OSS License.
6:                    */
7:                   
8:                   #include <stddef.h>                     // Defines NULL
9:                   #include <stdbool.h>                    // Defines true
10:                  #include <stdlib.h>                     // Defines EXIT_FAILURE
11:                  #include "system/common/sys_module.h"
12:                  #include "doorbell.h"
13:                  
14:                  extern DOORBELL_DATA doorbellData;
15:                  
16:                  static inline uint32_t sanity_num(uint32_t a, uint32_t b)
17:                  {
18:                      a = a % b;
9D006ABC  3C08AAAA   LUI T0, -21846
9D006AC0  3508AAAB   ORI T0, T0, -21845
9D006AC4  00A80019   MULTU 0, A1, T0
9D006AC8  00003810   MFHI A3
9D006ACC  00073882   SRL A3, A3, 2
9D006AD0  00074840   SLL T1, A3, 1
9D006AD4  000710C0   SLL V0, A3, 3
9D006AD8  00491023   SUBU V0, V0, T1
9D006ADC  00A21023   SUBU V0, A1, V0
9D006AF0  3C07CCCC   LUI A3, -13108
9D006AF4  34E7CCCD   ORI A3, A3, -13107
9D006AF8  00670019   MULTU 0, V1, A3
9D006AFC  00001010   MFHI V0
9D006B00  000210C2   SRL V0, V0, 3
9D006B04  00022840   SLL A1, V0, 1
9D006B08  000210C0   SLL V0, V0, 3
9D006B0C  00A21021   ADDU V0, A1, V0
9D006B10  00621823   SUBU V1, V1, V0
9D006B20  00680019   MULTU 0, V1, T0
9D006B24  00004810   MFHI T1
9D006B28  00094882   SRL T1, T1, 2
9D006B2C  00095040   SLL T2, T1, 1
9D006B30  000928C0   SLL A1, T1, 3
9D006B34  00AA2823   SUBU A1, A1, T2
9D006B38  00652823   SUBU A1, V1, A1
9D006B4C  00470019   MULTU 0, V0, A3
9D006B50  00002810   MFHI A1
9D006B54  000528C2   SRL A1, A1, 3
9D006B58  00051840   SLL V1, A1, 1
9D006B5C  000528C0   SLL A1, A1, 3
9D006B60  00652821   ADDU A1, V1, A1
9D006B64  00451023   SUBU V0, V0, A1
9D006B70  00480019   MULTU 0, V0, T0
9D006B74  00004010   MFHI T0
9D006B78  00084042   SRL T0, T0, 1
9D006B7C  00081840   SLL V1, T0, 1
9D006B80  00684021   ADDU T0, V1, T0
9D006B84  00484023   SUBU T0, V0, T0
9D006B98  00870019   MULTU 0, A0, A3
9D006B9C  00001010   MFHI V0
9D006BA0  000210C2   SRL V0, V0, 3
9D006BA4  00022840   SLL A1, V0, 1
9D006BA8  000210C0   SLL V0, V0, 3
9D006BAC  00A21021   ADDU V0, A1, V0
9D006BB0  00821023   SUBU V0, A0, V0
19:                      return a;
20:                  }
21:                  
22:                  uint32_t rtcAlarmSet(uint32_t _nowtime, uint32_t _sec, bool do_random)
23:                  {
9D006A98  27BDFFD8   ADDIU SP, SP, -40
9D006A9C  AFBF0024   SW RA, 36(SP)
9D006AA0  AFB30020   SW S3, 32(SP)
9D006AA4  AFB2001C   SW S2, 28(SP)
9D006AA8  AFB10018   SW S1, 24(SP)
9D006AAC  AFB00014   SW S0, 20(SP)
9D006AB0  00A09821   ADDU S3, A1, ZERO
24:                      SYS_RTCC_BCD_TIME nexttime;
25:                      int s;
26:                      uint32_t nsec;
27:                      uint32_t nmin;
28:                      uint32_t nhour;
29:                      
30:                      uint32_t __sec;
31:                      uint32_t __min;
32:                      uint32_t __hour;
33:                     
34:                      __sec = (_nowtime >> 8) & 0xff;
9D006AB4  00041A02   SRL V1, A0, 8
35:                      __sec = sanity_num((__sec >> 4), 6) * 10 + sanity_num((__sec & 0x0f), 10);
9D006AB8  7C651900   EXT A1, V1, 4, 4
9D006AE0  00028840   SLL S1, V0, 1
9D006AE4  000210C0   SLL V0, V0, 3
9D006AE8  02228821   ADDU S1, S1, V0
9D006AEC  3063000F   ANDI V1, V1, 15
9D006B14  02238821   ADDU S1, S1, V1
36:                      __min = (_nowtime >> 16) & 0xff;
9D006B18  00041402   SRL V0, A0, 16
37:                      __min = sanity_num((__min >> 4), 6) * 10 + sanity_num((__min & 0x0f), 10);
9D006B1C  7C431900   EXT V1, V0, 4, 4
9D006B3C  00058040   SLL S0, A1, 1
9D006B40  000528C0   SLL A1, A1, 3
9D006B44  02058021   ADDU S0, S0, A1
9D006B48  3042000F   ANDI V0, V0, 15
9D006B68  02028021   ADDU S0, S0, V0
38:                      __hour = (_nowtime >> 24) & 0xff;
39:                      __hour = sanity_num((__hour >> 4), 3) * 10 + sanity_num((__hour & 0x0f), 10);
9D006B6C  00041702   SRL V0, A0, 28
9D006B88  00089040   SLL S2, T0, 1
9D006B8C  000840C0   SLL T0, T0, 3
9D006B90  02489021   ADDU S2, S2, T0
9D006B94  7C841E00   EXT A0, A0, 24, 4
9D006BB4  02429021   ADDU S2, S2, V0
40:                      if (do_random) {
9D006BB8  10C00004   BEQ A2, ZERO, 0x9D006BCC
9D006BBC  02601021   ADDU V0, S3, ZERO
41:                          int d = (int) SYS_RANDOM_PseudoGet();
9D006BC0  0F4055A0   JAL SYS_RANDOM_PseudoGet
9D006BC4  00000000   NOP
42:                          s = (int) _sec;
43:                          s = s + d;
9D006BC8  02621021   ADDU V0, S3, V0
44:                      } else {
45:                          s = _sec;
46:                      }
47:                      nsec = s % 60;
9D006BCC  3C038888   LUI V1, -30584
9D006BD0  34638889   ORI V1, V1, -30583
9D006BD4  00430018   MULT 0, V0, V1
9D006BD8  00003810   MFHI A3
9D006BDC  00E23821   ADDU A3, A3, V0
9D006BE0  00073943   SRA A3, A3, 5
9D006BE4  000247C3   SRA T0, V0, 31
9D006BE8  00E83023   SUBU A2, A3, T0
9D006BEC  00062880   SLL A1, A2, 2
9D006BF0  00063180   SLL A2, A2, 6
9D006BF4  00C53023   SUBU A2, A2, A1
9D006BF8  00463023   SUBU A2, V0, A2
48:                      nmin = (s / 60) % 60;
9D006BFC  00E83823   SUBU A3, A3, T0
9D006C00  00E30018   MULT 0, A3, V1
9D006C04  00001810   MFHI V1
9D006C08  00671821   ADDU V1, V1, A3
9D006C0C  00031943   SRA V1, V1, 5
9D006C10  000727C3   SRA A0, A3, 31
9D006C14  00641823   SUBU V1, V1, A0
9D006C18  00032080   SLL A0, V1, 2
9D006C1C  00031980   SLL V1, V1, 6
9D006C20  00641823   SUBU V1, V1, A0
9D006C24  00E31823   SUBU V1, A3, V1
49:                      nhour = s / 3600;
9D006C28  3C0591A2   LUI A1, -28254
9D006C2C  34A5B3C5   ORI A1, A1, -19515
9D006C30  00450018   MULT 0, V0, A1
9D006C34  00002810   MFHI A1
9D006C38  00A22821   ADDU A1, A1, V0
9D006C3C  00052AC3   SRA A1, A1, 11
50:                      
51:                      nsec = nsec + __sec;
9D006C40  02262021   ADDU A0, S1, A2
52:                      if(nsec >= 60) {
9D006C44  2C82003C   SLTIU V0, A0, 60
9D006C48  1440000B   BNE V0, ZERO, 0x9D006C78
9D006C4C  00A82823   SUBU A1, A1, T0
53:                          nmin += (nsec / 60);
9D006C50  3C028888   LUI V0, -30584
9D006C54  34428889   ORI V0, V0, -30583
9D006C58  00820019   MULTU 0, A0, V0
9D006C5C  00001010   MFHI V0
9D006C60  00021142   SRL V0, V0, 5
9D006C64  00621821   ADDU V1, V1, V0
54:                          nsec = nsec % 60;
9D006C68  00023080   SLL A2, V0, 2
9D006C6C  00021180   SLL V0, V0, 6
9D006C70  00461023   SUBU V0, V0, A2
9D006C74  00822023   SUBU A0, A0, V0
55:                      }
56:                      nmin = nmin + __min;
9D006C78  02031821   ADDU V1, S0, V1
57:                      if(nmin >= 60) {
9D006C7C  2C62003C   SLTIU V0, V1, 60
9D006C80  5440000C   BNEL V0, ZERO, 0x9D006CB4
9D006C84  02452821   ADDU A1, S2, A1
58:                          nhour += (nmin / 60);
9D006C88  3C028888   LUI V0, -30584
9D006C8C  34428889   ORI V0, V0, -30583
9D006C90  00620019   MULTU 0, V1, V0
9D006C94  00001010   MFHI V0
9D006C98  00021142   SRL V0, V0, 5
9D006C9C  00A22821   ADDU A1, A1, V0
59:                          nmin = nmin % 60;
9D006CA0  00023080   SLL A2, V0, 2
9D006CA4  00021180   SLL V0, V0, 6
9D006CA8  00461023   SUBU V0, V0, A2
9D006CAC  00621823   SUBU V1, V1, V0
60:                      }
61:                      nhour = nhour + __hour;
9D006CB0  02452821   ADDU A1, S2, A1
62:                      if(nhour >= 24) {
9D006CB4  2CA20018   SLTIU V0, A1, 24
9D006CB8  14400009   BNE V0, ZERO, 0x9D006CE0
9D006CBC  3C02AAAA   LUI V0, -21846
63:                          nhour = nhour % 24;
9D006CC0  3442AAAB   ORI V0, V0, -21845
9D006CC4  00A20019   MULTU 0, A1, V0
9D006CC8  00001010   MFHI V0
9D006CCC  00021102   SRL V0, V0, 4
9D006CD0  000230C0   SLL A2, V0, 3
9D006CD4  00021140   SLL V0, V0, 5
9D006CD8  00461023   SUBU V0, V0, A2
9D006CDC  00A22823   SUBU A1, A1, V0
64:                      }
65:                      
66:                      nexttime = 0;
67:                      nexttime = nexttime | (((nsec / 10) << 12) | (nsec % 10) << 8);
9D006CE0  3C06CCCC   LUI A2, -13108
9D006CE4  34C6CCCD   ORI A2, A2, -13107
9D006CE8  00860019   MULTU 0, A0, A2
9D006CEC  00001010   MFHI V0
9D006CF0  000210C2   SRL V0, V0, 3
9D006CF4  00028040   SLL S0, V0, 1
9D006CF8  000238C0   SLL A3, V0, 3
9D006CFC  02078021   ADDU S0, S0, A3
9D006D00  00908023   SUBU S0, A0, S0
9D006D04  00108200   SLL S0, S0, 8
9D006D08  00021300   SLL V0, V0, 12
9D006D4C  02048025   OR S0, S0, A0
68:                      nexttime = nexttime | (((nmin / 10) << 20) | (nmin % 10) << 16);
9D006D10  00660019   MULTU 0, V1, A2
9D006D14  00001010   MFHI V0
9D006D18  000210C2   SRL V0, V0, 3
9D006D1C  00023D00   SLL A3, V0, 20
9D006D20  02078025   OR S0, S0, A3
9D006D24  00022040   SLL A0, V0, 1
9D006D28  000210C0   SLL V0, V0, 3
9D006D2C  00821021   ADDU V0, A0, V0
9D006D30  00621823   SUBU V1, V1, V0
9D006D34  00031C00   SLL V1, V1, 16
9D006D38  02038025   OR S0, S0, V1
69:                      nexttime = nexttime | (((nhour / 10) << 28) | (nhour % 10) << 24);
9D006D0C  02028025   OR S0, S0, V0
9D006D3C  00A60019   MULTU 0, A1, A2
9D006D40  00003010   MFHI A2
9D006D44  000630C2   SRL A2, A2, 3
9D006D48  00062700   SLL A0, A2, 28
9D006D50  00061040   SLL V0, A2, 1
9D006D54  000630C0   SLL A2, A2, 3
9D006D58  00463021   ADDU A2, V0, A2
9D006D5C  00A62823   SUBU A1, A1, A2
9D006D60  00052E00   SLL A1, A1, 24
9D006D64  02058025   OR S0, S0, A1
70:                      SYS_RTCC_AlarmTimeSet(nexttime, true);
9D006D68  02002021   ADDU A0, S0, ZERO
9D006D6C  0F405579   JAL SYS_RTCC_AlarmTimeSet
9D006D70  24050001   ADDIU A1, ZERO, 1
71:                      return nexttime;
72:                  }
9D006D74  02001021   ADDU V0, S0, ZERO
9D006D78  8FBF0024   LW RA, 36(SP)
9D006D7C  8FB30020   LW S3, 32(SP)
9D006D80  8FB2001C   LW S2, 28(SP)
9D006D84  8FB10018   LW S1, 24(SP)
9D006D88  8FB00014   LW S0, 20(SP)
9D006D8C  03E00008   JR RA
9D006D90  27BD0028   ADDIU SP, SP, 40
73:                  
74:                  extern TaskHandle_t xHandleHouseKeeping;
75:                  
76:                  void wakeupTimerCallback(SYS_RTCC_ALARM_HANDLE handle, uintptr_t context)
77:                  {
78:                  //    rtcAlarmSet(ALARM_TICK_SECONDS, false);
79:                      //xTaskResume(xHandleHouseKeeping);
80:                      return;
81:                  }
82:                  
83:                  #include <stdio.h>
84:                  #include <string.h>
85:                  static const char *monthStr[] = {
86:                      "Jan", "Feb", "Mar", "Apr", "May", "Jun",
87:                      "Jul", "Aug", "Sep", "Oct", "Nov", "Dec", "NOP"
88:                  };
89:                  static const char *dotwStr[] = {
90:                      "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun", "NOP"
91:                  };
92:                  
93:                  void getDateTime(SYS_RTCC_BCD_DATE *_nowdate, SYS_RTCC_BCD_TIME *_nowtime)
94:                  {
9D014A5C  27BDFFE8   ADDIU SP, SP, -24
9D014A60  AFBF0014   SW RA, 20(SP)
9D014A64  AFB00010   SW S0, 16(SP)
95:                      if (_nowdate != NULL) SYS_RTCC_DateGet(_nowdate);
9D014A68  10800003   BEQ A0, ZERO, 0x9D014A78
9D014A6C  00A08021   ADDU S0, A1, ZERO
9D014A70  0F4055C2   JAL SYS_RTCC_DateGet
9D014A74  00000000   NOP
96:                      if (_nowtime != NULL) SYS_RTCC_TimeGet(_nowtime);
9D014A78  12000004   BEQ S0, ZERO, 0x9D014A8C
9D014A7C  8FBF0014   LW RA, 20(SP)
9D014A80  0F4055BC   JAL SYS_RTCC_TimeGet
9D014A84  02002021   ADDU A0, S0, ZERO
97:                  }
9D014A88  8FBF0014   LW RA, 20(SP)
9D014A8C  8FB00010   LW S0, 16(SP)
9D014A90  03E00008   JR RA
9D014A94  27BD0018   ADDIU SP, SP, 24
98:                  
99:                  void getDateTimeStr(SYS_RTCC_BCD_DATE nowdate, SYS_RTCC_BCD_TIME nowtime, char *buf, int len, bool print_dotw)
100:                 {
9D009BDC  27BDFFB0   ADDIU SP, SP, -80
9D009BE0  AFBF004C   SW RA, 76(SP)
9D009BE4  AFBE0048   SW S8, 72(SP)
9D009BE8  AFB70044   SW S7, 68(SP)
9D009BEC  AFB60040   SW S6, 64(SP)
9D009BF0  AFB5003C   SW S5, 60(SP)
9D009BF4  AFB40038   SW S4, 56(SP)
9D009BF8  AFB30034   SW S3, 52(SP)
9D009BFC  AFB20030   SW S2, 48(SP)
9D009C00  AFB1002C   SW S1, 44(SP)
9D009C04  AFB00028   SW S0, 40(SP)
9D009C08  AFA40050   SW A0, 80(SP)
9D009C0C  AFA50054   SW A1, 84(SP)
9D009C10  00C09821   ADDU S3, A2, ZERO
9D009C14  00E09021   ADDU S2, A3, ZERO
101:                     uint32_t _dotw, _year, _month, _day;
102:                     uint32_t _hour, _minute, _sec;
103:                 
104:                     SYS_RTCC_TimeGet(&nowtime);
9D009C18  0F4055BC   JAL SYS_RTCC_TimeGet
9D009C1C  27A40054   ADDIU A0, SP, 84
105:                     SYS_RTCC_DateGet(&nowdate);
9D009C20  0F4055C2   JAL SYS_RTCC_DateGet
9D009C24  27A40050   ADDIU A0, SP, 80
106:                 
107:                     _dotw = nowdate & 0x07;
9D009C28  8FB00050   LW S0, 80(SP)
108:                     _day = ((nowdate & 0x0000f000) >> 12) * 10 + ((nowdate & 0x00000f00) >> 8);
9D009C2C  7E021B00   EXT V0, S0, 12, 4
9D009C30  0002A040   SLL S4, V0, 1
9D009C34  000210C0   SLL V0, V0, 3
9D009C38  0282A021   ADDU S4, S4, V0
9D009C3C  7E031A00   EXT V1, S0, 8, 4
9D009C40  0283A021   ADDU S4, S4, V1
109:                     _month = ((nowdate & 0x00100000) >> 20) * 10 + ((nowdate & 0x000f0000) >> 16) - 1;
9D009C44  7E111C00   EXT S1, S0, 16, 4
9D009C48  2631FFFF   ADDIU S1, S1, -1
9D009C4C  7E020500   EXT V0, S0, 20, 1
9D009C50  00021840   SLL V1, V0, 1
9D009C54  000210C0   SLL V0, V0, 3
9D009C58  00621021   ADDU V0, V1, V0
9D009C5C  02228821   ADDU S1, S1, V0
110:                     _year = ((nowdate & 0xf0000000) >> 28) * 10 + ((nowdate & 0x0f000000) >> 24) + 2000;
9D009C60  00101702   SRL V0, S0, 28
9D009C64  0002B840   SLL S7, V0, 1
9D009C68  000210C0   SLL V0, V0, 3
9D009C6C  02E2B821   ADDU S7, S7, V0
9D009C70  7E031E00   EXT V1, S0, 24, 4
9D009C74  02E3B821   ADDU S7, S7, V1
9D009C78  26F707D0   ADDIU S7, S7, 2000
111:                 
112:                     _sec = ((nowtime & 0x00007000) >> 12) * 10 + ((nowtime & 0x00000f00) >> 8);
9D009C7C  8FA20054   LW V0, 84(SP)
9D009C80  7C431300   EXT V1, V0, 12, 3
9D009C84  0003A840   SLL S5, V1, 1
9D009C88  000318C0   SLL V1, V1, 3
9D009C8C  02A3A821   ADDU S5, S5, V1
9D009C90  7C441A00   EXT A0, V0, 8, 4
9D009C94  02A4A821   ADDU S5, S5, A0
113:                     _minute = ((nowtime & 0x00700000) >> 20) * 10 + ((nowtime & 0x000f0000) >> 16);
9D009C98  7C431500   EXT V1, V0, 20, 3
9D009C9C  0003B040   SLL S6, V1, 1
9D009CA0  000318C0   SLL V1, V1, 3
9D009CA4  02C3B021   ADDU S6, S6, V1
9D009CA8  7C441C00   EXT A0, V0, 16, 4
9D009CAC  02C4B021   ADDU S6, S6, A0
114:                     _hour = ((nowtime & 0x30000000) >> 28) * 10 + ((nowtime & 0x0f000000) >> 24);
9D009CB0  7C430F00   EXT V1, V0, 28, 2
9D009CB4  0003F040   SLL S8, V1, 1
9D009CB8  000318C0   SLL V1, V1, 3
9D009CBC  03C3F021   ADDU S8, S8, V1
9D009CC0  7C421E00   EXT V0, V0, 24, 4
9D009CC4  03C2F021   ADDU S8, S8, V0
115:                     memset(buf, 0x00, len);
9D009CC8  02602021   ADDU A0, S3, ZERO
9D009CCC  00002821   ADDU A1, ZERO, ZERO
9D009CD0  0F40464F   JAL memset
9D009CD4  02403021   ADDU A2, S2, ZERO
116:                 
117:                     if (_month > 12) _month = 0;
9D009CD8  2E22000D   SLTIU V0, S1, 13
9D009CDC  0002880A   MOVZ S1, ZERO, V0
9D009CE0  2E870020   SLTIU A3, S4, 32
9D009CE4  2402001F   ADDIU V0, ZERO, 31
9D009CE8  0287100B   MOVN V0, S4, A3
9D009CEC  00403821   ADDU A3, V0, ZERO
118:                     if (_month == 0) _month = 0;
119:                     if (_day > 31) _day = 31;
120:                     if (_day == 0) _day = 1;
9D009CF0  24020001   ADDIU V0, ZERO, 1
9D009CF4  0047380A   MOVZ A3, V0, A3
121:                     _dotw = _dotw & 7;
9D009D04  32100007   ANDI S0, S0, 7
122:                     if (print_dotw) {
9D009CF8  93A20060   LBU V0, 96(SP)
9D009CFC  10400019   BEQ V0, ZERO, 0x9D009D64
9D009D00  00118880   SLL S1, S1, 2
123:                         snprintf(buf, len, "%s, %02d %s %04d %02d:%02d:%02d", dotwStr[_dotw], _day, monthStr[_month], _year, _hour, _minute, _sec);
9D009D08  00108080   SLL S0, S0, 2
9D009D0C  3C029D01   LUI V0, -25343
9D009D10  244206E4   ADDIU V0, V0, 1764
9D009D14  02028021   ADDU S0, S0, V0
9D009D18  8E020000   LW V0, 0(S0)
9D009D1C  AFA70010   SW A3, 16(SP)
9D009D20  3C039D01   LUI V1, -25343
9D009D24  24630738   ADDIU V1, V1, 1848
9D009D28  02238821   ADDU S1, S1, V1
9D009D2C  8E230000   LW V1, 0(S1)
9D009D30  AFA30014   SW V1, 20(SP)
9D009D34  AFB70018   SW S7, 24(SP)
9D009D38  AFBE001C   SW S8, 28(SP)
9D009D3C  AFB60020   SW S6, 32(SP)
9D009D40  AFB50024   SW S5, 36(SP)
9D009D44  02602021   ADDU A0, S3, ZERO
9D009D48  02402821   ADDU A1, S2, ZERO
9D009D4C  3C069D01   LUI A2, -25343
9D009D50  24C60688   ADDIU A2, A2, 1672
9D009D54  0F4054D3   JAL _snprintf_cdfFnopsuxX
9D009D58  00403821   ADDU A3, V0, ZERO
9D009D5C  0B402768   J 0x9D009DA0
9D009D60  8FBF004C   LW RA, 76(SP)
124:                     } else {
125:                         snprintf(buf, len, "%02d %s %04d %02d:%02d:%02d", _day, monthStr[_month], _year, _hour, _minute, _sec);
9D009D64  3C029D01   LUI V0, -25343
9D009D68  24420738   ADDIU V0, V0, 1848
9D009D6C  02228821   ADDU S1, S1, V0
9D009D70  8E220000   LW V0, 0(S1)
9D009D74  AFA20010   SW V0, 16(SP)
9D009D78  AFB70014   SW S7, 20(SP)
9D009D7C  AFBE0018   SW S8, 24(SP)
9D009D80  AFB6001C   SW S6, 28(SP)
9D009D84  AFB50020   SW S5, 32(SP)
9D009D88  02602021   ADDU A0, S3, ZERO
9D009D8C  02402821   ADDU A1, S2, ZERO
9D009D90  3C069D01   LUI A2, -25343
9D009D94  0F4054D3   JAL _snprintf_cdfFnopsuxX
9D009D98  24C606A8   ADDIU A2, A2, 1704
126:                     }
127:                 }
9D009D9C  8FBF004C   LW RA, 76(SP)
9D009DA0  8FBE0048   LW S8, 72(SP)
9D009DA4  8FB70044   LW S7, 68(SP)
9D009DA8  8FB60040   LW S6, 64(SP)
9D009DAC  8FB5003C   LW S5, 60(SP)
9D009DB0  8FB40038   LW S4, 56(SP)
9D009DB4  8FB30034   LW S3, 52(SP)
9D009DB8  8FB20030   LW S2, 48(SP)
9D009DBC  8FB1002C   LW S1, 44(SP)
9D009DC0  8FB00028   LW S0, 40(SP)
9D009DC4  03E00008   JR RA
9D009DC8  27BD0050   ADDIU SP, SP, 80
128:                 
129:                 static inline bool check_digit(char n)
130:                 {
131:                     if (n >= '0') {
9D005CF8  2443FFD0   ADDIU V1, V0, -48
9D005CFC  306300FF   ANDI V1, V1, 255
9D005D00  2C63000A   SLTIU V1, V1, 10
9D005D04  1460009A   BNE V1, ZERO, 0x9D005F70
9D005D08  2445FFD0   ADDIU A1, V0, -48
9D005D14  2443FFD0   ADDIU V1, V0, -48
9D005D18  306300FF   ANDI V1, V1, 255
9D005D1C  2C63000A   SLTIU V1, V1, 10
9D005D20  14600095   BNE V1, ZERO, 0x9D005F78
9D005D24  00052900   SLL A1, A1, 4
9D005D3C  2443FFD0   ADDIU V1, V0, -48
9D005D40  306300FF   ANDI V1, V1, 255
9D005D44  2C63000A   SLTIU V1, V1, 10
9D005D48  1460008F   BNE V1, ZERO, 0x9D005F88
9D005D4C  00052900   SLL A1, A1, 4
9D005D54  2443FFD0   ADDIU V1, V0, -48
9D005D58  306300FF   ANDI V1, V1, 255
9D005D5C  2C63000A   SLTIU V1, V1, 10
9D005D60  1460008D   BNE V1, ZERO, 0x9D005F98
9D005D64  00052900   SLL A1, A1, 4
9D005D7C  2443FFD0   ADDIU V1, V0, -48
9D005D80  306300FF   ANDI V1, V1, 255
9D005D84  2C63000A   SLTIU V1, V1, 10
9D005D88  14600087   BNE V1, ZERO, 0x9D005FA8
9D005D8C  00052900   SLL A1, A1, 4
9D005D94  2443FFD0   ADDIU V1, V0, -48
9D005D98  306300FF   ANDI V1, V1, 255
9D005D9C  2C63000A   SLTIU V1, V1, 10
9D005DA0  14600085   BNE V1, ZERO, 0x9D005FB8
9D005DA4  0005A900   SLL S5, A1, 4
9D005EA8  2443FFD0   ADDIU V1, V0, -48
9D005EAC  306300FF   ANDI V1, V1, 255
9D005EB0  2C63000A   SLTIU V1, V1, 10
9D005EB4  14600046   BNE V1, ZERO, 0x9D005FD0
9D005EB8  2442FFD0   ADDIU V0, V0, -48
9D005EC4  2443FFD0   ADDIU V1, V0, -48
9D005EC8  306300FF   ANDI V1, V1, 255
9D005ECC  2C63000A   SLTIU V1, V1, 10
9D005ED0  14600041   BNE V1, ZERO, 0x9D005FD8
9D005ED4  00052900   SLL A1, A1, 4
9D005EEC  2443FFD0   ADDIU V1, V0, -48
9D005EF0  306300FF   ANDI V1, V1, 255
9D005EF4  2C63000A   SLTIU V1, V1, 10
9D005EF8  1460003B   BNE V1, ZERO, 0x9D005FE8
9D005EFC  00052900   SLL A1, A1, 4
9D005F04  2443FFD0   ADDIU V1, V0, -48
9D005F08  306300FF   ANDI V1, V1, 255
9D005F0C  2C63000A   SLTIU V1, V1, 10
9D005F10  14600039   BNE V1, ZERO, 0x9D005FF8
9D005F14  00052900   SLL A1, A1, 4
9D005F2C  2443FFD0   ADDIU V1, V0, -48
9D005F30  306300FF   ANDI V1, V1, 255
9D005F34  2C63000A   SLTIU V1, V1, 10
9D005F38  14600033   BNE V1, ZERO, 0x9D006008
9D005F3C  00052100   SLL A0, A1, 4
9D005F44  2443FFD0   ADDIU V1, V0, -48
9D005F48  306300FF   ANDI V1, V1, 255
9D005F4C  2C63000A   SLTIU V1, V1, 10
9D005F50  14600031   BNE V1, ZERO, 0x9D006018
9D005F54  00042100   SLL A0, A0, 4
132:                         if (n <= '9') return true;
133:                     }
134:                     return false;
135:                 }
136:                 
137:                 bool setDateTimeStr(char *_date)
138:                 {
9D005C98  27BDFFC8   ADDIU SP, SP, -56
9D005C9C  AFBF0034   SW RA, 52(SP)
9D005CA0  AFB60030   SW S6, 48(SP)
9D005CA4  AFB5002C   SW S5, 44(SP)
9D005CA8  AFB40028   SW S4, 40(SP)
9D005CAC  AFB30024   SW S3, 36(SP)
9D005CB0  AFB20020   SW S2, 32(SP)
9D005CB4  AFB1001C   SW S1, 28(SP)
9D005CB8  AFB00018   SW S0, 24(SP)
139:                     char *_time = NULL;
9D005E34  0000A021   ADDU S4, ZERO, ZERO
9D005FC8  0B40178F   J 0x9D005E3C
9D005FCC  0000A021   ADDU S4, ZERO, ZERO
140:                     char *nv = NULL;
141:                     uint32_t i;
142:                     if (_date != NULL) {
9D005CBC  108000AA   BEQ A0, ZERO, 0x9D005F68
9D005CC0  00808821   ADDU S1, A0, ZERO
9D005CC4  00808021   ADDU S0, A0, ZERO
143:                         // "yyyy/MM/dd DoW hh:mm:ss"
144:                         SYS_RTCC_BCD_DATE ndate = 0;
9D005D0C  00002821   ADDU A1, ZERO, ZERO
145:                         // YY
146:                         for (i = 0; i < strlen(_date); i++) {
9D005CDC  0F403499   JAL strlen
9D005CE0  02002021   ADDU A0, S0, ZERO
9D005CE4  02111823   SUBU V1, S0, S1
9D005CE8  0062102B   SLTU V0, V1, V0
9D005CEC  5440FFF8   BNEL V0, ZERO, 0x9D005CD0
9D005CF0  82020000   LB V0, 0(S0)
147:                             if (*_date != ' ') break;
9D005CC8  0B401737   J 0x9D005CDC
9D005CCC  24120020   ADDIU S2, ZERO, 32
9D005CD0  54520009   BNEL V0, S2, check_digit
9D005CD4  82020002   LB V0, 2(S0)
148:                             _date++;
9D005CD8  26100001   ADDIU S0, S0, 1
149:                         }
150:                         if (check_digit(_date[2])) {
9D005CF4  82020002   LB V0, 2(S0)
151:                             ndate |= ((_date[2] - '0') << 8);
9D005F70  0B401744   J 0x9D005D10
9D005F74  00052A00   SLL A1, A1, 8
152:                         }
153:                         ndate <<= 4;
154:                         if (check_digit(_date[3])) {
9D005D10  82020003   LB V0, 3(S0)
155:                             ndate |= ((_date[3] - '0') << 8);
9D005F78  2442FFD0   ADDIU V0, V0, -48
9D005F7C  00021200   SLL V0, V0, 8
9D005F80  0B40174A   J 0x9D005D28
9D005F84  00A22825   OR A1, A1, V0
156:                         }
157:                         ndate <<= 4;
158:                         // MM
159:                         if (_date[4] != '/') return false;
9D005D28  82040004   LB A0, 4(S0)
9D005D2C  2403002F   ADDIU V1, ZERO, 47
9D005D30  148300C4   BNE A0, V1, 0x9D006044
9D005D34  00001021   ADDU V0, ZERO, ZERO
160:                         if (check_digit(_date[5])) {
9D005D38  82020005   LB V0, 5(S0)
161:                             ndate |= ((_date[5] - '0') << 8);
9D005F88  2442FFD0   ADDIU V0, V0, -48
9D005F8C  00021200   SLL V0, V0, 8
9D005F90  0B401754   J 0x9D005D50
9D005F94  00A22825   OR A1, A1, V0
162:                         }
163:                         ndate <<= 4;
164:                         if (check_digit(_date[6])) {
9D005D50  82020006   LB V0, 6(S0)
165:                             ndate |= ((_date[6] - '0') << 8);
9D005F98  2442FFD0   ADDIU V0, V0, -48
9D005F9C  00021200   SLL V0, V0, 8
9D005FA0  0B40175A   J 0x9D005D68
9D005FA4  00A22825   OR A1, A1, V0
166:                         }
167:                         ndate <<= 4;
168:                         // DD
169:                         if (_date[7] != '/') return false;
9D005D68  82030007   LB V1, 7(S0)
9D005D6C  2402002F   ADDIU V0, ZERO, 47
9D005D70  146200B4   BNE V1, V0, 0x9D006044
9D005D74  00001021   ADDU V0, ZERO, ZERO
170:                         if (check_digit(_date[8])) {
9D005D78  82020008   LB V0, 8(S0)
171:                             ndate |= ((_date[8] - '0') << 8);
9D005FA8  2442FFD0   ADDIU V0, V0, -48
9D005FAC  00021200   SLL V0, V0, 8
9D005FB0  0B401764   J 0x9D005D90
9D005FB4  00A22825   OR A1, A1, V0
172:                         }
173:                         ndate <<= 4;
174:                         if (check_digit(_date[9])) {
9D005D90  82020009   LB V0, 9(S0)
175:                             ndate |= ((_date[9] - '0') << 8);
9D005FB8  2442FFD0   ADDIU V0, V0, -48
9D005FBC  00021200   SLL V0, V0, 8
9D005FC0  0B40176A   J 0x9D005DA8
9D005FC4  02A2A825   OR S5, S5, V0
176:                         }
177:                         //ndate <<= 4;
178:                         // DoW
179:                         char mbuf[8];
180:                         memset(mbuf, 0x00, sizeof (mbuf));
9D005DA8  AFA00010   SW ZERO, 16(SP)
9D005DAC  AFA00014   SW ZERO, 20(SP)
181:                         _date = &(_date[10]);
9D005DB4  2602000A   ADDIU V0, S0, 10
9D005DB8  2610000B   ADDIU S0, S0, 11
9D005DBC  3AD60020   XORI S6, S6, 32
9D005DC0  0216100A   MOVZ V0, S0, S6
9D005DC4  0040B021   ADDU S6, V0, ZERO
182:                         if (_date[0] == ' ') _date++;
9D005DB0  8216000A   LB S6, 10(S0)
183:                         nv = _date;
184:                         for (i = 0; i < 4; i++) {
9D005E28  24420001   ADDIU V0, V0, 1
9D005E2C  1447FFEF   BNE V0, A3, 0x9D005DEC
9D005E30  A0830000   SB V1, 0(A0)
9D006028  24020001   ADDIU V0, ZERO, 1
9D006034  0B40177B   J 0x9D005DEC
9D006038  24070004   ADDIU A3, ZERO, 4
9D00603C  0B401790   J 0x9D005E40
9D006040  3C109D01   LUI S0, -25343
185:                             if (_date[i] == 0x00) break;
9D005DC8  80420000   LB V0, 0(V0)
9D005DCC  1040007E   BEQ V0, ZERO, 0x9D005FC8
9D005DD0  2403000A   ADDIU V1, ZERO, 10
9D005DF0  80630000   LB V1, 0(V1)
9D005DF4  10600011   BEQ V1, ZERO, 0x9D005E3C
9D005DF8  0000A021   ADDU S4, ZERO, ZERO
186:                             if (_date[i] == '\n') break;
9D005DD4  1043007C   BEQ V0, V1, 0x9D005FC8
9D005DD8  24030020   ADDIU V1, ZERO, 32
9D005DFC  10650010   BEQ V1, A1, 0x9D005E40
9D005E00  3C109D01   LUI S0, -25343
9D00602C  2405000A   ADDIU A1, ZERO, 10
187:                             if (_date[i] == ' ') {
9D005DDC  54430092   BNEL V0, V1, 0x9D006028
9D005DE0  A3A20010   SB V0, 16(SP)
9D005E04  14660007   BNE V1, A2, 0x9D005E24
9D005E08  27A80010   ADDIU T0, SP, 16
9D006030  24060020   ADDIU A2, ZERO, 32
188:                                 _time = &(_date[i + 1]);
9D005DE4  0B40180F   J 0x9D00603C
9D005DE8  26D40001   ADDIU S4, S6, 1
9D005DEC  02C21821   ADDU V1, S6, V0
9D005E0C  24540001   ADDIU S4, V0, 1
189:                                 break;
190:                             }
191:                             mbuf[i] = _date[i];
192:                         }
193:                         if (i >= 4) {
9D005E10  2C420004   SLTIU V0, V0, 4
9D005E14  1440000A   BNE V0, ZERO, 0x9D005E40
9D005E18  02D4A021   ADDU S4, S6, S4
9D005E1C  0B401790   J 0x9D005E40
9D005E20  A3A00013   SB ZERO, 19(SP)
9D005E24  01022021   ADDU A0, T0, V0
194:                             mbuf[3] = '\0';
9D005E38  A3A00013   SB ZERO, 19(SP)
9D005E3C  3C109D01   LUI S0, -25343
9D005E40  261006E4   ADDIU S0, S0, 1764
9D005E44  26130024   ADDIU S3, S0, 36
195:                         }
196:                         i = 0;
197:                         do {
198:                             if (strcmp(dotwStr[i], "NOP") == 0) {
9D005E48  3C129D01   LUI S2, -25343
9D005E4C  265206C4   ADDIU S2, S2, 1732
9D005E50  8E110000   LW S1, 0(S0)
9D005E54  02202021   ADDU A0, S1, ZERO
9D005E58  0F403CA8   JAL strcmp
9D005E5C  02402821   ADDU A1, S2, ZERO
9D005E60  1040000A   BEQ V0, ZERO, 0x9D005E8C
9D005E64  02202021   ADDU A0, S1, ZERO
199:                                 _time = nv;
9D005E8C  02C0A021   ADDU S4, S6, ZERO
200:                                 break;
201:                             }
202:                             if (strncasecmp(dotwStr[i], mbuf, 8) == 0) break;
9D005E68  27A50010   ADDIU A1, SP, 16
9D005E6C  0F404B83   JAL strncasecmp
9D005E70  24060008   ADDIU A2, ZERO, 8
9D005E74  10400006   BEQ V0, ZERO, 0x9D005E90
9D005E78  26100004   ADDIU S0, S0, 4
203:                             i++;
204:                         } while (i < 9);
9D005E7C  5613FFF5   BNEL S0, S3, 0x9D005E54
9D005E80  8E110000   LW S1, 0(S0)
9D005E84  0B4017A4   J 0x9D005E90
9D005E88  00000000   NOP
205:                         if (i >= 8) i = 0;
206:                         //ndate = (ndate & 0xffffff00) | (i & 0x07);
207:                         SYS_RTCC_DateSet(ndate);
9D005E90  0F405669   JAL SYS_RTCC_DateSet
9D005E94  02A02021   ADDU A0, S5, ZERO
208:                     } else {
209:                         return false;
9D005F68  0B401811   J 0x9D006044
9D005F6C  00001021   ADDU V0, ZERO, ZERO
210:                     }
211:                     // Time
212:                     if (_time != NULL) {
9D005E98  1280006A   BEQ S4, ZERO, 0x9D006044
9D005E9C  00001021   ADDU V0, ZERO, ZERO
9D005EA0  0B4017AA   J check_digit
9D005EA4  82820000   LB V0, 0(S4)
213:                         // "yyyy/MM/dd DoW hh:mm:ss"
214:                         SYS_RTCC_BCD_TIME ntime = 0;
9D005EBC  00002821   ADDU A1, ZERO, ZERO
215:                         // HH
216:                         if (check_digit(_time[0])) {
217:                             ntime |= ((_time[0] - '0') << 8);
9D005FD0  0B4017B0   J 0x9D005EC0
9D005FD4  00022A00   SLL A1, V0, 8
218:                         }
219:                         ntime <<= 4;
220:                         if (check_digit(_time[1])) {
9D005EC0  82820001   LB V0, 1(S4)
221:                             ntime |= ((_time[1] - '0') << 8);
9D005FD8  2442FFD0   ADDIU V0, V0, -48
9D005FDC  00021200   SLL V0, V0, 8
9D005FE0  0B4017B6   J 0x9D005ED8
9D005FE4  00A22825   OR A1, A1, V0
222:                         }
223:                         ntime <<= 4;
224:                         // mm
225:                         if (_time[2] != ':') return false;
9D005ED8  82840002   LB A0, 2(S4)
9D005EDC  2403003A   ADDIU V1, ZERO, 58
9D005EE0  14830058   BNE A0, V1, 0x9D006044
9D005EE4  00001021   ADDU V0, ZERO, ZERO
226:                         if (check_digit(_time[3])) {
9D005EE8  82820003   LB V0, 3(S4)
227:                             ntime |= ((_time[3] - '0') << 8);
9D005FE8  2442FFD0   ADDIU V0, V0, -48
9D005FEC  00021200   SLL V0, V0, 8
9D005FF0  0B4017C0   J 0x9D005F00
9D005FF4  00A22825   OR A1, A1, V0
228:                         }
229:                         ntime <<= 4;
230:                         if (check_digit(_time[4])) {
9D005F00  82820004   LB V0, 4(S4)
231:                             ntime |= ((_time[4] - '0') << 8);
9D005FF8  2442FFD0   ADDIU V0, V0, -48
9D005FFC  00021200   SLL V0, V0, 8
9D006000  0B4017C6   J 0x9D005F18
9D006004  00A22825   OR A1, A1, V0
232:                         }
233:                         ntime <<= 4;
234:                         // ss
235:                         if (_time[5] != ':') return false;
9D005F18  82840005   LB A0, 5(S4)
9D005F1C  2403003A   ADDIU V1, ZERO, 58
9D005F20  14830048   BNE A0, V1, 0x9D006044
9D005F24  00001021   ADDU V0, ZERO, ZERO
236:                         if (check_digit(_time[6])) {
9D005F28  82820006   LB V0, 6(S4)
237:                             ntime |= ((_time[6] - '0') << 8);
9D006008  2442FFD0   ADDIU V0, V0, -48
9D00600C  00021200   SLL V0, V0, 8
9D006010  0B4017D0   J 0x9D005F40
9D006014  00822025   OR A0, A0, V0
238:                         }
239:                         ntime <<= 4;
240:                         if (check_digit(_time[7])) {
9D005F40  82820007   LB V0, 7(S4)
241:                             ntime |= ((_time[7] - '0') << 8);
9D006018  2442FFD0   ADDIU V0, V0, -48
9D00601C  00021200   SLL V0, V0, 8
9D006020  0B4017D6   J 0x9D005F58
9D006024  00822025   OR A0, A0, V0
242:                         }
243:                         //ntime <<= 4;
244:                         SYS_RTCC_TimeSet(ntime, true);
9D005F58  0F405571   JAL SYS_RTCC_TimeSet
9D005F5C  24050001   ADDIU A1, ZERO, 1
245:                         return true;
9D005F60  0B401811   J 0x9D006044
9D005F64  24020001   ADDIU V0, ZERO, 1
246:                     }
247:                     return false;
248:                 }
9D006044  8FBF0034   LW RA, 52(SP)
9D006048  8FB60030   LW S6, 48(SP)
9D00604C  8FB5002C   LW S5, 44(SP)
9D006050  8FB40028   LW S4, 40(SP)
9D006054  8FB30024   LW S3, 36(SP)
9D006058  8FB20020   LW S2, 32(SP)
9D00605C  8FB1001C   LW S1, 28(SP)
9D006060  8FB00018   LW S0, 24(SP)
9D006064  03E00008   JR RA
9D006068  27BD0038   ADDIU SP, SP, 56
---  /home/whatisthis/src/DoorBell_PIC32/firmware/src/ringbuffer.c  -------------------------------------
1:                   
2:                   #include <stddef.h>                     // Defines NULL
3:                   #include <stdbool.h>                    // Defines true
4:                   #include <stdlib.h>                     // Defines EXIT_FAILURE
5:                   #include "system/common/sys_module.h"
6:                   #include "doorbell.h"   // SYS function prototypes
7:                   #include "ringbuffer.h"
8:                   
9:                   /* Kernel includes. */
10:                  #include "FreeRTOS.h"
11:                  #include "task.h"
12:                  #include "queue.h"
13:                  #include "timers.h"
14:                  
15:                  bool vRingBufferCreate_Char(RingBuffer_Char_t *p, char *realBuffer, int size)
16:                  {
9D012B7C  27BDFFE0   ADDIU SP, SP, -32
9D012B80  AFBF001C   SW RA, 28(SP)
9D012B84  AFB20018   SW S2, 24(SP)
9D012B88  AFB10014   SW S1, 20(SP)
9D012B8C  AFB00010   SW S0, 16(SP)
17:                      if (p == NULL) return false;
9D012B90  10800010   BEQ A0, ZERO, 0x9D012BD4
9D012B94  00808021   ADDU S0, A0, ZERO
9D012BD4  0B404AFA   J 0x9D012BE8
9D012BD8  00001021   ADDU V0, ZERO, ZERO
18:                      if (realBuffer == NULL) return false;
9D012B98  10A00010   BEQ A1, ZERO, 0x9D012BDC
9D012B9C  00A08821   ADDU S1, A1, ZERO
9D012BDC  0B404AFA   J 0x9D012BE8
9D012BE0  00001021   ADDU V0, ZERO, ZERO
19:                      if (size <= 0) return false;
9D012BA0  18C00010   BLEZ A2, 0x9D012BE4
9D012BA4  00C09021   ADDU S2, A2, ZERO
9D012BE4  00001021   ADDU V0, ZERO, ZERO
20:                      memset(realBuffer, 0x00, sizeof (char) * size);
9D012BA8  00A02021   ADDU A0, A1, ZERO
9D012BAC  0F40464F   JAL memset
9D012BB0  00002821   ADDU A1, ZERO, ZERO
21:                      memset(p, 0x00, sizeof (RingBuffer_Char_t));
9D012BB4  02002021   ADDU A0, S0, ZERO
9D012BB8  00002821   ADDU A1, ZERO, ZERO
9D012BBC  0F40464F   JAL memset
9D012BC0  2406001C   ADDIU A2, ZERO, 28
22:                  
23:                      p->baseaddr = realBuffer;
9D012BC4  AE110000   SW S1, 0(S0)
24:                      p->members = size;
9D012BC8  AE120004   SW S2, 4(S0)
25:                      return true;
9D012BCC  0B404AFA   J 0x9D012BE8
9D012BD0  24020001   ADDIU V0, ZERO, 1
26:                  }
9D012BE8  8FBF001C   LW RA, 28(SP)
9D012BEC  8FB20018   LW S2, 24(SP)
9D012BF0  8FB10014   LW S1, 20(SP)
9D012BF4  8FB00010   LW S0, 16(SP)
9D012BF8  03E00008   JR RA
9D012BFC  27BD0020   ADDIU SP, SP, 32
27:                  
28:                  bool vRingBufferRead_Char(RingBuffer_Char_t *ringBuffer, char *p)
29:                  {
9D0113B4  27BDFFE0   ADDIU SP, SP, -32
9D0113B8  AFBF001C   SW RA, 28(SP)
9D0113BC  AFB10018   SW S1, 24(SP)
9D0113C0  AFB00014   SW S0, 20(SP)
30:                      int np;
31:                      char *vp;
32:                      bool stat = false;
33:                      if (p == NULL) return false;
9D0113C4  10A00022   BEQ A1, ZERO, 0x9D011450
9D0113C8  00A08821   ADDU S1, A1, ZERO
9D011450  0B404517   J 0x9D01145C
9D011454  00001021   ADDU V0, ZERO, ZERO
34:                      if (ringBuffer == NULL) return false;
9D0113CC  10800022   BEQ A0, ZERO, 0x9D011458
9D0113D0  00808021   ADDU S0, A0, ZERO
9D011458  00001021   ADDU V0, ZERO, ZERO
35:                      taskENTER_CRITICAL();
9D0113D4  0F405144   JAL vTaskEnterCritical
9D0113D8  00000000   NOP
36:                      vp = ringBuffer->baseaddr;
37:                      if ((ringBuffer->remain <= 0) || (vp == NULL)) {
9D0113DC  8E030018   LW V1, 24(S0)
9D0113E0  18600003   BLEZ V1, 0x9D0113F0
9D0113E4  8E020000   LW V0, 0(S0)
9D0113E8  54400005   BNEL V0, ZERO, 0x9D011400
9D0113EC  8E030008   LW V1, 8(S0)
38:                          // Empty
39:                          taskEXIT_CRITICAL();
9D0113F0  0F404EA8   JAL vTaskExitCritical
9D0113F4  00000000   NOP
40:                          return false;
9D0113F8  0B404517   J 0x9D01145C
9D0113FC  00001021   ADDU V0, ZERO, ZERO
41:                      }
42:                      if (ringBuffer->remain > 0) {
43:                          np = ringBuffer->read_ptr;
44:                          *p = vp[np];
9D011400  00431021   ADDU V0, V0, V1
9D011404  80420000   LB V0, 0(V0)
9D011408  A2220000   SB V0, 0(S1)
45:                          stat = true;
46:                          ringBuffer->read_ptr++;
9D01140C  8E020008   LW V0, 8(S0)
9D011410  24420001   ADDIU V0, V0, 1
9D011414  AE020008   SW V0, 8(S0)
47:                          ringBuffer->remain--;
9D011418  8E030018   LW V1, 24(S0)
9D01141C  2463FFFF   ADDIU V1, V1, -1
9D011420  AE030018   SW V1, 24(S0)
48:                      } else {
49:                          stat = false;
50:                      }
51:                      if (ringBuffer->read_ptr > ringBuffer->members) ringBuffer->read_ptr = 0;
9D011424  8E030004   LW V1, 4(S0)
9D011428  0062102A   SLT V0, V1, V0
9D01142C  54400001   BNEL V0, ZERO, 0x9D011434
9D011430  AE000008   SW ZERO, 8(S0)
52:                      if (ringBuffer->remain < 0) ringBuffer->remain = 0;
9D011434  8E020018   LW V0, 24(S0)
9D011438  04420001   BLTZL V0, 0x9D011440
9D01143C  AE000018   SW ZERO, 24(S0)
53:                      taskEXIT_CRITICAL();
9D011440  0F404EA8   JAL vTaskExitCritical
9D011444  00000000   NOP
54:                      return stat;
9D011448  0B404517   J 0x9D01145C
9D01144C  24020001   ADDIU V0, ZERO, 1
55:                  }
9D01145C  8FBF001C   LW RA, 28(SP)
9D011460  8FB10018   LW S1, 24(SP)
9D011464  8FB00014   LW S0, 20(SP)
9D011468  03E00008   JR RA
9D01146C  27BD0020   ADDIU SP, SP, 32
56:                  
57:                  bool vRingBufferWrite_Char(RingBuffer_Char_t *ringBuffer, char c)
58:                  {
9D012170  27BDFFE0   ADDIU SP, SP, -32
9D012174  AFBF001C   SW RA, 28(SP)
9D012178  AFB10018   SW S1, 24(SP)
9D01217C  AFB00014   SW S0, 20(SP)
59:                      int np;
60:                      char *vp;
61:                      if (ringBuffer == NULL) return false;
9D012180  1080001B   BEQ A0, ZERO, 0x9D0121F0
9D012184  00808021   ADDU S0, A0, ZERO
9D0121F0  00001021   ADDU V0, ZERO, ZERO
62:                      taskENTER_CRITICAL();
9D012188  0F405144   JAL vTaskEnterCritical
9D01218C  00A08821   ADDU S1, A1, ZERO
63:                      vp = ringBuffer->baseaddr;
9D012190  8E020000   LW V0, 0(S0)
64:                      if (vp == NULL) {
9D012194  54400005   BNEL V0, ZERO, 0x9D0121AC
9D012198  8E03000C   LW V1, 12(S0)
65:                          // Empty
66:                          taskEXIT_CRITICAL();
9D01219C  0F404EA8   JAL vTaskExitCritical
9D0121A0  00000000   NOP
67:                          return false;
9D0121A4  0B40487D   J 0x9D0121F4
9D0121A8  00001021   ADDU V0, ZERO, ZERO
68:                      }
69:                      // If fill overwrite.
70:                      np = ringBuffer->write_ptr;
71:                      vp[np] = c;
9D0121AC  00431021   ADDU V0, V0, V1
9D0121B0  A0510000   SB S1, 0(V0)
72:                      ringBuffer->write_ptr++;
9D0121B4  8E03000C   LW V1, 12(S0)
9D0121B8  24630001   ADDIU V1, V1, 1
9D0121BC  AE03000C   SW V1, 12(S0)
73:                      if (ringBuffer->write_ptr >= ringBuffer->members) ringBuffer->write_ptr = 0;
9D0121C0  8E020004   LW V0, 4(S0)
9D0121C4  0062182A   SLT V1, V1, V0
9D0121C8  50600001   BEQL V1, ZERO, 0x9D0121D0
9D0121CC  AE00000C   SW ZERO, 12(S0)
74:                      ringBuffer->remain++;
9D0121D0  8E030018   LW V1, 24(S0)
9D0121D4  24630001   ADDIU V1, V1, 1
9D0121DC  0064100A   MOVZ V0, V1, A0
75:                      if (ringBuffer->remain > ringBuffer->members) ringBuffer->remain = ringBuffer->members;
9D0121D8  0043202A   SLT A0, V0, V1
76:                      taskEXIT_CRITICAL();
9D0121E0  0F404EA8   JAL vTaskExitCritical
9D0121E4  AE020018   SW V0, 24(S0)
77:                      return true;
9D0121E8  0B40487D   J 0x9D0121F4
9D0121EC  24020001   ADDIU V0, ZERO, 1
78:                  }
9D0121F4  8FBF001C   LW RA, 28(SP)
9D0121F8  8FB10018   LW S1, 24(SP)
9D0121FC  8FB00014   LW S0, 20(SP)
9D012200  03E00008   JR RA
9D012204  27BD0020   ADDIU SP, SP, 32
79:                  
80:                  void vRingBufferClear_Char(RingBuffer_Char_t *p)
81:                  {
9D0132D0  27BDFFE0   ADDIU SP, SP, -32
9D0132D4  AFBF001C   SW RA, 28(SP)
9D0132D8  AFB10018   SW S1, 24(SP)
9D0132DC  AFB00014   SW S0, 20(SP)
9D0132E0  00808021   ADDU S0, A0, ZERO
82:                      int i;
83:                      char *vp = p->baseaddr;
84:                      taskENTER_CRITICAL();
9D0132E4  0F405144   JAL vTaskEnterCritical
9D0132E8  8C910000   LW S1, 0(A0)
85:                      for(i = 0; i < p->members; i++) {
9D0132EC  8E020004   LW V0, 4(S0)
9D0132F0  18400008   BLEZ V0, 0x9D013314
9D0132F4  00001021   ADDU V0, ZERO, ZERO
9D0132F8  02221821   ADDU V1, S1, V0
9D013300  24420001   ADDIU V0, V0, 1
9D013304  8E030004   LW V1, 4(S0)
9D013308  0043182A   SLT V1, V0, V1
9D01330C  1460FFFB   BNE V1, ZERO, 0x9D0132FC
9D013310  02221821   ADDU V1, S1, V0
86:                          vp[i] = '\0';
9D0132FC  A0600000   SB ZERO, 0(V1)
87:                      } 
88:                      p->remain = 0;
9D013314  AE000018   SW ZERO, 24(S0)
89:                      p->write_ptr = 0;
9D013318  AE00000C   SW ZERO, 12(S0)
90:                      p->read_ptr = 0;
9D01331C  AE000008   SW ZERO, 8(S0)
91:                      p->read_size = 0;
9D013320  AE000010   SW ZERO, 16(S0)
92:                      p->write_size = 0;
93:                      taskEXIT_CRITICAL();
9D013324  0F404EA8   JAL vTaskExitCritical
9D013328  AE000014   SW ZERO, 20(S0)
94:                  }
9D01332C  8FBF001C   LW RA, 28(SP)
9D013330  8FB10018   LW S1, 24(SP)
9D013334  8FB00014   LW S0, 20(SP)
9D013338  03E00008   JR RA
9D01333C  27BD0020   ADDIU SP, SP, 32
---  /home/whatisthis/src/DoorBell_PIC32/firmware/src/pca9655.c  ----------------------------------------
1:                   /* 
2:                    * File:   pca9655.c
3:                    * Description: Driver of PCA9655 I/O expander.
4:                    *                 This is for MPLAB-Harmony with FreeRTOS.
5:                    * Author: Kyuma Ohta <whatisthis.sowhat _at_ gmail.com>
6:                    *
7:                    * Created on 2017/11/12, 19:44
8:                    * License: Apache
9:                    */
10:                  
11:                  #include <stddef.h>                     // Defines NULL
12:                  #include <stdbool.h>                    // Defines true
13:                  #include <stdlib.h>                     // Defines EXIT_FAILURE
14:                  #include "system/common/sys_module.h"
15:                  #include "doorbell.h"   // SYS function prototypes
16:                  #include "lm01_drv.h"
17:                  #include "ringbuffer.h"
18:                  
19:                  /* Kernel includes. */
20:                  #include "FreeRTOS.h"
21:                  #include "task.h"
22:                  #include "queue.h"
23:                  #include "timers.h"
24:                  #include "semphr.h"
25:                  
26:                  #include "pca9655.h"
27:                  
28:                  #if 1
29:                  
30:                  DRV_HANDLE sv_open_i2c(int num)
31:                  {
9D0126AC  27BDFFE8   ADDIU SP, SP, -24
32:                      int n = -1;
33:                      switch (num) {
9D0126A0  2C820006   SLTIU V0, A0, 6
9D0126A4  1040001D   BEQ V0, ZERO, 0x9D01271C
9D0126A8  00042080   SLL A0, A0, 2
9D0126B0  3C029D01   LUI V0, -25343
9D0126B4  244226C8   ADDIU V0, V0, 9928
9D0126B8  00442021   ADDU A0, V0, A0
9D0126BC  8C820000   LW V0, 0(A0)
9D0126C0  00400008   JR V0
9D0126C4  AFBF0014   SW RA, 20(SP)
34:                      case 0:
35:                          n = DRV_I2C_INDEX_0;
9D0126E0  0B4049C3   J 0x9D01270C
9D0126E4  00002021   ADDU A0, ZERO, ZERO
36:                          break;
37:                      case 1:
38:                          n = DRV_I2C_INDEX_1;
9D012708  24040001   ADDIU A0, ZERO, 1
39:                          break;
40:                      case 2:
41:                          n = DRV_I2C_INDEX_2;
42:                          break;
9D0126E8  0B4049C3   J 0x9D01270C
9D0126EC  24040002   ADDIU A0, ZERO, 2
43:                      case 3:
44:                          n = DRV_I2C_INDEX_3;
45:                          break;
9D0126F0  0B4049C3   J 0x9D01270C
9D0126F4  24040003   ADDIU A0, ZERO, 3
46:                      case 4:
47:                          n = DRV_I2C_INDEX_4;
48:                          break;
9D0126F8  0B4049C3   J 0x9D01270C
9D0126FC  24040004   ADDIU A0, ZERO, 4
49:                      case 5:
50:                          n = DRV_I2C_INDEX_5;
51:                          break;
9D012700  0B4049C3   J 0x9D01270C
9D012704  24040005   ADDIU A0, ZERO, 5
52:                      default:
53:                          return DRV_HANDLE_INVALID;
9D01271C  03E00008   JR RA
9D012720  2402FFFF   ADDIU V0, ZERO, -1
54:                          break;
55:                      }
56:                      return DRV_I2C_Open(n, DRV_IO_INTENT_READWRITE);
9D01270C  0F40392C   JAL DRV_I2C_Open
9D012710  24050003   ADDIU A1, ZERO, 3
9D012714  0B4049C9   J 0x9D012724
9D012718  8FBF0014   LW RA, 20(SP)
57:                  }
9D012724  03E00008   JR RA
58:                  #endif
59:                  
60:                  void DRV_PCA9655_sample_open_port(void)
61:                  {
9D0159F8  03E00008   JR RA
62:                      //SYS_PORTS_PinWrite(PORTS_ID_0, PORT_CHANNEL_A, 0, false); //I2C Bus ON
63:                  }
64:                  
65:                  void DRV_PCA9655_sample_close_port(void)
66:                  {
9D015A00  03E00008   JR RA
67:                      //SYS_PORTS_PinWrite(PORTS_ID_0, PORT_CHANNEL_A, 0, true); //I2C Bus ON
68:                  }
69:                  
70:                  bool DRV_PCA9655_Reset(PCA9655_t *desc, uint8_t port0_val, uint8_t port1_val, bool b_reset)
71:                  {
9D0097F4  27BDFFC8   ADDIU SP, SP, -56
9D0097F8  AFBF0034   SW RA, 52(SP)
9D0097FC  AFB30030   SW S3, 48(SP)
9D009800  AFB2002C   SW S2, 44(SP)
9D009804  AFB10028   SW S1, 40(SP)
9D009808  AFB00024   SW S0, 36(SP)
72:                      DRV_I2C_BUFFER_HANDLE bHandle;
73:                      uint8_t sbuffer[4];
74:                      if (b_reset) {
9D00980C  10E00007   BEQ A3, ZERO, 0x9D00982C
9D009810  00808021   ADDU S0, A0, ZERO
9D009814  00A09021   ADDU S2, A1, ZERO
75:                          taskENTER_CRITICAL();
9D009818  0F405144   JAL vTaskEnterCritical
9D00981C  00C08821   ADDU S1, A2, ZERO
76:                          desc->port0_out_data = port0_val;
9D009820  A212000C   SB S2, 12(S0)
77:                          desc->port1_out_data = port1_val;
78:                          taskEXIT_CRITICAL();
9D009824  0F404EA8   JAL vTaskExitCritical
9D009828  A211000D   SB S1, 13(S0)
79:                      }
80:                  
81:                      if (desc->open_port != NULL) desc->open_port();
9D00982C  8E020014   LW V0, 20(S0)
9D009830  50400004   BEQL V0, ZERO, 0x9D009844
9D009834  8E030008   LW V1, 8(S0)
9D009838  0040F809   JALR V0
9D00983C  00000000   NOP
82:                      if (desc->devHandle != DRV_HANDLE_INVALID) {
9D009840  8E030008   LW V1, 8(S0)
9D009844  2402FFFF   ADDIU V0, ZERO, -1
9D009848  10620058   BEQ V1, V0, 0x9D0099AC
9D00984C  24020006   ADDIU V0, ZERO, 6
83:                          sbuffer[0] = 0x06; // Config
84:                          taskENTER_CRITICAL();
9D009850  0F405144   JAL vTaskEnterCritical
9D009854  A3A20018   SB V0, 24(SP)
85:                          sbuffer[1] = desc->direction_0;
9D009858  92020010   LBU V0, 16(S0)
9D00985C  A3A20019   SB V0, 25(SP)
86:                          sbuffer[2] = desc->direction_1;
9D009860  92020011   LBU V0, 17(S0)
87:                          taskEXIT_CRITICAL();
9D009864  0F404EA8   JAL vTaskExitCritical
9D009868  A3A2001A   SB V0, 26(SP)
88:                          bHandle = DRV_I2C_Transmit(desc->devHandle, desc->devAddr, (void *) sbuffer, 3, NULL);
9D00986C  8E040008   LW A0, 8(S0)
9D009870  96050004   LHU A1, 4(S0)
9D009874  AFA00010   SW ZERO, 16(SP)
9D009878  27A60018   ADDIU A2, SP, 24
9D00987C  0F402773   JAL DRV_I2C_Transmit
9D009880  24070003   ADDIU A3, ZERO, 3
9D009884  00408821   ADDU S1, V0, ZERO
89:                          while ((DRV_I2C_TransferStatusGet(desc->devHandle, bHandle) != DRV_I2C_BUFFER_EVENT_COMPLETE) &&
9D009888  24130001   ADDIU S3, ZERO, 1
9D00988C  0B402627   J 0x9D00989C
9D009890  24120002   ADDIU S2, ZERO, 2
9D00989C  8E040008   LW A0, 8(S0)
9D0098A0  0F405682   JAL DRV_I2C_TransferStatusGet
9D0098A4  02202821   ADDU A1, S1, ZERO
9D0098A8  10530006   BEQ V0, S3, 0x9D0098C4
9D0098AC  24020004   ADDIU V0, ZERO, 4
9D0098BC  1452FFF5   BNE V0, S2, 0x9D009894
9D0098C0  24020004   ADDIU V0, ZERO, 4
90:                                  (DRV_I2C_TransferStatusGet(desc->devHandle, bHandle) != DRV_I2C_BUFFER_EVENT_ERROR)) {
9D0098B0  8E040008   LW A0, 8(S0)
9D0098B4  0F405682   JAL DRV_I2C_TransferStatusGet
9D0098B8  02202821   ADDU A1, S1, ZERO
91:                              vTaskDelay(2);
9D009894  0F405001   JAL vTaskDelay
9D009898  02402021   ADDU A0, S2, ZERO
92:                          }
93:                          sbuffer[0] = 0x04; // Porality
94:                          taskENTER_CRITICAL();
9D0098C4  0F405144   JAL vTaskEnterCritical
9D0098C8  A3A20018   SB V0, 24(SP)
95:                          sbuffer[1] = desc->polality_0;
9D0098CC  92020012   LBU V0, 18(S0)
9D0098D0  A3A20019   SB V0, 25(SP)
96:                          sbuffer[2] = desc->polality_1;
9D0098D4  92020013   LBU V0, 19(S0)
97:                          taskEXIT_CRITICAL();
9D0098D8  0F404EA8   JAL vTaskExitCritical
9D0098DC  A3A2001A   SB V0, 26(SP)
98:                          bHandle = DRV_I2C_Transmit(desc->devHandle, desc->devAddr, (void *) sbuffer, 3, NULL);
9D0098E0  8E040008   LW A0, 8(S0)
9D0098E4  96050004   LHU A1, 4(S0)
9D0098E8  AFA00010   SW ZERO, 16(SP)
9D0098EC  27A60018   ADDIU A2, SP, 24
9D0098F0  0F402773   JAL DRV_I2C_Transmit
9D0098F4  24070003   ADDIU A3, ZERO, 3
9D0098F8  00408821   ADDU S1, V0, ZERO
99:                          while ((DRV_I2C_TransferStatusGet(desc->devHandle, bHandle) != DRV_I2C_BUFFER_EVENT_COMPLETE) &&
9D0098FC  24130001   ADDIU S3, ZERO, 1
9D009900  0B402644   J 0x9D009910
9D009904  24120002   ADDIU S2, ZERO, 2
9D009910  8E040008   LW A0, 8(S0)
9D009914  0F405682   JAL DRV_I2C_TransferStatusGet
9D009918  02202821   ADDU A1, S1, ZERO
9D00991C  10530006   BEQ V0, S3, 0x9D009938
9D009920  24020002   ADDIU V0, ZERO, 2
9D009930  1452FFF5   BNE V0, S2, 0x9D009908
9D009934  24020002   ADDIU V0, ZERO, 2
100:                                 (DRV_I2C_TransferStatusGet(desc->devHandle, bHandle) != DRV_I2C_BUFFER_EVENT_ERROR)) {
9D009924  8E040008   LW A0, 8(S0)
9D009928  0F405682   JAL DRV_I2C_TransferStatusGet
9D00992C  02202821   ADDU A1, S1, ZERO
101:                             vTaskDelay(2);
9D009908  0F405001   JAL vTaskDelay
9D00990C  02402021   ADDU A0, S2, ZERO
102:                         }
103:                         sbuffer[0] = 0x02; // Output
104:                         taskENTER_CRITICAL();
9D009938  0F405144   JAL vTaskEnterCritical
9D00993C  A3A20018   SB V0, 24(SP)
105:                         sbuffer[1] = desc->port0_out_data;
9D009940  9202000C   LBU V0, 12(S0)
9D009944  A3A20019   SB V0, 25(SP)
106:                         sbuffer[2] = desc->port1_out_data;
9D009948  9202000D   LBU V0, 13(S0)
107:                         taskEXIT_CRITICAL();
9D00994C  0F404EA8   JAL vTaskExitCritical
9D009950  A3A2001A   SB V0, 26(SP)
108:                         bHandle = DRV_I2C_Transmit(desc->devHandle, desc->devAddr, (void *) sbuffer, 3, NULL);
9D009954  8E040008   LW A0, 8(S0)
9D009958  96050004   LHU A1, 4(S0)
9D00995C  AFA00010   SW ZERO, 16(SP)
9D009960  27A60018   ADDIU A2, SP, 24
9D009964  0F402773   JAL DRV_I2C_Transmit
9D009968  24070003   ADDIU A3, ZERO, 3
9D00996C  00408821   ADDU S1, V0, ZERO
109:                         while ((DRV_I2C_TransferStatusGet(desc->devHandle, bHandle) != DRV_I2C_BUFFER_EVENT_COMPLETE) &&
9D009970  24130001   ADDIU S3, ZERO, 1
9D009974  0B402661   J 0x9D009984
9D009978  24120002   ADDIU S2, ZERO, 2
9D009984  8E040008   LW A0, 8(S0)
9D009988  0F405682   JAL DRV_I2C_TransferStatusGet
9D00998C  02202821   ADDU A1, S1, ZERO
9D009990  50530007   BEQL V0, S3, 0x9D0099B0
9D009994  8E020018   LW V0, 24(S0)
9D0099A4  1452FFF5   BNE V0, S2, 0x9D00997C
9D0099A8  00000000   NOP
110:                                 (DRV_I2C_TransferStatusGet(desc->devHandle, bHandle) != DRV_I2C_BUFFER_EVENT_ERROR)) {
9D009998  8E040008   LW A0, 8(S0)
9D00999C  0F405682   JAL DRV_I2C_TransferStatusGet
9D0099A0  02202821   ADDU A1, S1, ZERO
111:                             vTaskDelay(2);
9D00997C  0F405001   JAL vTaskDelay
9D009980  02402021   ADDU A0, S2, ZERO
112:                         }
113:                     }
114:                     if (desc->close_port != NULL) desc->close_port();
9D0099AC  8E020018   LW V0, 24(S0)
9D0099B0  50400004   BEQL V0, ZERO, 0x9D0099C4
9D0099B4  8E020008   LW V0, 8(S0)
9D0099B8  0040F809   JALR V0
9D0099BC  00000000   NOP
115:                     if (desc->devHandle != DRV_HANDLE_INVALID) {
9D0099C0  8E020008   LW V0, 8(S0)
9D0099C4  24420001   ADDIU V0, V0, 1
116:                         return true;
117:                     }
118:                     return false;
119:                 }
9D0099C8  0002102B   SLTU V0, ZERO, V0
120:                 
121:                 bool DRV_PCA9655_Init(int num, DRV_HANDLE handle, PCA9655_t *desc, uint16_t devaddr, PCA9655_INIT_t *init)
122:                 {
9D0110B8  27BDFFE8   ADDIU SP, SP, -24
9D0110BC  AFBF0014   SW RA, 20(SP)
123:                     if (desc == NULL) return false;
9D0110C0  10C00029   BEQ A2, ZERO, 0x9D011168
9D0110C4  8FA20028   LW V0, 40(SP)
9D011168  00001021   ADDU V0, ZERO, ZERO
124:                     desc->devAddr = devaddr & 0xfffe;
9D0110C8  7C070004   INS A3, ZERO, 0, 1
9D0110CC  A4C70004   SH A3, 4(A2)
125:                     desc->num = num;
9D0110D0  ACC40000   SW A0, 0(A2)
126:                     desc->devHandle = handle;
127:                     if (init == NULL) {
9D0110D4  1440000D   BNE V0, ZERO, 0x9D01110C
9D0110D8  ACC50008   SW A1, 8(A2)
128:                         desc->port0_in_data = 0;
9D0110DC  A0C0000E   SB ZERO, 14(A2)
129:                         desc->port1_in_data = 0;
9D0110E0  A0C0000F   SB ZERO, 15(A2)
130:                         desc->port0_out_data = 0xff;
9D0110E4  2402FFFF   ADDIU V0, ZERO, -1
9D0110E8  A0C2000C   SB V0, 12(A2)
131:                         desc->port1_out_data = 0xff;
9D0110EC  A0C2000D   SB V0, 13(A2)
132:                         desc->direction_0 = 0xff;
9D0110F0  A0C20010   SB V0, 16(A2)
133:                         desc->direction_1 = 0xff;
9D0110F4  A0C20011   SB V0, 17(A2)
134:                         desc->polality_0 = 0x00;
9D0110F8  A0C00012   SB ZERO, 18(A2)
135:                         desc->polality_1 = 0x00;
9D0110FC  A0C00013   SB ZERO, 19(A2)
136:                         desc->open_port = NULL;
9D011100  ACC00014   SW ZERO, 20(A2)
9D011104  0B404453   J 0x9D01114C
9D011108  ACC00018   SW ZERO, 24(A2)
137:                         desc->close_port = NULL;
138:                     } else {
139:                         desc->port0_out_data = init->data_0;
9D01110C  90430004   LBU V1, 4(V0)
9D011110  A0C3000C   SB V1, 12(A2)
140:                         desc->port1_out_data = init->data_1;
9D011114  90430005   LBU V1, 5(V0)
9D011118  A0C3000D   SB V1, 13(A2)
141:                         desc->direction_0 = init->direction_0;
9D01111C  90430000   LBU V1, 0(V0)
9D011120  A0C30010   SB V1, 16(A2)
142:                         desc->direction_1 = init->direction_1;
9D011124  90430001   LBU V1, 1(V0)
9D011128  A0C30011   SB V1, 17(A2)
143:                         desc->polality_0 = init->polality_0;
9D01112C  90430002   LBU V1, 2(V0)
9D011130  A0C30012   SB V1, 18(A2)
144:                         desc->polality_1 = init->polality_1;
9D011134  90430003   LBU V1, 3(V0)
9D011138  A0C30013   SB V1, 19(A2)
145:                         desc->open_port = init->open_port;
9D01113C  8C430008   LW V1, 8(V0)
9D011140  ACC30014   SW V1, 20(A2)
146:                         desc->close_port = init->close_port;
9D011144  8C42000C   LW V0, 12(V0)
9D011148  ACC20018   SW V0, 24(A2)
147:                     }
148:                     return DRV_PCA9655_Reset(desc, 0, 0, false);
9D01114C  00C02021   ADDU A0, A2, ZERO
9D011150  00002821   ADDU A1, ZERO, ZERO
9D011154  00003021   ADDU A2, ZERO, ZERO
9D011158  0F4025FD   JAL DRV_PCA9655_Reset
9D01115C  00003821   ADDU A3, ZERO, ZERO
9D011160  0B40445C   J 0x9D011170
9D011164  8FBF0014   LW RA, 20(SP)
149:                 }
9D01116C  8FBF0014   LW RA, 20(SP)
150:                 
151:                 uint8_t DRV_PCA9655_GetPort_Uint8(void *p, int port)
152:                 {
9D00F060  27BDFFC0   ADDIU SP, SP, -64
9D00F064  AFBF003C   SW RA, 60(SP)
9D00F068  AFB40038   SW S4, 56(SP)
9D00F06C  AFB30034   SW S3, 52(SP)
9D00F070  AFB20030   SW S2, 48(SP)
9D00F074  AFB1002C   SW S1, 44(SP)
9D00F078  AFB00028   SW S0, 40(SP)
153:                     uint8_t sbuf[2];
154:                     uint8_t rbuf[2];
155:                     PCA9655_t *desc = (PCA9655_t *) p;
156:                     DRV_I2C_BUFFER_HANDLE bHandle;
157:                     if (desc == NULL) return 0x00;
9D00F07C  10800037   BEQ A0, ZERO, 0x9D00F15C
9D00F080  00808021   ADDU S0, A0, ZERO
9D00F084  00A09821   ADDU S3, A1, ZERO
9D00F15C  00001021   ADDU V0, ZERO, ZERO
158:                     if ((port < 0) || (port > 1)) return 0x00;
9D00F088  2CA30002   SLTIU V1, A1, 2
9D00F08C  10600034   BEQ V1, ZERO, 0x9D00F160
9D00F090  00001021   ADDU V0, ZERO, ZERO
159:                     rbuf[0] = 0x00;
9D00F094  A3A00024   SB ZERO, 36(SP)
160:                     rbuf[1] = 0x00;
9D00F098  A3A00025   SB ZERO, 37(SP)
161:                 
162:                     if (desc->open_port != NULL) desc->open_port();
9D00F09C  8C820014   LW V0, 20(A0)
9D00F0A0  50400004   BEQL V0, ZERO, 0x9D00F0B4
9D00F0A4  8E040008   LW A0, 8(S0)
9D00F0A8  0040F809   JALR V0
9D00F0AC  00000000   NOP
163:                     if (desc->devHandle != DRV_HANDLE_INVALID) {
9D00F0B0  8E040008   LW A0, 8(S0)
9D00F0B4  2402FFFF   ADDIU V0, ZERO, -1
9D00F0B8  1082001A   BEQ A0, V0, 0x9D00F124
9D00F0BC  27A20024   ADDIU V0, SP, 36
164:                         sbuf[0] = 0x00; // Output
9D00F0C0  A3A00020   SB ZERO, 32(SP)
165:                         bHandle = DRV_I2C_TransmitThenReceive(desc->devHandle, desc->devAddr, sbuf, 1, rbuf, 2, NULL);
9D00F0C4  96050004   LHU A1, 4(S0)
9D00F0C8  AFA20010   SW V0, 16(SP)
9D00F0CC  24020002   ADDIU V0, ZERO, 2
9D00F0D0  AFA20014   SW V0, 20(SP)
9D00F0D4  AFA00018   SW ZERO, 24(SP)
9D00F0D8  27A60020   ADDIU A2, SP, 32
9D00F0DC  0F40267A   JAL DRV_I2C_TransmitThenReceive
9D00F0E0  24070001   ADDIU A3, ZERO, 1
9D00F0E4  00408821   ADDU S1, V0, ZERO
166:                         while ((DRV_I2C_TransferStatusGet(desc->devHandle, bHandle) != DRV_I2C_BUFFER_EVENT_COMPLETE) &&
9D00F0E8  24140001   ADDIU S4, ZERO, 1
9D00F0EC  0B403C3F   J 0x9D00F0FC
9D00F0F0  24120002   ADDIU S2, ZERO, 2
9D00F0FC  8E040008   LW A0, 8(S0)
9D00F100  0F405682   JAL DRV_I2C_TransferStatusGet
9D00F104  02202821   ADDU A1, S1, ZERO
9D00F108  10540006   BEQ V0, S4, 0x9D00F124
9D00F10C  00000000   NOP
9D00F11C  1452FFF5   BNE V0, S2, 0x9D00F0F4
9D00F120  00000000   NOP
167:                                 (DRV_I2C_TransferStatusGet(desc->devHandle, bHandle) != DRV_I2C_BUFFER_EVENT_ERROR)) {
9D00F110  8E040008   LW A0, 8(S0)
9D00F114  0F405682   JAL DRV_I2C_TransferStatusGet
9D00F118  02202821   ADDU A1, S1, ZERO
168:                             vTaskDelay(2);
9D00F0F4  0F405001   JAL vTaskDelay
9D00F0F8  02402021   ADDU A0, S2, ZERO
169:                         }
170:                     }
171:                     taskENTER_CRITICAL();
9D00F124  0F405144   JAL vTaskEnterCritical
9D00F128  00000000   NOP
172:                     desc->port0_in_data = rbuf[0];
9D00F12C  93A20024   LBU V0, 36(SP)
9D00F130  A202000E   SB V0, 14(S0)
173:                     desc->port1_in_data = rbuf[1];
9D00F134  93A20025   LBU V0, 37(SP)
174:                     taskEXIT_CRITICAL();
9D00F138  0F404EA8   JAL vTaskExitCritical
9D00F13C  A202000F   SB V0, 15(S0)
175:                     if (desc->close_port != NULL) desc->close_port();
9D00F140  8E020018   LW V0, 24(S0)
9D00F144  10400003   BEQ V0, ZERO, 0x9D00F154
9D00F148  03B39821   ADDU S3, SP, S3
9D00F14C  0040F809   JALR V0
9D00F150  00000000   NOP
176:                     return rbuf[port];
9D00F154  0B403C58   J 0x9D00F160
9D00F158  92620024   LBU V0, 36(S3)
177:                 }
9D00F160  8FBF003C   LW RA, 60(SP)
178:                 
179:                 bool DRV_PCA9655_GetPort_Bit(void *p, uint32_t bit)
180:                 {
9D01489C  27BDFFE8   ADDIU SP, SP, -24
9D0148A0  AFBF0014   SW RA, 20(SP)
9D0148A4  AFB00010   SW S0, 16(SP)
9D0148A8  00A08021   ADDU S0, A1, ZERO
181:                     int port;
182:                     uint8_t dat;
183:                     PCA9655_t *desc = (PCA9655_t *) p;
184:                 
185:                     if (bit >= 16) return false;
9D0148AC  2CA30010   SLTIU V1, A1, 16
9D0148B0  10600006   BEQ V1, ZERO, 0x9D0148CC
9D0148B4  00001021   ADDU V0, ZERO, ZERO
186:                     port = (int) (bit & 8);
187:                     dat = DRV_PCA9655_GetPort_Uint8(desc, port);
9D0148B8  0F403C18   JAL DRV_PCA9655_GetPort_Uint8
9D0148BC  30A50008   ANDI A1, A1, 8
188:                     dat = (dat >> (bit & 0x07)) & 1;
9D0148C0  32100007   ANDI S0, S0, 7
9D0148C4  02021007   SRAV V0, V0, S0
189:                     if (dat == 0) return false;
9D0148C8  30420001   ANDI V0, V0, 1
190:                     return true;
191:                 }
9D0148CC  8FBF0014   LW RA, 20(SP)
192:                 
193:                 void DRV_PCA9655_SetPort(void *p, int bitnum, bool set)
194:                 {
9D00BEE4  27BDFFC8   ADDIU SP, SP, -56
9D00BEE8  AFBF0034   SW RA, 52(SP)
9D00BEEC  AFB30030   SW S3, 48(SP)
9D00BEF0  AFB2002C   SW S2, 44(SP)
9D00BEF4  AFB10028   SW S1, 40(SP)
9D00BEF8  AFB00024   SW S0, 36(SP)
195:                     uint8_t sbuf[3];
196:                     DRV_I2C_BUFFER_HANDLE bHandle;
197:                     PCA9655_t *desc = (PCA9655_t *) p;
198:                     if ((bitnum >= 16) || (bitnum < 0)) return;
9D00BEFC  2CA20010   SLTIU V0, A1, 16
9D00BF00  10400058   BEQ V0, ZERO, 0x9D00C064
9D00BF04  00A08821   ADDU S1, A1, ZERO
199:                     if (desc == NULL) return;
9D00BF08  10800056   BEQ A0, ZERO, 0x9D00C064
9D00BF0C  00808021   ADDU S0, A0, ZERO
200:                     if (desc->open_port != NULL) desc->open_port();
9D00BF10  8C820014   LW V0, 20(A0)
9D00BF14  10400003   BEQ V0, ZERO, 0x9D00BF24
9D00BF18  00C09021   ADDU S2, A2, ZERO
9D00BF1C  0040F809   JALR V0
9D00BF20  00000000   NOP
201:                     if (set) {
9D00BF24  12400015   BEQ S2, ZERO, 0x9D00BF7C
9D00BF28  00000000   NOP
202:                         taskENTER_CRITICAL();
9D00BF2C  0F405144   JAL vTaskEnterCritical
9D00BF30  00000000   NOP
203:                         if (bitnum < 8) {
9D00BF34  2A220008   SLTI V0, S1, 8
9D00BF38  50400007   BEQL V0, ZERO, 0x9D00BF58
9D00BF3C  2631FFF8   ADDIU S1, S1, -8
204:                             desc->port0_out_data |= (1 << bitnum);
9D00BF40  24020001   ADDIU V0, ZERO, 1
9D00BF44  02228804   SLLV S1, V0, S1
9D00BF48  9202000C   LBU V0, 12(S0)
9D00BF4C  02228825   OR S1, S1, V0
9D00BF50  0B402FDB   J 0x9D00BF6C
9D00BF54  A211000C   SB S1, 12(S0)
205:                         } else {
206:                             desc->port1_out_data |= (1 << (bitnum - 8));
9D00BF58  24020001   ADDIU V0, ZERO, 1
9D00BF5C  02228804   SLLV S1, V0, S1
9D00BF60  9202000D   LBU V0, 13(S0)
9D00BF64  02221025   OR V0, S1, V0
9D00BF68  A202000D   SB V0, 13(S0)
207:                         }
208:                         taskEXIT_CRITICAL();
9D00BF6C  0F404EA8   JAL vTaskExitCritical
9D00BF70  00000000   NOP
9D00BF74  0B402FF4   J 0x9D00BFD0
9D00BF78  8E030008   LW V1, 8(S0)
209:                     } else {
210:                         taskENTER_CRITICAL();
9D00BF7C  0F405144   JAL vTaskEnterCritical
9D00BF80  00000000   NOP
211:                         if (bitnum < 8) {
9D00BF84  2A220008   SLTI V0, S1, 8
9D00BF88  50400008   BEQL V0, ZERO, 0x9D00BFAC
9D00BF8C  2631FFF8   ADDIU S1, S1, -8
212:                             desc->port0_out_data &= (uint8_t) (~(1 << bitnum));
9D00BF90  24020001   ADDIU V0, ZERO, 1
9D00BF94  02228804   SLLV S1, V0, S1
9D00BF98  00118827   NOR S1, ZERO, S1
9D00BF9C  9202000C   LBU V0, 12(S0)
9D00BFA0  02221024   AND V0, S1, V0
9D00BFA4  0B402FF1   J 0x9D00BFC4
9D00BFA8  A202000C   SB V0, 12(S0)
213:                         } else {
214:                             desc->port1_out_data &= (uint8_t) (~(1 << (bitnum - 8)));
9D00BFAC  24030001   ADDIU V1, ZERO, 1
9D00BFB0  02231804   SLLV V1, V1, S1
9D00BFB4  00031827   NOR V1, ZERO, V1
9D00BFB8  9202000D   LBU V0, 13(S0)
9D00BFBC  00621024   AND V0, V1, V0
9D00BFC0  A202000D   SB V0, 13(S0)
215:                         }
216:                         taskEXIT_CRITICAL();
9D00BFC4  0F404EA8   JAL vTaskExitCritical
9D00BFC8  00000000   NOP
217:                     }
218:                     if (desc->devHandle != DRV_HANDLE_INVALID) {
9D00BFCC  8E030008   LW V1, 8(S0)
9D00BFD0  2402FFFF   ADDIU V0, ZERO, -1
9D00BFD4  1062001E   BEQ V1, V0, 0x9D00C050
9D00BFD8  24020002   ADDIU V0, ZERO, 2
219:                         sbuf[0] = 0x02; // Output
220:                         taskENTER_CRITICAL();
9D00BFDC  0F405144   JAL vTaskEnterCritical
9D00BFE0  A3A20018   SB V0, 24(SP)
221:                         sbuf[1] = desc->port0_out_data;
9D00BFE4  9202000C   LBU V0, 12(S0)
9D00BFE8  A3A20019   SB V0, 25(SP)
222:                         sbuf[2] = desc->port1_out_data;
9D00BFEC  9202000D   LBU V0, 13(S0)
223:                         taskEXIT_CRITICAL();
9D00BFF0  0F404EA8   JAL vTaskExitCritical
9D00BFF4  A3A2001A   SB V0, 26(SP)
224:                         bHandle = DRV_I2C_Transmit(desc->devHandle, desc->devAddr, (void *) sbuf, 3, NULL);
9D00BFF8  8E040008   LW A0, 8(S0)
9D00BFFC  96050004   LHU A1, 4(S0)
9D00C000  AFA00010   SW ZERO, 16(SP)
9D00C004  27A60018   ADDIU A2, SP, 24
9D00C008  0F402773   JAL DRV_I2C_Transmit
9D00C00C  24070003   ADDIU A3, ZERO, 3
9D00C010  00408821   ADDU S1, V0, ZERO
225:                         while ((DRV_I2C_TransferStatusGet(desc->devHandle, bHandle) != DRV_I2C_BUFFER_EVENT_COMPLETE) &&
9D00C014  24120001   ADDIU S2, ZERO, 1
9D00C018  0B40300A   J 0x9D00C028
9D00C01C  24130002   ADDIU S3, ZERO, 2
9D00C028  8E040008   LW A0, 8(S0)
9D00C02C  0F405682   JAL DRV_I2C_TransferStatusGet
9D00C030  02202821   ADDU A1, S1, ZERO
9D00C034  50520007   BEQL V0, S2, 0x9D00C054
9D00C038  8E020018   LW V0, 24(S0)
9D00C048  1453FFF5   BNE V0, S3, 0x9D00C020
9D00C04C  00000000   NOP
226:                                 (DRV_I2C_TransferStatusGet(desc->devHandle, bHandle) != DRV_I2C_BUFFER_EVENT_ERROR)) {
9D00C03C  8E040008   LW A0, 8(S0)
9D00C040  0F405682   JAL DRV_I2C_TransferStatusGet
9D00C044  02202821   ADDU A1, S1, ZERO
227:                             vTaskDelay(3);
9D00C020  0F405001   JAL vTaskDelay
9D00C024  24040003   ADDIU A0, ZERO, 3
228:                         }
229:                     }
230:                     if (desc->close_port != NULL) desc->close_port();
9D00C050  8E020018   LW V0, 24(S0)
9D00C054  10400004   BEQ V0, ZERO, 0x9D00C068
9D00C058  8FBF0034   LW RA, 52(SP)
9D00C05C  0040F809   JALR V0
9D00C060  00000000   NOP
231:                 }
9D00C064  8FBF0034   LW RA, 52(SP)
232:                 
233:                 void DRV_PCA9655_SetPort_Uint8(void *p, int port, uint8_t val)
234:                 {
235:                     uint8_t sbuf[3];
236:                     DRV_I2C_BUFFER_HANDLE bHandle;
237:                     PCA9655_t *desc = (PCA9655_t *) p;
238:                     if ((port > 1) || (port < 0)) return;
239:                     if (desc == NULL) return;
240:                     if (desc->open_port != NULL) desc->open_port();
241:                     taskENTER_CRITICAL();
242:                     if (port == 0) {
243:                         desc->port0_out_data = val;
244:                         sbuf[1] = val;
245:                         sbuf[2] = desc->port1_out_data;
246:                     } else {
247:                         desc->port1_out_data = val;
248:                         sbuf[1] = desc->port0_out_data;
249:                         sbuf[2] = val;
250:                     }
251:                     taskEXIT_CRITICAL();
252:                     if (desc->devHandle != DRV_HANDLE_INVALID) {
253:                         sbuf[0] = 0x02; // Output
254:                         bHandle = DRV_I2C_Transmit(desc->devHandle, desc->devAddr, (void *) sbuf, 3, NULL);
255:                         while ((DRV_I2C_TransferStatusGet(desc->devHandle, bHandle) != DRV_I2C_BUFFER_EVENT_COMPLETE) &&
256:                                 (DRV_I2C_TransferStatusGet(desc->devHandle, bHandle) != DRV_I2C_BUFFER_EVENT_ERROR)) {
257:                             vTaskDelay(2);
258:                         }
259:                     }
260:                     if (desc->close_port != NULL) desc->close_port();
261:                 }
262:                 
263:                 void DRV_PCA9655_SetReg(PCA9655_t *desc, uint32_t regnum, uint8_t val)
264:                 {
265:                     uint8_t sbuf[2];
266:                     DRV_I2C_BUFFER_HANDLE bHandle;
267:                     if (desc == NULL) return;
268:                     if (desc->open_port != NULL) desc->open_port();
269:                     if (desc->devHandle != DRV_HANDLE_INVALID) {
270:                         sbuf[0] = regnum & 7; // Output
271:                         sbuf[1] = val;
272:                         bHandle = DRV_I2C_Transmit(desc->devHandle, desc->devAddr, (void *) sbuf, 2, NULL);
273:                         while ((DRV_I2C_TransferStatusGet(desc->devHandle, bHandle) != DRV_I2C_BUFFER_EVENT_COMPLETE) &&
274:                                 (DRV_I2C_TransferStatusGet(desc->devHandle, bHandle) != DRV_I2C_BUFFER_EVENT_ERROR)) {
275:                             vTaskDelay(2);
276:                         }
277:                     }
278:                     if (desc->close_port != NULL) desc->close_port();
279:                 }
280:                 
281:                 uint8_t DRV_PCA9655_GetReg(PCA9655_t *desc, uint32_t regnum)
282:                 {
283:                     uint8_t sbuf[2];
284:                     uint8_t rbuf[4];
285:                     DRV_I2C_BUFFER_HANDLE bHandle;
286:                     if (desc == NULL) return 0x00;
287:                     rbuf[0] = 0x00;
288:                     rbuf[1] = 0x00;
289:                     rbuf[2] = 0x00;
290:                     rbuf[3] = 0x00;
291:                     if (desc->open_port != NULL) desc->open_port();
292:                     if (desc->devHandle != DRV_HANDLE_INVALID) {
293:                         sbuf[0] = regnum & 7; // Output
294:                         bHandle = DRV_I2C_TransmitThenReceive(desc->devHandle, desc->devAddr, sbuf, 1, rbuf, 1, NULL);
295:                         while ((DRV_I2C_TransferStatusGet(desc->devHandle, bHandle) != DRV_I2C_BUFFER_EVENT_COMPLETE) &&
296:                                 (DRV_I2C_TransferStatusGet(desc->devHandle, bHandle) != DRV_I2C_BUFFER_EVENT_ERROR)) {
297:                             vTaskDelay(2);
298:                         }
299:                     }
300:                     if (desc->close_port != NULL) desc->close_port();
301:                     return rbuf[0];
302:                 }
303:                 
304:                 void DRV_PCA9655_GetRegs(PCA9655_t *desc, uint8_t *buf)
305:                 {
306:                     uint8_t sbuf[2];
307:                     uint8_t regnum;
308:                     DRV_I2C_BUFFER_HANDLE bHandle;
309:                     if(buf == NULL) return;
310:                     if (desc == NULL) return;
311:                     if (desc->open_port != NULL) desc->open_port();
312:                     if (desc->devHandle != DRV_HANDLE_INVALID) {
313:                         regnum = 0;
314:                         while (regnum < 8) {
315:                             sbuf[0] = regnum & 7; // Output
316:                             bHandle = DRV_I2C_TransmitThenReceive(desc->devHandle, desc->devAddr, sbuf, 1, &(buf[regnum]), 1, NULL);
317:                             while ((DRV_I2C_TransferStatusGet(desc->devHandle, bHandle) != DRV_I2C_BUFFER_EVENT_COMPLETE) &&
318:                                     (DRV_I2C_TransferStatusGet(desc->devHandle, bHandle) != DRV_I2C_BUFFER_EVENT_ERROR)) {
319:                                 vTaskDelay(2);
320:                             }
321:                             regnum++;
322:                         }
323:                 
324:                     }
325:                     if (desc->close_port != NULL) desc->close_port();
326:                     return;
327:                 }
---  /home/whatisthis/src/DoorBell_PIC32/firmware/src/passthrough.c  ------------------------------------
1:                   
2:                   /*******************************************************************************
3:                     MPLAB Harmony Project Main Source File
4:                   
5:                     Company:
6:                       Microchip Technology Inc.
7:                     
8:                     File Name:
9:                       passthrough.c
10:                  
11:                    Summary:
12:                      Pass through via UART and USB task(s).
13:                  
14:                    Description:
15:                      This file contains the "main" function for an MPLAB Harmony project.  The
16:                      "main" function calls the "SYS_Initialize" function to initialize the state 
17:                      machines of all MPLAB Harmony modules in the system and it calls the 
18:                      "SYS_Tasks" function from within a system-wide "super" loop to maintain 
19:                      their correct operation. These two functions are implemented in 
20:                      configuration-specific files (usually "system_init.c" and "system_tasks.c")
21:                      in a configuration-specific folder under the "src/system_config" folder 
22:                      within this project's top-level folder.  An MPLAB Harmony project may have
23:                      more than one configuration, each contained within it's own folder under
24:                      the "system_config" folder.
25:                   *******************************************************************************/
26:                  
27:                  // DOM-IGNORE-BEGIN
28:                  /******************************************************************************
29:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
30:                  
31:                  //Microchip licenses to you the right to use, modify, copy and distribute
32:                  Software only when embedded on a Microchip microcontroller or digital signal
33:                  controller that is integrated into your product or third party product
34:                  (pursuant to the sublicense terms in the accompanying license agreement).
35:                  
36:                  You should refer to the license agreement accompanying this Software for
37:                  additional information regarding your rights and obligations.
38:                  
39:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
40:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
41:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
42:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
43:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
44:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
45:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
46:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
47:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
48:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
49:                   *******************************************************************************/
50:                  // DOM-IGNORE-END
51:                  
52:                  // *****************************************************************************
53:                  // *****************************************************************************
54:                  // Section: Included Files
55:                  // *****************************************************************************
56:                  // *****************************************************************************
57:                  
58:                  #include <stddef.h>                     // Defines NULL
59:                  #include <stdbool.h>                    // Defines true
60:                  #include <stdlib.h>                     // Defines EXIT_FAILURE
61:                  #include "system/common/sys_module.h"
62:                  #include "doorbell.h"   // SYS function prototypes
63:                  /* Kernel includes. */
64:                  #include "FreeRTOS.h"
65:                  #include "task.h"
66:                  #include "queue.h"
67:                  #include "timers.h"
68:                  #include "semphr.h"
69:                  
70:                  static char rdUsbBuf[128];
71:                  static char wrUsbBuf[128];
72:                  static char rdTmpUsbBuf[32];
73:                  static char wrTmpUsbBuf[32];
74:                  static char *rdUsbPtr;
75:                  static char *wrUsbPtr;
76:                  static ssize_t rdUsbSize;
77:                  static ssize_t wrUsbSize;
78:                  const ssize_t rdUsbSizeLimit = 128;
79:                  const ssize_t wrUsbSizeLimit = 128;
80:                  
81:                  static SemaphoreHandle_t xUsbRdSemaphore;
82:                  static SemaphoreHandle_t xUsbWrSemaphore;
83:                  
84:                  #if 0
85:                  static consoleCallbackFunction cbUsbWriteComplete(void *handle)
86:                  {
87:                  	//SYS_PORTS_PinWrite(PORTS_ID_0, PORT_CHANNEL_B, 3, false); // Set LED OFF
88:                  }
89:                  
90:                  static consoleCallbackFunction cbUsbReadComplete(void *handle)
91:                  {
92:                  	char *p = rdTmpUsbBuf;
93:                  	ssize_t size = (ssize_t)handle;
94:                  
95:                  	if(size >= 0) {
96:                  		rdUsbSize += size;
97:                  		if(rdUsbSize <= rdUsbSizeLimit) {
98:                  			if(rdUsbPtr != NULL) {
99:                  				memcpy(rdUsbPtr, p, size);
100:                 				rdUsbPtr += size;
101:                 			}
102:                 		}
103:                 	}
104:                 	if(xUsbRdSemaphore != NULL) xSemaphoreGive(xUsbRdSemaphore);
105:                 }
106:                 #endif
107:                 
108:                 void prvReadFromUsb(void *pvparameters)
109:                 {
9D01076C  27BDFFD8   ADDIU SP, SP, -40
9D010770  AFBF0024   SW RA, 36(SP)
9D010774  AFB20020   SW S2, 32(SP)
9D010778  AFB1001C   SW S1, 28(SP)
9D01077C  AFB00018   SW S0, 24(SP)
110:                     volatile SYS_STATUS usbConsoleStatus;
111:                 	ssize_t _len;
112:                 	bool before_attached = true;
9D0107B0  24100001   ADDIU S0, ZERO, 1
113:                 	
114:                 	rdUsbSize = 0;
9D010780  AF808030   SW ZERO, -32720(GP)
115:                 	rdUsbPtr = NULL;
9D010784  AF808038   SW ZERO, -32712(GP)
116:                 	xUsbRdSemaphore = xSemaphoreCreateBinary();
9D010788  24040001   ADDIU A0, ZERO, 1
9D01078C  00002821   ADDU A1, ZERO, ZERO
9D010790  0F4048CD   JAL xQueueGenericCreate
9D010794  24060003   ADDIU A2, ZERO, 3
117:                 	if(xUsbRdSemaphore == NULL) return;
9D010798  10400027   BEQ V0, ZERO, 0x9D010838
9D01079C  AF828028   SW V0, -32728(GP)
118:                 
119:                 	//SYS_CONSOLE_RegisterCallback(SYS_CONSOLE_INDEX_0, cbUsbReadComplete, SYS_CONSOLE_EVENT_READ_COMPLETE);
120:                 
121:                 	rdUsbSize = 0;
9D0107A0  AF808030   SW ZERO, -32720(GP)
122:                 	rdUsbPtr = rdUsbBuf;
9D0107A4  3C02A000   LUI V0, -24576
9D0107A8  244271E4   ADDIU V0, V0, 29156
9D0107AC  AF828038   SW V0, -32712(GP)
123:                 
124:                 	while(1) {
125:                 		//usbConsoleStatus = SYS_CONSOLE_Status(sysObj.sysConsole0);
126:                 		if(usbConsoleStatus >= SYS_STATUS_READY) {
9D0107C4  8FA20010   LW V0, 16(SP)
9D0107C8  28420002   SLTI V0, V0, 2
9D0107CC  1440000C   BNE V0, ZERO, 0x9D010800
9D0107D0  8F828030   LW V0, -32720(GP)
127:                 			if(rdUsbSize > 0) {
9D0107D4  1840FFFA   BLEZ V0, 0x9D0107C0
9D0107D8  00511821   ADDU V1, V0, S1
128:                 				if((rdUsbBuf[rdUsbSize - 1] == '\n') || (rdUsbSize >= rdUsbSizeLimit)) {
9D0107B8  0B4041F1   J 0x9D0107C4
9D0107BC  2412000A   ADDIU S2, ZERO, 10
9D0107DC  8063FFFF   LB V1, -1(V1)
9D0107E0  10720003   BEQ V1, S2, 0x9D0107F0
9D0107E4  28420080   SLTI V0, V0, 128
9D0107E8  1440FFF6   BNE V0, ZERO, 0x9D0107C4
9D0107EC  24100001   ADDIU S0, ZERO, 1
129:                 					_len = rdUsbSize;
130:                 					//_len = SYS_CONSOLE_Write(SYS_CONSOLE_INDEX_1, STDOUT_FILENO, rdUsbBuf, _len);
131:                 					rdUsbPtr = rdUsbBuf;
9D0107F0  AF918038   SW S1, -32712(GP)
132:                 					rdUsbSize = 0;
9D0107F4  AF808030   SW ZERO, -32720(GP)
133:                 				}
134:                 			}
135:                 			before_attached = true;
9D0107C0  24100001   ADDIU S0, ZERO, 1
9D0107F8  0B4041F1   J 0x9D0107C4
9D0107FC  24100001   ADDIU S0, ZERO, 1
136:                 			_len = 1;
137:                 			//_len = SYS_CONSOLE_Read(SYS_CONSOLE_INDEX_0, STDIN_FILENO, rdTmpUsbBuf, _len);
138:                 			//while((xSemaphoreTake(xUsbRdSemaphore, cTick1Sec) != pdPASS) && (usbConsoleStatus >= SYS_STATUS_READY)) {
139:                 			//		usbConsoleStatus = SYS_CONSOLE_Status(sysObj.sysConsole0);
140:                 			//}
141:                 		} else {
142:                 			if(before_attached) {
9D010800  12000009   BEQ S0, ZERO, 0x9D010828
9D010804  00002821   ADDU A1, ZERO, ZERO
143:                 				rdUsbSize = 0;
9D010808  AF808030   SW ZERO, -32720(GP)
144:                 				rdUsbPtr = rdUsbBuf;
9D0107B4  00408821   ADDU S1, V0, ZERO
9D01080C  AF918038   SW S1, -32712(GP)
145:                 				xSemaphoreGive(xUsbRdSemaphore);
9D010810  8F848028   LW A0, -32728(GP)
9D010814  00003021   ADDU A2, ZERO, ZERO
9D010818  0F401FB3   JAL xQueueGenericSend
9D01081C  00003821   ADDU A3, ZERO, ZERO
9D010820  0B4041F1   J 0x9D0107C4
9D010824  00008021   ADDU S0, ZERO, ZERO
146:                 				before_attached = false;
147:                 			} else {
148:                 				vTaskDelay(cTick1Sec);
9D010828  0F405001   JAL vTaskDelay
9D01082C  8F848130   LW A0, -32464(GP)
9D010830  0B4041F1   J 0x9D0107C4
9D010834  00000000   NOP
149:                 			}
150:                 		}
151:                 	}
152:                 }
9D010838  8FBF0024   LW RA, 36(SP)
9D01083C  8FB20020   LW S2, 32(SP)
9D010840  8FB1001C   LW S1, 28(SP)
9D010844  8FB00018   LW S0, 24(SP)
9D010848  03E00008   JR RA
9D01084C  27BD0028   ADDIU SP, SP, 40
153:                 
154:                 #if 0
155:                 static consoleCallbackFunction cbUartReadComplete(void *handle)
156:                 {
157:                 	char *p = wrTmpUsbBuf;
158:                 	ssize_t size = (ssize_t)handle;
159:                 
160:                 	if(size >= 0) {
161:                 		wrUsbSize += size;
162:                 		if(wrUsbSize <= wrUsbSizeLimit) {
163:                 			if(wrUsbPtr != NULL) {
164:                 				memcpy(wrUsbPtr, p, size);
165:                 				wrUsbPtr += size;
166:                 			}
167:                 		}
168:                 	}
169:                 	if(xUsbWrSemaphore != NULL) xSemaphoreGive(xUsbWrSemaphore);
170:                 }
171:                 #endif
172:                 
173:                 void prvWriteToUsb(void *pvparameters)
174:                 {
9D0112F8  27BDFFE0   ADDIU SP, SP, -32
9D0112FC  AFBF001C   SW RA, 28(SP)
9D011300  AFB20018   SW S2, 24(SP)
9D011304  AFB10014   SW S1, 20(SP)
9D011308  AFB00010   SW S0, 16(SP)
175:                     volatile SYS_STATUS usbConsoleStatus;
176:                 	ssize_t _len;
177:                 	bool before_attached = true;
178:                 	
179:                 	wrUsbSize = 0;
9D01130C  AF80802C   SW ZERO, -32724(GP)
180:                 	wrUsbPtr = NULL;
9D011310  AF808034   SW ZERO, -32716(GP)
181:                 	xUsbWrSemaphore = xSemaphoreCreateBinary();
9D011314  24040001   ADDIU A0, ZERO, 1
9D011318  00002821   ADDU A1, ZERO, ZERO
9D01131C  0F4048CD   JAL xQueueGenericCreate
9D011320  24060003   ADDIU A2, ZERO, 3
182:                 	if(xUsbWrSemaphore == NULL) return;
9D011324  1040001D   BEQ V0, ZERO, 0x9D01139C
9D011328  AF828024   SW V0, -32732(GP)
183:                 
184:                 	//SYS_CONSOLE_RegisterCallback(SYS_CONSOLE_INDEX_1, cbUartReadComplete, SYS_CONSOLE_EVENT_READ_COMPLETE);
185:                 	//SYS_CONSOLE_RegisterCallback(SYS_CONSOLE_INDEX_0, cbUsbWriteComplete, SYS_CONSOLE_EVENT_WRITE_COMPLETE);
186:                 
187:                 	wrUsbSize = 0;
9D01132C  AF80802C   SW ZERO, -32724(GP)
188:                 	wrUsbPtr = wrUsbBuf;
9D011330  3C02A000   LUI V0, -24576
9D011334  24427164   ADDIU V0, V0, 29028
9D011338  AF828034   SW V0, -32716(GP)
189:                 	//SYS_PORTS_PinWrite(PORTS_ID_0, PORT_CHANNEL_B, 3, false); // Set LED OFF
190:                 	while(1) {
191:                 		_len = 1;
192:                 		//_len = SYS_CONSOLE_Read(SYS_CONSOLE_INDEX_1, STDIN_FILENO, wrTmpUsbBuf, _len);
193:                 		while(xSemaphoreTake(xUsbWrSemaphore, cTick1Sec) != pdPASS) {}
9D01133C  24100001   ADDIU S0, ZERO, 1
9D011348  8F848024   LW A0, -32732(GP)
9D01134C  00002821   ADDU A1, ZERO, ZERO
9D011350  8F868130   LW A2, -32464(GP)
9D011354  0F401E81   JAL xQueueGenericReceive
9D011358  00003821   ADDU A3, ZERO, ZERO
9D01135C  1450FFFB   BNE V0, S0, 0x9D01134C
9D011360  8F848024   LW A0, -32732(GP)
194:                 		if(wrUsbSize > 0) {
9D011364  8F82802C   LW V0, -32724(GP)
9D011368  18400009   BLEZ V0, 0x9D011390
9D01136C  00511821   ADDU V1, V0, S1
195:                 			//SYS_PORTS_PinWrite(PORTS_ID_0, PORT_CHANNEL_B, 3, true); // Set LED ON
196:                 			if((wrUsbBuf[wrUsbSize - 1] == '\n') || (wrUsbSize >= wrUsbSizeLimit)) {
9D011344  2412000A   ADDIU S2, ZERO, 10
9D011370  8063FFFF   LB V1, -1(V1)
9D011374  10720003   BEQ V1, S2, 0x9D011384
9D011378  28420080   SLTI V0, V0, 128
9D01137C  1440FFF4   BNE V0, ZERO, 0x9D011350
9D011380  00002821   ADDU A1, ZERO, ZERO
197:                 				_len = wrUsbSize;
198:                 				//usbConsoleStatus = SYS_CONSOLE_Status(sysObj.sysConsole0);
199:                 				//if(usbConsoleStatus >= SYS_STATUS_READY) {
200:                 				//	_len = SYS_CONSOLE_Write(SYS_CONSOLE_INDEX_0, STDOUT_FILENO, wrUsbBuf, _len);
201:                 				//}
202:                 				wrUsbPtr = wrUsbBuf;
9D011384  AF918034   SW S1, -32716(GP)
203:                 				wrUsbSize = 0;
9D011388  0B4044D2   J 0x9D011348
9D01138C  AF80802C   SW ZERO, -32724(GP)
204:                 			}
205:                 		} else {
206:                 			wrUsbPtr = wrUsbBuf;
9D011340  00408821   ADDU S1, V0, ZERO
9D011390  AF918034   SW S1, -32716(GP)
207:                 			wrUsbSize = 0;
9D011394  0B4044D2   J 0x9D011348
9D011398  AF80802C   SW ZERO, -32724(GP)
208:                 		}
209:                 	}
210:                 }
9D01139C  8FBF001C   LW RA, 28(SP)
9D0113A0  8FB20018   LW S2, 24(SP)
9D0113A4  8FB10014   LW S1, 20(SP)
9D0113A8  8FB00010   LW S0, 16(SP)
9D0113AC  03E00008   JR RA
9D0113B0  27BD0020   ADDIU SP, SP, 32
---  /home/whatisthis/src/DoorBell_PIC32/firmware/src/md5sum.c  -----------------------------------------
1:                   /*
2:                    * Calc/Check MD5 HASH SUM.
3:                    * (C) 2017 Kyuma Ohta <whatisthis.sowhat _at_ gmail.com >
4:                    * This is part of "DoorBell_PIC32" . You must have MPLAB HARMONY to use this routines.
5:                    * License : Apache OSS License.
6:                    */
7:                   
8:                   #include "doorbell.h"
9:                   
10:                  extern DOORBELL_DATA doorbellData;
11:                  
12:                  // These are specified to DoorBell_PIC32.
13:                  void CALC_MD5Sum(void)
14:                  {
9D013EFC  27BDFFE8   ADDIU SP, SP, -24
9D013F00  AFBF0014   SW RA, 20(SP)
9D013F04  AFB00010   SW S0, 16(SP)
15:                      unsigned int datasize = sizeof (DOORBELL_REAL_DATA_T);
16:                      CRYPT_MD5_Initialize(&(doorbellData.md5_context));
9D013F08  3C10A000   LUI S0, -24576
9D013F0C  0F4053B4   JAL CRYPT_MD5_Initialize
9D013F10  2604099C   ADDIU A0, S0, 2460
17:                      CRYPT_MD5_DataSizeSet(&(doorbellData.md5_context), datasize);
9D013F14  2604099C   ADDIU A0, S0, 2460
9D013F18  0F405670   JAL CRYPT_MD5_DataSizeSet
9D013F1C  240504B8   ADDIU A1, ZERO, 1208
18:                      CRYPT_MD5_DataAdd(&(doorbellData.md5_context), (const unsigned char*) &(doorbellData.realdata), datasize);
9D013F20  2604099C   ADDIU A0, S0, 2460
9D013F24  3C05A000   LUI A1, -24576
9D013F28  24A504A4   ADDIU A1, A1, 1188
9D013F2C  0F405237   JAL CRYPT_MD5_DataAdd
9D013F30  240604B8   ADDIU A2, ZERO, 1208
19:                      CRYPT_MD5_Finalize(&(doorbellData.md5_context), doorbellData.data_md5sum);
9D013F34  2604099C   ADDIU A0, S0, 2460
9D013F38  3C05A000   LUI A1, -24576
9D013F3C  0F405247   JAL CRYPT_MD5_Finalize
9D013F40  24A5095C   ADDIU A1, A1, 2396
20:                  }
9D013F44  8FBF0014   LW RA, 20(SP)
9D013F48  8FB00010   LW S0, 16(SP)
9D013F4C  03E00008   JR RA
9D013F50  27BD0018   ADDIU SP, SP, 24
21:                  
22:                  bool CHECK_MD5Sum(void)
23:                  {
9D013420  27BDFFA8   ADDIU SP, SP, -88
9D013424  AFBF0054   SW RA, 84(SP)
9D013428  AFB00050   SW S0, 80(SP)
24:                      unsigned char tmpmd5[MD5_DIGEST_SIZE];
25:                      unsigned int datasize = sizeof (DOORBELL_REAL_DATA_T);
26:                      CRYPT_MD5_Initialize(&(doorbellData.md5_context));
9D01342C  3C10A000   LUI S0, -24576
9D013430  0F4053B4   JAL CRYPT_MD5_Initialize
9D013434  2604099C   ADDIU A0, S0, 2460
27:                      CRYPT_MD5_DataSizeSet(&(doorbellData.md5_context), datasize);
9D013438  2604099C   ADDIU A0, S0, 2460
9D01343C  0F405670   JAL CRYPT_MD5_DataSizeSet
9D013440  240504B8   ADDIU A1, ZERO, 1208
28:                      CRYPT_MD5_DataAdd(&(doorbellData.md5_context), (const unsigned char*) &(doorbellData.realdata), datasize);
9D013444  2604099C   ADDIU A0, S0, 2460
9D013448  3C05A000   LUI A1, -24576
9D01344C  24A504A4   ADDIU A1, A1, 1188
9D013450  0F405237   JAL CRYPT_MD5_DataAdd
9D013454  240604B8   ADDIU A2, ZERO, 1208
29:                      CRYPT_MD5_Finalize(&(doorbellData.md5_context), tmpmd5);
9D013458  2604099C   ADDIU A0, S0, 2460
9D01345C  0F405247   JAL CRYPT_MD5_Finalize
9D013460  27A50010   ADDIU A1, SP, 16
30:                      if (memcmp(tmpmd5, doorbellData.data_md5sum, MD5_DIGEST_SIZE) != 0) {
9D013464  27A40010   ADDIU A0, SP, 16
9D013468  3C05A000   LUI A1, -24576
9D01346C  24A5095C   ADDIU A1, A1, 2396
9D013470  0F404882   JAL memcmp
9D013474  24060040   ADDIU A2, ZERO, 64
31:                          return false;
32:                      }
33:                      return true;
34:                  }
9D013478  2C420001   SLTIU V0, V0, 1
9D01347C  8FBF0054   LW RA, 84(SP)
9D013480  8FB00050   LW S0, 80(SP)
9D013484  03E00008   JR RA
9D013488  27BD0058   ADDIU SP, SP, 88
---  /home/whatisthis/src/DoorBell_PIC32/firmware/src/main.c  -------------------------------------------
1:                   /*******************************************************************************
2:                     MPLAB Harmony Project Main Source File
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                     
7:                     File Name:
8:                       main.c
9:                   
10:                    Summary:
11:                      This file contains the "main" function for an MPLAB Harmony project.
12:                  
13:                    Description:
14:                      This file contains the "main" function for an MPLAB Harmony project.  The
15:                      "main" function calls the "SYS_Initialize" function to initialize the state 
16:                      machines of all MPLAB Harmony modules in the system and it calls the 
17:                      "SYS_Tasks" function from within a system-wide "super" loop to maintain 
18:                      their correct operation. These two functions are implemented in 
19:                      configuration-specific files (usually "system_init.c" and "system_tasks.c")
20:                      in a configuration-specific folder under the "src/system_config" folder 
21:                      within this project's top-level folder.  An MPLAB Harmony project may have
22:                      more than one configuration, each contained within it's own folder under
23:                      the "system_config" folder.
24:                   *******************************************************************************/
25:                  
26:                  // DOM-IGNORE-BEGIN
27:                  /******************************************************************************
28:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
29:                  
30:                  //Microchip licenses to you the right to use, modify, copy and distribute
31:                  Software only when embedded on a Microchip microcontroller or digital signal
32:                  controller that is integrated into your product or third party product
33:                  (pursuant to the sublicense terms in the accompanying license agreement).
34:                  
35:                  You should refer to the license agreement accompanying this Software for
36:                  additional information regarding your rights and obligations.
37:                  
38:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
39:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
40:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
41:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
42:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
43:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
44:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
45:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
46:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
47:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
48:                   *******************************************************************************/
49:                  // DOM-IGNORE-END
50:                  
51:                  // *****************************************************************************
52:                  // *****************************************************************************
53:                  // Section: Included Files
54:                  // *****************************************************************************
55:                  // *****************************************************************************
56:                  
57:                  #include <stddef.h>                     // Defines NULL
58:                  #include <stdbool.h>                    // Defines true
59:                  #include <stdlib.h>                     // Defines EXIT_FAILURE
60:                  #include "system/common/sys_module.h"
61:                  #include "doorbell.h"   // SYS function prototypes
62:                  #include "ringbuffer.h"
63:                  
64:                  /* Kernel includes. */
65:                  #include "FreeRTOS.h"
66:                  #include "task.h"
67:                  #include "queue.h"
68:                  #include "timers.h"
69:                  
70:                  #include "pca9655.h"
71:                  /* Standard demo includes. */
72:                  //#include "partest.h"
73:                  
74:                  /* Hardware specific includes. */
75:                  //#include "ConfigPerformance.h"
76:                  
77:                  
78:                  // *****************************************************************************
79:                  // *****************************************************************************
80:                  // Section: Main Entry Point
81:                  // *****************************************************************************
82:                  // *****************************************************************************
83:                  
84:                  
85:                  DOORBELL_DATA doorbellData;
86:                  
87:                  RESET_REASON prvSetupHardware(void)
88:                  {
9D0122A0  27BDFFE0   ADDIU SP, SP, -32
9D0122A4  AFBF001C   SW RA, 28(SP)
9D0122A8  AFB20018   SW S2, 24(SP)
9D0122AC  AFB10014   SW S1, 20(SP)
9D0122B0  AFB00010   SW S0, 16(SP)
89:                      uint32_t _time, _date;
90:                      RESET_REASON reset_reason;
91:                  
92:                      PLIB_RTCC_Enable(RTCC_ID_0);
93:                      reset_reason = PLIB_RESET_ReasonGet(RESET_ID_0);
94:                      _time = PLIB_RTCC_RTCTimeGet(RTCC_ID_0);
95:                      _date = PLIB_RTCC_RTCDateGet(RTCC_ID_0);
96:                      SYS_Initialize(NULL);
9D0122D4  0F401F1A   JAL SYS_Initialize
9D0122D8  00002021   ADDU A0, ZERO, ZERO
97:                  
98:                      switch (reset_reason) {
9D0122DC  24020003   ADDIU V0, ZERO, 3
9D0122E0  12020003   BEQ S0, V0, 0x9D0122F0
9D0122E4  3C02BF80   LUI V0, -16512
99:                      case RESET_REASON_POWERON:
100:                         //case RESET_REASON_VBAT:
101:                         break;
102:                     default:
103:                         PLIB_RTCC_RTCTimeSet(RTCC_ID_0, _time);
104:                         PLIB_RTCC_RTCDateSet(RTCC_ID_0, _date);
105:                         break;
106:                     }
107:                     // Reset RTC value if POWERON, restore values if not.
108:                     //PLIB_RESET_ReasonClear(RESET_ID_0, reset_reason);
109:                  
110:                     U1RXRbits.U1RXR = 0x03; // RPB13 = U1RX
9D0122F0  3C02BF81   LUI V0, -16511
9D0122F4  9043FA50   LBU V1, -1456(V0)
9D0122F8  24040003   ADDIU A0, ZERO, 3
9D0122FC  7C831804   INS V1, A0, 0, 4
9D012300  A043FA50   SB V1, -1456(V0)
111:                     RPB15Rbits.RPB15R = 0x01; //RPB15 = U1TX
9D012304  3C02BF81   LUI V0, -16511
9D012308  9043FB68   LBU V1, -1176(V0)
9D01230C  24040001   ADDIU A0, ZERO, 1
9D012310  7C831804   INS V1, A0, 0, 4
9D012314  A043FB68   SB V1, -1176(V0)
112:                     return reset_reason;
113:                 }
9D012318  02001021   ADDU V0, S0, ZERO
114:                 
115:                 void DOORBELL_Initialize(void)
116:                 {
9D0103BC  27BDFFE8   ADDIU SP, SP, -24
9D0103C0  AFBF0014   SW RA, 20(SP)
117:                     /* TODO: Initialize your application's state machine and other
118:                      * parameters.
119:                      */
120:                     uint8_t data_md5sum[MD5_DIGEST_SIZE];
121:                     RESET_REASON reason;
122:                     reason = SYS_RESET_ReasonGet();
9D0103C4  0F405661   JAL SYS_RESET_ReasonGet
9D0103C8  AFB00010   SW S0, 16(SP)
9D0103CC  00408021   ADDU S0, V0, ZERO
123:                     switch (reason) {
9D0103D0  24020003   ADDIU V0, ZERO, 3
9D0103D4  12020003   BEQ S0, V0, 0x9D0103E4
9D0103D8  24020200   ADDIU V0, ZERO, 512
9D0103DC  16020006   BNE S0, V0, 0x9D0103F8
9D0103E0  00000000   NOP
124:                     case RESET_REASON_POWERON:
125:                     case RESET_REASON_CONFIG_MISMATCH:
126:                         memset(&doorbellData, 0x00, sizeof (doorbellData));
9D0103E4  3C04A000   LUI A0, -24576
9D0103E8  2484049C   ADDIU A0, A0, 1180
9D0103EC  00002821   ADDU A1, ZERO, ZERO
9D0103F0  0F40464F   JAL memset
9D0103F4  240606B8   ADDIU A2, ZERO, 1720
127:                         break;
128:                     default:
129:                         // Check MD5SUM
130:                         // If failed, clear.
131:                         break;
132:                     }
133:                     if (!CHECK_MD5Sum()) {
9D0103F8  0F404D08   JAL CHECK_MD5Sum
9D0103FC  00000000   NOP
9D010400  14400009   BNE V0, ZERO, 0x9D010428
9D010404  3C03A000   LUI V1, -24576
134:                         memset(&(doorbellData.realdata), 0x00, sizeof (doorbellData.realdata));
9D010408  3C04A000   LUI A0, -24576
9D01040C  248404A4   ADDIU A0, A0, 1188
9D010410  00002821   ADDU A1, ZERO, ZERO
9D010414  0F40464F   JAL memset
9D010418  240604B8   ADDIU A2, ZERO, 1208
135:                         // Re-Calc MD5.
136:                         CALC_MD5Sum();
9D01041C  0F404FBF   JAL CALC_MD5Sum
9D010420  00000000   NOP
137:                     }
138:                     doorbellData.ringed = false;
9D010424  3C03A000   LUI V1, -24576
9D010428  2463049C   ADDIU V1, V1, 1180
9D01042C  A0600001   SB ZERO, 1(V1)
139:                     doorbellData.uart_ready = true;
9D010430  24020001   ADDIU V0, ZERO, 1
9D010434  A0620002   SB V0, 2(V1)
140:                     doorbellData.usb_ready = false;
9D010438  A0600003   SB ZERO, 3(V1)
141:                     doorbellData.resetReason = reason;
9D01043C  AC700004   SW S0, 4(V1)
142:                 #if 1
143:                     if (!SYS_PORTS_PinRead(PORTS_ID_0, PORT_CHANNEL_B, 5)) {
9D010440  00002021   ADDU A0, ZERO, ZERO
9D010444  24050001   ADDIU A1, ZERO, 1
9D010448  0F405461   JAL SYS_PORTS_PinRead
9D01044C  24060005   ADDIU A2, ZERO, 5
9D010450  14400004   BNE V0, ZERO, 0x9D010464
9D010454  3C02A000   LUI V0, -24576
144:                         // IF S_MAINTAIN is LOW, PASSTHROUGH
145:                         doorbellData.bootparam_passthrough = true;
9D010458  24030001   ADDIU V1, ZERO, 1
9D01045C  0B40411A   J 0x9D010468
9D010460  A043049C   SB V1, 1180(V0)
146:                     } else {
147:                         doorbellData.bootparam_passthrough = false;
9D010464  A040049C   SB ZERO, 1180(V0)
148:                     }
149:                 #endif
150:                     {
151:                         // Resume all tasks and Wait for alarm waking.
152:                         // ToDo: button pressed.
153:                         //SYS_CLK_REFERENCE_SETUP sr;
154:                         //sr.stopInIdle = false;
155:                         //sr.suspendInSleep = false;
156:                         OSCCONbits.SLPEN = 0;
9D010468  3C02BF81   LUI V0, -16511
9D01046C  8C43F000   LW V1, -4096(V0)
9D010470  7C032104   INS V1, ZERO, 4, 1
9D010474  AC43F000   SW V1, -4096(V0)
157:                         //SYS_CLK_ReferenceClockSetup(CLK_BUS_REFERENCE_1, &sr);
158:                     }
159:                     
160:                 
161:                     SYS_RTCC_Stop();
9D010478  0F405631   JAL SYS_RTCC_Stop
9D01047C  00000000   NOP
162:                     RTCALRMbits.AMASK = 0b0110; // Once a day.
9D010480  3C02BF80   LUI V0, -16512
9D010484  94430210   LHU V1, 528(V0)
9D010488  24040006   ADDIU A0, ZERO, 6
9D01048C  7C835A04   INS V1, A0, 8, 4
9D010490  A4430210   SH V1, 528(V0)
163:                     SYS_RTCC_Start();
9D010494  0F40562C   JAL SYS_RTCC_Start
9D010498  00000000   NOP
164:                 }
9D01049C  8FBF0014   LW RA, 20(SP)
9D0104A0  8FB00010   LW S0, 16(SP)
9D0104A4  03E00008   JR RA
9D0104A8  27BD0018   ADDIU SP, SP, 24
165:                 
166:                 SYS_RTCC_ALARM_HANDLE *hAlarmTick;
167:                 TaskHandle_t xHandleHouseKeeping;
168:                 
169:                 TaskHandle_t xHandleReadFromUART;
170:                 TaskHandle_t xHandleReadFromUSB;
171:                 TaskHandle_t xHandleWriteToUART;
172:                 TaskHandle_t xHandleWriteToUSB;
173:                 TaskHandle_t xHandleLED;
174:                 TaskHandle_t xHandleSoundRender;
175:                 
176:                 QueueHandle_t xUartRecvQueue;
177:                 QueueHandle_t xUartSendQueue;
178:                 QueueHandle_t xUsbRecvQueue;
179:                 QueueHandle_t xUsbSendQueue;
180:                 extern QueueHandle_t xSoundCmdQueue;
181:                 extern QueueHandle_t xSoundQueue;
182:                 extern TimerHandle_t xSoundTimer;
183:                 DRV_HANDLE xDevHandleUart_Send;
184:                 DRV_HANDLE xDevHandleUart_Recv;
185:                 
186:                 #define UART_RECV_BUFFER_SIZE 128 
187:                 RingBuffer_Char_t xUartRecvRing;
188:                 char xUartRecvBuf[UART_RECV_BUFFER_SIZE];
189:                 
190:                 extern void prvHouseKeeping(void *pvParameters);
191:                 
192:                 uint32_t cTick100ms;
193:                 uint32_t cTick110ms;
194:                 uint32_t cTick200ms;
195:                 uint32_t cTick500ms;
196:                 uint32_t cTick1Sec;
197:                 uint32_t cTick5Sec;
198:                 
199:                 extern void prvReadFromUsb(void *pvparameters);
200:                 extern void prvWriteToUsb(void *pvparameters);
201:                 extern void prvReadFromUart(void *pvparameters);
202:                 extern void prvWriteToUart(void *pvparameters);
203:                 extern void prvHouseKeeping(void *pvParameters);
204:                 extern void prvWriteToUart_HK(void *pvparameters);
205:                 extern void prvReadFromUart_HK(void *pvparameters);
206:                 extern void prvSound(void *pvParameters);
207:                 
208:                 void setupTicks(void)
209:                 {
210:                     cTick100ms = (uint32_t) ((10000 / portTICK_PERIOD_MS) / 100);
9D014E34  24020019   ADDIU V0, ZERO, 25
9D014E38  AF8280F8   SW V0, -32520(GP)
211:                     cTick110ms = (uint32_t) ((11000 / portTICK_PERIOD_MS) / 100);
9D014E3C  2402001B   ADDIU V0, ZERO, 27
9D014E40  AF828118   SW V0, -32488(GP)
212:                     cTick200ms = (uint32_t) ((20000 / portTICK_PERIOD_MS) / 100);
9D014E44  24020032   ADDIU V0, ZERO, 50
9D014E48  AF828100   SW V0, -32512(GP)
213:                     cTick500ms = (uint32_t) ((5000 / portTICK_PERIOD_MS) / 10);
9D014E4C  2402007D   ADDIU V0, ZERO, 125
9D014E50  AF828120   SW V0, -32480(GP)
214:                     cTick1Sec = (uint32_t) ((1000 / portTICK_PERIOD_MS));
9D014E54  240200FA   ADDIU V0, ZERO, 250
9D014E58  AF828130   SW V0, -32464(GP)
215:                     cTick5Sec = (uint32_t) ((5000 / portTICK_PERIOD_MS));
9D014E5C  240204E2   ADDIU V0, ZERO, 1250
9D014E60  03E00008   JR RA
9D014E64  AF82812C   SW V0, -32468(GP)
216:                 
217:                 }
218:                 
219:                 int main(void)
220:                 {
9D009000  27BDFFE0   ADDIU SP, SP, -32
9D009004  AFBF001C   SW RA, 28(SP)
221:                     TimerHandle_t xTimer = NULL;
222:                     RESET_REASON reason = prvSetupHardware();
9D009008  0F4048A8   JAL prvSetupHardware
9D00900C  AFB00018   SW S0, 24(SP)
223:                     bool passthrough;
224:                     //IEC0bits.T1IE = 0;
225:                     //IFS0bits.T1IF = 0;
226:                     if (!SYS_PORTS_PinRead(PORTS_ID_0, PORT_CHANNEL_B, 5)) {
9D009010  00002021   ADDU A0, ZERO, ZERO
9D009014  24050001   ADDIU A1, ZERO, 1
9D009018  0F405461   JAL SYS_PORTS_PinRead
9D00901C  24060005   ADDIU A2, ZERO, 5
9D009020  00408021   ADDU S0, V0, ZERO
227:                         // IF S_MAINTAIN is LOW, PASSTHROUGH
228:                         passthrough = true;
229:                     } else {
230:                         passthrough = false;
231:                     }
232:                     xUartRecvQueue = NULL;
9D009024  AF808108   SW ZERO, -32504(GP)
233:                     xUartSendQueue = NULL;
9D009028  AF8080EC   SW ZERO, -32532(GP)
234:                     xUsbRecvQueue = NULL;
9D00902C  AF808128   SW ZERO, -32472(GP)
235:                     xUsbSendQueue = NULL;
9D009030  AF8080FC   SW ZERO, -32516(GP)
236:                     xDevHandleUart_Send = DRV_USART_Open(DRV_USART_INDEX_0, DRV_IO_INTENT_WRITE | DRV_IO_INTENT_NONBLOCKING);
9D009034  00002021   ADDU A0, ZERO, ZERO
9D009038  0F4030ED   JAL DRV_USART_Open
9D00903C  24050006   ADDIU A1, ZERO, 6
9D009040  AF828104   SW V0, -32508(GP)
237:                     xDevHandleUart_Recv = DRV_USART_Open(DRV_USART_INDEX_0, DRV_IO_INTENT_READ | DRV_IO_INTENT_BLOCKING);
9D009044  00002021   ADDU A0, ZERO, ZERO
9D009048  0F4030ED   JAL DRV_USART_Open
9D00904C  24050001   ADDIU A1, ZERO, 1
9D009050  AF8280E8   SW V0, -32536(GP)
238:                     xSoundCmdQueue = xQueueCreate(16, sizeof (uint32_t));
9D009054  24040010   ADDIU A0, ZERO, 16
9D009058  24050004   ADDIU A1, ZERO, 4
9D00905C  0F4048CD   JAL xQueueGenericCreate
9D009060  00003021   ADDU A2, ZERO, ZERO
9D009064  AF828154   SW V0, -32428(GP)
239:                     xSoundQueue = xQueueCreate(16, sizeof (sndData_t));
9D009068  24040010   ADDIU A0, ZERO, 16
9D00906C  2405000C   ADDIU A1, ZERO, 12
9D009070  0F4048CD   JAL xQueueGenericCreate
9D009074  00003021   ADDU A2, ZERO, ZERO
240:                 
241:                     //SYS_PORTS_PinWrite(PORTS_ID_0, PORT_CHANNEL_B, 3, true); // Set LED ON
242:                     
243:                     if (!passthrough) {
9D009078  12000036   BEQ S0, ZERO, 0x9D009154
9D00907C  AF82814C   SW V0, -32436(GP)
244:                         // FULL
245:                         setupTicks();
9D009080  0F40538D   JAL setupTicks
9D009084  00000000   NOP
246:                         vRingBufferCreate_Char(&xUartRecvRing, xUartRecvBuf, UART_RECV_BUFFER_SIZE);
9D009088  3C04A000   LUI A0, -24576
9D00908C  24840400   ADDIU A0, A0, 1024
9D009090  3C05A000   LUI A1, -24576
9D009094  24A5041C   ADDIU A1, A1, 1052
9D009098  0F404ADF   JAL vRingBufferCreate_Char
9D00909C  24060080   ADDIU A2, ZERO, 128
247:                         xUartSendQueue = xQueueCreate(128, sizeof (char));
9D0090A0  24040080   ADDIU A0, ZERO, 128
9D0090A4  24050001   ADDIU A1, ZERO, 1
9D0090A8  0F4048CD   JAL xQueueGenericCreate
9D0090AC  00003021   ADDU A2, ZERO, ZERO
9D0090B0  AF8280EC   SW V0, -32532(GP)
248:                         if (xDevHandleUart_Recv != DRV_HANDLE_INVALID) {
9D0090B4  2402FFFF   ADDIU V0, ZERO, -1
9D0090B8  8F8380E8   LW V1, -32536(GP)
9D0090BC  1062000B   BEQ V1, V0, 0x9D0090EC
9D0090C0  24020004   ADDIU V0, ZERO, 4
249:                             xTaskCreate(prvReadFromUart_HK, "ReadFromUart", 256, NULL, 4, &xHandleReadFromUART);
9D0090C4  AFA20010   SW V0, 16(SP)
9D0090C8  27828124   ADDIU V0, GP, -32476
9D0090CC  AFA20014   SW V0, 20(SP)
9D0090D0  3C049D01   LUI A0, -25343
9D0090D4  2484A70C   ADDIU A0, A0, -22772
9D0090D8  3C059D01   LUI A1, -25343
9D0090DC  24A5485C   ADDIU A1, A1, 18524
9D0090E0  24060100   ADDIU A2, ZERO, 256
9D0090E4  0F40448E   JAL xTaskCreate
9D0090E8  00003821   ADDU A3, ZERO, ZERO
250:                         }
251:                         if (xDevHandleUart_Send != DRV_HANDLE_INVALID) {
9D0090EC  2402FFFF   ADDIU V0, ZERO, -1
9D0090F0  8F838104   LW V1, -32508(GP)
9D0090F4  1062000B   BEQ V1, V0, 0x9D009124
9D0090F8  24020002   ADDIU V0, ZERO, 2
252:                             xTaskCreate(prvWriteToUart_HK, "WriteToUart", 160, NULL, 2, &xHandleWriteToUART);
9D0090FC  AFA20010   SW V0, 16(SP)
9D009100  2782810C   ADDIU V0, GP, -32500
9D009104  AFA20014   SW V0, 20(SP)
9D009108  3C049D01   LUI A0, -25343
9D00910C  24844E9C   ADDIU A0, A0, 20124
9D009110  3C059D01   LUI A1, -25343
9D009114  24A5486C   ADDIU A1, A1, 18540
9D009118  240600A0   ADDIU A2, ZERO, 160
9D00911C  0F40448E   JAL xTaskCreate
9D009120  00003821   ADDU A3, ZERO, ZERO
253:                         }
254:                         xTaskCreate(prvSound, "SoundRender", 1024, NULL, 1, NULL);
9D009124  24020001   ADDIU V0, ZERO, 1
9D009128  AFA20010   SW V0, 16(SP)
9D00912C  AFA00014   SW ZERO, 20(SP)
9D009130  3C049D00   LUI A0, -25344
9D009134  24841554   ADDIU A0, A0, 5460
9D009138  3C059D01   LUI A1, -25343
9D00913C  24A54878   ADDIU A1, A1, 18552
9D009140  24060400   ADDIU A2, ZERO, 1024
9D009144  0F40448E   JAL xTaskCreate
9D009148  00003821   ADDU A3, ZERO, ZERO
9D00914C  0B402477   J 0x9D0091DC
9D009150  00000000   NOP
255:                     } else {
256:                         setupTicks();
9D009154  0F40538D   JAL setupTicks
9D009158  00000000   NOP
257:                         xUsbRecvQueue = xQueueCreate(128, sizeof (char));
9D00915C  24040080   ADDIU A0, ZERO, 128
9D009160  24050001   ADDIU A1, ZERO, 1
9D009164  0F4048CD   JAL xQueueGenericCreate
9D009168  00003021   ADDU A2, ZERO, ZERO
9D00916C  AF828128   SW V0, -32472(GP)
258:                         xUsbSendQueue = xQueueCreate(256, sizeof (char));
9D009170  24040100   ADDIU A0, ZERO, 256
9D009174  24050001   ADDIU A1, ZERO, 1
9D009178  0F4048CD   JAL xQueueGenericCreate
9D00917C  00003021   ADDU A2, ZERO, ZERO
9D009180  AF8280FC   SW V0, -32516(GP)
259:                         xTaskCreate(prvReadFromUsb, "ReadFromUsb", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY + 1, &xHandleReadFromUSB);
9D009184  24020001   ADDIU V0, ZERO, 1
9D009188  AFA20010   SW V0, 16(SP)
9D00918C  27828110   ADDIU V0, GP, -32496
9D009190  AFA20014   SW V0, 20(SP)
9D009194  3C049D01   LUI A0, -25343
9D009198  2484076C   ADDIU A0, A0, 1900
9D00919C  3C059D01   LUI A1, -25343
9D0091A0  24A54884   ADDIU A1, A1, 18564
9D0091A4  24060080   ADDIU A2, ZERO, 128
9D0091A8  0F40448E   JAL xTaskCreate
9D0091AC  00003821   ADDU A3, ZERO, ZERO
260:                         xTaskCreate(prvWriteToUsb, "WriteToUsb", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY + 2, &xHandleWriteToUSB);
9D0091B0  24020002   ADDIU V0, ZERO, 2
9D0091B4  AFA20010   SW V0, 16(SP)
9D0091B8  27828138   ADDIU V0, GP, -32456
9D0091BC  AFA20014   SW V0, 20(SP)
9D0091C0  3C049D01   LUI A0, -25343
9D0091C4  248412F8   ADDIU A0, A0, 4856
9D0091C8  3C059D01   LUI A1, -25343
9D0091CC  24A54890   ADDIU A1, A1, 18576
9D0091D0  24060080   ADDIU A2, ZERO, 128
9D0091D4  0F40448E   JAL xTaskCreate
9D0091D8  00003821   ADDU A3, ZERO, ZERO
261:                         //xTaskCreate( prvLEDs, "LEDs", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY + 0, &xHandleLED );
262:                     }
263:                 #if 0
264:                     SYS_DEVCON_SystemUnlock();
265:                     PMD1bits.AD1MD = 1;
266:                     PMD1bits.CTMUMD = 1;
267:                     //PMD1bits.CVRMD = 1;
268:                     PMD3bits.OC1MD = 1;
269:                     PMD3bits.OC2MD = 0;
270:                     PMD3bits.OC3MD = 1;
271:                     PMD3bits.OC4MD = 1;
272:                     PMD3bits.OC5MD = 1;
273:                     PMD4bits.T1MD = 0;
274:                     PMD4bits.T2MD = 0;
275:                     PMD4bits.T3MD = 0;
276:                     PMD4bits.T4MD = 0;
277:                     PMD4bits.T5MD = 0;
278:                     PMD5bits.U1MD = 0;
279:                     PMD5bits.I2C1MD = 0;
280:                     PMD5bits.USB1MD = 0;
281:                     PMD5bits.USBMD = 0;
282:                     SYS_DEVCON_SystemLock();
283:                 #endif
284:                     /* A software timer is also used to start the high frequency timer test.
285:                     This is to ensure the test does not start before the kernel.  This time a
286:                     one shot software timer is used. */
287:                     //xTimer = xTimerCreate( "HighHzTimerSetup", 1, pdFALSE, ( void * ) 0, prvSetupHighFrequencyTimerTest );
288:                     //if( xTimer != NULL )
289:                     //{
290:                     //	xTimerStart( xTimer, mainDONT_BLOCK );
291:                     //}
292:                     /* Finally start the scheduler. */
293:                     //vTaskStartScheduler();
294:                     setupTicks();
9D0091DC  0F40538D   JAL setupTicks
9D0091E0  00000000   NOP
295:                 
296:                     /* If all is well, the scheduler will now be running, and the following line
297:                     will never be reached.  If the following line does execute, then there was
298:                     insufficient FreeRTOS heap memory available for the idle and/or timer tasks
299:                     to be created.  See the memory management section on the FreeRTOS web site
300:                     for more details. */
301:                     SYS_Tasks();
9D0091E4  0F404917   JAL SYS_Tasks
9D0091E8  00000000   NOP
302:                 
303:                     //for( ;; );
304:                     return ( EXIT_FAILURE);
305:                 }
9D0091EC  24020001   ADDIU V0, ZERO, 1
9D0091F0  8FBF001C   LW RA, 28(SP)
9D0091F4  8FB00018   LW S0, 24(SP)
9D0091F8  03E00008   JR RA
9D0091FC  27BD0020   ADDIU SP, SP, 32
306:                 
307:                 
308:                 /*******************************************************************************
309:                  End of File
310:                  */
---  /home/whatisthis/src/DoorBell_PIC32/firmware/src/logger.c  -----------------------------------------
1:                   /*
2:                    * Logging features .
3:                    * (C) 2017 Kyuma Ohta <whatisthis.sowhat _at_ gmail.com >
4:                    * This is part of "DoorBell_PIC32" . You must have MPLAB HARMONY to use this routines.
5:                    * License : Apache OSS License.
6:                    */
7:                   
8:                   /* Kernel includes. */
9:                   
10:                  #include "FreeRTOS.h"
11:                  #include "task.h"
12:                  #include "queue.h"
13:                  #include "timers.h"
14:                  
15:                  #include "doorbell.h"
16:                  
17:                  extern DOORBELL_DATA doorbellData;
18:                  extern DRV_HANDLE xDevHandleUart_Recv;
19:                  extern DRV_HANDLE xDevHandleUart_Send;
20:                  
21:                  void pushLog(SYS_RTCC_BCD_DATE _date, SYS_RTCC_BCD_TIME _time, uint8_t _type, uint8_t *_data, uint8_t _len)
22:                  {
9D00EF40  27BDFFE8   ADDIU SP, SP, -24
9D00EF44  AFBF0014   SW RA, 20(SP)
9D00EF48  AFB00010   SW S0, 16(SP)
23:                      uint16_t current = doorbellData.realdata.log_tail;
9D00EF4C  3C06A000   LUI A2, -24576
9D00EF50  24C6049C   ADDIU A2, A2, 1180
9D00EF54  94D0001C   LHU S0, 28(A2)
24:                      int8_t seed = 0;
9D00F044  00001821   ADDU V1, ZERO, ZERO
25:                      int i;
26:                      int8_t *p;
27:                      // Clear data
28:                      memset(doorbellData.realdata.logdata[current].data, 0x00, sizeof (uint8_t) * 8);
9D00EF58  00101840   SLL V1, S0, 1
9D00EF5C  00101100   SLL V0, S0, 4
9D00EF60  00621021   ADDU V0, V1, V0
9D00EF64  24480028   ADDIU T0, V0, 40
9D00EF68  00C84021   ADDU T0, A2, T0
9D00EF6C  25030001   ADDIU V1, T0, 1
9D00EF70  A1000001   SB ZERO, 1(T0)
9D00EF74  A1000002   SB ZERO, 2(T0)
9D00EF78  A1000003   SB ZERO, 3(T0)
9D00EF7C  A1000004   SB ZERO, 4(T0)
9D00EF80  A1000005   SB ZERO, 5(T0)
9D00EF84  A1000006   SB ZERO, 6(T0)
9D00EF88  A1000007   SB ZERO, 7(T0)
9D00EF8C  A1000008   SB ZERO, 8(T0)
29:                      // Set data
30:                      doorbellData.realdata.logdata[current].n_date = _date;
9D00EF90  00461021   ADDU V0, V0, A2
9D00EF94  A8440023   SWL A0, 35(V0)
9D00EF98  B8440020   SWR A0, 32(V0)
31:                      doorbellData.realdata.logdata[current].n_time = _time;
9D00EF9C  A8450027   SWL A1, 39(V0)
32:                      if (_data != NULL) {
9D00EFA0  10E0001F   BEQ A3, ZERO, 0x9D00F020
9D00EFA4  B8450024   SWR A1, 36(V0)
33:                          memcpy(doorbellData.realdata.logdata[current].data, _data, _len & 7);
9D00EFA8  00602021   ADDU A0, V1, ZERO
9D00EFAC  00E02821   ADDU A1, A3, ZERO
9D00EFB0  93A60028   LBU A2, 40(SP)
9D00EFB4  0F40343F   JAL memcpy
9D00EFB8  30C60007   ANDI A2, A2, 7
34:                      }
35:                      // Calc check sum
36:                      p = (int8_t *)&(doorbellData.realdata.logdata[current].n_date);
9D00EFBC  0B403C09   J 0x9D00F024
9D00EFC0  00101040   SLL V0, S0, 1
9D00F020  00101040   SLL V0, S0, 1
9D00F024  00101900   SLL V1, S0, 4
9D00F028  00431021   ADDU V0, V0, V1
9D00F02C  24420020   ADDIU V0, V0, 32
9D00F030  3C07A000   LUI A3, -24576
9D00F034  24E7049C   ADDIU A3, A3, 1180
9D00F038  00E23821   ADDU A3, A3, V0
37:                      for (i = 0; i < (sizeof (DOORBELL_LOG_DATA_T) - sizeof (uint8_t)); i++) {
9D00EFD8  24420001   ADDIU V0, V0, 1
9D00EFDC  1446FFF9   BNE V0, A2, 0x9D00EFC4
9D00EFE0  00402021   ADDU A0, V0, ZERO
9D00F03C  00002021   ADDU A0, ZERO, ZERO
9D00F040  00001021   ADDU V0, ZERO, ZERO
9D00F048  0B403BF1   J 0x9D00EFC4
9D00F04C  24060011   ADDIU A2, ZERO, 17
38:                          seed += p[i];
9D00EFC4  00E42021   ADDU A0, A3, A0
9D00EFC8  90850000   LBU A1, 0(A0)
9D00EFCC  00651821   ADDU V1, V1, A1
9D00EFD0  306500FF   ANDI A1, V1, 255
9D00EFD4  7C051C20   SEB V1, A1
39:                      }
40:                      seed = -seed;
9D00EFFC  00052823   SUBU A1, ZERO, A1
41:                      doorbellData.realdata.logdata[current].n_sum = seed;
9D00EFE4  00101840   SLL V1, S0, 1
9D00EFE8  00101100   SLL V0, S0, 4
9D00EFEC  00621821   ADDU V1, V1, V0
9D00EFF0  3C02A000   LUI V0, -24576
9D00EFF4  2442049C   ADDIU V0, V0, 1180
9D00EFF8  00621021   ADDU V0, V1, V0
9D00F000  A0450031   SB A1, 49(V0)
42:                      current++;
9D00F004  26100001   ADDIU S0, S0, 1
9D00F008  3210FFFF   ANDI S0, S0, -1
43:                      if (current >= LOG_LENGTH) {
9D00F00C  2E020040   SLTIU V0, S0, 64
44:                          current = 0;
9D00F010  0002800A   MOVZ S0, ZERO, V0
45:                      }
46:                      doorbellData.realdata.log_tail = current;
9D00F014  3C02A000   LUI V0, -24576
9D00F018  0B403C14   J 0x9D00F050
9D00F01C  A45004B8   SH S0, 1208(V0)
47:                  
48:                  }
9D00F050  8FBF0014   LW RA, 20(SP)
9D00F054  8FB00010   LW S0, 16(SP)
9D00F058  03E00008   JR RA
9D00F05C  27BD0018   ADDIU SP, SP, 24
49:                  
50:                  bool pushUartQueue(char *str)
51:                  {
9D011DC0  27BDFFD8   ADDIU SP, SP, -40
9D011DC4  AFBF0024   SW RA, 36(SP)
9D011DC8  AFB30020   SW S3, 32(SP)
9D011DCC  AFB2001C   SW S2, 28(SP)
9D011DD0  AFB10018   SW S1, 24(SP)
9D011DD4  AFB00014   SW S0, 20(SP)
52:                      ssize_t _len;
53:                      BaseType_t stat;
54:                      int i;
55:                  
56:                      if (str == NULL) return false;
9D011DD8  10800017   BEQ A0, ZERO, 0x9D011E38
9D011DDC  00808821   ADDU S1, A0, ZERO
9D011E38  0B404791   J 0x9D011E44
9D011E3C  00001021   ADDU V0, ZERO, ZERO
9D011E40  24020001   ADDIU V0, ZERO, 1
57:                      if (xUartSendQueue == NULL) return false;
9D011DE0  8F8280EC   LW V0, -32532(GP)
9D011DE4  10400017   BEQ V0, ZERO, 0x9D011E44
9D011DE8  00001021   ADDU V0, ZERO, ZERO
58:                  
59:                      _len = strlen(str);
9D011DEC  0F403499   JAL strlen
9D011DF0  00000000   NOP
60:                      if (_len > 0) {
9D011DF4  18400012   BLEZ V0, 0x9D011E40
9D011DF8  00409021   ADDU S2, V0, ZERO
9D011DFC  00008021   ADDU S0, ZERO, ZERO
61:                          i = 0;
62:                          while (i < _len) {
9D011E24  0212182A   SLT V1, S0, S2
9D011E28  1460FFF7   BNE V1, ZERO, 0x9D011E08
9D011E2C  8F8480EC   LW A0, -32532(GP)
9D011E30  0B404791   J 0x9D011E44
9D011E34  24020001   ADDIU V0, ZERO, 1
63:                              stat = xQueueSend(xUartSendQueue, &(str[i]), cTick1Sec);
9D011E04  8F8480EC   LW A0, -32532(GP)
9D011E08  02302821   ADDU A1, S1, S0
9D011E0C  8F868130   LW A2, -32464(GP)
9D011E10  0F401FB3   JAL xQueueGenericSend
9D011E14  00003821   ADDU A3, ZERO, ZERO
64:                              if (stat != pdTRUE) continue;
9D011E00  24130001   ADDIU S3, ZERO, 1
65:                              i++;
9D011E18  00531026   XOR V0, V0, S3
9D011E1C  2C430001   SLTIU V1, V0, 1
9D011E20  02038021   ADDU S0, S0, V1
66:                          }
67:                      }
68:                      return true;
69:                  }
9D011E44  8FBF0024   LW RA, 36(SP)
9D011E48  8FB30020   LW S3, 32(SP)
9D011E4C  8FB2001C   LW S2, 28(SP)
9D011E50  8FB10018   LW S1, 24(SP)
9D011E54  8FB00014   LW S0, 20(SP)
9D011E58  03E00008   JR RA
9D011E5C  27BD0028   ADDIU SP, SP, 40
70:                  
71:                  static inline void pushMessage(int index, char *str)
72:                  {
73:                      if(str == NULL) return;
9D00BDC0  12400008   BEQ S2, ZERO, printLog::pushMessage
9D00BDC4  24020040   ADDIU V0, ZERO, 64
9D00E274  1200000D   BEQ S0, ZERO, printMessage::pushMessage
9D00E278  00000000   NOP
9D00E2AC  1240000A   BEQ S2, ZERO, printMessage::pushMessage
9D00E2B0  2402000A   ADDIU V0, ZERO, 10
9D00E2FC  5640FFF0   BNEL S2, ZERO, 0x9D00E2C0
9D00E300  8F8280EC   LW V0, -32532(GP)
74:                      if(index == 0) {
9D00BDC8  5620002B   BNEL S1, ZERO, 0x9D00BE78
9D00BDCC  A7A20020   SH V0, 32(SP)
9D00BDE4  16200024   BNE S1, ZERO, 0x9D00BE78
9D00BDE8  A7A20020   SH V0, 32(SP)
9D00BE18  1620002B   BNE S1, ZERO, 0x9D00BEC8
9D00BE1C  A7A20020   SH V0, 32(SP)
9D00BE54  1620001C   BNE S1, ZERO, 0x9D00BEC8
9D00BE58  A7A20020   SH V0, 32(SP)
9D00E27C  16200027   BNE S1, ZERO, 0x9D00E31C
9D00E280  8F8280EC   LW V0, -32532(GP)
9D00E2B4  1620002C   BNE S1, ZERO, 0x9D00E368
9D00E2B8  8FBF007C   LW RA, 124(SP)
9D00E2D8  16200022   BNE S1, ZERO, 0x9D00E364
9D00E2DC  A7A20010   SH V0, 16(SP)
75:                          if (xUartSendQueue == NULL) return;
9D00BDEC  8F8280EC   LW V0, -32532(GP)
9D00BDF0  50400029   BEQL V0, ZERO, 0x9D00BE98
9D00BDF4  AFA00010   SW ZERO, 16(SP)
9D00BE20  8F8280EC   LW V0, -32532(GP)
9D00BE24  10400026   BEQ V0, ZERO, 0x9D00BEC0
9D00BE28  2402000A   ADDIU V0, ZERO, 10
9D00BE34  8F8280EC   LW V0, -32532(GP)
9D00BE38  50400021   BEQL V0, ZERO, 0x9D00BEC0
9D00BE3C  2402000A   ADDIU V0, ZERO, 10
9D00BE5C  8F8280EC   LW V0, -32532(GP)
9D00BE60  5040001A   BEQL V0, ZERO, 0x9D00BECC
9D00BE64  8FBF0094   LW RA, 148(SP)
9D00BEAC  8F8280EC   LW V0, -32532(GP)
9D00BEB0  1440FFD5   BNE V0, ZERO, printLog::pushMessage
9D00BEB4  00000000   NOP
9D00BEB8  0B402F84   J 0x9D00BE10
9D00BEBC  00000000   NOP
9D00E284  5040002D   BEQL V0, ZERO, 0x9D00E33C
9D00E288  27A40010   ADDIU A0, SP, 16
9D00E2BC  8F8280EC   LW V0, -32532(GP)
9D00E2C0  50400012   BEQL V0, ZERO, 0x9D00E30C
9D00E2C4  2402000A   ADDIU V0, ZERO, 10
9D00E2E0  8F8280EC   LW V0, -32532(GP)
9D00E2E4  50400020   BEQL V0, ZERO, 0x9D00E368
9D00E2E8  8FBF007C   LW RA, 124(SP)
9D00E350  8F8280EC   LW V0, -32532(GP)
9D00E354  1440FFD1   BNE V0, ZERO, printMessage::pushMessage
9D00E358  00000000   NOP
9D00E35C  0B4038BF   J printMessage::pushMessage
9D00E360  00000000   NOP
76:                          pushUartQueue(str);
9D00BDD0  0F404770   JAL pushUartQueue
9D00BDD4  02402021   ADDU A0, S2, ZERO
9D00BDF8  0F404770   JAL pushUartQueue
9D00BDFC  27A40020   ADDIU A0, SP, 32
9D00BE08  0F404770   JAL pushUartQueue
9D00BE0C  27A40020   ADDIU A0, SP, 32
9D00BE2C  0F404770   JAL pushUartQueue
9D00BE30  27A40020   ADDIU A0, SP, 32
9D00BE40  0F404770   JAL pushUartQueue
9D00BE44  02602021   ADDU A0, S3, ZERO
9D00BE68  0F404770   JAL pushUartQueue
9D00BE6C  27A40020   ADDIU A0, SP, 32
9D00E28C  0F404770   JAL pushUartQueue
9D00E290  02002021   ADDU A0, S0, ZERO
9D00E29C  0F404770   JAL pushUartQueue
9D00E2A0  27A40010   ADDIU A0, SP, 16
9D00E2A4  0B4038BF   J printMessage::pushMessage
9D00E2A8  00000000   NOP
9D00E2C8  0F404770   JAL pushUartQueue
9D00E2CC  02402021   ADDU A0, S2, ZERO
9D00E2EC  0F404770   JAL pushUartQueue
9D00E2F0  27A40010   ADDIU A0, SP, 16
77:                      } else {
78:                          
79:                      }
80:                  }
81:                  void printMessage(int index, char *head, char *str)
82:                  {
9D00E244  27BDFF80   ADDIU SP, SP, -128
9D00E248  AFBF007C   SW RA, 124(SP)
9D00E24C  AFB20078   SW S2, 120(SP)
9D00E250  AFB10074   SW S1, 116(SP)
9D00E254  AFB00070   SW S0, 112(SP)
9D00E258  00808821   ADDU S1, A0, ZERO
9D00E25C  00A08021   ADDU S0, A1, ZERO
9D00E260  00C09021   ADDU S2, A2, ZERO
83:                      char buf[96];
84:                      int i;
85:                      ssize_t _len;
86:                  
87:                      memset(buf, 0x00, sizeof (buf));
9D00E264  27A40010   ADDIU A0, SP, 16
9D00E268  00002821   ADDU A1, ZERO, ZERO
9D00E26C  0F40464F   JAL memset
9D00E270  24060060   ADDIU A2, ZERO, 96
88:                      pushMessage(index, head);
89:                      if (head != NULL) {
90:                          snprintf(buf, 96, "%s@", head);
9D00E294  0B4038CF   J 0x9D00E33C
9D00E298  27A40010   ADDIU A0, SP, 16
9D00E31C  27A40010   ADDIU A0, SP, 16
9D00E320  24050060   ADDIU A1, ZERO, 96
9D00E324  3C069D01   LUI A2, -25343
9D00E328  24C6D52C   ADDIU A2, A2, -10964
9D00E32C  0F4054D3   JAL _snprintf_cdfFnopsuxX
9D00E330  02003821   ADDU A3, S0, ZERO
9D00E33C  24050060   ADDIU A1, ZERO, 96
9D00E340  3C069D01   LUI A2, -25343
9D00E344  24C6D52C   ADDIU A2, A2, -10964
9D00E348  0F4054D3   JAL _snprintf_cdfFnopsuxX
9D00E34C  02003821   ADDU A3, S0, ZERO
91:                          pushMessage(index, buf);
92:                      }
93:                      pushMessage(index, str);
94:                      snprintf(buf, 96, "\n");
9D00E2D0  0B4038C3   J 0x9D00E30C
9D00E2D4  2402000A   ADDIU V0, ZERO, 10
9D00E304  0B4038C5   J 0x9D00E314
9D00E308  2402000A   ADDIU V0, ZERO, 10
9D00E30C  0B4038B8   J 0x9D00E2E0
9D00E310  A7A20010   SH V0, 16(SP)
9D00E314  0B4038B8   J 0x9D00E2E0
9D00E318  A7A20010   SH V0, 16(SP)
95:                      pushMessage(index, buf);
96:                  }
9D00E2F4  0B4038DA   J 0x9D00E368
9D00E2F8  8FBF007C   LW RA, 124(SP)
9D00E334  0B4038DA   J 0x9D00E368
9D00E338  8FBF007C   LW RA, 124(SP)
9D00E364  8FBF007C   LW RA, 124(SP)
9D00E368  8FB20078   LW S2, 120(SP)
9D00E36C  8FB10074   LW S1, 116(SP)
9D00E370  8FB00070   LW S0, 112(SP)
9D00E374  03E00008   JR RA
9D00E378  27BD0080   ADDIU SP, SP, 128
97:                  
98:                  void printLog(int index, char *head, char *str, uint8_t _type, uint8_t *rawdata, uint8_t _rawlen)
99:                  {
9D00BD48  27BDFF68   ADDIU SP, SP, -152
9D00BD4C  AFBF0094   SW RA, 148(SP)
9D00BD50  AFB30090   SW S3, 144(SP)
9D00BD54  AFB2008C   SW S2, 140(SP)
9D00BD58  AFB10088   SW S1, 136(SP)
9D00BD5C  AFB00084   SW S0, 132(SP)
9D00BD60  00808821   ADDU S1, A0, ZERO
9D00BD64  00A09021   ADDU S2, A1, ZERO
9D00BD68  00C09821   ADDU S3, A2, ZERO
9D00BD6C  00E08021   ADDU S0, A3, ZERO
100:                     SYS_RTCC_BCD_DATE _nowdate;
101:                     SYS_RTCC_BCD_TIME _nowtime;
102:                     BaseType_t stat;
103:                     char buf[96];
104:                     int i;
105:                     ssize_t _len;
106:                 
107:                     memset(buf, 0x00, sizeof (buf));
9D00BD70  27A40020   ADDIU A0, SP, 32
9D00BD74  00002821   ADDU A1, ZERO, ZERO
9D00BD78  0F40464F   JAL memset
9D00BD7C  24060060   ADDIU A2, ZERO, 96
108:                     getDateTime(&_nowdate, &_nowtime);
9D00BD80  27A40018   ADDIU A0, SP, 24
9D00BD84  0F405297   JAL getDateTime
9D00BD88  27A5001C   ADDIU A1, SP, 28
109:                 
110:                     if ((_type & 0x7f) != LOG_TYPE_NOP) pushLog(_nowdate, _nowtime, _type, rawdata, _rawlen);
9D00BD8C  3203007F   ANDI V1, S0, 127
9D00BD90  24020011   ADDIU V0, ZERO, 17
9D00BD94  10620007   BEQ V1, V0, 0x9D00BDB4
9D00BD98  93A200AC   LBU V0, 172(SP)
9D00BD9C  AFA20010   SW V0, 16(SP)
9D00BDA0  8FA40018   LW A0, 24(SP)
9D00BDA4  8FA5001C   LW A1, 28(SP)
9D00BDA8  02003021   ADDU A2, S0, ZERO
9D00BDAC  0F403BD0   JAL pushLog
9D00BDB0  8FA700A8   LW A3, 168(SP)
111:                 
112:                     if (xUartSendQueue == NULL) return;
9D00BDB4  8F8280EC   LW V0, -32532(GP)
9D00BDB8  10400044   BEQ V0, ZERO, 0x9D00BECC
9D00BDBC  8FBF0094   LW RA, 148(SP)
113:                     pushMessage(index, head);
114:                     snprintf(buf, 96, "@");
9D00BDD8  24020040   ADDIU V0, ZERO, 64
9D00BDDC  0B402F7B   J 0x9D00BDEC
9D00BDE0  A7A20020   SH V0, 32(SP)
115:                     pushMessage(index, buf);
116:                     getDateTimeStr(_nowdate, _nowtime, buf, sizeof (buf), false);
9D00BE00  0B402FA6   J 0x9D00BE98
9D00BE04  AFA00010   SW ZERO, 16(SP)
9D00BE78  AFA00010   SW ZERO, 16(SP)
9D00BE7C  8FA40018   LW A0, 24(SP)
9D00BE80  8FA5001C   LW A1, 28(SP)
9D00BE84  27A60020   ADDIU A2, SP, 32
9D00BE88  0F4026F7   JAL getDateTimeStr
9D00BE8C  24070060   ADDIU A3, ZERO, 96
9D00BE90  0B402F84   J 0x9D00BE10
9D00BE94  00000000   NOP
9D00BE98  8FA40018   LW A0, 24(SP)
9D00BE9C  8FA5001C   LW A1, 28(SP)
9D00BEA0  27A60020   ADDIU A2, SP, 32
9D00BEA4  0F4026F7   JAL getDateTimeStr
9D00BEA8  24070060   ADDIU A3, ZERO, 96
117:                     pushMessage(index, buf);
118:                     if (str != NULL) {
9D00BE10  1260000F   BEQ S3, ZERO, 0x9D00BE50
9D00BE14  24020020   ADDIU V0, ZERO, 32
119:                         snprintf(buf, 96, " ");
120:                         pushMessage(index, buf);
121:                         pushMessage(index, str);
122:                     }
123:                 
124:                     snprintf(buf, 96, "\n");
9D00BE48  0B402FB0   J 0x9D00BEC0
9D00BE4C  2402000A   ADDIU V0, ZERO, 10
9D00BE50  2402000A   ADDIU V0, ZERO, 10
9D00BEC0  0B402F97   J 0x9D00BE5C
9D00BEC4  A7A20020   SH V0, 32(SP)
125:                     pushMessage(index, buf);
126:                 }
9D00BE70  0B402FB3   J 0x9D00BECC
9D00BE74  8FBF0094   LW RA, 148(SP)
9D00BEC8  8FBF0094   LW RA, 148(SP)
9D00BECC  8FB30090   LW S3, 144(SP)
9D00BED0  8FB2008C   LW S2, 140(SP)
9D00BED4  8FB10088   LW S1, 136(SP)
9D00BED8  8FB00084   LW S0, 132(SP)
9D00BEDC  03E00008   JR RA
9D00BEE0  27BD0098   ADDIU SP, SP, 152
127:                 
128:                 void prvWriteToUart(void)
129:                 {
130:                     char qval[4];
131:                     BaseType_t stat;
132:                     ssize_t size;
133:                     bool mustread = true;
134:                     while (1) {
135:                         stat = pdPASS;
136:                         if (xUartSendQueue != NULL) {
137:                             while (stat == pdTRUE) {
138:                                 if (mustread) stat = xQueueReceive(xUartSendQueue, qval, 0xffffffff);
139:                                 if ((stat == pdTRUE) && (xDevHandleUart_Send != DRV_HANDLE_INVALID)) {
140:                                     //SYS_CONSOLE_Write(SYS_CONSOLE_INDEX_0, STDOUT_FILENO, qval, 1);
141:                                     size = DRV_USART_Write(xDevHandleUart_Send, qval, sizeof (char));
142:                                     if (size < (sizeof (char) * 1)) {
143:                                         mustread = false;
144:                                     } else {
145:                                         mustread = true;
146:                                     }
147:                                 }
148:                             }
149:                         }
150:                         vTaskDelay(cTick110ms);
151:                     }
152:                 }
153:                 
154:                 void prvReadFromUart(void)
155:                 {
156:                     char qval[4];
157:                     BaseType_t stat;
158:                     ssize_t _len = 0;
159:                     while (1) {
160:                         stat = pdPASS;
161:                         if (xUartRecvQueue != NULL) {
162:                             //_len = SYS_CONSOLE_Read(SYS_CONSOLE_INDEX_0, STDIN_FILENO, qval, 1);
163:                             _len = DRV_UART_Read(xDevHandleUart_Recv, qval, sizeof (char));
164:                             if (_len >= (sizeof (char) * 1)) {
165:                                 stat = xQueueSend(xUartRecvQueue, &qval, 0xffffffff);
166:                             }
167:                         }
168:                         if (_len < 1) vTaskDelay(cTick110ms);
169:                     }
170:                 }
171:                 
---  /home/whatisthis/src/DoorBell_PIC32/firmware/src/lm01.c  -------------------------------------------
1:                   
2:                   #include "doorbell.h"
3:                   
4:                   
5:                   #include "lm01_drv.h"
6:                   
7:                   
8:                   static void DRV_TEMP_LM01_SetPort(void *p, uint32_t num, bool stat)
9:                   {
9D0159F0  03E00008   JR RA
9D0159F4  00000000   NOP
10:                      //SYS_PORTS_PinWrite(PORTS_ID_0, PORT_CHANNEL_A, 0, stat);  // For I2C Bus
11:                  }
12:                  
13:                  void DRV_TEMP_LM01_Init(DRV_TEMP_LM01_T *p, uint32_t num, void *update_port, void *userptr)
14:                  {
15:                      DRV_TMR_INIT init;
16:                      p->wait_ms = (((50 + 54) * 100) / portTICK_PERIOD_MS) / 100;
9D015008  2402001A   ADDIU V0, ZERO, 26
9D01500C  AC820000   SW V0, 0(A0)
17:                      p->sensor_num = num;
9D015010  AC850004   SW A1, 4(A0)
18:                      p->temp1_Handle = NULL;
9D015014  AC800008   SW ZERO, 8(A0)
19:                      p->userptr = userptr;
20:                      if (update_port == NULL) {
9D015018  14C00005   BNE A2, ZERO, 0x9D015030
9D01501C  AC870010   SW A3, 16(A0)
21:                          p->update_port_p = &DRV_TEMP_LM01_SetPort;
9D015020  3C029D01   LUI V0, -25343
9D015024  244259F0   ADDIU V0, V0, 23024
9D015028  03E00008   JR RA
9D01502C  AC82000C   SW V0, 12(A0)
22:                      } else {
23:                          p->update_port_p = update_port;
9D015030  03E00008   JR RA
9D015034  AC86000C   SW A2, 12(A0)
24:                      }
25:                  }
26:                  
27:                  bool DRV_TEMP_LM01_StartConversion(DRV_TEMP_LM01_T *p)
28:                  {
9D012AF8  27BDFFE8   ADDIU SP, SP, -24
9D012AFC  AFBF0014   SW RA, 20(SP)
9D012B00  AFB00010   SW S0, 16(SP)
29:                      if(p == NULL) return false;
9D012B04  10800018   BEQ A0, ZERO, 0x9D012B68
9D012B08  00808021   ADDU S0, A0, ZERO
9D012B68  00001021   ADDU V0, ZERO, ZERO
30:                      if (p->temp1_Handle != NULL) return false;
9D012B0C  8C830008   LW V1, 8(A0)
9D012B10  14600016   BNE V1, ZERO, 0x9D012B6C
9D012B14  00001021   ADDU V0, ZERO, ZERO
31:                      p->temp1_Handle = DRV_TMR_Open(DRV_TMR_INDEX_2, DRV_IO_INTENT_EXCLUSIVE);
9D012B18  24040002   ADDIU A0, ZERO, 2
9D012B1C  0F405569   JAL DRV_TMR_Open
9D012B20  24050008   ADDIU A1, ZERO, 8
9D012B24  00402021   ADDU A0, V0, ZERO
9D012B28  AE020008   SW V0, 8(S0)
32:                      if (p->temp1_Handle != NULL) {
9D012B2C  1080000F   BEQ A0, ZERO, 0x9D012B6C
9D012B30  00001021   ADDU V0, ZERO, ZERO
33:                          
34:                          DRV_TMR_CounterClear(p->temp1_Handle);
9D012B34  0F404F7A   JAL DRV_TMR_CounterClear
9D012B38  00000000   NOP
35:                          DRV_TMR_Start(p->temp1_Handle);
9D012B3C  0F404E2D   JAL DRV_TMR_Start
9D012B40  8E040008   LW A0, 8(S0)
36:                         p->update_port_p(p->userptr, p->sensor_num, true);
9D012B44  8E02000C   LW V0, 12(S0)
9D012B48  8E040010   LW A0, 16(S0)
9D012B4C  8E050004   LW A1, 4(S0)
9D012B50  0040F809   JALR V0
9D012B54  24060001   ADDIU A2, ZERO, 1
37:                         vTaskDelay(p->wait_ms);
9D012B58  0F405001   JAL vTaskDelay
9D012B5C  8E040000   LW A0, 0(S0)
38:                          return true;
9D012B60  0B404ADB   J 0x9D012B6C
9D012B64  24020001   ADDIU V0, ZERO, 1
39:                      }
40:                      return false;
41:                  }
9D012B6C  8FBF0014   LW RA, 20(SP)
9D012B70  8FB00010   LW S0, 16(SP)
9D012B74  03E00008   JR RA
9D012B78  27BD0018   ADDIU SP, SP, 24
42:                  
43:                  uint32_t DRV_TEMP_LM01_EndConversion(DRV_TEMP_LM01_T *p)
44:                  {
9D013980  27BDFFE0   ADDIU SP, SP, -32
9D013984  AFBF001C   SW RA, 28(SP)
9D013988  AFB10018   SW S1, 24(SP)
9D01398C  AFB00014   SW S0, 20(SP)
9D013990  00808021   ADDU S0, A0, ZERO
45:                      uint32_t answer;
46:                      // Record time_temp1, date_temp1;
47:                      p->update_port_p(p->userptr, p->sensor_num, false);
9D013994  8C82000C   LW V0, 12(A0)
9D013998  8C840010   LW A0, 16(A0)
9D01399C  8E050004   LW A1, 4(S0)
9D0139A0  0040F809   JALR V0
9D0139A4  00003021   ADDU A2, ZERO, ZERO
48:                      DRV_TMR_Stop(p->temp1_Handle);
9D0139A8  0F404F91   JAL DRV_TMR_Stop
9D0139AC  8E040008   LW A0, 8(S0)
49:                      answer = DRV_TMR_CounterValueGet(p->temp1_Handle);
9D0139B0  0F404E13   JAL DRV_TMR_CounterValueGet
9D0139B4  8E040008   LW A0, 8(S0)
9D0139B8  00408821   ADDU S1, V0, ZERO
50:                      DRV_TMR_Close(p->temp1_Handle);
9D0139BC  0F404F4C   JAL DRV_TMR_Close
9D0139C0  8E040008   LW A0, 8(S0)
51:                      p->temp1_Handle = NULL;
9D0139C4  AE000008   SW ZERO, 8(S0)
52:                      return answer;
53:                  }
9D0139C8  02201021   ADDU V0, S1, ZERO
9D0139CC  8FBF001C   LW RA, 28(SP)
9D0139D0  8FB10018   LW S1, 24(SP)
9D0139D4  8FB00014   LW S0, 20(SP)
9D0139D8  03E00008   JR RA
9D0139DC  27BD0020   ADDIU SP, SP, 32
54:                  
55:                  #include <string.h>
56:                  #include <stdio.h>
57:                  #include "logger.h"
58:                  
59:                  void printThermalLMT01(int cons_index, int index, uint32_t temp)
60:                  {
9D00FFEC  27BDFF70   ADDIU SP, SP, -144
9D00FFF0  AFBF008C   SW RA, 140(SP)
9D00FFF4  AFB30088   SW S3, 136(SP)
9D00FFF8  AFB20084   SW S2, 132(SP)
9D00FFFC  AFB10080   SW S1, 128(SP)
9D010000  AFB0007C   SW S0, 124(SP)
9D010004  00809821   ADDU S3, A0, ZERO
9D010008  00A09021   ADDU S2, A1, ZERO
61:                      char shead[64];
62:                      char str[16];
63:                      uint8_t dbuf[10];
64:                      
65:                      int itemp;
66:                      float ftemp;
67:                  
68:                      memset(dbuf, 0x00, sizeof(dbuf));
9D01000C  27B00068   ADDIU S0, SP, 104
9D010010  AFA0006C   SW ZERO, 108(SP)
9D010014  A7A00070   SH ZERO, 112(SP)
69:                      ftemp = (float) ((temp & 0x1fff) << 8) - (50.0 * 4096.0);
9D010018  30C41FFF   ANDI A0, A2, 8191
9D01001C  0F40510D   JAL __floatunsisf
9D010020  00042200   SLL A0, A0, 8
9D010024  00402021   ADDU A0, V0, ZERO
9D010028  3C029D01   LUI V0, -25343
9D01002C  0F401CAC   JAL __subsf3
9D010030  8C455678   LW A1, 22136(V0)
70:                      ftemp = ftemp / 4096.0;
9D010034  00402021   ADDU A0, V0, ZERO
9D010038  3C029D01   LUI V0, -25343
9D01003C  0F402AA4   JAL __mulsf3
9D010040  8C45567C   LW A1, 22140(V0)
9D010044  00408821   ADDU S1, V0, ZERO
9D010048  AFA20074   SW V0, 116(SP)
71:                      memcpy(dbuf, &ftemp, sizeof(float));
9D01004C  AFA20068   SW V0, 104(SP)
72:                      
73:                      memset(shead, 0x00, sizeof(shead));
9D010050  27A40018   ADDIU A0, SP, 24
9D010054  00002821   ADDU A1, ZERO, ZERO
9D010058  0F40464F   JAL memset
9D01005C  24060040   ADDIU A2, ZERO, 64
74:                      memset(str, 0x00, sizeof(str));
9D010060  AFA00058   SW ZERO, 88(SP)
9D010064  AFA0005C   SW ZERO, 92(SP)
9D010068  AFA00060   SW ZERO, 96(SP)
9D01006C  AFA00064   SW ZERO, 100(SP)
75:                      snprintf(shead, sizeof (shead), "TEMP%02d", index);
9D010070  27A40018   ADDIU A0, SP, 24
9D010074  24050040   ADDIU A1, ZERO, 64
9D010078  3C069D01   LUI A2, -25343
9D01007C  24C65664   ADDIU A2, A2, 22116
9D010080  0F4054D3   JAL _snprintf_cdfFnopsuxX
9D010084  02403821   ADDU A3, S2, ZERO
76:                      snprintf(str, sizeof (str), "%.3f", ftemp);
9D010088  27A40058   ADDIU A0, SP, 88
9D01008C  24050010   ADDIU A1, ZERO, 16
9D010090  3C069D01   LUI A2, -25343
9D010094  24C65670   ADDIU A2, A2, 22128
9D010098  0F4054D3   JAL _snprintf_cdfFnopsuxX
9D01009C  02203821   ADDU A3, S1, ZERO
77:                      printLog(cons_index, shead, str, LOG_TYPE_TEMP1 + index, dbuf, sizeof(float));
9D0100A0  26470050   ADDIU A3, S2, 80
9D0100A4  AFB00010   SW S0, 16(SP)
9D0100A8  24020004   ADDIU V0, ZERO, 4
9D0100AC  AFA20014   SW V0, 20(SP)
9D0100B0  02602021   ADDU A0, S3, ZERO
9D0100B4  27A50018   ADDIU A1, SP, 24
9D0100B8  27A60058   ADDIU A2, SP, 88
9D0100BC  0F402F52   JAL printLog
9D0100C0  30E700FF   ANDI A3, A3, 255
78:                  }
9D0100C4  8FBF008C   LW RA, 140(SP)
9D0100C8  8FB30088   LW S3, 136(SP)
9D0100CC  8FB20084   LW S2, 132(SP)
9D0100D0  8FB10080   LW S1, 128(SP)
9D0100D4  8FB0007C   LW S0, 124(SP)
9D0100D8  03E00008   JR RA
9D0100DC  27BD0090   ADDIU SP, SP, 144
---  /home/whatisthis/src/DoorBell_PIC32/firmware/src/housekeeping.c  -----------------------------------
1:                   /*******************************************************************************
2:                     MPLAB Harmony Project Main Source File
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                     
7:                     File Name:
8:                       passthrough.c
9:                   
10:                    Summary:
11:                      Pass through via UART and USB task(s).
12:                  
13:                    Description:
14:                      This file contains the "main" function for an MPLAB Harmony project.  The
15:                      "main" function calls the "SYS_Initialize" function to initialize the state 
16:                      machines of all MPLAB Harmony modules in the system and it calls the 
17:                      "SYS_Tasks" function from within a system-wide "super" loop to maintain 
18:                      their correct operation. These two functions are implemented in 
19:                      configuration-specific files (usually "system_init.c" and "system_tasks.c")
20:                      in a configuration-specific folder under the "src/system_config" folder 
21:                      within this project's top-level folder.  An MPLAB Harmony project may have
22:                      more than one configuration, each contained within it's own folder under
23:                      the "system_config" folder.
24:                   *******************************************************************************/
25:                  
26:                  // DOM-IGNORE-BEGIN
27:                  /******************************************************************************
28:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
29:                  
30:                  //Microchip licenses to you the right to use, modify, copy and distribute
31:                  Software only when embedded on a Microchip microcontroller or digital signal
32:                  controller that is integrated into your product or third party product
33:                  (pursuant to the sublicense terms in the accompanying license agreement).
34:                  
35:                  You should refer to the license agreement accompanying this Software for
36:                  additional information regarding your rights and obligations.
37:                  
38:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
39:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
40:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
41:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
42:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
43:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
44:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
45:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
46:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
47:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
48:                   *******************************************************************************/
49:                  // DOM-IGNORE-END
50:                  
51:                  // *****************************************************************************
52:                  // *****************************************************************************
53:                  // Section: Included Files
54:                  // *****************************************************************************
55:                  // *****************************************************************************
56:                  
57:                  #include <stddef.h>                     // Defines NULL
58:                  #include <stdbool.h>                    // Defines true
59:                  #include <stdlib.h>                     // Defines EXIT_FAILURE
60:                  #include "system/common/sys_module.h"
61:                  #include "doorbell.h"   // SYS function prototypes
62:                  #include "lm01_drv.h"
63:                  #include "ringbuffer.h"
64:                  
65:                  /* Kernel includes. */
66:                  #include "FreeRTOS.h"
67:                  #include "task.h"
68:                  #include "queue.h"
69:                  #include "timers.h"
70:                  #include "semphr.h"
71:                  
72:                  #include "pca9655.h"
73:                  /* Standard demo includes. */
74:                  //#include "partest.h"
75:                  
76:                  /* Hardware specific includes. */
77:                  //#include "ConfigPerformance.h"
78:                  extern void prvWriteToUart_HK(void *pvparameters);
79:                  extern void prvReadFromUart_HK(void *pvparameters);
80:                  extern ssize_t recvUartQueue(char *buf, ssize_t len, int timeout);
81:                  extern ssize_t recvUartQueueDelim(char *buf, ssize_t maxlen, char delim, uint32_t timeout);
82:                  extern void TWE_Wakeup(bool onoff);
83:                  extern RingBuffer_Char_t xUartRecvRing;
84:                  extern QueueHandle_t xSoundCmdQueue;
85:                  extern uint32_t rtcAlarmSet(uint32_t _nowtime, uint32_t _sec, bool do_random);
86:                  
87:                  static char pStrBufHK[128];
88:                  
89:                  #define LMT01_SENSOR_NUM 1
90:                  DRV_TEMP_LM01_T x_Temp[LMT01_SENSOR_NUM];
91:                  
92:                  bool f_Interrupted;
93:                  uint32_t hk_TickVal;
94:                  extern DOORBELL_DATA doorbellData;
95:                  bool vShellMain(int index, char *head, char *tmpdata)
96:                  {
97:                      bool f_quit;
98:                      char cmdhead;
99:                      int num;
100:                     if (tmpdata == NULL) return false;
101:                 
102:                     cmdhead = tmpdata[0];
103:                 
104:                     // parse string
105:                     f_quit = false;
106:                     switch (cmdhead) {
107:                     case 'Q':
108:                     case 'q':
109:                         printLog(index, head, "MSG QUIT SHELL", LOG_TYPE_MESSAGE, NULL, 0);
110:                         f_quit = true;
111:                         break;
112:                     case 'T': // set time
113:                         if ((tmpdata[1] == ' ') && (strlen(tmpdata) > 3)) {
114:                             if (setDateTimeStr(&(tmpdata[2]))) {
115:                                 printLog(index, head, "MSG TIME SET", LOG_TYPE_TIME_UPDATED, NULL, 0);
116:                             } else {
117:                                 printLog(index, head, "MSG TIME ERR", LOG_TYPE_TIME_ERROR, NULL, 0);
118:                             }
119:                         }
120:                         break;
121:                     case 't':
122:                         // Get tempareture #
123:                         if (strlen(tmpdata) < 3) {
124:                             num = 0;
125:                         } else if ((tmpdata[2] >= '0') && (tmpdata[2] <= '9')) {
126:                             num = tmpdata[2] - '0';
127:                         } else if ((tmpdata[2] >= 'a') && (tmpdata[2] <= 'f')) {
128:                             num = tmpdata[2] - 'a' + 10;
129:                         } else if ((tmpdata[2] >= 'A') && (tmpdata[2] <= 'F')) {
130:                             num = tmpdata[2] - 'A' + 10;
131:                         }
132:                         if (num < LMT01_SENSOR_NUM) {
133:                             if (DRV_TEMP_LM01_StartConversion(&(x_Temp[num]))) {
134:                                 uint32_t tval;
135:                                 vTaskDelay(cTick110ms);
136:                                 tval = DRV_TEMP_LM01_EndConversion(&(x_Temp[num]));
137:                                 printThermalLMT01(index, num, tval); // USB
138:                             }
139:                         }
140:                         break;
141:                     case 'h':
142:                     case 'H':
143:                         printLog(index, head, "MSG SHELL HELP", LOG_TYPE_NOP, NULL, 0);
144:                         printLog(index, head, "HELP T [yyyy/MM/DD hh:mm:ss]  : Set time", LOG_TYPE_NOP, NULL, 0);
145:                         printLog(index, head, "HELP t [num]  : Get tempareture : num = [0-9] or [A-F].", LOG_TYPE_NOP, NULL, 0);
146:                         printLog(index, head, "HELP s : Stop Sound .", LOG_TYPE_NOP, NULL, 0);
147:                         printLog(index, head, "HELP ms [num] : Set main MML to [num] : num = [0-9] or [A-F].", LOG_TYPE_NOP, NULL, 0);
148:                         printLog(index, head, "HELP md num : Delete MML [num].", LOG_TYPE_NOP, NULL, 0);
149:                         printLog(index, head, "HELP ml : List MMLs.", LOG_TYPE_NOP, NULL, 0);
150:                         printLog(index, head, "HELP mu num : Upload MML to [num]. MML should be ended with '.'.", LOG_TYPE_NOP, NULL, 0);
151:                         printLog(index, head, "HELP x [num] : Read switch value #num.", LOG_TYPE_NOP, NULL, 0);
152:                         printLog(index, head, "HELP l [all-log] : Read log.If all-log = ALL print all stored log.", LOG_TYPE_NOP, NULL, 0);
153:                         printLog(index, head, "HELP H : Print this help.", LOG_TYPE_NOP, NULL, 0);
154:                         printLog(index, head, "HELP q : Quit.", LOG_TYPE_NOP, NULL, 0);
155:                         printLog(index, head, "MSG HELP END", LOG_TYPE_NOP, NULL, 0);
156:                         break;
157:                     case 'p':
158:                         // Test sound arg1 = num
159:                         // If don't set, play default.
160:                         break;
161:                     case 's':
162:                         // Stop sound.
163:                         break;
164:                     case 'm':
165:                         // manage MML
166:                         // arg0 = ms : Set number of MML
167:                         //        md : Delete number of MML.
168:                         //        mu : Upload MML
169:                         //             arg1 = num;
170:                         //             if prompt(MML>) displayed, you can push MML.
171:                         break;
172:                     case 'l':
173:                         // Load log
174:                         // l/lu : load unsent log.
175:                         // la   : load all log.
176:                         // lcc  : Clear chalacter logs.
177:                         // lcb  : Clear binary logs.
178:                         // ln   : print number of logs.
179:                         break;
180:                     case 'x':
181:                         //  Read/Set switch value.
182:                         break;
183:                     default:
184:                         break;
185:                     }
186:                     return f_quit;
187:                 }
188:                 SemaphoreHandle_t xWakeupTimerSemaphore;
189:                 
190:                 SYS_RTCC_ALARM_CALLBACK wakeupCallback(SYS_RTCC_ALARM_HANDLE handle, uintptr_t context)
191:                 {
9D014708  27BDFFE8   ADDIU SP, SP, -24
9D01470C  AFBF0014   SW RA, 20(SP)
9D014710  AFB00010   SW S0, 16(SP)
192:                     while (xSemaphoreGive(xWakeupTimerSemaphore) != pdPASS) {
9D014714  0B4051C9   J 0x9D014724
9D014718  24100001   ADDIU S0, ZERO, 1
9D014724  8F84813C   LW A0, -32452(GP)
9D014728  00002821   ADDU A1, ZERO, ZERO
9D01472C  00003021   ADDU A2, ZERO, ZERO
9D014730  0F401FB3   JAL xQueueGenericSend
9D014734  00003821   ADDU A3, ZERO, ZERO
9D014738  1450FFF8   BNE V0, S0, 0x9D01471C
9D01473C  8FBF0014   LW RA, 20(SP)
193:                         vTaskDelay(cTick100ms);
9D01471C  0F405001   JAL vTaskDelay
9D014720  8F8480F8   LW A0, -32520(GP)
194:                     }
195:                 }
9D014740  8FB00010   LW S0, 16(SP)
9D014744  03E00008   JR RA
9D014748  27BD0018   ADDIU SP, SP, 24
196:                 static const uint32_t days_of_month[12] ={
197:                     0x00003100,
198:                     0x00002800,
199:                     0x00003100,
200:                     0x00003000,
201:                     0x00003100,
202:                     0x00003000,
203:                     0x00003100,
204:                     0x00003100,
205:                     0x00003000,
206:                     0x00003100,
207:                     0x00003000,
208:                     0x00003100,
209:                 };
210:                 // AD2..0 = SCL,SDA,VDD
211:                 #define I2C_EXPANDER_ADDRESS 0xa6
212:                 #define I2C_USING_DRV 0
213:                 #define IO_CHECK_BUZZER_BIT 7
214:                 PCA9655_t ioexpander1_data;
215:                 DRV_HANDLE i2cHandle;
216:                 static  PCA9655_INIT_t ioexpander1_init_data;
217:                 
218:                 static inline bool check_button_level(PCA9655_t *desc, uint32_t checkbit)
219:                 {
220:                     return DRV_PCA9655_GetPort_Bit((void *)desc, checkbit);
221:                 }
222:                 
223:                 bool CheckLowVoltage(void)
224:                 {
225:                     bool status = PLIB_PORTS_PinGet(PORTS_ID_0, PORT_CHANNEL_B, 3);
226:                     return status;
227:                 }
9D01591C  03E00008   JR RA
9D015920  7C4200C0   EXT V0, V0, 3, 1
228:                 
229:                 bool CheckBatteryRemoved(void)
230:                 {
9D015374  27BDFFE8   ADDIU SP, SP, -24
9D015378  AFBF0014   SW RA, 20(SP)
231:                     bool status = DRV_PCA9655_GetPort_Bit(&ioexpander1_data, 4); // IO0_4
9D01537C  3C04A000   LUI A0, -24576
9D015380  24840B68   ADDIU A0, A0, 2920
9D015384  0F405227   JAL DRV_PCA9655_GetPort_Bit
9D015388  24050004   ADDIU A1, ZERO, 4
232:                     return status; 
233:                 }
9D01538C  8FBF0014   LW RA, 20(SP)
9D015390  03E00008   JR RA
9D015394  27BD0018   ADDIU SP, SP, 24
234:                 void prvHouseKeeping(void *pvParameters)
235:                 {
9D002C98  27BDFF90   ADDIU SP, SP, -112
9D002C9C  AFBF006C   SW RA, 108(SP)
9D002CA0  AFBE0068   SW S8, 104(SP)
9D002CA4  AFB70064   SW S7, 100(SP)
9D002CA8  AFB60060   SW S6, 96(SP)
9D002CAC  AFB5005C   SW S5, 92(SP)
9D002CB0  AFB40058   SW S4, 88(SP)
9D002CB4  AFB30054   SW S3, 84(SP)
9D002CB8  AFB20050   SW S2, 80(SP)
9D002CBC  AFB1004C   SW S1, 76(SP)
9D002CC0  AFB00048   SW S0, 72(SP)
236:                     bool first = true;
9D002DFC  24100001   ADDIU S0, ZERO, 1
237:                     //bool first = false;
238:                     bool time_set = false;
239:                     BaseType_t stat;
240:                     uint32_t tval;
241:                     uint32_t data;
242:                     int i;
243:                     bool debug_mode;
244:                     bool rtcc_sleep = true;
245:                     SYS_RTCC_BCD_DATE _nowdate;
246:                     SYS_RTCC_BCD_TIME _nowtime;
247:                     static char ssbuf[64];
248:                     uint32_t hostnum;
249:                     bool timeout = false;
9D002DF8  AFA00040   SW ZERO, 64(SP)
250:                     bool pass = false;
9D002DF4  0000F021   ADDU S8, ZERO, ZERO
251:                     bool battery_removed;
252:                     bool low_voltage;
253:                     int retry = 0;
9D002DF0  00009021   ADDU S2, ZERO, ZERO
254:                     uint32_t nexttime;
255:                     int n;
256:                     char *ps;
257:                     SYS_RTCC_ALARM_HANDLE wakeupHandle;
258:                     int sndcmd;
259:                     
260:                     uint8_t pca9655_regs[8];
261:                     
262:                     f_Interrupted = false; // External switch status
9D002CC4  A3808140   SB ZERO, -32448(GP)
263:                     //hk_TickVal = 300;
264:                     hk_TickVal = 10;
9D002CC8  2402000A   ADDIU V0, ZERO, 10
9D002CCC  AF828144   SW V0, -32444(GP)
265:                     xWakeupTimerSemaphore = xSemaphoreCreateBinary();
9D002CD0  24040001   ADDIU A0, ZERO, 1
9D002CD4  00002821   ADDU A1, ZERO, ZERO
9D002CD8  0F4048CD   JAL xQueueGenericCreate
9D002CDC  24060003   ADDIU A2, ZERO, 3
9D002CE0  AF82813C   SW V0, -32452(GP)
266:                     //xSemaphoreGive(xWakeupTimerSemaphore);
267:                     i2cHandle = sv_open_i2c(I2C_USING_DRV);
9D002CE4  0F4049A8   JAL sv_open_i2c
9D002CE8  00002021   ADDU A0, ZERO, ZERO
9D002CEC  AF828148   SW V0, -32440(GP)
268:                     
269:                     ioexpander1_init_data.close_port = &DRV_PCA9655_sample_close_port;
9D002CF0  3C04A000   LUI A0, -24576
9D002CF4  24837398   ADDIU V1, A0, 29592
9D002CF8  3C059D01   LUI A1, -25343
9D002CFC  24A55A00   ADDIU A1, A1, 23040
9D002D00  AC65000C   SW A1, 12(V1)
270:                     //ioexpander1_init_data.close_port = NULL;
271:                     ioexpander1_init_data.open_port = &DRV_PCA9655_sample_open_port;
9D002D04  3C059D01   LUI A1, -25343
9D002D08  24A559F8   ADDIU A1, A1, 23032
9D002D0C  AC650008   SW A1, 8(V1)
272:                     ioexpander1_init_data.direction_0 = 0b11011100; // IO0_5 = Out (AUDIO_ON)
9D002D10  2405FFDC   ADDIU A1, ZERO, -36
9D002D14  A0857398   SB A1, 29592(A0)
273:                     ioexpander1_init_data.direction_1 = 0b11110000; // ALL OUT
9D002D18  2404FFF0   ADDIU A0, ZERO, -16
9D002D1C  A0640001   SB A0, 1(V1)
274:                     ioexpander1_init_data.polality_0 = 0b00000000; // Not invert
9D002D20  A0600002   SB ZERO, 2(V1)
275:                     ioexpander1_init_data.polality_1 = 0b00000000; // Not invert
9D002D24  A0600003   SB ZERO, 3(V1)
276:                     ioexpander1_init_data.data_0 = 0b11111100; // IO0_5 = ON
9D002D28  2405FFFC   ADDIU A1, ZERO, -4
9D002D2C  A0650004   SB A1, 4(V1)
277:                     ioexpander1_init_data.data_1 = 0b11110000; // ALL OFF
9D002D30  A0640005   SB A0, 5(V1)
278:                     I2C1CONbits.ON = 1;
9D002D34  3C04BF80   LUI A0, -16512
9D002D38  94855000   LHU A1, 20480(A0)
9D002D3C  24060001   ADDIU A2, ZERO, 1
9D002D40  7CC57BC4   INS A1, A2, 15, 1
9D002D44  A4855000   SH A1, 20480(A0)
279:                     DRV_PCA9655_Init(0, i2cHandle, &ioexpander1_data, (uint16_t)I2C_EXPANDER_ADDRESS, &ioexpander1_init_data);
9D002D48  AFA30010   SW V1, 16(SP)
9D002D4C  00002021   ADDU A0, ZERO, ZERO
9D002D50  00402821   ADDU A1, V0, ZERO
9D002D54  3C10A000   LUI S0, -24576
9D002D58  26060B68   ADDIU A2, S0, 2920
9D002D5C  0F40442E   JAL DRV_PCA9655_Init
9D002D60  240700A6   ADDIU A3, ZERO, 166
280:                     DRV_PCA9655_SetPort(&ioexpander1_data, 5, false);
9D002D64  26040B68   ADDIU A0, S0, 2920
9D002D68  24050005   ADDIU A1, ZERO, 5
9D002D6C  0F402FB9   JAL DRV_PCA9655_SetPort
9D002D70  00003021   ADDU A2, ZERO, ZERO
281:                     battery_removed = CheckBatteryRemoved();
9D002D74  0F4054DD   JAL CheckBatteryRemoved
9D002D78  00000000   NOP
282:                     low_voltage = CheckLowVoltage();
9D002D7C  0F405645   JAL CheckLowVoltage
9D002D80  00000000   NOP
283:                     for (i = 0; i < LMT01_SENSOR_NUM; i++) {
284:                         DRV_TEMP_LM01_Init(&(x_Temp[i]),  (uint32_t)(i + 8), &DRV_PCA9655_SetPort, (void *)(&ioexpander1_data)); 
9D002D84  3C04A000   LUI A0, -24576
9D002D88  24840B54   ADDIU A0, A0, 2900
9D002D8C  24050008   ADDIU A1, ZERO, 8
9D002D90  3C069D01   LUI A2, -25343
9D002D94  24C6BEE4   ADDIU A2, A2, -16668
9D002D98  0F405402   JAL DRV_TEMP_LM01_Init
9D002D9C  26070B68   ADDIU A3, S0, 2920
285:                     }
286:                     memset(pStrBufHK, 0x00, sizeof (pStrBufHK));
9D002DA0  3C04A000   LUI A0, -24576
9D002DA4  248473A8   ADDIU A0, A0, 29608
9D002DA8  00002821   ADDU A1, ZERO, ZERO
9D002DAC  0F40464F   JAL memset
9D002DB0  24060080   ADDIU A2, ZERO, 128
287:                     SLEEP_Periferals(true); // Disable unused periferals.
9D002DB4  0F4038DF   JAL SLEEP_Periferals
9D002DB8  24040001   ADDIU A0, ZERO, 1
288:                     wakeupHandle = SYS_RTCC_AlarmRegister(&wakeupCallback, NULL);
9D002DBC  3C049D01   LUI A0, -25343
9D002DC0  24844708   ADDIU A0, A0, 18184
9D002DC4  0F4055AE   JAL SYS_RTCC_AlarmRegister
9D002DC8  00002821   ADDU A1, ZERO, ZERO
289:                     SYS_RESET_ReasonClear(doorbellData.resetReason);
9D002DCC  3C02A000   LUI V0, -24576
9D002DD0  0F405665   JAL SYS_RESET_ReasonClear
9D002DD4  8C4404A0   LW A0, 1184(V0)
290:                     
291:                     TWE_Wakeup(false);
9D002DD8  0F40539A   JAL TWE_Wakeup
9D002DDC  00002021   ADDU A0, ZERO, ZERO
292:                     RPA1Rbits.RPA1R = 0b0000; // Sound OFF
9D002DE0  3C02BF81   LUI V0, -16511
9D002DE4  9043FB04   LBU V1, -1276(V0)
9D002DE8  7C031804   INS V1, ZERO, 0, 4
9D002DEC  A043FB04   SB V1, -1276(V0)
293:                     while (1) {
294:                         SYS_WDT_TimerClear();
9D002E18  0F405640   JAL SYS_WDT_TimerClear
9D002E1C  00000000   NOP
295:                         //SYS_WDT_Enable(false);
296:                         sndcmd = C_SOUND_START;
9D002E20  24020002   ADDIU V0, ZERO, 2
9D002E24  AFA20038   SW V0, 56(SP)
297:                         xQueueSend(xSoundCmdQueue, &sndcmd, 0);
9D002E28  8F848154   LW A0, -32428(GP)
9D002E2C  27A50038   ADDIU A1, SP, 56
9D002E30  00003021   ADDU A2, ZERO, ZERO
9D002E34  0F401FB3   JAL xQueueGenericSend
9D002E38  00003821   ADDU A3, ZERO, ZERO
298:                         if (first) {
9D002E3C  1200009E   BEQ S0, ZERO, 0x9D0030B8
9D002E40  00000000   NOP
299:                             SYS_WDT_TimerClear();
9D002E44  0F405640   JAL SYS_WDT_TimerClear
9D002E48  00000000   NOP
300:                             TWE_Wakeup(true);
9D002E4C  0F40539A   JAL TWE_Wakeup
9D002E50  24040001   ADDIU A0, ZERO, 1
301:                             vTaskDelay(cTick100ms);
9D002E54  0F405001   JAL vTaskDelay
9D002E58  8F8480F8   LW A0, -32520(GP)
302:                             vRingBufferClear_Char(&xUartRecvRing);
9D002E5C  3C04A000   LUI A0, -24576
9D002E60  0F404CB4   JAL vRingBufferClear_Char
9D002E64  24840400   ADDIU A0, A0, 1024
303:                             vTaskDelay(cTick100ms);
9D002E68  0F405001   JAL vTaskDelay
9D002E6C  8F8480F8   LW A0, -32520(GP)
304:                             // "yyyy/MM/dd DoW hh:mm:ss"
305:                             printLog(0, "BEGIN", "DOORBELL HOUSEKEEPING TASK", LOG_TYPE_MESSAGE, NULL, 0);
9D002E70  AFA00010   SW ZERO, 16(SP)
9D002E74  AFA00014   SW ZERO, 20(SP)
9D002E78  00002021   ADDU A0, ZERO, ZERO
9D002E7C  3C059D00   LUI A1, -25344
9D002E80  24A56640   ADDIU A1, A1, 26176
9D002E84  3C069D00   LUI A2, -25344
9D002E88  24C66648   ADDIU A2, A2, 26184
9D002E8C  0F402F52   JAL printLog
9D002E90  00003821   ADDU A3, ZERO, ZERO
306:                             printLog(0, "MSG", "NOW TIME IS", LOG_TYPE_MESSAGE, NULL, 0);
9D002E94  AFA00010   SW ZERO, 16(SP)
9D002E98  AFA00014   SW ZERO, 20(SP)
9D002E9C  00002021   ADDU A0, ZERO, ZERO
9D002EA0  3C059D00   LUI A1, -25344
9D002EA4  24A56664   ADDIU A1, A1, 26212
9D002EA8  3C069D00   LUI A2, -25344
9D002EAC  24C66668   ADDIU A2, A2, 26216
9D002EB0  0F402F52   JAL printLog
9D002EB4  00003821   ADDU A3, ZERO, ZERO
307:                             if((doorbellData.resetReason & RESET_REASON_WDT_TIMEOUT) != 0) {
9D002EB8  3C02A000   LUI V0, -24576
9D002EBC  8C4204A0   LW V0, 1184(V0)
9D002EC0  30420010   ANDI V0, V0, 16
9D002EC4  1040000B   BEQ V0, ZERO, 0x9D002EF4
9D002EC8  3C02A000   LUI V0, -24576
308:                                 printLog(0, "MSG", "WDT EXPIRED.", LOG_TYPE_WDT_RESET, NULL, 0);
9D002ECC  AFA00010   SW ZERO, 16(SP)
9D002ED0  AFA00014   SW ZERO, 20(SP)
9D002ED4  00002021   ADDU A0, ZERO, ZERO
9D002ED8  3C059D00   LUI A1, -25344
9D002EDC  24A56664   ADDIU A1, A1, 26212
9D002EE0  3C069D00   LUI A2, -25344
9D002EE4  24C66674   ADDIU A2, A2, 26228
9D002EE8  0F402F52   JAL printLog
9D002EEC  24070007   ADDIU A3, ZERO, 7
309:                             } 
310:                             if((doorbellData.resetReason & 0x03) == RESET_REASON_BROWNOUT) {
9D002EF0  3C02A000   LUI V0, -24576
9D002EF4  8C4304A0   LW V1, 1184(V0)
9D002EF8  30630003   ANDI V1, V1, 3
9D002EFC  24020002   ADDIU V0, ZERO, 2
9D002F00  1462000B   BNE V1, V0, 0x9D002F30
9D002F04  3C11A000   LUI S1, -24576
311:                                 printLog(0, "MSG", "LOW VOLTAGE RESET HAPPENED.", LOG_TYPE_BOR_RESET, NULL, 0);
9D002F08  AFA00010   SW ZERO, 16(SP)
9D002F0C  AFA00014   SW ZERO, 20(SP)
9D002F10  00002021   ADDU A0, ZERO, ZERO
9D002F14  3C059D00   LUI A1, -25344
9D002F18  24A56664   ADDIU A1, A1, 26212
9D002F1C  3C069D00   LUI A2, -25344
9D002F20  24C66684   ADDIU A2, A2, 26244
9D002F24  0F402F52   JAL printLog
9D002F28  24070008   ADDIU A3, ZERO, 8
312:                             }
313:                             i = 0;
314:                             do {
315:                                 SYS_WDT_TimerClear();
9D002F40  0F405640   JAL SYS_WDT_TimerClear
9D002F44  00000000   NOP
316:                                 printLog(0, "REQ", "DATETIME WAIT 15 SEC", LOG_TYPE_MESSAGE, NULL, 0);
9D002E00  3C159D00   LUI S5, -25344
9D002E04  26B566A0   ADDIU S5, S5, 26272
9D002E08  3C149D00   LUI S4, -25344
9D002E0C  269466A4   ADDIU S4, S4, 26276
9D002F48  AFA00010   SW ZERO, 16(SP)
9D002F4C  AFA00014   SW ZERO, 20(SP)
9D002F50  00002021   ADDU A0, ZERO, ZERO
9D002F54  02A02821   ADDU A1, S5, ZERO
9D002F58  02803021   ADDU A2, S4, ZERO
9D002F5C  0F402F52   JAL printLog
9D002F60  00003821   ADDU A3, ZERO, ZERO
317:                                 //vTaskDelay(cTick1Sec * 5);
318:                                 
319:                                 printMessage(0, NULL, "OK");
9D002E10  3C139D00   LUI S3, -25344
9D002E14  267366BC   ADDIU S3, S3, 26300
9D002F64  00002021   ADDU A0, ZERO, ZERO
9D002F68  00002821   ADDU A1, ZERO, ZERO
9D002F6C  0F403891   JAL printMessage
9D002F70  02603021   ADDU A2, S3, ZERO
320:                                 //vTaskDelay(cTick200ms);
321:                                 pStrBufHK[0] = '\0';
9D002F2C  3C11A000   LUI S1, -24576
9D002F74  A22073A8   SB ZERO, 29608(S1)
322:                             _nn0:
323:                                 n = recvUartQueueDelim(pStrBufHK, sizeof (pStrBufHK) / sizeof (char), '\n', cTick5Sec * 3);
9D002F30  263073A8   ADDIU S0, S1, 29608
9D002F78  8F82812C   LW V0, -32468(GP)
9D002F7C  00023840   SLL A3, V0, 1
9D002F80  02002021   ADDU A0, S0, ZERO
9D002F84  24050080   ADDIU A1, ZERO, 128
9D002F88  2406000A   ADDIU A2, ZERO, 10
9D002F8C  0F403275   JAL recvUartQueueDelim
9D002F90  00E23821   ADDU A3, A3, V0
324:                                 if (n > 0) {
9D002F94  18400027   BLEZ V0, 0x9D003034
9D002F98  02002021   ADDU A0, S0, ZERO
325:                                     if (checkSender(pStrBufHK, &hostnum, &ps, sizeof (pStrBufHK) / sizeof (char)) == N_HOST_COMPLETE) {
9D002F9C  27A50030   ADDIU A1, SP, 48
9D002FA0  27A60034   ADDIU A2, SP, 52
9D002FA4  0F402480   JAL checkSender
9D002FA8  24070080   ADDIU A3, ZERO, 128
9D002FAC  1440FFF3   BNE V0, ZERO, 0x9D002F7C
9D002FB0  8F82812C   LW V0, -32468(GP)
326:                                         if (ps != NULL) {
9D002FB4  8FA40034   LW A0, 52(SP)
9D002FB8  1080FFE1   BEQ A0, ZERO, 0x9D002F40
9D002FBC  00000000   NOP
327:                                             if (!setDateTimeStr(ps)) {
9D002FC0  0F401726   JAL setDateTimeStr
9D002FC4  00000000   NOP
9D002FC8  1440000D   BNE V0, ZERO, 0x9D003000
9D002FCC  02E02821   ADDU A1, S7, ZERO
328:                                                 printLog(0, "ERR", "WRONG TIME STRING.", LOG_TYPE_MESSAGE, NULL, 0);
9D002F34  3C179D00   LUI S7, -25344
9D002F38  26F766C0   ADDIU S7, S7, 26304
9D002F3C  3C169D00   LUI S6, -25344
9D002FD0  AFA00010   SW ZERO, 16(SP)
9D002FD4  AFA00014   SW ZERO, 20(SP)
9D002FD8  00002021   ADDU A0, ZERO, ZERO
9D002FDC  26C666C4   ADDIU A2, S6, 26308
9D002FE0  0F402F52   JAL printLog
9D002FE4  00003821   ADDU A3, ZERO, ZERO
329:                                                 retry++;
9D002FE8  26520001   ADDIU S2, S2, 1
330:                                                 if (retry >= 5) break;
9D002FEC  2A420005   SLTI V0, S2, 5
9D002FF0  1440FFD3   BNE V0, ZERO, 0x9D002F40
9D002FF4  00000000   NOP
9D002FF8  0B400C11   J 0x9D003044
9D002FFC  00000000   NOP
331:                                             } else {
332:                                                 printLog(0, "MSG", "TIME SET.", LOG_TYPE_MESSAGE, NULL, 0);
9D003000  AFA00010   SW ZERO, 16(SP)
9D003004  AFA00014   SW ZERO, 20(SP)
9D003008  00002021   ADDU A0, ZERO, ZERO
9D00300C  3C059D00   LUI A1, -25344
9D003010  24A56664   ADDIU A1, A1, 26212
9D003014  3C069D00   LUI A2, -25344
9D003018  24C666D8   ADDIU A2, A2, 26328
9D00301C  0F402F52   JAL printLog
9D003020  00003821   ADDU A3, ZERO, ZERO
333:                                                 pass = true;
334:                                                 break;
335:                                             }
336:                                         }
337:                                     } else {
338:                                         goto _nn0;
339:                                     }
340:                                 } else if (n == 0) {
9D003034  1040FFD1   BEQ V0, ZERO, 0x9D002F7C
9D003038  8F82812C   LW V0, -32468(GP)
9D00303C  0B400CE9   J 0x9D0033A4
9D003040  00000000   NOP
341:                                     goto _nn0;
342:                                     //printLog(0, "ERR", "UNKNOWN TIME STRING.", LOG_TYPE_MESSAGE, NULL, 0);
343:                                 } else {
344:                                     timeout = true;
9D0030B0  AFA20040   SW V0, 64(SP)
9D0033B4  0B400C17   J 0x9D00305C
9D0033B8  AFA20040   SW V0, 64(SP)
345:                                     break;
346:                                 }
347:                             } while (n > 0);
348:                            SYS_WDT_TimerClear();
9D003024  0F405640   JAL SYS_WDT_TimerClear
9D003028  241E0001   ADDIU S8, ZERO, 1
9D003044  0F405640   JAL SYS_WDT_TimerClear
9D003048  00008021   ADDU S0, ZERO, ZERO
9D0033A4  0F405640   JAL SYS_WDT_TimerClear
9D0033A8  00000000   NOP
349:                             if (!pass) {
9D00304C  17C0001A   BNE S8, ZERO, 0x9D0030B8
9D003050  8FA20040   LW V0, 64(SP)
9D0033AC  17C0FF40   BNE S8, ZERO, 0x9D0030B0
9D0033B0  24020001   ADDIU V0, ZERO, 1
350:                                 if (timeout) printLog(0, "ERR", "TIME OUT.", LOG_TYPE_MESSAGE, NULL, 0);
9D003054  5040000B   BEQL V0, ZERO, 0x9D003084
9D003058  AFA00010   SW ZERO, 16(SP)
9D00305C  AFA00010   SW ZERO, 16(SP)
9D003060  AFA00014   SW ZERO, 20(SP)
9D003064  00002021   ADDU A0, ZERO, ZERO
9D003068  3C059D00   LUI A1, -25344
9D00306C  24A566C0   ADDIU A1, A1, 26304
9D003070  3C069D00   LUI A2, -25344
9D003074  24C666E4   ADDIU A2, A2, 26340
9D003078  0F402F52   JAL printLog
9D00307C  00003821   ADDU A3, ZERO, ZERO
351:                                 printLog(0, "ERR", "IGNORE TIME SETTING.", LOG_TYPE_MESSAGE, NULL, 0);
9D003080  AFA00010   SW ZERO, 16(SP)
9D003084  AFA00014   SW ZERO, 20(SP)
9D003088  00002021   ADDU A0, ZERO, ZERO
9D00308C  3C059D00   LUI A1, -25344
9D003090  24A566C0   ADDIU A1, A1, 26304
9D003094  3C069D00   LUI A2, -25344
9D003098  24C666F0   ADDIU A2, A2, 26352
9D00309C  0F402F52   JAL printLog
9D0030A0  00003821   ADDU A3, ZERO, ZERO
9D0030A4  0000F021   ADDU S8, ZERO, ZERO
352:                             }
353:                             first = false;
9D00302C  0B400C2E   J 0x9D0030B8
9D003030  00008021   ADDU S0, ZERO, ZERO
9D0030A8  0B400C2E   J 0x9D0030B8
9D0030AC  00008021   ADDU S0, ZERO, ZERO
9D0030B4  00008021   ADDU S0, ZERO, ZERO
354:                         }
355:                         SYS_RTCC_DateGet(&_nowdate);
9D0030B8  0F4055C2   JAL SYS_RTCC_DateGet
9D0030BC  27A40028   ADDIU A0, SP, 40
356:                         SYS_RTCC_TimeGet(&_nowtime);
9D0030C0  0F4055BC   JAL SYS_RTCC_TimeGet
9D0030C4  27A4002C   ADDIU A0, SP, 44
357:                         SYS_WDT_TimerClear();
9D0030C8  0F405640   JAL SYS_WDT_TimerClear
9D0030CC  00000000   NOP
358:                         TWE_Wakeup(true);
9D0030D0  0F40539A   JAL TWE_Wakeup
9D0030D4  24040001   ADDIU A0, ZERO, 1
359:                         //vTaskDelay(cTick1Sec);
360:                         printLog(0, "MSG", "WAKE UP", LOG_TYPE_MESSAGE, NULL, 0);
9D0030D8  AFA00010   SW ZERO, 16(SP)
9D0030DC  AFA00014   SW ZERO, 20(SP)
9D0030E0  00002021   ADDU A0, ZERO, ZERO
9D0030E4  3C059D00   LUI A1, -25344
9D0030E8  24A56664   ADDIU A1, A1, 26212
9D0030EC  3C069D00   LUI A2, -25344
9D0030F0  24C66708   ADDIU A2, A2, 26376
9D0030F4  0F402F52   JAL printLog
9D0030F8  00003821   ADDU A3, ZERO, ZERO
361:                         TWE_Wakeup(false);
9D0030FC  0F40539A   JAL TWE_Wakeup
9D003100  00002021   ADDU A0, ZERO, ZERO
362:                         SYS_WDT_TimerClear();
9D003104  0F405640   JAL SYS_WDT_TimerClear
9D003108  00000000   NOP
363:                         DRV_PCA9655_Reset(&ioexpander1_data, 0, 0, false); // Reset I/O Expander.
9D00310C  3C04A000   LUI A0, -24576
9D003110  24840B68   ADDIU A0, A0, 2920
9D003114  00002821   ADDU A1, ZERO, ZERO
9D003118  00003021   ADDU A2, ZERO, ZERO
9D00311C  0F4025FD   JAL DRV_PCA9655_Reset
9D003120  00003821   ADDU A3, ZERO, ZERO
364:                 #if 1
365:                         for (i = 0; i < LMT01_SENSOR_NUM; i++) {
366:                             I2C1CONbits.ON = 1;
9D003124  3C02BF80   LUI V0, -16512
9D003128  94435000   LHU V1, 20480(V0)
9D00312C  24040001   ADDIU A0, ZERO, 1
9D003130  7C837BC4   INS V1, A0, 15, 1
9D003134  A4435000   SH V1, 20480(V0)
367:                             if (DRV_TEMP_LM01_StartConversion(&(x_Temp[i]))) {
9D003138  3C04A000   LUI A0, -24576
9D00313C  0F404ABE   JAL DRV_TEMP_LM01_StartConversion
9D003140  24840B54   ADDIU A0, A0, 2900
9D003144  10400013   BEQ V0, ZERO, 0x9D003194
9D003148  3C02BF80   LUI V0, -16512
368:                             I2C1CONbits.ON = 1;
9D00314C  94435000   LHU V1, 20480(V0)
9D003150  24040001   ADDIU A0, ZERO, 1
9D003154  7C837BC4   INS V1, A0, 15, 1
9D003158  A4435000   SH V1, 20480(V0)
369:                                 tval = DRV_TEMP_LM01_EndConversion(&(x_Temp[i]));
9D00315C  3C04A000   LUI A0, -24576
9D003160  0F404E60   JAL DRV_TEMP_LM01_EndConversion
9D003164  24840B54   ADDIU A0, A0, 2900
9D003168  00408821   ADDU S1, V0, ZERO
370:                                 TWE_Wakeup(true);
9D00316C  0F40539A   JAL TWE_Wakeup
9D003170  24040001   ADDIU A0, ZERO, 1
371:                                 printThermalLMT01(0, i, tval); // USB
9D003174  00002021   ADDU A0, ZERO, ZERO
9D003178  00002821   ADDU A1, ZERO, ZERO
9D00317C  0F403FFB   JAL printThermalLMT01
9D003180  02203021   ADDU A2, S1, ZERO
372:                                 TWE_Wakeup(false);
9D003184  0F40539A   JAL TWE_Wakeup
9D003188  00002021   ADDU A0, ZERO, ZERO
373:                                 SYS_WDT_TimerClear();
9D00318C  0F405640   JAL SYS_WDT_TimerClear
9D003190  00000000   NOP
374:                             }
375:                         }
376:                 #endif
377:                 #if 0
378:                         DRV_PCA9655_GetRegs(&ioexpander1_data, pca9655_regs);
379:                         TWE_Wakeup(true);
380:                         printLog(0, "DEBUG",   "PCA6955 REGS   0  1  2  3", LOG_TYPE_MESSAGE, NULL, 0);
381:                         snprintf(pStrBufHK, 48, "PCA9655 REG +0: %02x %02x %02x %02x", pca9655_regs[0], pca9655_regs[1], pca9655_regs[2], pca9655_regs[3]);
382:                         printLog(0, "DEBUG", pStrBufHK, LOG_TYPE_MESSAGE, NULL, 0);
383:                         snprintf(pStrBufHK, 48, "PCA9655 REG +4: %02x %02x %02x %02x", pca9655_regs[4], pca9655_regs[5], pca9655_regs[6], pca9655_regs[7]);
384:                         printLog(0, "DEBUG", pStrBufHK, LOG_TYPE_MESSAGE, NULL, 0);
385:                         TWE_Wakeup(false);
386:                        //vTaskDelay(cTick1Sec * 5);
387:                 #endif
388:                         battery_removed = CheckBatteryRemoved();
9D003194  0F4054DD   JAL CheckBatteryRemoved
9D003198  00000000   NOP
389:                         low_voltage = CheckLowVoltage();
9D00319C  0F405645   JAL CheckLowVoltage
9D0031A0  0040B021   ADDU S6, V0, ZERO
9D0031A4  00408821   ADDU S1, V0, ZERO
390:                         TWE_Wakeup(true);
9D0031A8  0F40539A   JAL TWE_Wakeup
9D0031AC  24040001   ADDIU A0, ZERO, 1
391:                         sndcmd = C_SOUND_STOP;
9D0031B0  AFA00038   SW ZERO, 56(SP)
392:                         xQueueSend(xSoundCmdQueue, &sndcmd, 0);
9D0031B4  8F848154   LW A0, -32428(GP)
9D0031B8  27A50038   ADDIU A1, SP, 56
9D0031BC  00003021   ADDU A2, ZERO, ZERO
9D0031C0  0F401FB3   JAL xQueueGenericSend
9D0031C4  00003821   ADDU A3, ZERO, ZERO
393:                         if(battery_removed) {
9D0031C8  12C00009   BEQ S6, ZERO, 0x9D0031F0
9D0031CC  00002021   ADDU A0, ZERO, ZERO
394:                             printLog(0, "MSG",   "POWER REMOVED.", LOG_TYPE_MESSAGE, NULL, 0);
9D0031D0  AFA00010   SW ZERO, 16(SP)
9D0031D4  AFA00014   SW ZERO, 20(SP)
9D0031D8  3C059D00   LUI A1, -25344
9D0031DC  24A56664   ADDIU A1, A1, 26212
9D0031E0  3C069D00   LUI A2, -25344
9D0031E4  24C66710   ADDIU A2, A2, 26384
9D0031E8  0F402F52   JAL printLog
9D0031EC  00003821   ADDU A3, ZERO, ZERO
395:                         }
396:                         if(low_voltage) {
9D0031F0  1220000A   BEQ S1, ZERO, 0x9D00321C
9D0031F4  00002021   ADDU A0, ZERO, ZERO
397:                             printLog(0, "MSG",   "LOW VOLTAGE.", LOG_TYPE_MESSAGE, NULL, 0);
9D0031F8  AFA00010   SW ZERO, 16(SP)
9D0031FC  AFA00014   SW ZERO, 20(SP)
9D003200  3C059D00   LUI A1, -25344
9D003204  24A56664   ADDIU A1, A1, 26212
9D003208  3C069D00   LUI A2, -25344
9D00320C  24C66720   ADDIU A2, A2, 26400
9D003210  0F402F52   JAL printLog
9D003214  00003821   ADDU A3, ZERO, ZERO
398:                         }
399:                         printMessage(0, NULL, "READY");
9D003218  00002021   ADDU A0, ZERO, ZERO
9D00321C  00002821   ADDU A1, ZERO, ZERO
9D003220  3C069D00   LUI A2, -25344
9D003224  0F403891   JAL printMessage
9D003228  24C66730   ADDIU A2, A2, 26416
400:                         //vTaskDelay(cTick200ms);
401:                 
402:                         //if (xQueuePeek(xUartRecvQueue, pStrBufHK, cTick1Sec) == pdPASS) {
403:                         debug_mode = false;
404:                         //do {
405:                             n = recvUartQueueDelim(pStrBufHK, sizeof (pStrBufHK) / sizeof (char), '\n', cTick1Sec * 3);
9D00322C  8F828130   LW V0, -32464(GP)
9D003230  00023840   SLL A3, V0, 1
9D003234  3C04A000   LUI A0, -24576
9D003238  248473A8   ADDIU A0, A0, 29608
9D00323C  24050080   ADDIU A1, ZERO, 128
9D003240  2406000A   ADDIU A2, ZERO, 10
9D003244  0F403275   JAL recvUartQueueDelim
9D003248  00E23821   ADDU A3, A3, V0
406:                             if (n > 0) {
9D00324C  18400041   BLEZ V0, 0x9D003354
9D003250  3C04A000   LUI A0, -24576
407:                                 int nn;
408:                                 ps = NULL;
9D003254  AFA00034   SW ZERO, 52(SP)
409:                                 if(checkSender(pStrBufHK, &hostnum, &ps, sizeof (pStrBufHK) / sizeof (char)) == N_HOST_COMPLETE) {
9D003258  248473A8   ADDIU A0, A0, 29608
9D00325C  27A50030   ADDIU A1, SP, 48
9D003260  27A60034   ADDIU A2, SP, 52
9D003264  0F402480   JAL checkSender
9D003268  24070080   ADDIU A3, ZERO, 128
9D00326C  1440001F   BNE V0, ZERO, 0x9D0032EC
9D003270  3C11A000   LUI S1, -24576
410:                                     if (ps != NULL) {
9D003274  8FB10034   LW S1, 52(SP)
9D003278  5220001C   BEQL S1, ZERO, 0x9D0032EC
9D00327C  3C11A000   LUI S1, -24576
411:                                         if (strlen(ps) > (3 + 19)) {
9D003280  0F403499   JAL strlen
9D003284  02202021   ADDU A0, S1, ZERO
9D003288  2C420017   SLTIU V0, V0, 23
9D00328C  54400017   BNEL V0, ZERO, 0x9D0032EC
9D003290  3C11A000   LUI S1, -24576
412:                                             if (strncmp(ps, " T ", 3) == 0) {
9D003294  02202021   ADDU A0, S1, ZERO
9D003298  3C059D00   LUI A1, -25344
9D00329C  24A56738   ADDIU A1, A1, 26424
9D0032A0  0F404CEC   JAL strncmp
9D0032A4  24060003   ADDIU A2, ZERO, 3
9D0032A8  54400010   BNEL V0, ZERO, 0x9D0032EC
9D0032AC  3C11A000   LUI S1, -24576
413:                                                 ps = &(ps[3]);
9D0032B0  26240003   ADDIU A0, S1, 3
414:                                                     if (setDateTimeStr(ps)) {
9D0032B4  0F401726   JAL setDateTimeStr
9D0032B8  AFA40034   SW A0, 52(SP)
9D0032BC  1040000B   BEQ V0, ZERO, 0x9D0032EC
9D0032C0  3C11A000   LUI S1, -24576
415:                                                     printLog(0, "MSG", "TIME SET.", LOG_TYPE_MESSAGE, NULL, 0);
9D0032C4  AFA00010   SW ZERO, 16(SP)
9D0032C8  AFA00014   SW ZERO, 20(SP)
9D0032CC  00002021   ADDU A0, ZERO, ZERO
9D0032D0  3C059D00   LUI A1, -25344
9D0032D4  24A56664   ADDIU A1, A1, 26212
9D0032D8  3C069D00   LUI A2, -25344
9D0032DC  24C666D8   ADDIU A2, A2, 26328
9D0032E0  0F402F52   JAL printLog
9D0032E4  00003821   ADDU A3, ZERO, ZERO
416:                                                 }
417:                                             } else {
418:                                                 // Another command.
419:                                             } 
420:                                         }
421:                                     }
422:                                 }
423:                                 snprintf(ssbuf, sizeof (ssbuf), "ECHO: %s", pStrBufHK);
9D0032E8  3C11A000   LUI S1, -24576
9D0032EC  26247358   ADDIU A0, S1, 29528
9D0032F0  24050040   ADDIU A1, ZERO, 64
9D0032F4  3C069D00   LUI A2, -25344
9D0032F8  24C6673C   ADDIU A2, A2, 26428
9D0032FC  3C07A000   LUI A3, -24576
9D003300  0F4054D3   JAL _snprintf_cdfFnopsuxX
9D003304  24E773A8   ADDIU A3, A3, 29608
424:                                 printLog(0, "MSG", ssbuf, LOG_TYPE_NOP, NULL, 0);
9D003308  AFA00010   SW ZERO, 16(SP)
9D00330C  AFA00014   SW ZERO, 20(SP)
9D003310  00002021   ADDU A0, ZERO, ZERO
9D003314  3C059D00   LUI A1, -25344
9D003318  24A56664   ADDIU A1, A1, 26212
9D00331C  26267358   ADDIU A2, S1, 29528
9D003320  0F402F52   JAL printLog
9D003324  24070011   ADDIU A3, ZERO, 17
425:                                 printMessage(0, NULL, "READY");
9D003328  00002021   ADDU A0, ZERO, ZERO
9D00332C  00002821   ADDU A1, ZERO, ZERO
9D003330  3C069D00   LUI A2, -25344
9D003334  0F403891   JAL printMessage
9D003338  24C66730   ADDIU A2, A2, 26416
426:                                 SYS_RTCC_DateGet(&_nowdate);
9D00333C  0F4055C2   JAL SYS_RTCC_DateGet
9D003340  27A40028   ADDIU A0, SP, 40
427:                                 SYS_RTCC_TimeGet(&_nowtime);
9D003344  0F4055BC   JAL SYS_RTCC_TimeGet
9D003348  27A4002C   ADDIU A0, SP, 44
428:                                 SYS_WDT_TimerClear();
9D00334C  0F405640   JAL SYS_WDT_TimerClear
9D003350  00000000   NOP
429:                             }
430:                         //} while (n > 0);
431:                         debug_mode = false;
432:                         if (f_Interrupted) {
9D003354  93828140   LBU V0, -32448(GP)
9D003358  14400018   BNE V0, ZERO, 0x9D0033BC
9D00335C  00000000   NOP
9D003360  0B400CF5   J 0x9D0033D4
9D003364  00000000   NOP
433:                             rtcc_sleep = false;
434:                         } else if (!rtcc_sleep) {
435:                             rtcc_sleep = true;
436:                         }
437:                         SYS_WDT_TimerClear();
9D0033BC  0F405640   JAL SYS_WDT_TimerClear
9D0033C0  00000000   NOP
9D0033D4  0F405640   JAL SYS_WDT_TimerClear
9D0033D8  3C11A000   LUI S1, -24576
438:                         if (rtcc_sleep) {
439:                             f_Interrupted = false;
9D0033DC  A3808140   SB ZERO, -32448(GP)
440:                 #if 0   /* Debugging */
441:                             {
442:                                 SYS_RTCC_DateGet(&_nowdate);
443:                                 SYS_RTCC_TimeGet(&_nowtime);
444:                                 nexttime = rtcAlarmSet(_nowtime, 5, false);
445:                             }
446:                 #else
447:                            nexttime = rtcAlarmSet(_nowtime, hk_TickVal, false);
9D0033E0  8FA4002C   LW A0, 44(SP)
9D0033E4  8F858144   LW A1, -32444(GP)
9D0033E8  0F401AA6   JAL rtcAlarmSet
9D0033EC  00003021   ADDU A2, ZERO, ZERO
448:                 #endif /* Debugging */
449:                             snprintf(ssbuf, sizeof (ssbuf) / sizeof (char), "ENTER TO SLEEP UNTIL %d%d:%d%d:%d%d", 
9D0033F0  7C431E00   EXT V1, V0, 24, 4
9D0033F4  AFA30010   SW V1, 16(SP)
9D0033F8  7C431D00   EXT V1, V0, 20, 4
9D0033FC  AFA30014   SW V1, 20(SP)
9D003400  7C431C00   EXT V1, V0, 16, 4
9D003404  AFA30018   SW V1, 24(SP)
9D003408  7C431B00   EXT V1, V0, 12, 4
9D00340C  AFA3001C   SW V1, 28(SP)
9D003410  7C431A00   EXT V1, V0, 8, 4
9D003414  AFA30020   SW V1, 32(SP)
9D003418  26247358   ADDIU A0, S1, 29528
9D00341C  24050040   ADDIU A1, ZERO, 64
9D003420  3C069D00   LUI A2, -25344
9D003424  24C66748   ADDIU A2, A2, 26440
9D003428  0F4054D3   JAL _snprintf_cdfFnopsuxX
9D00342C  00023F02   SRL A3, V0, 28
450:                                     (nexttime >> 28) & 0x0f,
451:                                     (nexttime >> 24) & 0x0f,
452:                                     (nexttime >> 20) & 0x0f,
453:                                     (nexttime >> 16) & 0x0f,
454:                                     (nexttime >> 12) & 0x0f,
455:                                     (nexttime >>  8) & 0x0f
456:                                     );
457:                             SYS_WDT_TimerClear();
9D003430  0F405640   JAL SYS_WDT_TimerClear
9D003434  00000000   NOP
458:                             SYS_WDT_Enable(false);
9D003438  0F40544A   JAL SYS_WDT_Enable
9D00343C  00002021   ADDU A0, ZERO, ZERO
459:                             printLog(0, "MSG", ssbuf, LOG_TYPE_MESSAGE, NULL, 0);
9D003440  AFA00010   SW ZERO, 16(SP)
9D003444  AFA00014   SW ZERO, 20(SP)
9D003448  00002021   ADDU A0, ZERO, ZERO
9D00344C  3C059D00   LUI A1, -25344
9D003450  24A56664   ADDIU A1, A1, 26212
9D003454  26267358   ADDIU A2, S1, 29528
9D003458  0F402F52   JAL printLog
9D00345C  00003821   ADDU A3, ZERO, ZERO
460:                             //vTaskDelay(cTick1Sec);
461:                             TWE_Wakeup(false);
9D003460  0F40539A   JAL TWE_Wakeup
9D003464  00002021   ADDU A0, ZERO, ZERO
462:                             {
463:                                 // Set alarm and Sleep all tasks.
464:                                 SYS_RTCC_AlarmEnable();
9D003468  0F405636   JAL SYS_RTCC_AlarmEnable
9D00346C  00000000   NOP
465:                                 SYS_WDT_TimerClear();
9D003470  0F405640   JAL SYS_WDT_TimerClear
9D003474  00000000   NOP
466:                                 SYS_WDT_Disable();
9D003478  0F40563B   JAL SYS_WDT_Disable
9D00347C  00000000   NOP
467:                                 vTaskSuspendAll();
9D003480  0F4055F0   JAL vTaskSuspendAll
9D003484  00000000   NOP
468:                             }
469:                             {
470:                                 // Sleep machine except RTCC and interrupts.
471:                                 SYS_DEVCON_SystemUnlock();
9D003488  0F405017   JAL SYS_DEVCON_SystemUnlock
9D00348C  00000000   NOP
472:                                 OSCCONbits.NOSC = 0b100; // SOSC.
9D003490  3C03BF81   LUI V1, -16511
9D003494  8C62F000   LW V0, -4096(V1)
9D003498  24040004   ADDIU A0, ZERO, 4
9D00349C  7C825204   INS V0, A0, 8, 3
9D0034A0  AC62F000   SW V0, -4096(V1)
473:                                 OSCCONbits.OSWEN = 1;
9D0034A4  8C64F000   LW A0, -4096(V1)
9D0034A8  24020001   ADDIU V0, ZERO, 1
9D0034AC  7C440004   INS A0, V0, 0, 1
9D0034B0  AC64F000   SW A0, -4096(V1)
474:                                 OSCCONbits.SLPEN = 1;
9D0034B4  8C64F000   LW A0, -4096(V1)
9D0034B8  7C442104   INS A0, V0, 4, 1
9D0034BC  AC64F000   SW A0, -4096(V1)
475:                 #if 1           
476:                                 PMD1bits.AD1MD = 1;
9D0034C0  3C03BF81   LUI V1, -16511
9D0034C4  9464F240   LHU A0, -3520(V1)
9D0034C8  7C440004   INS A0, V0, 0, 1
9D0034CC  A464F240   SH A0, -3520(V1)
477:                                 PMD1bits.CTMUMD = 1;
9D0034D0  9464F240   LHU A0, -3520(V1)
9D0034D4  7C444204   INS A0, V0, 8, 1
9D0034D8  A464F240   SH A0, -3520(V1)
478:                                 //PMD1bits.CVRMD = 1;
479:                                 PMD2bits.CMP1MD = 1;
9D0034DC  3C03BF81   LUI V1, -16511
9D0034E0  9064F250   LBU A0, -3504(V1)
9D0034E4  7C440004   INS A0, V0, 0, 1
9D0034E8  A064F250   SB A0, -3504(V1)
480:                                 PMD2bits.CMP2MD = 1;
9D0034EC  9064F250   LBU A0, -3504(V1)
9D0034F0  7C440844   INS A0, V0, 1, 1
9D0034F4  A064F250   SB A0, -3504(V1)
481:                                 PMD2bits.CMP3MD = 1;
9D0034F8  9064F250   LBU A0, -3504(V1)
9D0034FC  7C441084   INS A0, V0, 2, 1
9D003500  A064F250   SB A0, -3504(V1)
482:                                 PMD3bits.IC1MD = 1;
9D003504  3C03BF81   LUI V1, -16511
9D003508  8C64F260   LW A0, -3488(V1)
9D00350C  7C440004   INS A0, V0, 0, 1
9D003510  AC64F260   SW A0, -3488(V1)
483:                                 PMD3bits.IC2MD = 1;
9D003514  8C64F260   LW A0, -3488(V1)
9D003518  7C440844   INS A0, V0, 1, 1
9D00351C  AC64F260   SW A0, -3488(V1)
484:                                 PMD3bits.IC3MD = 1;
9D003520  8C64F260   LW A0, -3488(V1)
9D003524  7C441084   INS A0, V0, 2, 1
9D003528  AC64F260   SW A0, -3488(V1)
485:                                 PMD3bits.IC4MD = 1;
9D00352C  8C64F260   LW A0, -3488(V1)
9D003530  7C4418C4   INS A0, V0, 3, 1
9D003534  AC64F260   SW A0, -3488(V1)
486:                                 PMD3bits.IC5MD = 1;
9D003538  8C64F260   LW A0, -3488(V1)
9D00353C  7C442104   INS A0, V0, 4, 1
9D003540  AC64F260   SW A0, -3488(V1)
487:                                 PMD3bits.OC1MD = 1;
9D003544  8C64F260   LW A0, -3488(V1)
9D003548  7C448404   INS A0, V0, 16, 1
9D00354C  AC64F260   SW A0, -3488(V1)
488:                                 //PMD3bits.OC2MD = 1;
489:                                 PMD3bits.OC3MD = 1;
9D003550  8C64F260   LW A0, -3488(V1)
9D003554  7C449484   INS A0, V0, 18, 1
9D003558  AC64F260   SW A0, -3488(V1)
490:                                 PMD3bits.OC4MD = 1;
9D00355C  8C64F260   LW A0, -3488(V1)
9D003560  7C449CC4   INS A0, V0, 19, 1
9D003564  AC64F260   SW A0, -3488(V1)
491:                                 PMD3bits.OC5MD = 1;
9D003568  8C64F260   LW A0, -3488(V1)
9D00356C  7C44A504   INS A0, V0, 20, 1
9D003570  AC64F260   SW A0, -3488(V1)
492:                                 //PMD4bits.T1MD = 1;
493:                                 //PMD4bits.T2MD = 1;
494:                                 //PMD4bits.T3MD = 1;
495:                                 //PMD4bits.T4MD = 1;
496:                                 //PMD4bits.T5MD = 1;
497:                                 //PMD5bits.U1MD = 1;
498:                                 PMD5bits.U2MD = 1;
9D003574  3C03BF81   LUI V1, -16511
9D003578  8C64F280   LW A0, -3456(V1)
9D00357C  7C440844   INS A0, V0, 1, 1
9D003580  AC64F280   SW A0, -3456(V1)
499:                                 //PMD5bits.I2C1MD = 1;
500:                                 PMD5bits.I2C2MD = 1;
9D003584  8C64F280   LW A0, -3456(V1)
9D003588  7C448C44   INS A0, V0, 17, 1
9D00358C  AC64F280   SW A0, -3456(V1)
501:                                 PMD5bits.SPI1MD = 1;
9D003590  8C64F280   LW A0, -3456(V1)
9D003594  7C444204   INS A0, V0, 8, 1
9D003598  AC64F280   SW A0, -3456(V1)
502:                                 PMD5bits.SPI2MD = 1;
9D00359C  8C64F280   LW A0, -3456(V1)
9D0035A0  7C444A44   INS A0, V0, 9, 1
9D0035A4  AC64F280   SW A0, -3456(V1)
503:                                 //PMD5bits.USB1MD = 1;
504:                                 //PMD5bits.USBMD = 1;
505:                                 PMD6bits.PMPMD = 1;
9D0035A8  3C03BF81   LUI V1, -16511
9D0035AC  8C64F290   LW A0, -3440(V1)
9D0035B0  7C448404   INS A0, V0, 16, 1
506:                 #endif
507:                                 SYS_DEVCON_SystemLock();
9D0035B4  0F40517A   JAL SYS_DEVCON_SystemLock
9D0035B8  AC64F290   SW A0, -3440(V1)
508:                 
509:                                 asm volatile("WAIT");
9D0035BC  42000020   WAIT
510:                 //                SYS_WDT_Disable();
511:                             }    
512:                             {
513:                                 // Resume all tasks and Wait for alarm waking.
514:                                 // ToDo: button pressed.
515:                                 SYS_DEVCON_SystemUnlock();
9D0035C0  0F405017   JAL SYS_DEVCON_SystemUnlock
9D0035C4  00000000   NOP
516:                                 OSCCONbits.SLPEN = 0;
9D0035C8  3C03BF81   LUI V1, -16511
9D0035CC  8C62F000   LW V0, -4096(V1)
9D0035D0  7C022104   INS V0, ZERO, 4, 1
9D0035D4  AC62F000   SW V0, -4096(V1)
517:                 #if 1
518:                                 PMD4bits.T1MD = 0;
9D0035D8  3C02BF81   LUI V0, -16511
9D0035DC  9044F270   LBU A0, -3472(V0)
9D0035E0  7C040004   INS A0, ZERO, 0, 1
9D0035E4  A044F270   SB A0, -3472(V0)
519:                                 PMD4bits.T2MD = 0;
9D0035E8  9044F270   LBU A0, -3472(V0)
9D0035EC  7C040844   INS A0, ZERO, 1, 1
9D0035F0  A044F270   SB A0, -3472(V0)
520:                                 PMD4bits.T3MD = 0;
9D0035F4  9044F270   LBU A0, -3472(V0)
9D0035F8  7C041084   INS A0, ZERO, 2, 1
9D0035FC  A044F270   SB A0, -3472(V0)
521:                                 PMD4bits.T4MD = 0;
9D003600  9044F270   LBU A0, -3472(V0)
9D003604  7C0418C4   INS A0, ZERO, 3, 1
9D003608  A044F270   SB A0, -3472(V0)
522:                                 PMD4bits.T5MD = 0;
9D00360C  9044F270   LBU A0, -3472(V0)
9D003610  7C042104   INS A0, ZERO, 4, 1
9D003614  A044F270   SB A0, -3472(V0)
523:                                 PMD3bits.OC2MD = 0;
9D003618  3C02BF81   LUI V0, -16511
9D00361C  8C44F260   LW A0, -3488(V0)
9D003620  7C048C44   INS A0, ZERO, 17, 1
9D003624  AC44F260   SW A0, -3488(V0)
524:                                 PMD5bits.U1MD = 0;
9D003628  3C02BF81   LUI V0, -16511
9D00362C  8C44F280   LW A0, -3456(V0)
9D003630  7C040004   INS A0, ZERO, 0, 1
9D003634  AC44F280   SW A0, -3456(V0)
525:                                 PMD5bits.I2C1MD = 0;
9D003638  8C44F280   LW A0, -3456(V0)
9D00363C  7C048404   INS A0, ZERO, 16, 1
9D003640  AC44F280   SW A0, -3456(V0)
526:                                 PMD5bits.USB1MD = 0;
9D003644  8C44F280   LW A0, -3456(V0)
9D003648  7C04C604   INS A0, ZERO, 24, 1
9D00364C  AC44F280   SW A0, -3456(V0)
527:                                 PMD5bits.USBMD = 0;
9D003650  8C44F280   LW A0, -3456(V0)
9D003654  7C04C604   INS A0, ZERO, 24, 1
9D003658  AC44F280   SW A0, -3456(V0)
528:                                 OSCCONbits.NOSC = 0b011; // PLL.
9D00365C  8C62F000   LW V0, -4096(V1)
9D003660  24040003   ADDIU A0, ZERO, 3
9D003664  7C825204   INS V0, A0, 8, 3
9D003668  AC62F000   SW V0, -4096(V1)
529:                                 OSCCONbits.OSWEN = 1;
9D00366C  8C62F000   LW V0, -4096(V1)
9D003670  24040001   ADDIU A0, ZERO, 1
9D003674  7C820004   INS V0, A0, 0, 1
9D003678  AC62F000   SW V0, -4096(V1)
530:                 #endif
531:                                 SYS_DEVCON_SystemLock();
9D00367C  0F40517A   JAL SYS_DEVCON_SystemLock
9D003680  24110001   ADDIU S1, ZERO, 1
532:                 
533:                                 xTaskResumeAll();
9D003684  0F40379F   JAL xTaskResumeAll
9D003688  00000000   NOP
534:                                 // Check Interrupts
535:                                 
536:                                 // Check ALARM
537:                                 uint32_t nc = 0;
538:                                 SYS_WDT_TimerClear();
9D00368C  0F405640   JAL SYS_WDT_TimerClear
9D003690  00000000   NOP
539:                                 SYS_WDT_Enable(false);
9D003694  0F40544A   JAL SYS_WDT_Enable
9D003698  00002021   ADDU A0, ZERO, ZERO
540:                                 while(xSemaphoreTake(xWakeupTimerSemaphore, cTick1Sec) != pdPASS) {
9D003370  8F84813C   LW A0, -32452(GP)
9D003374  00002821   ADDU A1, ZERO, ZERO
9D003378  8F868130   LW A2, -32464(GP)
9D00337C  0F401E81   JAL xQueueGenericReceive
9D003380  00003821   ADDU A3, ZERO, ZERO
9D003384  1451FFF8   BNE V0, S1, 0x9D003368
9D003388  00000000   NOP
9D00369C  0B400CDD   J 0x9D003374
541:                                    vTaskDelay(cTick1Sec);
9D003368  0F405001   JAL vTaskDelay
9D00336C  8F848130   LW A0, -32464(GP)
542:                                    nc++;
543:                                 }
544:                                 SYS_WDT_TimerClear();
9D00338C  0F405640   JAL SYS_WDT_TimerClear
9D003390  00000000   NOP
545:                                 SYS_WDT_Disable();
9D003394  0F40563B   JAL SYS_WDT_Disable
9D003398  00000000   NOP
9D00339C  0B400B86   J 0x9D002E18
9D0033A0  00000000   NOP
546:                             }
547:                             //vTaskSuspendAll();
548:                             // Stop Periferals.
549:                             //vTaskDelay(cTick1Sec);
550:                         } else {
551:                             vTaskDelay(cTick200ms);
9D0033C4  0F405001   JAL vTaskDelay
9D0033C8  8F848100   LW A0, -32512(GP)
9D0033CC  0B400B86   J 0x9D002E18
9D0033D0  00000000   NOP
9D0033D4  0F405640   JAL SYS_WDT_TimerClear
9D0033D8  3C11A000   LUI S1, -24576
9D0033DC  A3808140   SB ZERO, -32448(GP)
9D0033E0  8FA4002C   LW A0, 44(SP)
9D0033E4  8F858144   LW A1, -32444(GP)
9D0033E8  0F401AA6   JAL rtcAlarmSet
9D0033EC  00003021   ADDU A2, ZERO, ZERO
9D0033F0  7C431E00   EXT V1, V0, 24, 4
9D0033F4  AFA30010   SW V1, 16(SP)
9D0033F8  7C431D00   EXT V1, V0, 20, 4
9D0033FC  AFA30014   SW V1, 20(SP)
9D003400  7C431C00   EXT V1, V0, 16, 4
9D003404  AFA30018   SW V1, 24(SP)
9D003408  7C431B00   EXT V1, V0, 12, 4
9D00340C  AFA3001C   SW V1, 28(SP)
9D003410  7C431A00   EXT V1, V0, 8, 4
9D003414  AFA30020   SW V1, 32(SP)
9D003418  26247358   ADDIU A0, S1, 29528
9D00341C  24050040   ADDIU A1, ZERO, 64
9D003420  3C069D00   LUI A2, -25344
9D003424  24C66748   ADDIU A2, A2, 26440
9D003428  0F4054D3   JAL _snprintf_cdfFnopsuxX
9D00342C  00023F02   SRL A3, V0, 28
9D003430  0F405640   JAL SYS_WDT_TimerClear
9D003434  00000000   NOP
9D003438  0F40544A   JAL SYS_WDT_Enable
9D00343C  00002021   ADDU A0, ZERO, ZERO
9D003440  AFA00010   SW ZERO, 16(SP)
9D003444  AFA00014   SW ZERO, 20(SP)
9D003448  00002021   ADDU A0, ZERO, ZERO
9D00344C  3C059D00   LUI A1, -25344
9D003450  24A56664   ADDIU A1, A1, 26212
9D003454  26267358   ADDIU A2, S1, 29528
9D003458  0F402F52   JAL printLog
9D00345C  00003821   ADDU A3, ZERO, ZERO
9D003460  0F40539A   JAL TWE_Wakeup
9D003464  00002021   ADDU A0, ZERO, ZERO
9D003468  0F405636   JAL SYS_RTCC_AlarmEnable
9D00346C  00000000   NOP
9D003470  0F405640   JAL SYS_WDT_TimerClear
9D003474  00000000   NOP
9D003478  0F40563B   JAL SYS_WDT_Disable
9D00347C  00000000   NOP
9D003480  0F4055F0   JAL vTaskSuspendAll
9D003484  00000000   NOP
9D003488  0F405017   JAL SYS_DEVCON_SystemUnlock
9D00348C  00000000   NOP
9D003490  3C03BF81   LUI V1, -16511
9D003494  8C62F000   LW V0, -4096(V1)
9D003498  24040004   ADDIU A0, ZERO, 4
9D00349C  7C825204   INS V0, A0, 8, 3
9D0034A0  AC62F000   SW V0, -4096(V1)
9D0034A4  8C64F000   LW A0, -4096(V1)
9D0034A8  24020001   ADDIU V0, ZERO, 1
9D0034AC  7C440004   INS A0, V0, 0, 1
9D0034B0  AC64F000   SW A0, -4096(V1)
9D0034B4  8C64F000   LW A0, -4096(V1)
9D0034B8  7C442104   INS A0, V0, 4, 1
9D0034BC  AC64F000   SW A0, -4096(V1)
9D0034C0  3C03BF81   LUI V1, -16511
9D0034C4  9464F240   LHU A0, -3520(V1)
9D0034C8  7C440004   INS A0, V0, 0, 1
9D0034CC  A464F240   SH A0, -3520(V1)
9D0034D0  9464F240   LHU A0, -3520(V1)
9D0034D4  7C444204   INS A0, V0, 8, 1
9D0034D8  A464F240   SH A0, -3520(V1)
9D0034DC  3C03BF81   LUI V1, -16511
9D0034E0  9064F250   LBU A0, -3504(V1)
9D0034E4  7C440004   INS A0, V0, 0, 1
9D0034E8  A064F250   SB A0, -3504(V1)
9D0034EC  9064F250   LBU A0, -3504(V1)
9D0034F0  7C440844   INS A0, V0, 1, 1
9D0034F4  A064F250   SB A0, -3504(V1)
9D0034F8  9064F250   LBU A0, -3504(V1)
9D0034FC  7C441084   INS A0, V0, 2, 1
9D003500  A064F250   SB A0, -3504(V1)
9D003504  3C03BF81   LUI V1, -16511
9D003508  8C64F260   LW A0, -3488(V1)
9D00350C  7C440004   INS A0, V0, 0, 1
9D003510  AC64F260   SW A0, -3488(V1)
9D003514  8C64F260   LW A0, -3488(V1)
9D003518  7C440844   INS A0, V0, 1, 1
9D00351C  AC64F260   SW A0, -3488(V1)
9D003520  8C64F260   LW A0, -3488(V1)
9D003524  7C441084   INS A0, V0, 2, 1
9D003528  AC64F260   SW A0, -3488(V1)
9D00352C  8C64F260   LW A0, -3488(V1)
9D003530  7C4418C4   INS A0, V0, 3, 1
9D003534  AC64F260   SW A0, -3488(V1)
9D003538  8C64F260   LW A0, -3488(V1)
9D00353C  7C442104   INS A0, V0, 4, 1
9D003540  AC64F260   SW A0, -3488(V1)
9D003544  8C64F260   LW A0, -3488(V1)
9D003548  7C448404   INS A0, V0, 16, 1
9D00354C  AC64F260   SW A0, -3488(V1)
9D003550  8C64F260   LW A0, -3488(V1)
9D003554  7C449484   INS A0, V0, 18, 1
9D003558  AC64F260   SW A0, -3488(V1)
9D00355C  8C64F260   LW A0, -3488(V1)
9D003560  7C449CC4   INS A0, V0, 19, 1
9D003564  AC64F260   SW A0, -3488(V1)
9D003568  8C64F260   LW A0, -3488(V1)
9D00356C  7C44A504   INS A0, V0, 20, 1
9D003570  AC64F260   SW A0, -3488(V1)
9D003574  3C03BF81   LUI V1, -16511
9D003578  8C64F280   LW A0, -3456(V1)
9D00357C  7C440844   INS A0, V0, 1, 1
9D003580  AC64F280   SW A0, -3456(V1)
9D003584  8C64F280   LW A0, -3456(V1)
9D003588  7C448C44   INS A0, V0, 17, 1
9D00358C  AC64F280   SW A0, -3456(V1)
9D003590  8C64F280   LW A0, -3456(V1)
9D003594  7C444204   INS A0, V0, 8, 1
9D003598  AC64F280   SW A0, -3456(V1)
9D00359C  8C64F280   LW A0, -3456(V1)
9D0035A0  7C444A44   INS A0, V0, 9, 1
9D0035A4  AC64F280   SW A0, -3456(V1)
9D0035A8  3C03BF81   LUI V1, -16511
9D0035AC  8C64F290   LW A0, -3440(V1)
9D0035B0  7C448404   INS A0, V0, 16, 1
9D0035B4  0F40517A   JAL SYS_DEVCON_SystemLock
9D0035B8  AC64F290   SW A0, -3440(V1)
9D0035BC  42000020   WAIT
9D0035C0  0F405017   JAL SYS_DEVCON_SystemUnlock
9D0035C4  00000000   NOP
9D0035C8  3C03BF81   LUI V1, -16511
9D0035CC  8C62F000   LW V0, -4096(V1)
9D0035D0  7C022104   INS V0, ZERO, 4, 1
9D0035D4  AC62F000   SW V0, -4096(V1)
9D0035D8  3C02BF81   LUI V0, -16511
9D0035DC  9044F270   LBU A0, -3472(V0)
9D0035E0  7C040004   INS A0, ZERO, 0, 1
9D0035E4  A044F270   SB A0, -3472(V0)
9D0035E8  9044F270   LBU A0, -3472(V0)
9D0035EC  7C040844   INS A0, ZERO, 1, 1
9D0035F0  A044F270   SB A0, -3472(V0)
9D0035F4  9044F270   LBU A0, -3472(V0)
9D0035F8  7C041084   INS A0, ZERO, 2, 1
9D0035FC  A044F270   SB A0, -3472(V0)
9D003600  9044F270   LBU A0, -3472(V0)
9D003604  7C0418C4   INS A0, ZERO, 3, 1
9D003608  A044F270   SB A0, -3472(V0)
9D00360C  9044F270   LBU A0, -3472(V0)
9D003610  7C042104   INS A0, ZERO, 4, 1
9D003614  A044F270   SB A0, -3472(V0)
9D003618  3C02BF81   LUI V0, -16511
9D00361C  8C44F260   LW A0, -3488(V0)
9D003620  7C048C44   INS A0, ZERO, 17, 1
9D003624  AC44F260   SW A0, -3488(V0)
9D003628  3C02BF81   LUI V0, -16511
9D00362C  8C44F280   LW A0, -3456(V0)
9D003630  7C040004   INS A0, ZERO, 0, 1
9D003634  AC44F280   SW A0, -3456(V0)
9D003638  8C44F280   LW A0, -3456(V0)
9D00363C  7C048404   INS A0, ZERO, 16, 1
9D003640  AC44F280   SW A0, -3456(V0)
9D003644  8C44F280   LW A0, -3456(V0)
9D003648  7C04C604   INS A0, ZERO, 24, 1
9D00364C  AC44F280   SW A0, -3456(V0)
9D003650  8C44F280   LW A0, -3456(V0)
9D003654  7C04C604   INS A0, ZERO, 24, 1
9D003658  AC44F280   SW A0, -3456(V0)
9D00365C  8C62F000   LW V0, -4096(V1)
9D003660  24040003   ADDIU A0, ZERO, 3
9D003664  7C825204   INS V0, A0, 8, 3
9D003668  AC62F000   SW V0, -4096(V1)
9D00366C  8C62F000   LW V0, -4096(V1)
9D003670  24040001   ADDIU A0, ZERO, 1
9D003674  7C820004   INS V0, A0, 0, 1
9D003678  AC62F000   SW V0, -4096(V1)
9D00367C  0F40517A   JAL SYS_DEVCON_SystemLock
9D003680  24110001   ADDIU S1, ZERO, 1
9D003684  0F40379F   JAL xTaskResumeAll
9D003688  00000000   NOP
9D00368C  0F405640   JAL SYS_WDT_TimerClear
9D003690  00000000   NOP
9D003694  0F40544A   JAL SYS_WDT_Enable
9D003698  00002021   ADDU A0, ZERO, ZERO
9D00369C  0B400CDD   J 0x9D003374
9D0036A0  8F84813C   LW A0, -32452(GP)
552:                         }
553:                     }
554:                 }
555:                 
---  /home/whatisthis/src/DoorBell_PIC32/firmware/src/doorbell.c  ---------------------------------------
1:                   /*******************************************************************************
2:                     MPLAB Harmony Application Source File
3:                     
4:                     Company:
5:                       Microchip Technology Inc.
6:                     
7:                     File Name:
8:                       doorbell.c
9:                   
10:                    Summary:
11:                      This file contains the source code for the MPLAB Harmony application.
12:                  
13:                    Description:
14:                      This file contains the source code for the MPLAB Harmony application.  It 
15:                      implements the logic of the application's state machine and it may call 
16:                      API routines of other MPLAB Harmony modules in the system, such as drivers,
17:                      system services, and middleware.  However, it does not call any of the
18:                      system interfaces (such as the "Initialize" and "Tasks" functions) of any of
19:                      the modules in the system or make any assumptions about when those functions
20:                      are called.  That is the responsibility of the configuration-specific system
21:                      files.
22:                   *******************************************************************************/
23:                  
24:                  // DOM-IGNORE-BEGIN
25:                  /*******************************************************************************
26:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
27:                  
28:                  Microchip licenses to you the right to use, modify, copy and distribute
29:                  Software only when embedded on a Microchip microcontroller or digital signal
30:                  controller that is integrated into your product or third party product
31:                  (pursuant to the sublicense terms in the accompanying license agreement).
32:                  
33:                  You should refer to the license agreement accompanying this Software for
34:                  additional information regarding your rights and obligations.
35:                  
36:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
37:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
38:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
39:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
40:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
41:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
42:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
43:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
44:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
45:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
46:                   *******************************************************************************/
47:                  // DOM-IGNORE-END
48:                  
49:                  
50:                  // *****************************************************************************
51:                  // *****************************************************************************
52:                  // Section: Included Files 
53:                  // *****************************************************************************
54:                  // *****************************************************************************
55:                  
56:                  #include "lm01_drv.h"
57:                  #include "doorbell.h"
58:                  #include "system_definitions.h"
59:                  #include "system_config.h"
60:                  // *****************************************************************************
61:                  // *****************************************************************************
62:                  // Section: Global Data Definitions
63:                  // *****************************************************************************
64:                  // *****************************************************************************
65:                  
66:                  // *****************************************************************************
67:                  /* Application Data
68:                  
69:                    Summary:
70:                      Holds application data
71:                  
72:                    Description:
73:                      This structure holds the application's data.
74:                  
75:                    Remarks:
76:                      This structure should be initialized by the APP_Initialize function.
77:                      
78:                      Application strings and buffers are be defined outside this structure.
79:                   */
80:                  
81:                  DOORBELL_DATA doorbellData;
82:                  
83:                  /* Fulfill USB DMA transfer criteria */
84:                  
85:                  // *****************************************************************************
86:                  // *****************************************************************************
87:                  // Section: Application Callback Functions
88:                  // *****************************************************************************
89:                  // *****************************************************************************
90:                  
91:                  /* TODO:  Add any necessary callback functions.
92:                   */
93:                  
94:                  // *****************************************************************************
95:                  // *****************************************************************************
96:                  // Section: Application Local Functions
97:                  // *****************************************************************************
98:                  // *****************************************************************************
99:                  
100:                 
101:                 /* TODO:  Add any necessary local functions.
102:                  */
103:                 
104:                 
105:                 // *****************************************************************************
106:                 // *****************************************************************************
107:                 // Section: Application Initialization and State Machine Functions
108:                 // *****************************************************************************
109:                 // *****************************************************************************
110:                 
111:                 /*******************************************************************************
112:                   Function:
113:                     void DOORBELL_Initialize ( void )
114:                 
115:                   Remarks:
116:                     See prototype in doorbell.h.
117:                  */
118:                 
119:                 
120:                 extern void ledTimerCallback(uintptr_t context, uint32_t currTick);
121:                 extern void pollCallback(uintptr_t context, uint32_t currTick);
122:                 
123:                 void SLEEP_Periferals(bool onoff)
124:                 {
9D00E37C  27BDFFE8   ADDIU SP, SP, -24
9D00E380  AFBF0014   SW RA, 20(SP)
9D00E384  AFB00010   SW S0, 16(SP)
125:                     int n = (onoff) ? 1 : 0; // OFF = TRUE
126:                     // ToDo: Unlock PMDxbits.
127:                     // A/D OFF
128:                     SYS_DEVCON_SystemUnlock();
9D00E388  0F405017   JAL SYS_DEVCON_SystemUnlock
9D00E38C  00808021   ADDU S0, A0, ZERO
129:                     PMD1bits.AD1MD = n;
9D00E390  3C02BF81   LUI V0, -16511
9D00E394  9443F240   LHU V1, -3520(V0)
9D00E398  7E030004   INS V1, S0, 0, 1
9D00E39C  A443F240   SH V1, -3520(V0)
130:                     PMD1bits.CTMUMD = n;
9D00E3A0  9443F240   LHU V1, -3520(V0)
9D00E3A4  7E034204   INS V1, S0, 8, 1
9D00E3A8  A443F240   SH V1, -3520(V0)
131:                 
132:                     // Internal Comparator off
133:                     PMD2bits.CMP1MD = n;
9D00E3AC  3C02BF81   LUI V0, -16511
9D00E3B0  9043F250   LBU V1, -3504(V0)
9D00E3B4  7E030004   INS V1, S0, 0, 1
9D00E3B8  A043F250   SB V1, -3504(V0)
134:                     PMD2bits.CMP2MD = n;
9D00E3BC  9043F250   LBU V1, -3504(V0)
9D00E3C0  7E030844   INS V1, S0, 1, 1
9D00E3C4  A043F250   SB V1, -3504(V0)
135:                     PMD2bits.CMP3MD = n;
9D00E3C8  9043F250   LBU V1, -3504(V0)
9D00E3CC  7E031084   INS V1, S0, 2, 1
9D00E3D0  A043F250   SB V1, -3504(V0)
136:                 
137:                     // Input Capture OFF
138:                     PMD3bits.IC1MD = n;
9D00E3D4  3C02BF81   LUI V0, -16511
9D00E3D8  8C43F260   LW V1, -3488(V0)
9D00E3DC  7E030004   INS V1, S0, 0, 1
9D00E3E0  AC43F260   SW V1, -3488(V0)
139:                     PMD3bits.IC2MD = n;
9D00E3E4  8C43F260   LW V1, -3488(V0)
9D00E3E8  7E030844   INS V1, S0, 1, 1
9D00E3EC  AC43F260   SW V1, -3488(V0)
140:                     PMD3bits.IC3MD = n;
9D00E3F0  8C43F260   LW V1, -3488(V0)
9D00E3F4  7E031084   INS V1, S0, 2, 1
9D00E3F8  AC43F260   SW V1, -3488(V0)
141:                     PMD3bits.IC4MD = n;
9D00E3FC  8C43F260   LW V1, -3488(V0)
9D00E400  7E0318C4   INS V1, S0, 3, 1
9D00E404  AC43F260   SW V1, -3488(V0)
142:                     PMD3bits.IC5MD = n;
9D00E408  8C43F260   LW V1, -3488(V0)
9D00E40C  7E032104   INS V1, S0, 4, 1
9D00E410  AC43F260   SW V1, -3488(V0)
143:                 
144:                     // Output Compare 1, 3-5 OFF
145:                     PMD3bits.OC1MD = n;
9D00E414  8C43F260   LW V1, -3488(V0)
9D00E418  7E038404   INS V1, S0, 16, 1
9D00E41C  AC43F260   SW V1, -3488(V0)
146:                     //PMD3bits.IC2MD = n;
147:                     PMD3bits.OC3MD = n;
9D00E420  8C43F260   LW V1, -3488(V0)
9D00E424  7E039484   INS V1, S0, 18, 1
9D00E428  AC43F260   SW V1, -3488(V0)
148:                     PMD3bits.OC4MD = n;
9D00E42C  8C43F260   LW V1, -3488(V0)
9D00E430  7E039CC4   INS V1, S0, 19, 1
9D00E434  AC43F260   SW V1, -3488(V0)
149:                     PMD3bits.OC5MD = n;
9D00E438  8C43F260   LW V1, -3488(V0)
9D00E43C  7E03A504   INS V1, S0, 20, 1
9D00E440  AC43F260   SW V1, -3488(V0)
150:                 
151:                     // Timer4 OFF
152:                     PMD4bits.T4MD = n;
9D00E444  3C02BF81   LUI V0, -16511
9D00E448  9043F270   LBU V1, -3472(V0)
9D00E44C  7E0318C4   INS V1, S0, 3, 1
9D00E450  A043F270   SB V1, -3472(V0)
153:                 
154:                     // UART2 OFF
155:                     PMD5bits.U2MD = n;
9D00E454  3C02BF81   LUI V0, -16511
9D00E458  8C43F280   LW V1, -3456(V0)
9D00E45C  7E030844   INS V1, S0, 1, 1
9D00E460  AC43F280   SW V1, -3456(V0)
156:                     // I2C-2 OFF
157:                     PMD5bits.I2C2MD = n;
9D00E464  8C43F280   LW V1, -3456(V0)
9D00E468  7E038C44   INS V1, S0, 17, 1
9D00E46C  AC43F280   SW V1, -3456(V0)
158:                     // SPI OFF
159:                     PMD5bits.SPI1MD = n;
9D00E470  8C43F280   LW V1, -3456(V0)
9D00E474  7E034204   INS V1, S0, 8, 1
9D00E478  AC43F280   SW V1, -3456(V0)
160:                     PMD5bits.SPI2MD = n;
9D00E47C  8C43F280   LW V1, -3456(V0)
9D00E480  7E034A44   INS V1, S0, 9, 1
9D00E484  AC43F280   SW V1, -3456(V0)
161:                     // PMP OFF
162:                     PMD6bits.PMPMD = n;
9D00E488  3C02BF81   LUI V0, -16511
9D00E48C  8C43F290   LW V1, -3440(V0)
9D00E490  7E038404   INS V1, S0, 16, 1
9D00E494  AC43F290   SW V1, -3440(V0)
163:                     // ToDo: Lock PMDxbits.
164:                     SYS_DEVCON_SystemLock();
9D00E498  0F40517A   JAL SYS_DEVCON_SystemLock
9D00E49C  00000000   NOP
165:                 }
9D00E4A0  8FBF0014   LW RA, 20(SP)
9D00E4A4  8FB00010   LW S0, 16(SP)
9D00E4A8  03E00008   JR RA
9D00E4AC  27BD0018   ADDIU SP, SP, 24
166:                 
167:                 void TWE_Wakeup(bool onoff)
168:                 {
9D014E68  27BDFFE8   ADDIU SP, SP, -24
9D014E6C  AFBF0014   SW RA, 20(SP)
9D014E70  00803821   ADDU A3, A0, ZERO
169:                     // Enter critical
170:                     //SYS_PORTS_PinWrite(PORTS_ID_0, PORT_CHANNEL_B, 3, onoff); // ON/OFF LED
171:                     SYS_PORTS_PinWrite(PORTS_ID_0, PORT_CHANNEL_B, 2, onoff); // ON/OFF TWE
9D014E74  00002021   ADDU A0, ZERO, ZERO
9D014E78  24050001   ADDIU A1, ZERO, 1
9D014E7C  0F404EC0   JAL SYS_PORTS_PinWrite
9D014E80  24060002   ADDIU A2, ZERO, 2
172:                     // Leave critical
173:                     // ON/OFF TWE Module
174:                     vTaskDelay(cTick100ms / 2);
9D014E84  8F8480F8   LW A0, -32520(GP)
9D014E88  0F405001   JAL vTaskDelay
9D014E8C  00042042   SRL A0, A0, 1
175:                 }
9D014E90  8FBF0014   LW RA, 20(SP)
9D014E94  03E00008   JR RA
9D014E98  27BD0018   ADDIU SP, SP, 24
176:                 /******************************************************************************
177:                   Function:
178:                     void DOORBELL_Tasks ( void )
179:                 
180:                   Remarks:
181:                     See prototype in doorbell.h.
182:                  */
183:                 
184:                 extern void prvHouseKeeping(void *pvParameters);
185:                 
186:                 void DOORBELL_Tasks(void)
187:                 {
9D015524  27BDFFE8   ADDIU SP, SP, -24
9D015528  AFBF0014   SW RA, 20(SP)
188:                     prvHouseKeeping((void *) (&doorbellData));
9D01552C  3C04A000   LUI A0, -24576
9D015530  0F400B26   JAL prvHouseKeeping
9D015534  2484049C   ADDIU A0, A0, 1180
189:                 }
9D015538  8FBF0014   LW RA, 20(SP)
9D01553C  03E00008   JR RA
9D015540  27BD0018   ADDIU SP, SP, 24
190:                 
191:                 
192:                 
193:                 /*******************************************************************************
194:                  End of File
195:                  */
---  /home/whatisthis/microchip/harmony/v2_04/third_party/rtos/FreeRTOS/Source/timers.c  ----------------
1:                   /*
2:                       FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
3:                       All rights reserved
4:                   
5:                       VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
6:                   
7:                       This file is part of the FreeRTOS distribution.
8:                   
9:                       FreeRTOS is free software; you can redistribute it and/or modify it under
10:                      the terms of the GNU General Public License (version 2) as published by the
11:                      Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
12:                  
13:                      ***************************************************************************
14:                      >>!   NOTE: The modification to the GPL is included to allow you to     !<<
15:                      >>!   distribute a combined work that includes FreeRTOS without being   !<<
16:                      >>!   obliged to provide the source code for proprietary components     !<<
17:                      >>!   outside of the FreeRTOS kernel.                                   !<<
18:                      ***************************************************************************
19:                  
20:                      FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
21:                      WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
22:                      FOR A PARTICULAR PURPOSE.  Full license text is available on the following
23:                      link: http://www.freertos.org/a00114.html
24:                  
25:                      ***************************************************************************
26:                       *                                                                       *
27:                       *    FreeRTOS provides completely free yet professionally developed,    *
28:                       *    robust, strictly quality controlled, supported, and cross          *
29:                       *    platform software that is more than just the market leader, it     *
30:                       *    is the industry's de facto standard.                               *
31:                       *                                                                       *
32:                       *    Help yourself get started quickly while simultaneously helping     *
33:                       *    to support the FreeRTOS project by purchasing a FreeRTOS           *
34:                       *    tutorial book, reference manual, or both:                          *
35:                       *    http://www.FreeRTOS.org/Documentation                              *
36:                       *                                                                       *
37:                      ***************************************************************************
38:                  
39:                      http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
40:                      the FAQ page "My application does not run, what could be wrong?".  Have you
41:                      defined configASSERT()?
42:                  
43:                      http://www.FreeRTOS.org/support - In return for receiving this top quality
44:                      embedded software for free we request you assist our global community by
45:                      participating in the support forum.
46:                  
47:                      http://www.FreeRTOS.org/training - Investing in training allows your team to
48:                      be as productive as possible as early as possible.  Now you can receive
49:                      FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
50:                      Ltd, and the world's leading authority on the world's leading RTOS.
51:                  
52:                      http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
53:                      including FreeRTOS+Trace - an indispensable productivity tool, a DOS
54:                      compatible FAT file system, and our tiny thread aware UDP/IP stack.
55:                  
56:                      http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
57:                      Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
58:                  
59:                      http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
60:                      Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
61:                      licenses offer ticketed support, indemnification and commercial middleware.
62:                  
63:                      http://www.SafeRTOS.com - High Integrity Systems also provide a safety
64:                      engineered and independently SIL3 certified version for use in safety and
65:                      mission critical applications that require provable dependability.
66:                  
67:                      1 tab == 4 spaces!
68:                  */
69:                  
70:                  /* Standard includes. */
71:                  #include <stdlib.h>
72:                  
73:                  /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
74:                  all the API functions to use the MPU wrappers.  That should only be done when
75:                  task.h is included from an application file. */
76:                  #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
77:                  
78:                  #include "FreeRTOS.h"
79:                  #include "task.h"
80:                  #include "queue.h"
81:                  #include "timers.h"
82:                  
83:                  #if ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 0 )
84:                  	#error configUSE_TIMERS must be set to 1 to make the xTimerPendFunctionCall() function available.
85:                  #endif
86:                  
87:                  /* Lint e961 and e750 are suppressed as a MISRA exception justified because the
88:                  MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
89:                  header files above, but not in this file, in order to generate the correct
90:                  privileged Vs unprivileged linkage and placement. */
91:                  #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
92:                  
93:                  
94:                  /* This entire source file will be skipped if the application is not configured
95:                  to include software timer functionality.  This #if is closed at the very bottom
96:                  of this file.  If you want to include software timer functionality then ensure
97:                  configUSE_TIMERS is set to 1 in FreeRTOSConfig.h. */
98:                  #if ( configUSE_TIMERS == 1 )
99:                  
100:                 /* Misc definitions. */
101:                 #define tmrNO_DELAY		( TickType_t ) 0U
102:                 
103:                 /* The definition of the timers themselves. */
104:                 typedef struct tmrTimerControl
105:                 {
106:                 	const char				*pcTimerName;		/*<< Text name.  This is not used by the kernel, it is included simply to make debugging easier. */ /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
107:                 	ListItem_t				xTimerListItem;		/*<< Standard linked list item as used by all kernel features for event management. */
108:                 	TickType_t				xTimerPeriodInTicks;/*<< How quickly and often the timer expires. */
109:                 	UBaseType_t				uxAutoReload;		/*<< Set to pdTRUE if the timer should be automatically restarted once expired.  Set to pdFALSE if the timer is, in effect, a one-shot timer. */
110:                 	void 					*pvTimerID;			/*<< An ID to identify the timer.  This allows the timer to be identified when the same callback is used for multiple timers. */
111:                 	TimerCallbackFunction_t	pxCallbackFunction;	/*<< The function that will be called when the timer expires. */
112:                 	#if( configUSE_TRACE_FACILITY == 1 )
113:                 		UBaseType_t			uxTimerNumber;		/*<< An ID assigned by trace tools such as FreeRTOS+Trace */
114:                 	#endif
115:                 
116:                 	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
117:                 		uint8_t 			ucStaticallyAllocated; /*<< Set to pdTRUE if the timer was created statically so no attempt is made to free the memory again if the timer is later deleted. */
118:                 	#endif
119:                 } xTIMER;
120:                 
121:                 /* The old xTIMER name is maintained above then typedefed to the new Timer_t
122:                 name below to enable the use of older kernel aware debuggers. */
123:                 typedef xTIMER Timer_t;
124:                 
125:                 /* The definition of messages that can be sent and received on the timer queue.
126:                 Two types of message can be queued - messages that manipulate a software timer,
127:                 and messages that request the execution of a non-timer related callback.  The
128:                 two message types are defined in two separate structures, xTimerParametersType
129:                 and xCallbackParametersType respectively. */
130:                 typedef struct tmrTimerParameters
131:                 {
132:                 	TickType_t			xMessageValue;		/*<< An optional value used by a subset of commands, for example, when changing the period of a timer. */
133:                 	Timer_t *			pxTimer;			/*<< The timer to which the command will be applied. */
134:                 } TimerParameter_t;
135:                 
136:                 
137:                 typedef struct tmrCallbackParameters
138:                 {
139:                 	PendedFunction_t	pxCallbackFunction;	/* << The callback function to execute. */
140:                 	void *pvParameter1;						/* << The value that will be used as the callback functions first parameter. */
141:                 	uint32_t ulParameter2;					/* << The value that will be used as the callback functions second parameter. */
142:                 } CallbackParameters_t;
143:                 
144:                 /* The structure that contains the two message types, along with an identifier
145:                 that is used to determine which message type is valid. */
146:                 typedef struct tmrTimerQueueMessage
147:                 {
148:                 	BaseType_t			xMessageID;			/*<< The command being sent to the timer service task. */
149:                 	union
150:                 	{
151:                 		TimerParameter_t xTimerParameters;
152:                 
153:                 		/* Don't include xCallbackParameters if it is not going to be used as
154:                 		it makes the structure (and therefore the timer queue) larger. */
155:                 		#if ( INCLUDE_xTimerPendFunctionCall == 1 )
156:                 			CallbackParameters_t xCallbackParameters;
157:                 		#endif /* INCLUDE_xTimerPendFunctionCall */
158:                 	} u;
159:                 } DaemonTaskMessage_t;
160:                 
161:                 /*lint -e956 A manual analysis and inspection has been used to determine which
162:                 static variables must be declared volatile. */
163:                 
164:                 /* The list in which active timers are stored.  Timers are referenced in expire
165:                 time order, with the nearest expiry time at the front of the list.  Only the
166:                 timer service task is allowed to access these lists. */
167:                 PRIVILEGED_DATA static List_t xActiveTimerList1;
168:                 PRIVILEGED_DATA static List_t xActiveTimerList2;
169:                 PRIVILEGED_DATA static List_t *pxCurrentTimerList;
170:                 PRIVILEGED_DATA static List_t *pxOverflowTimerList;
171:                 
172:                 /* A queue that is used to send commands to the timer service task. */
173:                 PRIVILEGED_DATA static QueueHandle_t xTimerQueue = NULL;
174:                 PRIVILEGED_DATA static TaskHandle_t xTimerTaskHandle = NULL;
175:                 
176:                 /*lint +e956 */
177:                 
178:                 /*-----------------------------------------------------------*/
179:                 
180:                 #if( configSUPPORT_STATIC_ALLOCATION == 1 )
181:                 
182:                 	/* If static allocation is supported then the application must provide the
183:                 	following callback function - which enables the application to optionally
184:                 	provide the memory that will be used by the timer task as the task's stack
185:                 	and TCB. */
186:                 	extern void vApplicationGetTimerTaskMemory( StaticTask_t **ppxTimerTaskTCBBuffer, StackType_t **ppxTimerTaskStackBuffer, uint32_t *pulTimerTaskStackSize );
187:                 
188:                 #endif
189:                 
190:                 /*
191:                  * Initialise the infrastructure used by the timer service task if it has not
192:                  * been initialised already.
193:                  */
194:                 static void prvCheckForValidListAndQueue( void ) PRIVILEGED_FUNCTION;
195:                 
196:                 /*
197:                  * The timer service task (daemon).  Timer functionality is controlled by this
198:                  * task.  Other tasks communicate with the timer service task using the
199:                  * xTimerQueue queue.
200:                  */
201:                 static void prvTimerTask( void *pvParameters ) PRIVILEGED_FUNCTION;
202:                 
203:                 /*
204:                  * Called by the timer service task to interpret and process a command it
205:                  * received on the timer queue.
206:                  */
207:                 static void prvProcessReceivedCommands( void ) PRIVILEGED_FUNCTION;
208:                 
209:                 /*
210:                  * Insert the timer into either xActiveTimerList1, or xActiveTimerList2,
211:                  * depending on if the expire time causes a timer counter overflow.
212:                  */
213:                 static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime ) PRIVILEGED_FUNCTION;
214:                 
215:                 /*
216:                  * An active timer has reached its expire time.  Reload the timer if it is an
217:                  * auto reload timer, then call its callback.
218:                  */
219:                 static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow ) PRIVILEGED_FUNCTION;
220:                 
221:                 /*
222:                  * The tick count has overflowed.  Switch the timer lists after ensuring the
223:                  * current timer list does not still reference some timers.
224:                  */
225:                 static void prvSwitchTimerLists( void ) PRIVILEGED_FUNCTION;
226:                 
227:                 /*
228:                  * Obtain the current tick count, setting *pxTimerListsWereSwitched to pdTRUE
229:                  * if a tick count overflow occurred since prvSampleTimeNow() was last called.
230:                  */
231:                 static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched ) PRIVILEGED_FUNCTION;
232:                 
233:                 /*
234:                  * If the timer list contains any active timers then return the expire time of
235:                  * the timer that will expire first and set *pxListWasEmpty to false.  If the
236:                  * timer list does not contain any timers then return 0 and set *pxListWasEmpty
237:                  * to pdTRUE.
238:                  */
239:                 static TickType_t prvGetNextExpireTime( BaseType_t * const pxListWasEmpty ) PRIVILEGED_FUNCTION;
240:                 
241:                 /*
242:                  * If a timer has expired, process it.  Otherwise, block the timer service task
243:                  * until either a timer does expire or a command is received.
244:                  */
245:                 static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty ) PRIVILEGED_FUNCTION;
246:                 
247:                 /*
248:                  * Called after a Timer_t structure has been allocated either statically or
249:                  * dynamically to fill in the structure's members.
250:                  */
251:                 static void prvInitialiseNewTimer(	const char * const pcTimerName,
252:                 									const TickType_t xTimerPeriodInTicks,
253:                 									const UBaseType_t uxAutoReload,
254:                 									void * const pvTimerID,
255:                 									TimerCallbackFunction_t pxCallbackFunction,
256:                 									Timer_t *pxNewTimer ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
257:                 /*-----------------------------------------------------------*/
258:                 
259:                 BaseType_t xTimerCreateTimerTask( void )
260:                 {
9D013C78  27BDFFE0   ADDIU SP, SP, -32
9D013C7C  AFBF001C   SW RA, 28(SP)
261:                 BaseType_t xReturn = pdFAIL;
9D013CC4  00001021   ADDU V0, ZERO, ZERO
262:                 
263:                 	/* This function is called when the scheduler is started if
264:                 	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
265:                 	timer service task has been created/initialised.  If timers have already
266:                 	been created then the initialisation will already have been performed. */
267:                 	prvCheckForValidListAndQueue();
9D013C80  0F404A7A   JAL prvCheckForValidListAndQueue
9D013C84  00000000   NOP
268:                 
269:                 	if( xTimerQueue != NULL )
9D013C88  8F8280B0   LW V0, -32592(GP)
9D013C8C  1040000D   BEQ V0, ZERO, 0x9D013CC4
9D013C90  24020003   ADDIU V0, ZERO, 3
270:                 	{
271:                 		#if( configSUPPORT_STATIC_ALLOCATION == 1 )
272:                 		{
273:                 			StaticTask_t *pxTimerTaskTCBBuffer = NULL;
274:                 			StackType_t *pxTimerTaskStackBuffer = NULL;
275:                 			uint32_t ulTimerTaskStackSize;
276:                 
277:                 			vApplicationGetTimerTaskMemory( &pxTimerTaskTCBBuffer, &pxTimerTaskStackBuffer, &ulTimerTaskStackSize );
278:                 			xTimerTaskHandle = xTaskCreateStatic(	prvTimerTask,
279:                 													"Tmr Svc",
280:                 													ulTimerTaskStackSize,
281:                 													NULL,
282:                 													( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT,
283:                 													pxTimerTaskStackBuffer,
284:                 													pxTimerTaskTCBBuffer );
285:                 
286:                 			if( xTimerTaskHandle != NULL )
287:                 			{
288:                 				xReturn = pdPASS;
289:                 			}
290:                 		}
291:                 		#else
292:                 		{
293:                 			xReturn = xTaskCreate(	prvTimerTask,
9D013C94  AFA20010   SW V0, 16(SP)
9D013C98  278280AC   ADDIU V0, GP, -32596
9D013C9C  AFA20014   SW V0, 20(SP)
9D013CA0  3C049D00   LUI A0, -25344
9D013CA4  24847528   ADDIU A0, A0, 29992
9D013CA8  3C059D01   LUI A1, -25343
9D013CAC  24A5594C   ADDIU A1, A1, 22860
9D013CB0  24060100   ADDIU A2, ZERO, 256
9D013CB4  0F40448E   JAL xTaskCreate
9D013CB8  00003821   ADDU A3, ZERO, ZERO
9D013CBC  0B404F33   J 0x9D013CCC
9D013CC0  8FBF001C   LW RA, 28(SP)
294:                 									"Tmr Svc",
295:                 									configTIMER_TASK_STACK_DEPTH,
296:                 									NULL,
297:                 									( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT,
298:                 									&xTimerTaskHandle );
299:                 		}
300:                 		#endif /* configSUPPORT_STATIC_ALLOCATION */
301:                 	}
302:                 	else
303:                 	{
304:                 		mtCOVERAGE_TEST_MARKER();
305:                 	}
306:                 
307:                 	configASSERT( xReturn );
308:                 	return xReturn;
309:                 }
9D013CC8  8FBF001C   LW RA, 28(SP)
9D013CCC  03E00008   JR RA
9D013CD0  27BD0020   ADDIU SP, SP, 32
310:                 /*-----------------------------------------------------------*/
311:                 
312:                 #if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
313:                 
314:                 	TimerHandle_t xTimerCreate(	const char * const pcTimerName,
315:                 								const TickType_t xTimerPeriodInTicks,
316:                 								const UBaseType_t uxAutoReload,
317:                 								void * const pvTimerID,
318:                 								TimerCallbackFunction_t pxCallbackFunction ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
319:                 	{
320:                 	Timer_t *pxNewTimer;
321:                 
322:                 		pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) );
323:                 
324:                 		if( pxNewTimer != NULL )
325:                 		{
326:                 			prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxNewTimer );
327:                 
328:                 			#if( configSUPPORT_STATIC_ALLOCATION == 1 )
329:                 			{
330:                 				/* Timers can be created statically or dynamically, so note this
331:                 				timer was created dynamically in case the timer is later
332:                 				deleted. */
333:                 				pxNewTimer->ucStaticallyAllocated = pdFALSE;
334:                 			}
335:                 			#endif /* configSUPPORT_STATIC_ALLOCATION */
336:                 		}
337:                 
338:                 		return pxNewTimer;
339:                 	}
340:                 
341:                 #endif /* configSUPPORT_STATIC_ALLOCATION */
342:                 /*-----------------------------------------------------------*/
343:                 
344:                 #if( configSUPPORT_STATIC_ALLOCATION == 1 )
345:                 
346:                 	TimerHandle_t xTimerCreateStatic(	const char * const pcTimerName,
347:                 										const TickType_t xTimerPeriodInTicks,
348:                 										const UBaseType_t uxAutoReload,
349:                 										void * const pvTimerID,
350:                 										TimerCallbackFunction_t pxCallbackFunction,
351:                 										StaticTimer_t *pxTimerBuffer ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
352:                 	{
353:                 	Timer_t *pxNewTimer;
354:                 
355:                 		#if( configASSERT_DEFINED == 1 )
356:                 		{
357:                 			/* Sanity check that the size of the structure used to declare a
358:                 			variable of type StaticTimer_t equals the size of the real timer
359:                 			structures. */
360:                 			volatile size_t xSize = sizeof( StaticTimer_t );
361:                 			configASSERT( xSize == sizeof( Timer_t ) );
362:                 		}
363:                 		#endif /* configASSERT_DEFINED */
364:                 
365:                 		/* A pointer to a StaticTimer_t structure MUST be provided, use it. */
366:                 		configASSERT( pxTimerBuffer );
367:                 		pxNewTimer = ( Timer_t * ) pxTimerBuffer; /*lint !e740 Unusual cast is ok as the structures are designed to have the same alignment, and the size is checked by an assert. */
368:                 
369:                 		if( pxNewTimer != NULL )
370:                 		{
371:                 			prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxNewTimer );
372:                 
373:                 			#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
374:                 			{
375:                 				/* Timers can be created statically or dynamically so note this
376:                 				timer was created statically in case it is later deleted. */
377:                 				pxNewTimer->ucStaticallyAllocated = pdTRUE;
378:                 			}
379:                 			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
380:                 		}
381:                 
382:                 		return pxNewTimer;
383:                 	}
384:                 
385:                 #endif /* configSUPPORT_STATIC_ALLOCATION */
386:                 /*-----------------------------------------------------------*/
387:                 
388:                 static void prvInitialiseNewTimer(	const char * const pcTimerName,
389:                 									const TickType_t xTimerPeriodInTicks,
390:                 									const UBaseType_t uxAutoReload,
391:                 									void * const pvTimerID,
392:                 									TimerCallbackFunction_t pxCallbackFunction,
393:                 									Timer_t *pxNewTimer ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
394:                 {
395:                 	/* 0 is not a valid value for xTimerPeriodInTicks. */
396:                 	configASSERT( ( xTimerPeriodInTicks > 0 ) );
397:                 
398:                 	if( pxNewTimer != NULL )
399:                 	{
400:                 		/* Ensure the infrastructure used by the timer service task has been
401:                 		created/initialised. */
402:                 		prvCheckForValidListAndQueue();
403:                 
404:                 		/* Initialise the timer structure members using the function
405:                 		parameters. */
406:                 		pxNewTimer->pcTimerName = pcTimerName;
407:                 		pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
408:                 		pxNewTimer->uxAutoReload = uxAutoReload;
409:                 		pxNewTimer->pvTimerID = pvTimerID;
410:                 		pxNewTimer->pxCallbackFunction = pxCallbackFunction;
411:                 		vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
412:                 		traceTIMER_CREATE( pxNewTimer );
413:                 	}
414:                 }
415:                 /*-----------------------------------------------------------*/
416:                 
417:                 BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
418:                 {
9D0123C8  27BDFFD8   ADDIU SP, SP, -40
9D0123CC  AFBF0024   SW RA, 36(SP)
419:                 BaseType_t xReturn = pdFAIL;
420:                 DaemonTaskMessage_t xMessage;
421:                 
422:                 	configASSERT( xTimer );
423:                 
424:                 	/* Send a message to the timer service task to perform a particular action
425:                 	on a particular timer definition. */
426:                 	if( xTimerQueue != NULL )
9D0123D0  8F8280B0   LW V0, -32592(GP)
9D0123D4  5040001E   BEQL V0, ZERO, 0x9D012450
9D0123D8  00001021   ADDU V0, ZERO, ZERO
427:                 	{
428:                 		/* Send a command to the timer service task to start the xTimer timer. */
429:                 		xMessage.xMessageID = xCommandID;
9D0123DC  AFA50010   SW A1, 16(SP)
430:                 		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
9D0123E0  AFA60014   SW A2, 20(SP)
431:                 		xMessage.u.xTimerParameters.pxTimer = ( Timer_t * ) xTimer;
432:                 
433:                 		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
9D0123E4  28A50006   SLTI A1, A1, 6
9D0123E8  10A00012   BEQ A1, ZERO, 0x9D012434
9D0123EC  AFA40018   SW A0, 24(SP)
434:                 		{
435:                 			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
9D0123F0  0F405561   JAL xTaskGetSchedulerState
9D0123F4  00000000   NOP
9D0123F8  24030002   ADDIU V1, ZERO, 2
9D0123FC  14430007   BNE V0, V1, 0x9D01241C
9D012400  8F8480B0   LW A0, -32592(GP)
436:                 			{
437:                 				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
9D012404  27A50010   ADDIU A1, SP, 16
9D012408  8FA60038   LW A2, 56(SP)
9D01240C  0F401FB3   JAL xQueueGenericSend
9D012410  00003821   ADDU A3, ZERO, ZERO
9D012414  0B404915   J 0x9D012454
9D012418  8FBF0024   LW RA, 36(SP)
438:                 			}
439:                 			else
440:                 			{
441:                 				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
9D01241C  27A50010   ADDIU A1, SP, 16
9D012420  00003021   ADDU A2, ZERO, ZERO
9D012424  0F401FB3   JAL xQueueGenericSend
9D012428  00003821   ADDU A3, ZERO, ZERO
442:                 			}
443:                 		}
444:                 		else
445:                 		{
446:                 			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
9D012434  00402021   ADDU A0, V0, ZERO
9D012438  27A50010   ADDIU A1, SP, 16
9D01243C  00E03021   ADDU A2, A3, ZERO
9D012440  0F403B87   JAL xQueueGenericSendFromISR
9D012444  00003821   ADDU A3, ZERO, ZERO
447:                 		}
448:                 
449:                 		traceTIMER_COMMAND_SEND( xTimer, xCommandID, xOptionalValue, xReturn );
450:                 	}
451:                 	else
452:                 	{
453:                 		mtCOVERAGE_TEST_MARKER();
454:                 	}
455:                 
456:                 	return xReturn;
457:                 }
9D01242C  0B404915   J 0x9D012454
9D012430  8FBF0024   LW RA, 36(SP)
9D012448  0B404915   J 0x9D012454
9D01244C  8FBF0024   LW RA, 36(SP)
9D012450  8FBF0024   LW RA, 36(SP)
9D012454  03E00008   JR RA
9D012458  27BD0028   ADDIU SP, SP, 40
458:                 /*-----------------------------------------------------------*/
459:                 
460:                 TaskHandle_t xTimerGetTimerDaemonTaskHandle( void )
461:                 {
462:                 	/* If xTimerGetTimerDaemonTaskHandle() is called before the scheduler has been
463:                 	started, then xTimerTaskHandle will be NULL. */
464:                 	configASSERT( ( xTimerTaskHandle != NULL ) );
465:                 	return xTimerTaskHandle;
466:                 }
467:                 /*-----------------------------------------------------------*/
468:                 
469:                 TickType_t xTimerGetPeriod( TimerHandle_t xTimer )
470:                 {
471:                 Timer_t *pxTimer = ( Timer_t * ) xTimer;
472:                 
473:                 	configASSERT( xTimer );
474:                 	return pxTimer->xTimerPeriodInTicks;
475:                 }
476:                 /*-----------------------------------------------------------*/
477:                 
478:                 TickType_t xTimerGetExpiryTime( TimerHandle_t xTimer )
479:                 {
480:                 Timer_t * pxTimer = ( Timer_t * ) xTimer;
481:                 TickType_t xReturn;
482:                 
483:                 	configASSERT( xTimer );
484:                 	xReturn = listGET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ) );
485:                 	return xReturn;
486:                 }
487:                 /*-----------------------------------------------------------*/
488:                 
489:                 const char * pcTimerGetName( TimerHandle_t xTimer ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
490:                 {
491:                 Timer_t *pxTimer = ( Timer_t * ) xTimer;
492:                 
493:                 	configASSERT( xTimer );
494:                 	return pxTimer->pcTimerName;
495:                 }
496:                 /*-----------------------------------------------------------*/
497:                 
498:                 static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
499:                 {
500:                 BaseType_t xResult;
501:                 Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
9D007594  8F8280B8   LW V0, -32584(GP)
9D007598  8C42000C   LW V0, 12(V0)
9D00759C  8C54000C   LW S4, 12(V0)
502:                 
503:                 	/* Remove the timer from the list of active timers.  A check has already
504:                 	been performed to ensure the list is not empty. */
505:                 	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
9D0075A0  0F4051D3   JAL uxListRemove
9D0075A4  26840004   ADDIU A0, S4, 4
506:                 	traceTIMER_EXPIRED( pxTimer );
507:                 
508:                 	/* If the timer is an auto reload timer then calculate the next
509:                 	expiry time and re-insert the timer in the list of active timers. */
510:                 	if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
9D007544  24120001   ADDIU S2, ZERO, 1
9D0075A8  8E82001C   LW V0, 28(S4)
9D0075AC  54520010   BNEL V0, S2, 0x9D0075F0
9D0075B0  8E820024   LW V0, 36(S4)
511:                 	{
512:                 		/* The timer is inserted into a list using a time relative to anything
513:                 		other than the current time.  It will therefore be inserted into the
514:                 		correct list relative to the time this task thinks it is now. */
515:                 		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
9D0075B4  8E850018   LW A1, 24(S4)
9D0075B8  02802021   ADDU A0, S4, ZERO
9D0075BC  02052821   ADDU A1, S0, A1
9D0075C0  02603021   ADDU A2, S3, ZERO
9D0075C4  0F404C7A   JAL prvInsertTimerInActiveList
9D0075C8  02003821   ADDU A3, S0, ZERO
9D0075CC  50400008   BEQL V0, ZERO, 0x9D0075F0
9D0075D0  8E820024   LW V0, 36(S4)
516:                 		{
517:                 			/* The timer expired before it was added to the active timer
518:                 			list.  Reload it now.  */
519:                 			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
9D0075D4  AFA00010   SW ZERO, 16(SP)
9D0075D8  02802021   ADDU A0, S4, ZERO
9D0075DC  00002821   ADDU A1, ZERO, ZERO
9D0075E0  02003021   ADDU A2, S0, ZERO
9D0075E4  0F4048F2   JAL xTimerGenericCommand
9D0075E8  00003821   ADDU A3, ZERO, ZERO
520:                 			configASSERT( xResult );
521:                 			( void ) xResult;
522:                 		}
523:                 		else
524:                 		{
525:                 			mtCOVERAGE_TEST_MARKER();
526:                 		}
527:                 	}
528:                 	else
529:                 	{
530:                 		mtCOVERAGE_TEST_MARKER();
531:                 	}
532:                 
533:                 	/* Call the timer callback. */
534:                 	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
9D0075EC  8E820024   LW V0, 36(S4)
9D0075F0  0040F809   JALR V0
9D0075F4  02802021   ADDU A0, S4, ZERO
535:                 }
536:                 /*-----------------------------------------------------------*/
537:                 
538:                 static void prvTimerTask( void *pvParameters )
539:                 {
9D007528  27BDFFC0   ADDIU SP, SP, -64
9D00752C  AFBF003C   SW RA, 60(SP)
9D007530  AFB40038   SW S4, 56(SP)
9D007534  AFB30034   SW S3, 52(SP)
9D007538  AFB20030   SW S2, 48(SP)
9D00753C  AFB1002C   SW S1, 44(SP)
9D007540  AFB00028   SW S0, 40(SP)
540:                 TickType_t xNextExpireTime;
541:                 BaseType_t xListWasEmpty;
542:                 
543:                 	/* Just to avoid compiler warnings. */
544:                 	( void ) pvParameters;
545:                 
546:                 	#if( configUSE_DAEMON_TASK_STARTUP_HOOK == 1 )
547:                 	{
548:                 		extern void vApplicationDaemonTaskStartupHook( void );
549:                 
550:                 		/* Allow the application writer to execute some code in the context of
551:                 		this task at the point the task starts executing.  This is useful if the
552:                 		application includes initialisation code that would benefit from
553:                 		executing after the scheduler has been started. */
554:                 		vApplicationDaemonTaskStartupHook();
555:                 	}
556:                 	#endif /* configUSE_DAEMON_TASK_STARTUP_HOOK */
557:                 
558:                 	for( ;; )
559:                 	{
560:                 		/* Query the timers list to see if it contains any timers, and if so,
561:                 		obtain the time at which the next timer will expire. */
562:                 		xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
563:                 
564:                 		/* If a timer has expired, process it.  Otherwise, block this task
565:                 		until either a timer does expire, or a command is received. */
566:                 		prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
567:                 
568:                 		/* Empty the command queue. */
569:                 		prvProcessReceivedCommands();
570:                 	}
571:                 }
572:                 /*-----------------------------------------------------------*/
573:                 
574:                 static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
575:                 {
576:                 TickType_t xTimeNow;
577:                 BaseType_t xTimerListsWereSwitched;
578:                 
579:                 	vTaskSuspendAll();
9D007564  0F4055F0   JAL vTaskSuspendAll
9D007568  8C500000   LW S0, 0(V0)
9D007774  0F4055F0   JAL vTaskSuspendAll
9D007778  00000000   NOP
580:                 	{
581:                 		/* Obtain the time now to make an assessment as to whether the timer
582:                 		has expired or not.  If obtaining the time causes the lists to switch
583:                 		then don't process this timer as any timers that remained in the list
584:                 		when the lists were switched will have been processed within the
585:                 		prvSampleTimeNow() function. */
586:                 		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
9D00756C  0F403E00   JAL prvSampleTimeNow
9D007570  27A40018   ADDIU A0, SP, 24
9D007574  00409821   ADDU S3, V0, ZERO
9D00777C  0F403E00   JAL prvSampleTimeNow
9D007780  27A40018   ADDIU A0, SP, 24
9D007784  00409821   ADDU S3, V0, ZERO
587:                 		if( xTimerListsWereSwitched == pdFALSE )
9D007578  8FA20018   LW V0, 24(SP)
9D00757C  14400030   BNE V0, ZERO, prvTimerTask::prvProcessTimerOrBlockTask
9D007580  0270102B   SLTU V0, S3, S0
9D007788  8FA20018   LW V0, 24(SP)
588:                 		{
589:                 			/* The tick count has not overflowed, has the timer expired? */
590:                 			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
9D007584  14400021   BNE V0, ZERO, prvTimerTask::prvProcessTimerOrBlockTask
9D007588  00003021   ADDU A2, ZERO, ZERO
591:                 			{
592:                 				( void ) xTaskResumeAll();
9D00758C  0F40379F   JAL xTaskResumeAll
9D007590  00000000   NOP
593:                 				prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
594:                 			}
595:                 			else
596:                 			{
597:                 				/* The tick count has not overflowed, and the next expire
598:                 				time has not been reached yet.  This task should therefore
599:                 				block to wait for the next expire time or a command to be
600:                 				received - whichever comes first.  The following line cannot
601:                 				be reached unless xNextExpireTime > xTimeNow, except in the
602:                 				case when the current timer list is empty. */
603:                 				if( xListWasEmpty != pdFALSE )
604:                 				{
605:                 					/* The current timer list is empty - is the overflow list
606:                 					also empty? */
607:                 					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
9D007600  8C460000   LW A2, 0(V0)
9D007604  2CC60001   SLTIU A2, A2, 1
608:                 				}
609:                 
610:                 				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
9D00760C  8F8480B0   LW A0, -32592(GP)
9D007610  0F4049EE   JAL vQueueWaitForMessageRestricted
9D007614  02132823   SUBU A1, S0, S3
611:                 
612:                 				if( xTaskResumeAll() == pdFALSE )
9D007618  0F40379F   JAL xTaskResumeAll
9D00761C  00000000   NOP
9D007620  5440004C   BNEL V0, ZERO, 0x9D007754
9D007624  8F8480B0   LW A0, -32592(GP)
613:                 				{
614:                 					/* Yield to wait for either a command to arrive, or the
615:                 					block time to expire.  If a command arrived between the
616:                 					critical section being exited and this yield then the yield
617:                 					will not cause the task to block. */
618:                 					portYIELD_WITHIN_API();
9D007628  40026800   MFC0 V0, Cause
9D00762C  34420100   ORI V0, V0, 256
9D007630  40826800   MTC0 V0, Cause
9D007634  000000C0   EHB
619:                 				}
620:                 				else
621:                 				{
622:                 					mtCOVERAGE_TEST_MARKER();
623:                 				}
624:                 			}
625:                 		}
626:                 		else
627:                 		{
628:                 			( void ) xTaskResumeAll();
9D007640  0F40379F   JAL xTaskResumeAll
9D007644  00000000   NOP
629:                 		}
630:                 	}
631:                 }
632:                 /*-----------------------------------------------------------*/
633:                 
634:                 static TickType_t prvGetNextExpireTime( BaseType_t * const pxListWasEmpty )
635:                 {
636:                 TickType_t xNextExpireTime;
637:                 
638:                 	/* Timers are listed in expiry time order, with the head of the list
639:                 	referencing the task that will expire first.  Obtain the time at which
640:                 	the timer with the nearest expiry time will expire.  If there are no
641:                 	active timers then just set the next expire time to 0.  That will cause
642:                 	this task to unblock when the tick count overflows, at which point the
643:                 	timer lists will be switched and the next expiry time can be
644:                 	re-assessed.  */
645:                 	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
9D007550  8F8280B8   LW V0, -32584(GP)
9D00776C  0B401D55   J 0x9D007554
9D007770  8F8280B8   LW V0, -32584(GP)
646:                 	if( *pxListWasEmpty == pdFALSE )
9D007554  8C430000   LW V1, 0(V0)
9D007558  10600086   BEQ V1, ZERO, prvTimerTask::prvProcessTimerOrBlockTask
9D00755C  00000000   NOP
647:                 	{
648:                 		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
9D007560  8C42000C   LW V0, 12(V0)
649:                 	}
650:                 	else
651:                 	{
652:                 		/* Ensure the task unblocks when the tick count rolls over. */
653:                 		xNextExpireTime = ( TickType_t ) 0U;
9D007608  00008021   ADDU S0, ZERO, ZERO
654:                 	}
655:                 
656:                 	return xNextExpireTime;
657:                 }
658:                 /*-----------------------------------------------------------*/
659:                 
660:                 static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
661:                 {
9D00F800  27BDFFC8   ADDIU SP, SP, -56
9D00F804  AFBF0034   SW RA, 52(SP)
9D00F808  AFB50030   SW S5, 48(SP)
9D00F80C  AFB4002C   SW S4, 44(SP)
9D00F810  AFB30028   SW S3, 40(SP)
9D00F814  AFB20024   SW S2, 36(SP)
9D00F818  AFB10020   SW S1, 32(SP)
9D00F81C  AFB0001C   SW S0, 28(SP)
662:                 TickType_t xTimeNow;
663:                 PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */
664:                 
665:                 	xTimeNow = xTaskGetTickCount();
9D00F820  0F405673   JAL xTaskGetTickCount
9D00F824  0080A021   ADDU S4, A0, ZERO
9D00F828  00409821   ADDU S3, V0, ZERO
666:                 
667:                 	if( xTimeNow < xLastTime )
9D00F82C  8F8280A8   LW V0, -32600(GP)
9D00F830  0262102B   SLTU V0, S3, V0
9D00F834  1440001F   BNE V0, ZERO, 0x9D00F8B4
9D00F838  24120001   ADDIU S2, ZERO, 1
9D00F83C  0B403E36   J 0x9D00F8D8
9D00F840  AE800000   SW ZERO, 0(S4)
668:                 	{
669:                 		prvSwitchTimerLists();
670:                 		*pxTimerListsWereSwitched = pdTRUE;
9D00F8D0  24020001   ADDIU V0, ZERO, 1
9D00F8D4  AE820000   SW V0, 0(S4)
671:                 	}
672:                 	else
673:                 	{
674:                 		*pxTimerListsWereSwitched = pdFALSE;
675:                 	}
676:                 
677:                 	xLastTime = xTimeNow;
9D00F8D8  AF9380A8   SW S3, -32600(GP)
678:                 
679:                 	return xTimeNow;
680:                 }
9D00F8DC  02601021   ADDU V0, S3, ZERO
681:                 /*-----------------------------------------------------------*/
682:                 
683:                 static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
684:                 {
9D0131E8  27BDFFE8   ADDIU SP, SP, -24
9D0131EC  AFBF0014   SW RA, 20(SP)
9D0131F0  00801821   ADDU V1, A0, ZERO
685:                 BaseType_t xProcessTimerNow = pdFALSE;
9D013224  0B404C94   J 0x9D013250
9D013228  00001021   ADDU V0, ZERO, ZERO
9D01324C  00001021   ADDU V0, ZERO, ZERO
686:                 
687:                 	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
9D0131F4  AC850004   SW A1, 4(A0)
688:                 	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
689:                 
690:                 	if( xNextExpiryTime <= xTimeNow )
9D0131F8  00C5102B   SLTU V0, A2, A1
9D0131FC  1440000B   BNE V0, ZERO, 0x9D01322C
9D013200  AC640010   SW A0, 16(V1)
691:                 	{
692:                 		/* Has the expiry time elapsed between the command to start/reset a
693:                 		timer was issued, and the time the command was processed? */
694:                 		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
9D013204  00C73023   SUBU A2, A2, A3
9D013208  8C820018   LW V0, 24(A0)
9D01320C  00C2302B   SLTU A2, A2, V0
9D013210  10C0000F   BEQ A2, ZERO, 0x9D013250
9D013214  24020001   ADDIU V0, ZERO, 1
695:                 		{
696:                 			/* The time between a command being issued and the command being
697:                 			processed actually exceeds the timers period.  */
698:                 			xProcessTimerNow = pdTRUE;
699:                 		}
700:                 		else
701:                 		{
702:                 			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
9D013218  8F8480B4   LW A0, -32588(GP)
9D01321C  0F404F07   JAL vListInsert
9D013220  24650004   ADDIU A1, V1, 4
703:                 		}
704:                 	}
705:                 	else
706:                 	{
707:                 		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
9D01322C  00C7302B   SLTU A2, A2, A3
9D013230  10C00003   BEQ A2, ZERO, 0x9D013240
9D013234  00A7282B   SLTU A1, A1, A3
9D013238  10A00005   BEQ A1, ZERO, 0x9D013250
9D01323C  24020001   ADDIU V0, ZERO, 1
708:                 		{
709:                 			/* If, since the command was issued, the tick count has overflowed
710:                 			but the expiry time has not, then the timer must have already passed
711:                 			its expiry time and should be processed immediately. */
712:                 			xProcessTimerNow = pdTRUE;
713:                 		}
714:                 		else
715:                 		{
716:                 			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
9D013240  8F8480B8   LW A0, -32584(GP)
9D013244  0F404F07   JAL vListInsert
9D013248  24650004   ADDIU A1, V1, 4
717:                 		}
718:                 	}
719:                 
720:                 	return xProcessTimerNow;
721:                 }
9D013250  8FBF0014   LW RA, 20(SP)
9D013254  03E00008   JR RA
9D013258  27BD0018   ADDIU SP, SP, 24
722:                 /*-----------------------------------------------------------*/
723:                 
724:                 static void	prvProcessReceivedCommands( void )
725:                 {
726:                 DaemonTaskMessage_t xMessage;
727:                 Timer_t *pxTimer;
728:                 BaseType_t xTimerListsWereSwitched, xResult;
729:                 TickType_t xTimeNow;
730:                 
731:                 	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
9D0075F8  0B401DD5   J 0x9D007754
9D0075FC  8F8480B0   LW A0, -32592(GP)
9D007638  0B401DD5   J 0x9D007754
9D00763C  8F8480B0   LW A0, -32592(GP)
9D007648  0B401DD5   J 0x9D007754
9D00764C  8F8480B0   LW A0, -32592(GP)
9D00771C  0B401DD5   J 0x9D007754
9D007720  8F8480B0   LW A0, -32592(GP)
9D007740  0B401DD5   J 0x9D007754
9D007744  8F8480B0   LW A0, -32592(GP)
9D007750  8F8480B0   LW A0, -32592(GP)
9D007754  27A50018   ADDIU A1, SP, 24
9D007758  00003021   ADDU A2, ZERO, ZERO
9D00775C  0F401E81   JAL xQueueGenericReceive
9D007760  00003821   ADDU A3, ZERO, ZERO
9D007764  5440FFBA   BNEL V0, ZERO, prvTimerTask::prvProcessReceivedCommands
9D007768  8FA20018   LW V0, 24(SP)
732:                 	{
733:                 		#if ( INCLUDE_xTimerPendFunctionCall == 1 )
734:                 		{
735:                 			/* Negative commands are pended function calls rather than timer
736:                 			commands. */
737:                 			if( xMessage.xMessageID < ( BaseType_t ) 0 )
738:                 			{
739:                 				const CallbackParameters_t * const pxCallback = &( xMessage.u.xCallbackParameters );
740:                 
741:                 				/* The timer uses the xCallbackParameters member to request a
742:                 				callback be executed.  Check the callback is not NULL. */
743:                 				configASSERT( pxCallback );
744:                 
745:                 				/* Call the function. */
746:                 				pxCallback->pxCallbackFunction( pxCallback->pvParameter1, pxCallback->ulParameter2 );
747:                 			}
748:                 			else
749:                 			{
750:                 				mtCOVERAGE_TEST_MARKER();
751:                 			}
752:                 		}
753:                 		#endif /* INCLUDE_xTimerPendFunctionCall */
754:                 
755:                 		/* Commands that are positive are timer commands rather than pended
756:                 		function calls. */
757:                 		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
9D007650  04400040   BLTZ V0, 0x9D007754
9D007654  8F8480B0   LW A0, -32592(GP)
758:                 		{
759:                 			/* The messages uses the xTimerParameters member to work on a
760:                 			software timer. */
761:                 			pxTimer = xMessage.u.xTimerParameters.pxTimer;
9D007658  8FB00020   LW S0, 32(SP)
762:                 
763:                 			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
9D00765C  8E020014   LW V0, 20(S0)
9D007660  10400003   BEQ V0, ZERO, 0x9D007670
9D007664  00000000   NOP
764:                 			{
765:                 				/* The timer is in a list, remove it. */
766:                 				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
9D007668  0F4051D3   JAL uxListRemove
9D00766C  26040004   ADDIU A0, S0, 4
767:                 			}
768:                 			else
769:                 			{
770:                 				mtCOVERAGE_TEST_MARKER();
771:                 			}
772:                 
773:                 			traceTIMER_COMMAND_RECEIVED( pxTimer, xMessage.xMessageID, xMessage.u.xTimerParameters.xMessageValue );
774:                 
775:                 			/* In this case the xTimerListsWereSwitched parameter is not used, but
776:                 			it must be present in the function call.  prvSampleTimeNow() must be
777:                 			called after the message is received from xTimerQueue so there is no
778:                 			possibility of a higher priority task adding a message to the message
779:                 			queue with a time that is ahead of the timer daemon task (because it
780:                 			pre-empted the timer daemon task after the xTimeNow value was set). */
781:                 			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
9D007670  0F403E00   JAL prvSampleTimeNow
9D007674  27A40024   ADDIU A0, SP, 36
782:                 
783:                 			switch( xMessage.xMessageID )
9D007548  3C119D00   LUI S1, -25344
9D00754C  2631769C   ADDIU S1, S1, 30364
9D007678  8FA30018   LW V1, 24(SP)
9D00767C  2C63000A   SLTIU V1, V1, 10
9D007680  10600033   BEQ V1, ZERO, 0x9D007750
9D007684  8FA30018   LW V1, 24(SP)
9D007688  00031880   SLL V1, V1, 2
9D00768C  02231821   ADDU V1, S1, V1
9D007690  8C630000   LW V1, 0(V1)
9D007694  00600008   JR V1
9D007698  00000000   NOP
784:                 			{
785:                 				case tmrCOMMAND_START :
786:                 			    case tmrCOMMAND_START_FROM_ISR :
787:                 			    case tmrCOMMAND_RESET :
788:                 			    case tmrCOMMAND_RESET_FROM_ISR :
789:                 				case tmrCOMMAND_START_DONT_TRACE :
790:                 					/* Start or restart a timer. */
791:                 					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
9D0076C4  8FA7001C   LW A3, 28(SP)
9D0076C8  8E050018   LW A1, 24(S0)
9D0076CC  02002021   ADDU A0, S0, ZERO
9D0076D0  00E52821   ADDU A1, A3, A1
9D0076D4  0F404C7A   JAL prvInsertTimerInActiveList
9D0076D8  00403021   ADDU A2, V0, ZERO
9D0076DC  1040001D   BEQ V0, ZERO, 0x9D007754
9D0076E0  8F8480B0   LW A0, -32592(GP)
792:                 					{
793:                 						/* The timer expired before it was added to the active
794:                 						timer list.  Process it now. */
795:                 						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
9D0076E4  8E020024   LW V0, 36(S0)
9D0076E8  0040F809   JALR V0
9D0076EC  02002021   ADDU A0, S0, ZERO
796:                 						traceTIMER_EXPIRED( pxTimer );
797:                 
798:                 						if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
9D0076F0  8E02001C   LW V0, 28(S0)
9D0076F4  54520017   BNEL V0, S2, 0x9D007754
9D0076F8  8F8480B0   LW A0, -32592(GP)
799:                 						{
800:                 							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
9D0076FC  8E060018   LW A2, 24(S0)
9D007700  AFA00010   SW ZERO, 16(SP)
9D007704  02002021   ADDU A0, S0, ZERO
9D007708  00002821   ADDU A1, ZERO, ZERO
9D00770C  8FA2001C   LW V0, 28(SP)
9D007710  00C23021   ADDU A2, A2, V0
9D007714  0F4048F2   JAL xTimerGenericCommand
9D007718  00003821   ADDU A3, ZERO, ZERO
801:                 							configASSERT( xResult );
802:                 							( void ) xResult;
803:                 						}
804:                 						else
805:                 						{
806:                 							mtCOVERAGE_TEST_MARKER();
807:                 						}
808:                 					}
809:                 					else
810:                 					{
811:                 						mtCOVERAGE_TEST_MARKER();
812:                 					}
813:                 					break;
814:                 
815:                 				case tmrCOMMAND_STOP :
816:                 				case tmrCOMMAND_STOP_FROM_ISR :
817:                 					/* The timer has already been removed from the active list.
818:                 					There is nothing to do here. */
819:                 					break;
820:                 
821:                 				case tmrCOMMAND_CHANGE_PERIOD :
822:                 				case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
823:                 					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
9D007724  8FA5001C   LW A1, 28(SP)
9D007728  AE050018   SW A1, 24(S0)
824:                 					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
825:                 
826:                 					/* The new period does not really have a reference, and can
827:                 					be longer or shorter than the old one.  The command time is
828:                 					therefore set to the current time, and as the period cannot
829:                 					be zero the next expiry time can only be in the future,
830:                 					meaning (unlike for the xTimerStart() case above) there is
831:                 					no fail case that needs to be handled here. */
832:                 					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
9D00772C  02002021   ADDU A0, S0, ZERO
9D007730  00452821   ADDU A1, V0, A1
9D007734  00403021   ADDU A2, V0, ZERO
9D007738  0F404C7A   JAL prvInsertTimerInActiveList
9D00773C  00403821   ADDU A3, V0, ZERO
833:                 					break;
834:                 
835:                 				case tmrCOMMAND_DELETE :
836:                 					/* The timer has already been removed from the active list,
837:                 					just free up the memory if the memory was dynamically
838:                 					allocated. */
839:                 					#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
840:                 					{
841:                 						/* The timer can only have been allocated dynamically -
842:                 						free it again. */
843:                 						vPortFree( pxTimer );
9D007748  0F404C97   JAL vPortFree
9D00774C  02002021   ADDU A0, S0, ZERO
9D007750  8F8480B0   LW A0, -32592(GP)
9D007754  27A50018   ADDIU A1, SP, 24
9D007758  00003021   ADDU A2, ZERO, ZERO
9D00775C  0F401E81   JAL xQueueGenericReceive
9D007760  00003821   ADDU A3, ZERO, ZERO
9D007764  5440FFBA   BNEL V0, ZERO, prvTimerTask::prvProcessReceivedCommands
9D007768  8FA20018   LW V0, 24(SP)
9D00776C  0B401D55   J 0x9D007554
9D007770  8F8280B8   LW V0, -32584(GP)
9D007774  0F4055F0   JAL vTaskSuspendAll
9D007778  00000000   NOP
9D00777C  0F403E00   JAL prvSampleTimeNow
9D007780  27A40018   ADDIU A0, SP, 24
9D007784  00409821   ADDU S3, V0, ZERO
9D007788  8FA20018   LW V0, 24(SP)
9D00778C  1040FF9C   BEQ V0, ZERO, prvTimerTask::prvProcessTimerOrBlockTask
9D007790  8F8280B4   LW V0, -32588(GP)
9D007794  0B401D90   J prvTimerTask::prvProcessTimerOrBlockTask
9D007798  00000000   NOP
844:                 					}
845:                 					#elif( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
846:                 					{
847:                 						/* The timer could have been allocated statically or
848:                 						dynamically, so check before attempting to free the
849:                 						memory. */
850:                 						if( pxTimer->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
851:                 						{
852:                 							vPortFree( pxTimer );
853:                 						}
854:                 						else
855:                 						{
856:                 							mtCOVERAGE_TEST_MARKER();
857:                 						}
858:                 					}
859:                 					#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
860:                 					break;
861:                 
862:                 				default	:
863:                 					/* Don't expect to get here. */
864:                 					break;
865:                 			}
866:                 		}
867:                 	}
868:                 }
869:                 /*-----------------------------------------------------------*/
870:                 
871:                 static void prvSwitchTimerLists( void )
872:                 {
873:                 TickType_t xNextExpireTime, xReloadTime;
874:                 List_t *pxTemp;
875:                 Timer_t *pxTimer;
876:                 BaseType_t xResult;
877:                 
878:                 	/* The tick count has overflowed.  The timer lists must be switched.
879:                 	If there are any timers still referenced from the current timer list
880:                 	then they must have expired and should be processed before the lists
881:                 	are switched. */
882:                 	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
9D00F898  0B403E2E   J 0x9D00F8B8
9D00F89C  8F8380B8   LW V1, -32584(GP)
9D00F8B4  8F8380B8   LW V1, -32584(GP)
9D00F8B8  8C650000   LW A1, 0(V1)
9D00F8BC  54A0FFE1   BNEL A1, ZERO, prvSampleTimeNow::prvSwitchTimerLists
9D00F8C0  8C63000C   LW V1, 12(V1)
883:                 	{
884:                 		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
9D00F844  8C750000   LW S5, 0(V1)
885:                 
886:                 		/* Remove the timer from the list. */
887:                 		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
9D00F848  8C70000C   LW S0, 12(V1)
888:                 		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
9D00F84C  26110004   ADDIU S1, S0, 4
9D00F850  0F4051D3   JAL uxListRemove
9D00F854  02202021   ADDU A0, S1, ZERO
889:                 		traceTIMER_EXPIRED( pxTimer );
890:                 
891:                 		/* Execute its callback, then send a command to restart the timer if
892:                 		it is an auto-reload timer.  It cannot be restarted here as the lists
893:                 		have not yet been switched. */
894:                 		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
9D00F858  8E030024   LW V1, 36(S0)
9D00F85C  0060F809   JALR V1
9D00F860  02002021   ADDU A0, S0, ZERO
895:                 
896:                 		if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
9D00F864  8E02001C   LW V0, 28(S0)
9D00F868  14520013   BNE V0, S2, 0x9D00F8B8
9D00F86C  8F8380B8   LW V1, -32584(GP)
897:                 		{
898:                 			/* Calculate the reload value, and if the reload value results in
899:                 			the timer going into the same timer list then it has already expired
900:                 			and the timer should be re-inserted into the current list so it is
901:                 			processed again within this loop.  Otherwise a command should be sent
902:                 			to restart the timer to ensure it is only inserted into a list after
903:                 			the lists have been swapped. */
904:                 			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
9D00F870  8E020018   LW V0, 24(S0)
9D00F874  02A21021   ADDU V0, S5, V0
905:                 			if( xReloadTime > xNextExpireTime )
9D00F878  02A2182B   SLTU V1, S5, V0
9D00F87C  50600008   BEQL V1, ZERO, prvSampleTimeNow::prvSwitchTimerLists
9D00F880  AFA00010   SW ZERO, 16(SP)
906:                 			{
907:                 				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
9D00F884  AE020004   SW V0, 4(S0)
908:                 				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
9D00F888  AE100010   SW S0, 16(S0)
909:                 				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
9D00F88C  8F8480B8   LW A0, -32584(GP)
9D00F890  0F404F07   JAL vListInsert
9D00F894  02202821   ADDU A1, S1, ZERO
910:                 			}
911:                 			else
912:                 			{
913:                 				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
9D00F8A0  02002021   ADDU A0, S0, ZERO
9D00F8A4  00002821   ADDU A1, ZERO, ZERO
9D00F8A8  02A03021   ADDU A2, S5, ZERO
9D00F8AC  0F4048F2   JAL xTimerGenericCommand
9D00F8B0  00003821   ADDU A3, ZERO, ZERO
914:                 				configASSERT( xResult );
915:                 				( void ) xResult;
916:                 			}
917:                 		}
918:                 		else
919:                 		{
920:                 			mtCOVERAGE_TEST_MARKER();
921:                 		}
922:                 	}
923:                 
924:                 	pxTemp = pxCurrentTimerList;
925:                 	pxCurrentTimerList = pxOverflowTimerList;
9D00F8C4  8F8280B4   LW V0, -32588(GP)
9D00F8C8  AF8280B8   SW V0, -32584(GP)
926:                 	pxOverflowTimerList = pxTemp;
9D00F8CC  AF8380B4   SW V1, -32588(GP)
9D00F8D0  24020001   ADDIU V0, ZERO, 1
9D00F8D4  AE820000   SW V0, 0(S4)
9D00F8D8  AF9380A8   SW S3, -32600(GP)
9D00F8DC  02601021   ADDU V0, S3, ZERO
9D00F8E0  8FBF0034   LW RA, 52(SP)
9D00F8E4  8FB50030   LW S5, 48(SP)
9D00F8E8  8FB4002C   LW S4, 44(SP)
9D00F8EC  8FB30028   LW S3, 40(SP)
9D00F8F0  8FB20024   LW S2, 36(SP)
9D00F8F4  8FB10020   LW S1, 32(SP)
9D00F8F8  8FB0001C   LW S0, 28(SP)
9D00F8FC  03E00008   JR RA
9D00F900  27BD0038   ADDIU SP, SP, 56
927:                 }
928:                 /*-----------------------------------------------------------*/
929:                 
930:                 static void prvCheckForValidListAndQueue( void )
931:                 {
9D0129E8  27BDFFE0   ADDIU SP, SP, -32
9D0129EC  AFBF001C   SW RA, 28(SP)
9D0129F0  AFB10018   SW S1, 24(SP)
932:                 	/* Check that the list from which active timers are referenced, and the
933:                 	queue used to communicate with the timer service, have been
934:                 	initialised. */
935:                 	taskENTER_CRITICAL();
9D0129F4  0F405144   JAL vTaskEnterCritical
9D0129F8  AFB00014   SW S0, 20(SP)
936:                 	{
937:                 		if( xTimerQueue == NULL )
9D0129FC  8F8280B0   LW V0, -32592(GP)
9D012A00  14400014   BNE V0, ZERO, 0x9D012A54
9D012A04  3C11A000   LUI S1, -24576
938:                 		{
939:                 			vListInitialise( &xActiveTimerList1 );
9D012A08  0F405559   JAL vListInitialise
9D012A0C  26247590   ADDIU A0, S1, 30096
940:                 			vListInitialise( &xActiveTimerList2 );
9D012A10  3C10A000   LUI S0, -24576
9D012A14  0F405559   JAL vListInitialise
9D012A18  2604757C   ADDIU A0, S0, 30076
941:                 			pxCurrentTimerList = &xActiveTimerList1;
9D012A1C  26317590   ADDIU S1, S1, 30096
9D012A20  AF9180B8   SW S1, -32584(GP)
942:                 			pxOverflowTimerList = &xActiveTimerList2;
9D012A24  2610757C   ADDIU S0, S0, 30076
9D012A28  AF9080B4   SW S0, -32588(GP)
943:                 
944:                 			#if( configSUPPORT_STATIC_ALLOCATION == 1 )
945:                 			{
946:                 				/* The timer queue is allocated statically in case
947:                 				configSUPPORT_DYNAMIC_ALLOCATION is 0. */
948:                 				static StaticQueue_t xStaticTimerQueue;
949:                 				static uint8_t ucStaticTimerQueueStorage[ configTIMER_QUEUE_LENGTH * sizeof( DaemonTaskMessage_t ) ];
950:                 
951:                 				xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
952:                 			}
953:                 			#else
954:                 			{
955:                 				xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
9D012A2C  2404000A   ADDIU A0, ZERO, 10
9D012A30  2405000C   ADDIU A1, ZERO, 12
9D012A34  0F4048CD   JAL xQueueGenericCreate
9D012A38  00003021   ADDU A2, ZERO, ZERO
956:                 			}
957:                 			#endif
958:                 
959:                 			#if ( configQUEUE_REGISTRY_SIZE > 0 )
960:                 			{
961:                 				if( xTimerQueue != NULL )
9D012A3C  10400005   BEQ V0, ZERO, 0x9D012A54
9D012A40  AF8280B0   SW V0, -32592(GP)
962:                 				{
963:                 					vQueueAddToRegistry( xTimerQueue, "TmrQ" );
9D012A44  00402021   ADDU A0, V0, ZERO
9D012A48  3C059D01   LUI A1, -25343
9D012A4C  0F404E90   JAL vQueueAddToRegistry
9D012A50  24A55944   ADDIU A1, A1, 22852
964:                 				}
965:                 				else
966:                 				{
967:                 					mtCOVERAGE_TEST_MARKER();
968:                 				}
969:                 			}
970:                 			#endif /* configQUEUE_REGISTRY_SIZE */
971:                 		}
972:                 		else
973:                 		{
974:                 			mtCOVERAGE_TEST_MARKER();
975:                 		}
976:                 	}
977:                 	taskEXIT_CRITICAL();
9D012A54  0F404EA8   JAL vTaskExitCritical
9D012A58  00000000   NOP
978:                 }
9D012A5C  8FBF001C   LW RA, 28(SP)
9D012A60  8FB10018   LW S1, 24(SP)
9D012A64  8FB00014   LW S0, 20(SP)
9D012A68  03E00008   JR RA
9D012A6C  27BD0020   ADDIU SP, SP, 32
979:                 /*-----------------------------------------------------------*/
980:                 
981:                 BaseType_t xTimerIsTimerActive( TimerHandle_t xTimer )
982:                 {
983:                 BaseType_t xTimerIsInActiveList;
984:                 Timer_t *pxTimer = ( Timer_t * ) xTimer;
985:                 
986:                 	configASSERT( xTimer );
987:                 
988:                 	/* Is the timer in the list of active timers? */
989:                 	taskENTER_CRITICAL();
990:                 	{
991:                 		/* Checking to see if it is in the NULL list in effect checks to see if
992:                 		it is referenced from either the current or the overflow timer lists in
993:                 		one go, but the logic has to be reversed, hence the '!'. */
994:                 		xTimerIsInActiveList = ( BaseType_t ) !( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) );
995:                 	}
996:                 	taskEXIT_CRITICAL();
997:                 
998:                 	return xTimerIsInActiveList;
999:                 } /*lint !e818 Can't be pointer to const due to the typedef. */
1000:                /*-----------------------------------------------------------*/
1001:                
1002:                void *pvTimerGetTimerID( const TimerHandle_t xTimer )
1003:                {
1004:                Timer_t * const pxTimer = ( Timer_t * ) xTimer;
1005:                void *pvReturn;
1006:                
1007:                	configASSERT( xTimer );
1008:                
1009:                	taskENTER_CRITICAL();
1010:                	{
1011:                		pvReturn = pxTimer->pvTimerID;
1012:                	}
1013:                	taskEXIT_CRITICAL();
1014:                
1015:                	return pvReturn;
1016:                }
1017:                /*-----------------------------------------------------------*/
1018:                
1019:                void vTimerSetTimerID( TimerHandle_t xTimer, void *pvNewID )
1020:                {
1021:                Timer_t * const pxTimer = ( Timer_t * ) xTimer;
1022:                
1023:                	configASSERT( xTimer );
1024:                
1025:                	taskENTER_CRITICAL();
1026:                	{
1027:                		pxTimer->pvTimerID = pvNewID;
1028:                	}
1029:                	taskEXIT_CRITICAL();
1030:                }
1031:                /*-----------------------------------------------------------*/
1032:                
1033:                #if( INCLUDE_xTimerPendFunctionCall == 1 )
1034:                
1035:                	BaseType_t xTimerPendFunctionCallFromISR( PendedFunction_t xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, BaseType_t *pxHigherPriorityTaskWoken )
1036:                	{
1037:                	DaemonTaskMessage_t xMessage;
1038:                	BaseType_t xReturn;
1039:                
1040:                		/* Complete the message with the function parameters and post it to the
1041:                		daemon task. */
1042:                		xMessage.xMessageID = tmrCOMMAND_EXECUTE_CALLBACK_FROM_ISR;
1043:                		xMessage.u.xCallbackParameters.pxCallbackFunction = xFunctionToPend;
1044:                		xMessage.u.xCallbackParameters.pvParameter1 = pvParameter1;
1045:                		xMessage.u.xCallbackParameters.ulParameter2 = ulParameter2;
1046:                
1047:                		xReturn = xQueueSendFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
1048:                
1049:                		tracePEND_FUNC_CALL_FROM_ISR( xFunctionToPend, pvParameter1, ulParameter2, xReturn );
1050:                
1051:                		return xReturn;
1052:                	}
1053:                
1054:                #endif /* INCLUDE_xTimerPendFunctionCall */
1055:                /*-----------------------------------------------------------*/
1056:                
1057:                #if( INCLUDE_xTimerPendFunctionCall == 1 )
1058:                
1059:                	BaseType_t xTimerPendFunctionCall( PendedFunction_t xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, TickType_t xTicksToWait )
1060:                	{
1061:                	DaemonTaskMessage_t xMessage;
1062:                	BaseType_t xReturn;
1063:                
1064:                		/* This function can only be called after a timer has been created or
1065:                		after the scheduler has been started because, until then, the timer
1066:                		queue does not exist. */
1067:                		configASSERT( xTimerQueue );
1068:                
1069:                		/* Complete the message with the function parameters and post it to the
1070:                		daemon task. */
1071:                		xMessage.xMessageID = tmrCOMMAND_EXECUTE_CALLBACK;
1072:                		xMessage.u.xCallbackParameters.pxCallbackFunction = xFunctionToPend;
1073:                		xMessage.u.xCallbackParameters.pvParameter1 = pvParameter1;
1074:                		xMessage.u.xCallbackParameters.ulParameter2 = ulParameter2;
1075:                
1076:                		xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
1077:                
1078:                		tracePEND_FUNC_CALL( xFunctionToPend, pvParameter1, ulParameter2, xReturn );
1079:                
1080:                		return xReturn;
1081:                	}
1082:                
1083:                #endif /* INCLUDE_xTimerPendFunctionCall */
1084:                /*-----------------------------------------------------------*/
1085:                
1086:                /* This entire source file will be skipped if the application is not configured
1087:                to include software timer functionality.  If you want to include software timer
1088:                functionality then ensure configUSE_TIMERS is set to 1 in FreeRTOSConfig.h. */
1089:                #endif /* configUSE_TIMERS == 1 */
1090:                
1091:                
1092:                
---  /home/whatisthis/microchip/harmony/v2_04/third_party/rtos/FreeRTOS/Source/tasks.c  -----------------
1:                   /*
2:                       FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
3:                       All rights reserved
4:                   
5:                       VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
6:                   
7:                       This file is part of the FreeRTOS distribution.
8:                   
9:                       FreeRTOS is free software; you can redistribute it and/or modify it under
10:                      the terms of the GNU General Public License (version 2) as published by the
11:                      Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
12:                  
13:                      ***************************************************************************
14:                      >>!   NOTE: The modification to the GPL is included to allow you to     !<<
15:                      >>!   distribute a combined work that includes FreeRTOS without being   !<<
16:                      >>!   obliged to provide the source code for proprietary components     !<<
17:                      >>!   outside of the FreeRTOS kernel.                                   !<<
18:                      ***************************************************************************
19:                  
20:                      FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
21:                      WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
22:                      FOR A PARTICULAR PURPOSE.  Full license text is available on the following
23:                      link: http://www.freertos.org/a00114.html
24:                  
25:                      ***************************************************************************
26:                       *                                                                       *
27:                       *    FreeRTOS provides completely free yet professionally developed,    *
28:                       *    robust, strictly quality controlled, supported, and cross          *
29:                       *    platform software that is more than just the market leader, it     *
30:                       *    is the industry's de facto standard.                               *
31:                       *                                                                       *
32:                       *    Help yourself get started quickly while simultaneously helping     *
33:                       *    to support the FreeRTOS project by purchasing a FreeRTOS           *
34:                       *    tutorial book, reference manual, or both:                          *
35:                       *    http://www.FreeRTOS.org/Documentation                              *
36:                       *                                                                       *
37:                      ***************************************************************************
38:                  
39:                      http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
40:                      the FAQ page "My application does not run, what could be wrong?".  Have you
41:                      defined configASSERT()?
42:                  
43:                      http://www.FreeRTOS.org/support - In return for receiving this top quality
44:                      embedded software for free we request you assist our global community by
45:                      participating in the support forum.
46:                  
47:                      http://www.FreeRTOS.org/training - Investing in training allows your team to
48:                      be as productive as possible as early as possible.  Now you can receive
49:                      FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
50:                      Ltd, and the world's leading authority on the world's leading RTOS.
51:                  
52:                      http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
53:                      including FreeRTOS+Trace - an indispensable productivity tool, a DOS
54:                      compatible FAT file system, and our tiny thread aware UDP/IP stack.
55:                  
56:                      http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
57:                      Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
58:                  
59:                      http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
60:                      Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
61:                      licenses offer ticketed support, indemnification and commercial middleware.
62:                  
63:                      http://www.SafeRTOS.com - High Integrity Systems also provide a safety
64:                      engineered and independently SIL3 certified version for use in safety and
65:                      mission critical applications that require provable dependability.
66:                  
67:                      1 tab == 4 spaces!
68:                  */
69:                  
70:                  /* Standard includes. */
71:                  #include <stdlib.h>
72:                  #include <string.h>
73:                  
74:                  /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
75:                  all the API functions to use the MPU wrappers.  That should only be done when
76:                  task.h is included from an application file. */
77:                  #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
78:                  
79:                  /* FreeRTOS includes. */
80:                  #include "FreeRTOS.h"
81:                  #include "task.h"
82:                  #include "timers.h"
83:                  #include "StackMacros.h"
84:                  
85:                  /* Lint e961 and e750 are suppressed as a MISRA exception justified because the
86:                  MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
87:                  header files above, but not in this file, in order to generate the correct
88:                  privileged Vs unprivileged linkage and placement. */
89:                  #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
90:                  
91:                  /* Set configUSE_STATS_FORMATTING_FUNCTIONS to 2 to include the stats formatting
92:                  functions but without including stdio.h here. */
93:                  #if ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 )
94:                  	/* At the bottom of this file are two optional functions that can be used
95:                  	to generate human readable text from the raw data generated by the
96:                  	uxTaskGetSystemState() function.  Note the formatting functions are provided
97:                  	for convenience only, and are NOT considered part of the kernel. */
98:                  	#include <stdio.h>
99:                  #endif /* configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) */
100:                 
101:                 #if( configUSE_PREEMPTION == 0 )
102:                 	/* If the cooperative scheduler is being used then a yield should not be
103:                 	performed just because a higher priority task has been woken. */
104:                 	#define taskYIELD_IF_USING_PREEMPTION()
105:                 #else
106:                 	#define taskYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
107:                 #endif
108:                 
109:                 /* Values that can be assigned to the ucNotifyState member of the TCB. */
110:                 #define taskNOT_WAITING_NOTIFICATION	( ( uint8_t ) 0 )
111:                 #define taskWAITING_NOTIFICATION		( ( uint8_t ) 1 )
112:                 #define taskNOTIFICATION_RECEIVED		( ( uint8_t ) 2 )
113:                 
114:                 /*
115:                  * The value used to fill the stack of a task when the task is created.  This
116:                  * is used purely for checking the high water mark for tasks.
117:                  */
118:                 #define tskSTACK_FILL_BYTE	( 0xa5U )
119:                 
120:                 /* Sometimes the FreeRTOSConfig.h settings only allow a task to be created using
121:                 dynamically allocated RAM, in which case when any task is deleted it is known
122:                 that both the task's stack and TCB need to be freed.  Sometimes the
123:                 FreeRTOSConfig.h settings only allow a task to be created using statically
124:                 allocated RAM, in which case when any task is deleted it is known that neither
125:                 the task's stack or TCB should be freed.  Sometimes the FreeRTOSConfig.h
126:                 settings allow a task to be created using either statically or dynamically
127:                 allocated RAM, in which case a member of the TCB is used to record whether the
128:                 stack and/or TCB were allocated statically or dynamically, so when a task is
129:                 deleted the RAM that was allocated dynamically is freed again and no attempt is
130:                 made to free the RAM that was allocated statically.
131:                 tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE is only true if it is possible for a
132:                 task to be created using either statically or dynamically allocated RAM.  Note
133:                 that if portUSING_MPU_WRAPPERS is 1 then a protected task can be created with
134:                 a statically allocated stack and a dynamically allocated TCB. */
135:                 #define tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE ( ( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) || ( portUSING_MPU_WRAPPERS == 1 ) )
136:                 #define tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB 		( ( uint8_t ) 0 )
137:                 #define tskSTATICALLY_ALLOCATED_STACK_ONLY 			( ( uint8_t ) 1 )
138:                 #define tskSTATICALLY_ALLOCATED_STACK_AND_TCB		( ( uint8_t ) 2 )
139:                 
140:                 /*
141:                  * Macros used by vListTask to indicate which state a task is in.
142:                  */
143:                 #define tskBLOCKED_CHAR		( 'B' )
144:                 #define tskREADY_CHAR		( 'R' )
145:                 #define tskDELETED_CHAR		( 'D' )
146:                 #define tskSUSPENDED_CHAR	( 'S' )
147:                 
148:                 /*
149:                  * Some kernel aware debuggers require the data the debugger needs access to be
150:                  * global, rather than file scope.
151:                  */
152:                 #ifdef portREMOVE_STATIC_QUALIFIER
153:                 	#define static
154:                 #endif
155:                 
156:                 #if ( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
157:                 
158:                 	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 0 then task selection is
159:                 	performed in a generic way that is not optimised to any particular
160:                 	microcontroller architecture. */
161:                 
162:                 	/* uxTopReadyPriority holds the priority of the highest priority ready
163:                 	state task. */
164:                 	#define taskRECORD_READY_PRIORITY( uxPriority )														\
165:                 	{																									\
166:                 		if( ( uxPriority ) > uxTopReadyPriority )														\
167:                 		{																								\
168:                 			uxTopReadyPriority = ( uxPriority );														\
169:                 		}																								\
170:                 	} /* taskRECORD_READY_PRIORITY */
171:                 
172:                 	/*-----------------------------------------------------------*/
173:                 
174:                 	#define taskSELECT_HIGHEST_PRIORITY_TASK()															\
175:                 	{																									\
176:                 	UBaseType_t uxTopPriority = uxTopReadyPriority;														\
177:                 																										\
178:                 		/* Find the highest priority queue that contains ready tasks. */								\
179:                 		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopPriority ] ) ) )							\
180:                 		{																								\
181:                 			configASSERT( uxTopPriority );																\
182:                 			--uxTopPriority;																			\
183:                 		}																								\
184:                 																										\
185:                 		/* listGET_OWNER_OF_NEXT_ENTRY indexes through the list, so the tasks of						\
186:                 		the	same priority get an equal share of the processor time. */									\
187:                 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );			\
188:                 		uxTopReadyPriority = uxTopPriority;																\
189:                 	} /* taskSELECT_HIGHEST_PRIORITY_TASK */
190:                 
191:                 	/*-----------------------------------------------------------*/
192:                 
193:                 	/* Define away taskRESET_READY_PRIORITY() and portRESET_READY_PRIORITY() as
194:                 	they are only required when a port optimised method of task selection is
195:                 	being used. */
196:                 	#define taskRESET_READY_PRIORITY( uxPriority )
197:                 	#define portRESET_READY_PRIORITY( uxPriority, uxTopReadyPriority )
198:                 
199:                 #else /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
200:                 
201:                 	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 1 then task selection is
202:                 	performed in a way that is tailored to the particular microcontroller
203:                 	architecture being used. */
204:                 
205:                 	/* A port optimised version is provided.  Call the port defined macros. */
206:                 	#define taskRECORD_READY_PRIORITY( uxPriority )	portRECORD_READY_PRIORITY( uxPriority, uxTopReadyPriority )
207:                 
208:                 	/*-----------------------------------------------------------*/
209:                 
210:                 	#define taskSELECT_HIGHEST_PRIORITY_TASK()														\
211:                 	{																								\
212:                 	UBaseType_t uxTopPriority;																		\
213:                 																									\
214:                 		/* Find the highest priority list that contains ready tasks. */								\
215:                 		portGET_HIGHEST_PRIORITY( uxTopPriority, uxTopReadyPriority );								\
216:                 		configASSERT( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ uxTopPriority ] ) ) > 0 );		\
217:                 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );		\
218:                 	} /* taskSELECT_HIGHEST_PRIORITY_TASK() */
219:                 
220:                 	/*-----------------------------------------------------------*/
221:                 
222:                 	/* A port optimised version is provided, call it only if the TCB being reset
223:                 	is being referenced from a ready list.  If it is referenced from a delayed
224:                 	or suspended list then it won't be in a ready list. */
225:                 	#define taskRESET_READY_PRIORITY( uxPriority )														\
226:                 	{																									\
227:                 		if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ ( uxPriority ) ] ) ) == ( UBaseType_t ) 0 )	\
228:                 		{																								\
229:                 			portRESET_READY_PRIORITY( ( uxPriority ), ( uxTopReadyPriority ) );							\
230:                 		}																								\
231:                 	}
232:                 
233:                 #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
234:                 
235:                 /*-----------------------------------------------------------*/
236:                 
237:                 /* pxDelayedTaskList and pxOverflowDelayedTaskList are switched when the tick
238:                 count overflows. */
239:                 #define taskSWITCH_DELAYED_LISTS()																	\
240:                 {																									\
241:                 	List_t *pxTemp;																					\
242:                 																									\
243:                 	/* The delayed tasks list should be empty when the lists are switched. */						\
244:                 	configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );										\
245:                 																									\
246:                 	pxTemp = pxDelayedTaskList;																		\
247:                 	pxDelayedTaskList = pxOverflowDelayedTaskList;													\
248:                 	pxOverflowDelayedTaskList = pxTemp;																\
249:                 	xNumOfOverflows++;																				\
250:                 	prvResetNextTaskUnblockTime();																	\
251:                 }
252:                 
253:                 /*-----------------------------------------------------------*/
254:                 
255:                 /*
256:                  * Place the task represented by pxTCB into the appropriate ready list for
257:                  * the task.  It is inserted at the end of the list.
258:                  */
259:                 #define prvAddTaskToReadyList( pxTCB )																\
260:                 	traceMOVED_TASK_TO_READY_STATE( pxTCB );														\
261:                 	taskRECORD_READY_PRIORITY( ( pxTCB )->uxPriority );												\
262:                 	vListInsertEnd( &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xStateListItem ) ); \
263:                 	tracePOST_MOVED_TASK_TO_READY_STATE( pxTCB )
264:                 /*-----------------------------------------------------------*/
265:                 
266:                 /*
267:                  * Several functions take an TaskHandle_t parameter that can optionally be NULL,
268:                  * where NULL is used to indicate that the handle of the currently executing
269:                  * task should be used in place of the parameter.  This macro simply checks to
270:                  * see if the parameter is NULL and returns a pointer to the appropriate TCB.
271:                  */
272:                 #define prvGetTCBFromHandle( pxHandle ) ( ( ( pxHandle ) == NULL ) ? ( TCB_t * ) pxCurrentTCB : ( TCB_t * ) ( pxHandle ) )
273:                 
274:                 /* The item value of the event list item is normally used to hold the priority
275:                 of the task to which it belongs (coded to allow it to be held in reverse
276:                 priority order).  However, it is occasionally borrowed for other purposes.  It
277:                 is important its value is not updated due to a task priority change while it is
278:                 being used for another purpose.  The following bit definition is used to inform
279:                 the scheduler that the value should not be changed - in which case it is the
280:                 responsibility of whichever module is using the value to ensure it gets set back
281:                 to its original value when it is released. */
282:                 #if( configUSE_16_BIT_TICKS == 1 )
283:                 	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x8000U
284:                 #else
285:                 	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x80000000UL
286:                 #endif
287:                 
288:                 /*
289:                  * Task control block.  A task control block (TCB) is allocated for each task,
290:                  * and stores task state information, including a pointer to the task's context
291:                  * (the task's run time environment, including register values)
292:                  */
293:                 typedef struct tskTaskControlBlock
294:                 {
295:                 	volatile StackType_t	*pxTopOfStack;	/*< Points to the location of the last item placed on the tasks stack.  THIS MUST BE THE FIRST MEMBER OF THE TCB STRUCT. */
296:                 
297:                 	#if ( portUSING_MPU_WRAPPERS == 1 )
298:                 		xMPU_SETTINGS	xMPUSettings;		/*< The MPU settings are defined as part of the port layer.  THIS MUST BE THE SECOND MEMBER OF THE TCB STRUCT. */
299:                 	#endif
300:                 
301:                 	ListItem_t			xStateListItem;	/*< The list that the state list item of a task is reference from denotes the state of that task (Ready, Blocked, Suspended ). */
302:                 	ListItem_t			xEventListItem;		/*< Used to reference a task from an event list. */
303:                 	UBaseType_t			uxPriority;			/*< The priority of the task.  0 is the lowest priority. */
304:                 	StackType_t			*pxStack;			/*< Points to the start of the stack. */
305:                 	char				pcTaskName[ configMAX_TASK_NAME_LEN ];/*< Descriptive name given to the task when created.  Facilitates debugging only. */ /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
306:                 
307:                 	#if ( portSTACK_GROWTH > 0 )
308:                 		StackType_t		*pxEndOfStack;		/*< Points to the end of the stack on architectures where the stack grows up from low memory. */
309:                 	#endif
310:                 
311:                 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
312:                 		UBaseType_t		uxCriticalNesting;	/*< Holds the critical section nesting depth for ports that do not maintain their own count in the port layer. */
313:                 	#endif
314:                 
315:                 	#if ( configUSE_TRACE_FACILITY == 1 )
316:                 		UBaseType_t		uxTCBNumber;		/*< Stores a number that increments each time a TCB is created.  It allows debuggers to determine when a task has been deleted and then recreated. */
317:                 		UBaseType_t		uxTaskNumber;		/*< Stores a number specifically for use by third party trace code. */
318:                 	#endif
319:                 
320:                 	#if ( configUSE_MUTEXES == 1 )
321:                 		UBaseType_t		uxBasePriority;		/*< The priority last assigned to the task - used by the priority inheritance mechanism. */
322:                 		UBaseType_t		uxMutexesHeld;
323:                 	#endif
324:                 
325:                 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
326:                 		TaskHookFunction_t pxTaskTag;
327:                 	#endif
328:                 
329:                 	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0 )
330:                 		void *pvThreadLocalStoragePointers[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ];
331:                 	#endif
332:                 
333:                 	#if( configGENERATE_RUN_TIME_STATS == 1 )
334:                 		uint32_t		ulRunTimeCounter;	/*< Stores the amount of time the task has spent in the Running state. */
335:                 	#endif
336:                 
337:                 	#if ( configUSE_NEWLIB_REENTRANT == 1 )
338:                 		/* Allocate a Newlib reent structure that is specific to this task.
339:                 		Note Newlib support has been included by popular demand, but is not
340:                 		used by the FreeRTOS maintainers themselves.  FreeRTOS is not
341:                 		responsible for resulting newlib operation.  User must be familiar with
342:                 		newlib and must provide system-wide implementations of the necessary
343:                 		stubs. Be warned that (at the time of writing) the current newlib design
344:                 		implements a system-wide malloc() that must be provided with locks. */
345:                 		struct	_reent xNewLib_reent;
346:                 	#endif
347:                 
348:                 	#if( configUSE_TASK_NOTIFICATIONS == 1 )
349:                 		volatile uint32_t ulNotifiedValue;
350:                 		volatile uint8_t ucNotifyState;
351:                 	#endif
352:                 
353:                 	/* See the comments above the definition of
354:                 	tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE. */
355:                 	#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )
356:                 		uint8_t	ucStaticallyAllocated; 		/*< Set to pdTRUE if the task is a statically allocated to ensure no attempt is made to free the memory. */
357:                 	#endif
358:                 
359:                 	#if( INCLUDE_xTaskAbortDelay == 1 )
360:                 		uint8_t ucDelayAborted;
361:                 	#endif
362:                 
363:                 } tskTCB;
364:                 
365:                 /* The old tskTCB name is maintained above then typedefed to the new TCB_t name
366:                 below to enable the use of older kernel aware debuggers. */
367:                 typedef tskTCB TCB_t;
368:                 
369:                 /*lint -e956 A manual analysis and inspection has been used to determine which
370:                 static variables must be declared volatile. */
371:                 
372:                 PRIVILEGED_DATA TCB_t * volatile pxCurrentTCB = NULL;
373:                 
374:                 /* Lists for ready and blocked tasks. --------------------*/
375:                 PRIVILEGED_DATA static List_t pxReadyTasksLists[ configMAX_PRIORITIES ];/*< Prioritised ready tasks. */
376:                 PRIVILEGED_DATA static List_t xDelayedTaskList1;						/*< Delayed tasks. */
377:                 PRIVILEGED_DATA static List_t xDelayedTaskList2;						/*< Delayed tasks (two lists are used - one for delays that have overflowed the current tick count. */
378:                 PRIVILEGED_DATA static List_t * volatile pxDelayedTaskList;				/*< Points to the delayed task list currently being used. */
379:                 PRIVILEGED_DATA static List_t * volatile pxOverflowDelayedTaskList;		/*< Points to the delayed task list currently being used to hold tasks that have overflowed the current tick count. */
380:                 PRIVILEGED_DATA static List_t xPendingReadyList;						/*< Tasks that have been readied while the scheduler was suspended.  They will be moved to the ready list when the scheduler is resumed. */
381:                 
382:                 #if( INCLUDE_vTaskDelete == 1 )
383:                 
384:                 	PRIVILEGED_DATA static List_t xTasksWaitingTermination;				/*< Tasks that have been deleted - but their memory not yet freed. */
385:                 	PRIVILEGED_DATA static volatile UBaseType_t uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
386:                 
387:                 #endif
388:                 
389:                 #if ( INCLUDE_vTaskSuspend == 1 )
390:                 
391:                 	PRIVILEGED_DATA static List_t xSuspendedTaskList;					/*< Tasks that are currently suspended. */
392:                 
393:                 #endif
394:                 
395:                 /* Other file private variables. --------------------------------*/
396:                 PRIVILEGED_DATA static volatile UBaseType_t uxCurrentNumberOfTasks 	= ( UBaseType_t ) 0U;
397:                 PRIVILEGED_DATA static volatile TickType_t xTickCount 				= ( TickType_t ) 0U;
398:                 PRIVILEGED_DATA static volatile UBaseType_t uxTopReadyPriority 		= tskIDLE_PRIORITY;
399:                 PRIVILEGED_DATA static volatile BaseType_t xSchedulerRunning 		= pdFALSE;
400:                 PRIVILEGED_DATA static volatile UBaseType_t uxPendedTicks 			= ( UBaseType_t ) 0U;
401:                 PRIVILEGED_DATA static volatile BaseType_t xYieldPending 			= pdFALSE;
402:                 PRIVILEGED_DATA static volatile BaseType_t xNumOfOverflows 			= ( BaseType_t ) 0;
403:                 PRIVILEGED_DATA static UBaseType_t uxTaskNumber 					= ( UBaseType_t ) 0U;
404:                 PRIVILEGED_DATA static volatile TickType_t xNextTaskUnblockTime		= ( TickType_t ) 0U; /* Initialised to portMAX_DELAY before the scheduler starts. */
405:                 PRIVILEGED_DATA static TaskHandle_t xIdleTaskHandle					= NULL;			/*< Holds the handle of the idle task.  The idle task is created automatically when the scheduler is started. */
406:                 
407:                 /* Context switches are held pending while the scheduler is suspended.  Also,
408:                 interrupts must not manipulate the xStateListItem of a TCB, or any of the
409:                 lists the xStateListItem can be referenced from, if the scheduler is suspended.
410:                 If an interrupt needs to unblock a task while the scheduler is suspended then it
411:                 moves the task's event list item into the xPendingReadyList, ready for the
412:                 kernel to move the task from the pending ready list into the real ready list
413:                 when the scheduler is unsuspended.  The pending ready list itself can only be
414:                 accessed from a critical section. */
415:                 PRIVILEGED_DATA static volatile UBaseType_t uxSchedulerSuspended	= ( UBaseType_t ) pdFALSE;
416:                 
417:                 #if ( configGENERATE_RUN_TIME_STATS == 1 )
418:                 
419:                 	PRIVILEGED_DATA static uint32_t ulTaskSwitchedInTime = 0UL;	/*< Holds the value of a timer/counter the last time a task was switched in. */
420:                 	PRIVILEGED_DATA static uint32_t ulTotalRunTime = 0UL;		/*< Holds the total amount of execution time as defined by the run time counter clock. */
421:                 
422:                 #endif
423:                 
424:                 /*lint +e956 */
425:                 
426:                 /*-----------------------------------------------------------*/
427:                 
428:                 /* Callback function prototypes. --------------------------*/
429:                 #if(  configCHECK_FOR_STACK_OVERFLOW > 0 )
430:                 	extern void vApplicationStackOverflowHook( TaskHandle_t xTask, char *pcTaskName );
431:                 #endif
432:                 
433:                 #if( configUSE_TICK_HOOK > 0 )
434:                 	extern void vApplicationTickHook( void );
435:                 #endif
436:                 
437:                 #if( configSUPPORT_STATIC_ALLOCATION == 1 )
438:                 	extern void vApplicationGetIdleTaskMemory( StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize );
439:                 #endif
440:                 
441:                 /* File private functions. --------------------------------*/
442:                 
443:                 /**
444:                  * Utility task that simply returns pdTRUE if the task referenced by xTask is
445:                  * currently in the Suspended state, or pdFALSE if the task referenced by xTask
446:                  * is in any other state.
447:                  */
448:                 #if ( INCLUDE_vTaskSuspend == 1 )
449:                 	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
450:                 #endif /* INCLUDE_vTaskSuspend */
451:                 
452:                 /*
453:                  * Utility to ready all the lists used by the scheduler.  This is called
454:                  * automatically upon the creation of the first task.
455:                  */
456:                 static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
457:                 
458:                 /*
459:                  * The idle task, which as all tasks is implemented as a never ending loop.
460:                  * The idle task is automatically created and added to the ready lists upon
461:                  * creation of the first user task.
462:                  *
463:                  * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
464:                  * language extensions.  The equivalent prototype for this function is:
465:                  *
466:                  * void prvIdleTask( void *pvParameters );
467:                  *
468:                  */
469:                 static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters );
470:                 
471:                 /*
472:                  * Utility to free all memory allocated by the scheduler to hold a TCB,
473:                  * including the stack pointed to by the TCB.
474:                  *
475:                  * This does not free memory allocated by the task itself (i.e. memory
476:                  * allocated by calls to pvPortMalloc from within the tasks application code).
477:                  */
478:                 #if ( INCLUDE_vTaskDelete == 1 )
479:                 
480:                 	static void prvDeleteTCB( TCB_t *pxTCB ) PRIVILEGED_FUNCTION;
481:                 
482:                 #endif
483:                 
484:                 /*
485:                  * Used only by the idle task.  This checks to see if anything has been placed
486:                  * in the list of tasks waiting to be deleted.  If so the task is cleaned up
487:                  * and its TCB deleted.
488:                  */
489:                 static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
490:                 
491:                 /*
492:                  * The currently executing task is entering the Blocked state.  Add the task to
493:                  * either the current or the overflow delayed task list.
494:                  */
495:                 static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely ) PRIVILEGED_FUNCTION;
496:                 
497:                 /*
498:                  * Fills an TaskStatus_t structure with information on each task that is
499:                  * referenced from the pxList list (which may be a ready list, a delayed list,
500:                  * a suspended list, etc.).
501:                  *
502:                  * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
503:                  * NORMAL APPLICATION CODE.
504:                  */
505:                 #if ( configUSE_TRACE_FACILITY == 1 )
506:                 
507:                 	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState ) PRIVILEGED_FUNCTION;
508:                 
509:                 #endif
510:                 
511:                 /*
512:                  * Searches pxList for a task with name pcNameToQuery - returning a handle to
513:                  * the task if it is found, or NULL if the task is not found.
514:                  */
515:                 #if ( INCLUDE_xTaskGetHandle == 1 )
516:                 
517:                 	static TCB_t *prvSearchForNameWithinSingleList( List_t *pxList, const char pcNameToQuery[] ) PRIVILEGED_FUNCTION;
518:                 
519:                 #endif
520:                 
521:                 /*
522:                  * When a task is created, the stack of the task is filled with a known value.
523:                  * This function determines the 'high water mark' of the task stack by
524:                  * determining how much of the stack remains at the original preset value.
525:                  */
526:                 #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
527:                 
528:                 	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte ) PRIVILEGED_FUNCTION;
529:                 
530:                 #endif
531:                 
532:                 /*
533:                  * Return the amount of time, in ticks, that will pass before the kernel will
534:                  * next move a task from the Blocked state to the Running state.
535:                  *
536:                  * This conditional compilation should use inequality to 0, not equality to 1.
537:                  * This is to ensure portSUPPRESS_TICKS_AND_SLEEP() can be called when user
538:                  * defined low power mode implementations require configUSE_TICKLESS_IDLE to be
539:                  * set to a value other than 1.
540:                  */
541:                 #if ( configUSE_TICKLESS_IDLE != 0 )
542:                 
543:                 	static TickType_t prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;
544:                 
545:                 #endif
546:                 
547:                 /*
548:                  * Set xNextTaskUnblockTime to the time at which the next Blocked state task
549:                  * will exit the Blocked state.
550:                  */
551:                 static void prvResetNextTaskUnblockTime( void );
552:                 
553:                 #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
554:                 
555:                 	/*
556:                 	 * Helper function used to pad task names with spaces when printing out
557:                 	 * human readable tables of task information.
558:                 	 */
559:                 	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName ) PRIVILEGED_FUNCTION;
560:                 
561:                 #endif
562:                 
563:                 /*
564:                  * Called after a Task_t structure has been allocated either statically or
565:                  * dynamically to fill in the structure's members.
566:                  */
567:                 static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
568:                 									const char * const pcName,
569:                 									const uint32_t ulStackDepth,
570:                 									void * const pvParameters,
571:                 									UBaseType_t uxPriority,
572:                 									TaskHandle_t * const pxCreatedTask,
573:                 									TCB_t *pxNewTCB,
574:                 									const MemoryRegion_t * const xRegions ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
575:                 
576:                 /*
577:                  * Called after a new task has been created and initialised to place the task
578:                  * under the control of the scheduler.
579:                  */
580:                 static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB ) PRIVILEGED_FUNCTION;
581:                 
582:                 /*-----------------------------------------------------------*/
583:                 
584:                 #if( configSUPPORT_STATIC_ALLOCATION == 1 )
585:                 
586:                 	TaskHandle_t xTaskCreateStatic(	TaskFunction_t pxTaskCode,
587:                 									const char * const pcName,
588:                 									const uint32_t ulStackDepth,
589:                 									void * const pvParameters,
590:                 									UBaseType_t uxPriority,
591:                 									StackType_t * const puxStackBuffer,
592:                 									StaticTask_t * const pxTaskBuffer ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
593:                 	{
594:                 	TCB_t *pxNewTCB;
595:                 	TaskHandle_t xReturn;
596:                 
597:                 		configASSERT( puxStackBuffer != NULL );
598:                 		configASSERT( pxTaskBuffer != NULL );
599:                 
600:                 		if( ( pxTaskBuffer != NULL ) && ( puxStackBuffer != NULL ) )
601:                 		{
602:                 			/* The memory used for the task's TCB and stack are passed into this
603:                 			function - use them. */
604:                 			pxNewTCB = ( TCB_t * ) pxTaskBuffer; /*lint !e740 Unusual cast is ok as the structures are designed to have the same alignment, and the size is checked by an assert. */
605:                 			pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
606:                 
607:                 			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )
608:                 			{
609:                 				/* Tasks can be created statically or dynamically, so note this
610:                 				task was created statically in case the task is later deleted. */
611:                 				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
612:                 			}
613:                 			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
614:                 
615:                 			prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNewTCB, NULL );
616:                 			prvAddNewTaskToReadyList( pxNewTCB );
617:                 		}
618:                 		else
619:                 		{
620:                 			xReturn = NULL;
621:                 		}
622:                 
623:                 		return xReturn;
624:                 	}
625:                 
626:                 #endif /* SUPPORT_STATIC_ALLOCATION */
627:                 /*-----------------------------------------------------------*/
628:                 
629:                 #if( portUSING_MPU_WRAPPERS == 1 )
630:                 
631:                 	BaseType_t xTaskCreateRestricted( const TaskParameters_t * const pxTaskDefinition, TaskHandle_t *pxCreatedTask )
632:                 	{
633:                 	TCB_t *pxNewTCB;
634:                 	BaseType_t xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
635:                 
636:                 		configASSERT( pxTaskDefinition->puxStackBuffer );
637:                 
638:                 		if( pxTaskDefinition->puxStackBuffer != NULL )
639:                 		{
640:                 			/* Allocate space for the TCB.  Where the memory comes from depends
641:                 			on the implementation of the port malloc function and whether or
642:                 			not static allocation is being used. */
643:                 			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
644:                 
645:                 			if( pxNewTCB != NULL )
646:                 			{
647:                 				/* Store the stack location in the TCB. */
648:                 				pxNewTCB->pxStack = pxTaskDefinition->puxStackBuffer;
649:                 
650:                 				/* Tasks can be created statically or dynamically, so note
651:                 				this task had a statically allocated stack in case it is
652:                 				later deleted.  The TCB was allocated dynamically. */
653:                 				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_ONLY;
654:                 
655:                 				prvInitialiseNewTask(	pxTaskDefinition->pvTaskCode,
656:                 										pxTaskDefinition->pcName,
657:                 										( uint32_t ) pxTaskDefinition->usStackDepth,
658:                 										pxTaskDefinition->pvParameters,
659:                 										pxTaskDefinition->uxPriority,
660:                 										pxCreatedTask, pxNewTCB,
661:                 										pxTaskDefinition->xRegions );
662:                 
663:                 				prvAddNewTaskToReadyList( pxNewTCB );
664:                 				xReturn = pdPASS;
665:                 			}
666:                 		}
667:                 
668:                 		return xReturn;
669:                 	}
670:                 
671:                 #endif /* portUSING_MPU_WRAPPERS */
672:                 /*-----------------------------------------------------------*/
673:                 
674:                 #if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
675:                 
676:                 	BaseType_t xTaskCreate(	TaskFunction_t pxTaskCode,
677:                 							const char * const pcName,
678:                 							const uint16_t usStackDepth,
679:                 							void * const pvParameters,
680:                 							UBaseType_t uxPriority,
681:                 							TaskHandle_t * const pxCreatedTask ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
682:                 	{
9D011238  27BDFFC0   ADDIU SP, SP, -64
9D01123C  AFBF003C   SW RA, 60(SP)
9D011240  AFB50038   SW S5, 56(SP)
9D011244  AFB40034   SW S4, 52(SP)
9D011248  AFB30030   SW S3, 48(SP)
9D01124C  AFB2002C   SW S2, 44(SP)
9D011250  AFB10028   SW S1, 40(SP)
9D011254  AFB00024   SW S0, 36(SP)
9D011258  0080A821   ADDU S5, A0, ZERO
9D01125C  00A0A021   ADDU S4, A1, ZERO
9D011260  00C09021   ADDU S2, A2, ZERO
9D011264  00E09821   ADDU S3, A3, ZERO
683:                 	TCB_t *pxNewTCB;
684:                 	BaseType_t xReturn;
685:                 
686:                 		/* If the stack grows down then allocate the stack then the TCB so the stack
687:                 		does not grow into the TCB.  Likewise if the stack grows up then allocate
688:                 		the TCB then the stack. */
689:                 		#if( portSTACK_GROWTH > 0 )
690:                 		{
691:                 			/* Allocate space for the TCB.  Where the memory comes from depends on
692:                 			the implementation of the port malloc function and whether or not static
693:                 			allocation is being used. */
694:                 			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
695:                 
696:                 			if( pxNewTCB != NULL )
697:                 			{
698:                 				/* Allocate space for the stack used by the task being created.
699:                 				The base of the stack memory stored in the TCB so the task can
700:                 				be deleted later if required. */
701:                 				pxNewTCB->pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
702:                 
703:                 				if( pxNewTCB->pxStack == NULL )
704:                 				{
705:                 					/* Could not allocate the stack.  Delete the allocated TCB. */
706:                 					vPortFree( pxNewTCB );
707:                 					pxNewTCB = NULL;
708:                 				}
709:                 			}
710:                 		}
711:                 		#else /* portSTACK_GROWTH */
712:                 		{
713:                 		StackType_t *pxStack;
714:                 
715:                 			/* Allocate space for the stack used by the task being created. */
716:                 			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
9D011268  0F402EE8   JAL pvPortMalloc
9D01126C  00062080   SLL A0, A2, 2
717:                 
718:                 			if( pxStack != NULL )
9D011270  10400017   BEQ V0, ZERO, 0x9D0112D0
9D011274  00408821   ADDU S1, V0, ZERO
719:                 			{
720:                 				/* Allocate space for the TCB. */
721:                 				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
9D011278  0F402EE8   JAL pvPortMalloc
9D01127C  24040058   ADDIU A0, ZERO, 88
722:                 
723:                 				if( pxNewTCB != NULL )
9D011280  10400011   BEQ V0, ZERO, 0x9D0112C8
9D011284  00408021   ADDU S0, V0, ZERO
724:                 				{
725:                 					/* Store the stack location in the TCB. */
726:                 					pxNewTCB->pxStack = pxStack;
9D011288  AC510030   SW S1, 48(V0)
727:                 				}
728:                 				else
729:                 				{
730:                 					/* The stack cannot be used as the TCB was not created.  Free
731:                 					it again. */
732:                 					vPortFree( pxStack );
9D0112C8  0F404C97   JAL vPortFree
9D0112CC  02202021   ADDU A0, S1, ZERO
733:                 				}
734:                 			}
735:                 			else
736:                 			{
737:                 				pxNewTCB = NULL;
738:                 			}
739:                 		}
740:                 		#endif /* portSTACK_GROWTH */
741:                 
742:                 		if( pxNewTCB != NULL )
743:                 		{
744:                 			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )
745:                 			{
746:                 				/* Tasks can be created statically or dynamically, so note this
747:                 				task was created dynamically in case it is later deleted. */
748:                 				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
749:                 			}
750:                 			#endif /* configSUPPORT_STATIC_ALLOCATION */
751:                 
752:                 			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
9D01128C  8FA20050   LW V0, 80(SP)
9D011290  AFA20010   SW V0, 16(SP)
9D011294  8FA20054   LW V0, 84(SP)
9D011298  AFA20014   SW V0, 20(SP)
9D01129C  AFB00018   SW S0, 24(SP)
9D0112A0  AFA0001C   SW ZERO, 28(SP)
9D0112A4  02A02021   ADDU A0, S5, ZERO
9D0112A8  02802821   ADDU A1, S4, ZERO
9D0112AC  02403021   ADDU A2, S2, ZERO
9D0112B0  0F403A11   JAL prvInitialiseNewTask
9D0112B4  02603821   ADDU A3, S3, ZERO
753:                 			prvAddNewTaskToReadyList( pxNewTCB );
9D0112B8  0F403DBF   JAL prvAddNewTaskToReadyList
9D0112BC  02002021   ADDU A0, S0, ZERO
9D0112C0  0B4044B5   J 0x9D0112D4
9D0112C4  24020001   ADDIU V0, ZERO, 1
754:                 			xReturn = pdPASS;
755:                 		}
756:                 		else
757:                 		{
758:                 			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
9D0112D0  2402FFFF   ADDIU V0, ZERO, -1
759:                 		}
760:                 
761:                 		return xReturn;
762:                 	}
9D0112D4  8FBF003C   LW RA, 60(SP)
9D0112D8  8FB50038   LW S5, 56(SP)
9D0112DC  8FB40034   LW S4, 52(SP)
9D0112E0  8FB30030   LW S3, 48(SP)
9D0112E4  8FB2002C   LW S2, 44(SP)
9D0112E8  8FB10028   LW S1, 40(SP)
9D0112EC  8FB00024   LW S0, 36(SP)
9D0112F0  03E00008   JR RA
9D0112F4  27BD0040   ADDIU SP, SP, 64
763:                 
764:                 #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
765:                 /*-----------------------------------------------------------*/
766:                 
767:                 static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
768:                 									const char * const pcName,
769:                 									const uint32_t ulStackDepth,
770:                 									void * const pvParameters,
771:                 									UBaseType_t uxPriority,
772:                 									TaskHandle_t * const pxCreatedTask,
773:                 									TCB_t *pxNewTCB,
774:                 									const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
775:                 {
9D00E844  27BDFFD0   ADDIU SP, SP, -48
9D00E848  AFBF002C   SW RA, 44(SP)
9D00E84C  AFB60028   SW S6, 40(SP)
9D00E850  AFB50024   SW S5, 36(SP)
9D00E854  AFB40020   SW S4, 32(SP)
9D00E858  AFB3001C   SW S3, 28(SP)
9D00E85C  AFB20018   SW S2, 24(SP)
9D00E860  AFB10014   SW S1, 20(SP)
9D00E864  AFB00010   SW S0, 16(SP)
9D00E868  0080A021   ADDU S4, A0, ZERO
9D00E86C  00A0B021   ADDU S6, A1, ZERO
9D00E870  00E09821   ADDU S3, A3, ZERO
9D00E874  8FB10040   LW S1, 64(SP)
9D00E878  8FB20044   LW S2, 68(SP)
9D00E87C  8FB00048   LW S0, 72(SP)
776:                 StackType_t *pxTopOfStack;
777:                 UBaseType_t x;
778:                 
779:                 	#if( portUSING_MPU_WRAPPERS == 1 )
780:                 		/* Should the task be created in privileged mode? */
781:                 		BaseType_t xRunPrivileged;
782:                 		if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
783:                 		{
784:                 			xRunPrivileged = pdTRUE;
785:                 		}
786:                 		else
787:                 		{
788:                 			xRunPrivileged = pdFALSE;
789:                 		}
790:                 		uxPriority &= ~portPRIVILEGE_BIT;
791:                 	#endif /* portUSING_MPU_WRAPPERS == 1 */
792:                 
793:                 	/* Avoid dependency on memset() if it is not required. */
794:                 	#if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
795:                 	{
796:                 		/* Fill the stack with a known value to assist debugging. */
797:                 		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
9D00E880  0006A880   SLL S5, A2, 2
9D00E884  8E040030   LW A0, 48(S0)
9D00E888  240500A5   ADDIU A1, ZERO, 165
9D00E88C  0F40464F   JAL memset
9D00E890  02A03021   ADDU A2, S5, ZERO
798:                 	}
799:                 	#endif /* ( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) ) */
800:                 
801:                 	/* Calculate the top of stack address.  This depends on whether the stack
802:                 	grows from high memory to low (as per the 80x86) or vice versa.
803:                 	portSTACK_GROWTH is used to make the result positive or negative as required
804:                 	by the port. */
805:                 	#if( portSTACK_GROWTH < 0 )
806:                 	{
807:                 		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
9D00E894  26B5FFFC   ADDIU S5, S5, -4
9D00E898  8E020030   LW V0, 48(S0)
9D00E89C  0055A821   ADDU S5, V0, S5
808:                 		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
809:                 
810:                 		/* Check the alignment of the calculated top of stack is correct. */
811:                 		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
812:                 	}
813:                 	#else /* portSTACK_GROWTH */
814:                 	{
815:                 		pxTopOfStack = pxNewTCB->pxStack;
816:                 
817:                 		/* Check the alignment of the stack buffer is correct. */
818:                 		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxNewTCB->pxStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
819:                 
820:                 		/* The other extreme of the stack space is required if stack checking is
821:                 		performed. */
822:                 		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
823:                 	}
824:                 	#endif /* portSTACK_GROWTH */
825:                 
826:                 	/* Store the task name in the TCB. */
827:                 	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
9D00E8B8  24030001   ADDIU V1, ZERO, 1
9D00E8BC  24060010   ADDIU A2, ZERO, 16
9D00E8D8  1466FFF9   BNE V1, A2, 0x9D00E8C0
9D00E8DC  24420001   ADDIU V0, V0, 1
828:                 	{
829:                 		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
9D00E8A0  82C20000   LB V0, 0(S6)
9D00E8A4  A2020034   SB V0, 52(S0)
9D00E8C0  80450000   LB A1, 0(V0)
9D00E8C4  02032021   ADDU A0, S0, V1
9D00E8C8  A0850034   SB A1, 52(A0)
830:                 
831:                 		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
832:                 		configMAX_TASK_NAME_LEN characters just in case the memory after the
833:                 		string is not accessible (extremely unlikely). */
834:                 		if( pcName[ x ] == 0x00 )
9D00E8A8  82C20000   LB V0, 0(S6)
9D00E8AC  1040000C   BEQ V0, ZERO, 0x9D00E8E0
9D00E8B0  7C151004   INS S5, ZERO, 0, 3
9D00E8B4  26C20001   ADDIU V0, S6, 1
9D00E8CC  80480000   LB T0, 0(V0)
9D00E8D0  11000003   BEQ T0, ZERO, 0x9D00E8E0
9D00E8D4  24630001   ADDIU V1, V1, 1
835:                 		{
836:                 			break;
837:                 		}
838:                 		else
839:                 		{
840:                 			mtCOVERAGE_TEST_MARKER();
841:                 		}
842:                 	}
843:                 
844:                 	/* Ensure the name string is terminated in the case that the string length
845:                 	was greater or equal to configMAX_TASK_NAME_LEN. */
846:                 	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
9D00E8E0  A2000043   SB ZERO, 67(S0)
9D00E8E4  2E230005   SLTIU V1, S1, 5
9D00E8E8  24020004   ADDIU V0, ZERO, 4
9D00E8EC  0043880A   MOVZ S1, V0, V1
847:                 
848:                 	/* This is used as an array index so must ensure it's not too large.  First
849:                 	remove the privilege bit if one is present. */
850:                 	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
851:                 	{
852:                 		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
853:                 	}
854:                 	else
855:                 	{
856:                 		mtCOVERAGE_TEST_MARKER();
857:                 	}
858:                 
859:                 	pxNewTCB->uxPriority = uxPriority;
9D00E8F0  AE11002C   SW S1, 44(S0)
860:                 	#if ( configUSE_MUTEXES == 1 )
861:                 	{
862:                 		pxNewTCB->uxBasePriority = uxPriority;
9D00E8F4  AE110048   SW S1, 72(S0)
863:                 		pxNewTCB->uxMutexesHeld = 0;
9D00E8F8  AE00004C   SW ZERO, 76(S0)
864:                 	}
865:                 	#endif /* configUSE_MUTEXES */
866:                 
867:                 	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
9D00E8FC  0F405686   JAL vListInitialiseItem
9D00E900  26040004   ADDIU A0, S0, 4
868:                 	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
9D00E904  0F405686   JAL vListInitialiseItem
9D00E908  26040018   ADDIU A0, S0, 24
869:                 
870:                 	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
871:                 	back to	the containing TCB from a generic item in a list. */
872:                 	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
9D00E90C  AE100010   SW S0, 16(S0)
873:                 
874:                 	/* Event lists are always in priority order. */
875:                 	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
9D00E910  24020005   ADDIU V0, ZERO, 5
9D00E914  00518823   SUBU S1, V0, S1
9D00E918  AE110018   SW S1, 24(S0)
876:                 	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
9D00E91C  AE100024   SW S0, 36(S0)
877:                 
878:                 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
879:                 	{
880:                 		pxNewTCB->uxCriticalNesting = ( UBaseType_t ) 0U;
9D00E920  AE000044   SW ZERO, 68(S0)
881:                 	}
882:                 	#endif /* portCRITICAL_NESTING_IN_TCB */
883:                 
884:                 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
885:                 	{
886:                 		pxNewTCB->pxTaskTag = NULL;
887:                 	}
888:                 	#endif /* configUSE_APPLICATION_TASK_TAG */
889:                 
890:                 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
891:                 	{
892:                 		pxNewTCB->ulRunTimeCounter = 0UL;
893:                 	}
894:                 	#endif /* configGENERATE_RUN_TIME_STATS */
895:                 
896:                 	#if ( portUSING_MPU_WRAPPERS == 1 )
897:                 	{
898:                 		vPortStoreTaskMPUSettings( &( pxNewTCB->xMPUSettings ), xRegions, pxNewTCB->pxStack, ulStackDepth );
899:                 	}
900:                 	#else
901:                 	{
902:                 		/* Avoid compiler warning about unreferenced parameter. */
903:                 		( void ) xRegions;
904:                 	}
905:                 	#endif
906:                 
907:                 	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
908:                 	{
909:                 		for( x = 0; x < ( UBaseType_t ) configNUM_THREAD_LOCAL_STORAGE_POINTERS; x++ )
910:                 		{
911:                 			pxNewTCB->pvThreadLocalStoragePointers[ x ] = NULL;
912:                 		}
913:                 	}
914:                 	#endif
915:                 
916:                 	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
917:                 	{
918:                 		pxNewTCB->ulNotifiedValue = 0;
9D00E924  AE000050   SW ZERO, 80(S0)
919:                 		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
9D00E928  A2000054   SB ZERO, 84(S0)
920:                 	}
921:                 	#endif
922:                 
923:                 	#if ( configUSE_NEWLIB_REENTRANT == 1 )
924:                 	{
925:                 		/* Initialise this task's Newlib reent structure. */
926:                 		_REENT_INIT_PTR( ( &( pxNewTCB->xNewLib_reent ) ) );
927:                 	}
928:                 	#endif
929:                 
930:                 	#if( INCLUDE_xTaskAbortDelay == 1 )
931:                 	{
932:                 		pxNewTCB->ucDelayAborted = pdFALSE;
933:                 	}
934:                 	#endif
935:                 
936:                 	/* Initialize the TCB stack to look as if the task was already running,
937:                 	but had been interrupted by the scheduler.  The return address is set
938:                 	to the start of the task function. Once the stack has been initialised
939:                 	the	top of stack variable is updated. */
940:                 	#if( portUSING_MPU_WRAPPERS == 1 )
941:                 	{
942:                 		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
943:                 	}
944:                 	#else /* portUSING_MPU_WRAPPERS */
945:                 	{
946:                 		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
9D00E92C  02A02021   ADDU A0, S5, ZERO
9D00E930  02802821   ADDU A1, S4, ZERO
9D00E934  0F40506D   JAL pxPortInitialiseStack
9D00E938  02603021   ADDU A2, S3, ZERO
947:                 	}
948:                 	#endif /* portUSING_MPU_WRAPPERS */
949:                 
950:                 	if( ( void * ) pxCreatedTask != NULL )
9D00E93C  12400002   BEQ S2, ZERO, 0x9D00E948
9D00E940  AE020000   SW V0, 0(S0)
951:                 	{
952:                 		/* Pass the handle out in an anonymous way.  The handle can be used to
953:                 		change the created task's priority, delete the created task, etc.*/
954:                 		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
9D00E944  AE500000   SW S0, 0(S2)
955:                 	}
956:                 	else
957:                 	{
958:                 		mtCOVERAGE_TEST_MARKER();
959:                 	}
960:                 }
9D00E948  8FBF002C   LW RA, 44(SP)
9D00E94C  8FB60028   LW S6, 40(SP)
9D00E950  8FB50024   LW S5, 36(SP)
9D00E954  8FB40020   LW S4, 32(SP)
9D00E958  8FB3001C   LW S3, 28(SP)
9D00E95C  8FB20018   LW S2, 24(SP)
9D00E960  8FB10014   LW S1, 20(SP)
9D00E964  8FB00010   LW S0, 16(SP)
9D00E968  03E00008   JR RA
9D00E96C  27BD0030   ADDIU SP, SP, 48
961:                 /*-----------------------------------------------------------*/
962:                 
963:                 static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
964:                 {
9D00F6FC  27BDFFE8   ADDIU SP, SP, -24
9D00F700  AFBF0014   SW RA, 20(SP)
9D00F704  AFB00010   SW S0, 16(SP)
965:                 	/* Ensure interrupts don't access the task lists while the lists are being
966:                 	updated. */
967:                 	taskENTER_CRITICAL();
9D00F708  0F405144   JAL vTaskEnterCritical
9D00F70C  00808021   ADDU S0, A0, ZERO
968:                 	{
969:                 		uxCurrentNumberOfTasks++;
9D00F710  8F82809C   LW V0, -32612(GP)
9D00F714  24420001   ADDIU V0, V0, 1
9D00F718  AF82809C   SW V0, -32612(GP)
970:                 		if( pxCurrentTCB == NULL )
9D00F71C  8F8280A4   LW V0, -32604(GP)
9D00F720  1440000A   BNE V0, ZERO, 0x9D00F74C
9D00F724  00000000   NOP
971:                 		{
972:                 			/* There are no other tasks, or all the other tasks are in
973:                 			the suspended state - make this the current task. */
974:                 			pxCurrentTCB = pxNewTCB;
9D00F728  AF9080A4   SW S0, -32604(GP)
975:                 
976:                 			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
9D00F72C  8F83809C   LW V1, -32612(GP)
9D00F730  24020001   ADDIU V0, ZERO, 1
9D00F734  5462000F   BNEL V1, V0, 0x9D00F774
9D00F738  8F828080   LW V0, -32640(GP)
977:                 			{
978:                 				/* This is the first task to be created so do the preliminary
979:                 				initialisation required.  We will not recover if this call
980:                 				fails, but we will report the failure. */
981:                 				prvInitialiseTaskLists();
9D00F73C  0F404960   JAL prvInitialiseTaskLists
9D00F740  00000000   NOP
9D00F744  0B403DDD   J 0x9D00F774
9D00F748  8F828080   LW V0, -32640(GP)
982:                 			}
983:                 			else
984:                 			{
985:                 				mtCOVERAGE_TEST_MARKER();
986:                 			}
987:                 		}
988:                 		else
989:                 		{
990:                 			/* If the scheduler is not already running, make this task the
991:                 			current task if it is the highest priority task to be created
992:                 			so far. */
993:                 			if( xSchedulerRunning == pdFALSE )
9D00F74C  8F828090   LW V0, -32624(GP)
9D00F750  14400008   BNE V0, ZERO, 0x9D00F774
9D00F754  8F828080   LW V0, -32640(GP)
994:                 			{
995:                 				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
9D00F758  8F8280A4   LW V0, -32604(GP)
9D00F75C  8C43002C   LW V1, 44(V0)
9D00F760  8E02002C   LW V0, 44(S0)
9D00F764  0043102B   SLTU V0, V0, V1
9D00F768  50400001   BEQL V0, ZERO, 0x9D00F770
9D00F76C  AF9080A4   SW S0, -32604(GP)
996:                 				{
997:                 					pxCurrentTCB = pxNewTCB;
998:                 				}
999:                 				else
1000:                				{
1001:                					mtCOVERAGE_TEST_MARKER();
1002:                				}
1003:                			}
1004:                			else
1005:                			{
1006:                				mtCOVERAGE_TEST_MARKER();
1007:                			}
1008:                		}
1009:                
1010:                		uxTaskNumber++;
9D00F770  8F828080   LW V0, -32640(GP)
9D00F774  24420001   ADDIU V0, V0, 1
9D00F778  AF828080   SW V0, -32640(GP)
1011:                
1012:                		#if ( configUSE_TRACE_FACILITY == 1 )
1013:                		{
1014:                			/* Add a counter into the TCB for tracing only. */
1015:                			pxNewTCB->uxTCBNumber = uxTaskNumber;
1016:                		}
1017:                		#endif /* configUSE_TRACE_FACILITY */
1018:                		traceTASK_CREATE( pxNewTCB );
1019:                
1020:                		prvAddTaskToReadyList( pxNewTCB );
9D00F77C  8E02002C   LW V0, 44(S0)
9D00F780  8F848094   LW A0, -32620(GP)
9D00F784  24030001   ADDIU V1, ZERO, 1
9D00F788  00431804   SLLV V1, V1, V0
9D00F78C  00641825   OR V1, V1, A0
9D00F790  AF838094   SW V1, -32620(GP)
9D00F794  00021880   SLL V1, V0, 2
9D00F798  00021100   SLL V0, V0, 4
9D00F79C  00621021   ADDU V0, V1, V0
9D00F7A0  3C04A000   LUI A0, -24576
9D00F7A4  24840E30   ADDIU A0, A0, 3632
9D00F7A8  00822021   ADDU A0, A0, V0
9D00F7AC  0F405426   JAL vListInsertEnd
9D00F7B0  26050004   ADDIU A1, S0, 4
1021:                
1022:                		portSETUP_TCB( pxNewTCB );
1023:                	}
1024:                	taskEXIT_CRITICAL();
9D00F7B4  0F404EA8   JAL vTaskExitCritical
9D00F7B8  00000000   NOP
1025:                
1026:                	if( xSchedulerRunning != pdFALSE )
9D00F7BC  8F828090   LW V0, -32624(GP)
9D00F7C0  1040000C   BEQ V0, ZERO, 0x9D00F7F4
9D00F7C4  8FBF0014   LW RA, 20(SP)
1027:                	{
1028:                		/* If the created task is of a higher priority than the current task
1029:                		then it should run now. */
1030:                		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
9D00F7C8  8F8280A4   LW V0, -32604(GP)
9D00F7CC  8C43002C   LW V1, 44(V0)
9D00F7D0  8E02002C   LW V0, 44(S0)
9D00F7D4  0062102B   SLTU V0, V1, V0
9D00F7D8  10400007   BEQ V0, ZERO, 0x9D00F7F8
9D00F7DC  8FB00010   LW S0, 16(SP)
1031:                		{
1032:                			taskYIELD_IF_USING_PREEMPTION();
9D00F7E0  40026800   MFC0 V0, Cause
9D00F7E4  34420100   ORI V0, V0, 256
9D00F7E8  40826800   MTC0 V0, Cause
9D00F7EC  000000C0   EHB
1033:                		}
1034:                		else
1035:                		{
1036:                			mtCOVERAGE_TEST_MARKER();
1037:                		}
1038:                	}
1039:                	else
1040:                	{
1041:                		mtCOVERAGE_TEST_MARKER();
1042:                	}
1043:                }
9D00F7F0  8FBF0014   LW RA, 20(SP)
9D00F7F4  8FB00010   LW S0, 16(SP)
9D00F7F8  03E00008   JR RA
9D00F7FC  27BD0018   ADDIU SP, SP, 24
1044:                /*-----------------------------------------------------------*/
1045:                
1046:                #if ( INCLUDE_vTaskDelete == 1 )
1047:                
1048:                	void vTaskDelete( TaskHandle_t xTaskToDelete )
1049:                	{
1050:                	TCB_t *pxTCB;
1051:                
1052:                		taskENTER_CRITICAL();
1053:                		{
1054:                			/* If null is passed in here then it is the calling task that is
1055:                			being deleted. */
1056:                			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
1057:                
1058:                			/* Remove task from the ready list. */
1059:                			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
1060:                			{
1061:                				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
1062:                			}
1063:                			else
1064:                			{
1065:                				mtCOVERAGE_TEST_MARKER();
1066:                			}
1067:                
1068:                			/* Is the task waiting on an event also? */
1069:                			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
1070:                			{
1071:                				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
1072:                			}
1073:                			else
1074:                			{
1075:                				mtCOVERAGE_TEST_MARKER();
1076:                			}
1077:                
1078:                			/* Increment the uxTaskNumber also so kernel aware debuggers can
1079:                			detect that the task lists need re-generating.  This is done before
1080:                			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
1081:                			not return. */
1082:                			uxTaskNumber++;
1083:                
1084:                			if( pxTCB == pxCurrentTCB )
1085:                			{
1086:                				/* A task is deleting itself.  This cannot complete within the
1087:                				task itself, as a context switch to another task is required.
1088:                				Place the task in the termination list.  The idle task will
1089:                				check the termination list and free up any memory allocated by
1090:                				the scheduler for the TCB and stack of the deleted task. */
1091:                				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
1092:                
1093:                				/* Increment the ucTasksDeleted variable so the idle task knows
1094:                				there is a task that has been deleted and that it should therefore
1095:                				check the xTasksWaitingTermination list. */
1096:                				++uxDeletedTasksWaitingCleanUp;
1097:                
1098:                				/* The pre-delete hook is primarily for the Windows simulator,
1099:                				in which Windows specific clean up operations are performed,
1100:                				after which it is not possible to yield away from this task -
1101:                				hence xYieldPending is used to latch that a context switch is
1102:                				required. */
1103:                				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
1104:                			}
1105:                			else
1106:                			{
1107:                				--uxCurrentNumberOfTasks;
1108:                				prvDeleteTCB( pxTCB );
1109:                
1110:                				/* Reset the next expected unblock time in case it referred to
1111:                				the task that has just been deleted. */
1112:                				prvResetNextTaskUnblockTime();
1113:                			}
1114:                
1115:                			traceTASK_DELETE( pxTCB );
1116:                		}
1117:                		taskEXIT_CRITICAL();
1118:                
1119:                		/* Force a reschedule if it is the currently running task that has just
1120:                		been deleted. */
1121:                		if( xSchedulerRunning != pdFALSE )
1122:                		{
1123:                			if( pxTCB == pxCurrentTCB )
1124:                			{
1125:                				configASSERT( uxSchedulerSuspended == 0 );
1126:                				portYIELD_WITHIN_API();
1127:                			}
1128:                			else
1129:                			{
1130:                				mtCOVERAGE_TEST_MARKER();
1131:                			}
1132:                		}
1133:                	}
1134:                
1135:                #endif /* INCLUDE_vTaskDelete */
1136:                /*-----------------------------------------------------------*/
1137:                
1138:                #if ( INCLUDE_vTaskDelayUntil == 1 )
1139:                
1140:                	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
1141:                	{
1142:                	TickType_t xTimeToWake;
1143:                	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
1144:                
1145:                		configASSERT( pxPreviousWakeTime );
1146:                		configASSERT( ( xTimeIncrement > 0U ) );
1147:                		configASSERT( uxSchedulerSuspended == 0 );
1148:                
1149:                		vTaskSuspendAll();
1150:                		{
1151:                			/* Minor optimisation.  The tick count cannot change in this
1152:                			block. */
1153:                			const TickType_t xConstTickCount = xTickCount;
1154:                
1155:                			/* Generate the tick time at which the task wants to wake. */
1156:                			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
1157:                
1158:                			if( xConstTickCount < *pxPreviousWakeTime )
1159:                			{
1160:                				/* The tick count has overflowed since this function was
1161:                				lasted called.  In this case the only time we should ever
1162:                				actually delay is if the wake time has also	overflowed,
1163:                				and the wake time is greater than the tick time.  When this
1164:                				is the case it is as if neither time had overflowed. */
1165:                				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
1166:                				{
1167:                					xShouldDelay = pdTRUE;
1168:                				}
1169:                				else
1170:                				{
1171:                					mtCOVERAGE_TEST_MARKER();
1172:                				}
1173:                			}
1174:                			else
1175:                			{
1176:                				/* The tick time has not overflowed.  In this case we will
1177:                				delay if either the wake time has overflowed, and/or the
1178:                				tick time is less than the wake time. */
1179:                				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
1180:                				{
1181:                					xShouldDelay = pdTRUE;
1182:                				}
1183:                				else
1184:                				{
1185:                					mtCOVERAGE_TEST_MARKER();
1186:                				}
1187:                			}
1188:                
1189:                			/* Update the wake time ready for the next call. */
1190:                			*pxPreviousWakeTime = xTimeToWake;
1191:                
1192:                			if( xShouldDelay != pdFALSE )
1193:                			{
1194:                				traceTASK_DELAY_UNTIL( xTimeToWake );
1195:                
1196:                				/* prvAddCurrentTaskToDelayedList() needs the block time, not
1197:                				the time to wake, so subtract the current tick count. */
1198:                				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
1199:                			}
1200:                			else
1201:                			{
1202:                				mtCOVERAGE_TEST_MARKER();
1203:                			}
1204:                		}
1205:                		xAlreadyYielded = xTaskResumeAll();
1206:                
1207:                		/* Force a reschedule if xTaskResumeAll has not already done so, we may
1208:                		have put ourselves to sleep. */
1209:                		if( xAlreadyYielded == pdFALSE )
1210:                		{
1211:                			portYIELD_WITHIN_API();
1212:                		}
1213:                		else
1214:                		{
1215:                			mtCOVERAGE_TEST_MARKER();
1216:                		}
1217:                	}
1218:                
1219:                #endif /* INCLUDE_vTaskDelayUntil */
1220:                /*-----------------------------------------------------------*/
1221:                
1222:                #if ( INCLUDE_vTaskDelay == 1 )
1223:                
1224:                	void vTaskDelay( const TickType_t xTicksToDelay )
1225:                	{
9D014004  27BDFFE8   ADDIU SP, SP, -24
9D014008  AFBF0014   SW RA, 20(SP)
9D01400C  AFB00010   SW S0, 16(SP)
1226:                	BaseType_t xAlreadyYielded = pdFALSE;
1227:                
1228:                		/* A delay time of zero just forces a reschedule. */
1229:                		if( xTicksToDelay > ( TickType_t ) 0U )
9D014010  1080000A   BEQ A0, ZERO, 0x9D01403C
9D014014  00808021   ADDU S0, A0, ZERO
1230:                		{
1231:                			configASSERT( uxSchedulerSuspended == 0 );
1232:                			vTaskSuspendAll();
9D014018  0F4055F0   JAL vTaskSuspendAll
9D01401C  00000000   NOP
1233:                			{
1234:                				traceTASK_DELAY();
1235:                
1236:                				/* A task that is removed from the event list while the
1237:                				scheduler is suspended will not get placed in the ready
1238:                				list or removed from the blocked list until the scheduler
1239:                				is resumed.
1240:                
1241:                				This task cannot be in an event list as it is the currently
1242:                				executing task. */
1243:                				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
9D014020  02002021   ADDU A0, S0, ZERO
9D014024  0F40424D   JAL prvAddCurrentTaskToDelayedList
9D014028  00002821   ADDU A1, ZERO, ZERO
1244:                			}
1245:                			xAlreadyYielded = xTaskResumeAll();
9D01402C  0F40379F   JAL xTaskResumeAll
9D014030  00000000   NOP
1246:                		}
1247:                		else
1248:                		{
1249:                			mtCOVERAGE_TEST_MARKER();
1250:                		}
1251:                
1252:                		/* Force a reschedule if xTaskResumeAll has not already done so, we may
1253:                		have put ourselves to sleep. */
1254:                		if( xAlreadyYielded == pdFALSE )
9D014034  14400006   BNE V0, ZERO, 0x9D014050
9D014038  8FBF0014   LW RA, 20(SP)
1255:                		{
1256:                			portYIELD_WITHIN_API();
9D01403C  40026800   MFC0 V0, Cause
9D014040  34420100   ORI V0, V0, 256
9D014044  40826800   MTC0 V0, Cause
9D014048  000000C0   EHB
1257:                		}
1258:                		else
1259:                		{
1260:                			mtCOVERAGE_TEST_MARKER();
1261:                		}
1262:                	}
9D01404C  8FBF0014   LW RA, 20(SP)
9D014050  8FB00010   LW S0, 16(SP)
9D014054  03E00008   JR RA
9D014058  27BD0018   ADDIU SP, SP, 24
1263:                
1264:                #endif /* INCLUDE_vTaskDelay */
1265:                /*-----------------------------------------------------------*/
1266:                
1267:                #if( ( INCLUDE_eTaskGetState == 1 ) || ( configUSE_TRACE_FACILITY == 1 ) )
1268:                
1269:                	eTaskState eTaskGetState( TaskHandle_t xTask )
1270:                	{
1271:                	eTaskState eReturn;
1272:                	List_t *pxStateList;
1273:                	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
1274:                
1275:                		configASSERT( pxTCB );
1276:                
1277:                		if( pxTCB == pxCurrentTCB )
1278:                		{
1279:                			/* The task calling this function is querying its own state. */
1280:                			eReturn = eRunning;
1281:                		}
1282:                		else
1283:                		{
1284:                			taskENTER_CRITICAL();
1285:                			{
1286:                				pxStateList = ( List_t * ) listLIST_ITEM_CONTAINER( &( pxTCB->xStateListItem ) );
1287:                			}
1288:                			taskEXIT_CRITICAL();
1289:                
1290:                			if( ( pxStateList == pxDelayedTaskList ) || ( pxStateList == pxOverflowDelayedTaskList ) )
1291:                			{
1292:                				/* The task being queried is referenced from one of the Blocked
1293:                				lists. */
1294:                				eReturn = eBlocked;
1295:                			}
1296:                
1297:                			#if ( INCLUDE_vTaskSuspend == 1 )
1298:                				else if( pxStateList == &xSuspendedTaskList )
1299:                				{
1300:                					/* The task being queried is referenced from the suspended
1301:                					list.  Is it genuinely suspended or is it block
1302:                					indefinitely? */
1303:                					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
1304:                					{
1305:                						eReturn = eSuspended;
1306:                					}
1307:                					else
1308:                					{
1309:                						eReturn = eBlocked;
1310:                					}
1311:                				}
1312:                			#endif
1313:                
1314:                			#if ( INCLUDE_vTaskDelete == 1 )
1315:                				else if( ( pxStateList == &xTasksWaitingTermination ) || ( pxStateList == NULL ) )
1316:                				{
1317:                					/* The task being queried is referenced from the deleted
1318:                					tasks list, or it is not referenced from any lists at
1319:                					all. */
1320:                					eReturn = eDeleted;
1321:                				}
1322:                			#endif
1323:                
1324:                			else /*lint !e525 Negative indentation is intended to make use of pre-processor clearer. */
1325:                			{
1326:                				/* If the task is not in any other state, it must be in the
1327:                				Ready (including pending ready) state. */
1328:                				eReturn = eReady;
1329:                			}
1330:                		}
1331:                
1332:                		return eReturn;
1333:                	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
1334:                
1335:                #endif /* INCLUDE_eTaskGetState */
1336:                /*-----------------------------------------------------------*/
1337:                
1338:                #if ( INCLUDE_uxTaskPriorityGet == 1 )
1339:                
1340:                	UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask )
1341:                	{
1342:                	TCB_t *pxTCB;
1343:                	UBaseType_t uxReturn;
1344:                
1345:                		taskENTER_CRITICAL();
1346:                		{
1347:                			/* If null is passed in here then it is the priority of the that
1348:                			called uxTaskPriorityGet() that is being queried. */
1349:                			pxTCB = prvGetTCBFromHandle( xTask );
1350:                			uxReturn = pxTCB->uxPriority;
1351:                		}
1352:                		taskEXIT_CRITICAL();
1353:                
1354:                		return uxReturn;
1355:                	}
1356:                
1357:                #endif /* INCLUDE_uxTaskPriorityGet */
1358:                /*-----------------------------------------------------------*/
1359:                
1360:                #if ( INCLUDE_uxTaskPriorityGet == 1 )
1361:                
1362:                	UBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask )
1363:                	{
1364:                	TCB_t *pxTCB;
1365:                	UBaseType_t uxReturn, uxSavedInterruptState;
1366:                
1367:                		/* RTOS ports that support interrupt nesting have the concept of a
1368:                		maximum	system call (or maximum API call) interrupt priority.
1369:                		Interrupts that are	above the maximum system call priority are keep
1370:                		permanently enabled, even when the RTOS kernel is in a critical section,
1371:                		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
1372:                		is defined in FreeRTOSConfig.h then
1373:                		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1374:                		failure if a FreeRTOS API function is called from an interrupt that has
1375:                		been assigned a priority above the configured maximum system call
1376:                		priority.  Only FreeRTOS functions that end in FromISR can be called
1377:                		from interrupts	that have been assigned a priority at or (logically)
1378:                		below the maximum system call interrupt priority.  FreeRTOS maintains a
1379:                		separate interrupt safe API to ensure interrupt entry is as fast and as
1380:                		simple as possible.  More information (albeit Cortex-M specific) is
1381:                		provided on the following link:
1382:                		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1383:                		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1384:                
1385:                		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
1386:                		{
1387:                			/* If null is passed in here then it is the priority of the calling
1388:                			task that is being queried. */
1389:                			pxTCB = prvGetTCBFromHandle( xTask );
1390:                			uxReturn = pxTCB->uxPriority;
1391:                		}
1392:                		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );
1393:                
1394:                		return uxReturn;
1395:                	}
1396:                
1397:                #endif /* INCLUDE_uxTaskPriorityGet */
1398:                /*-----------------------------------------------------------*/
1399:                
1400:                #if ( INCLUDE_vTaskPrioritySet == 1 )
1401:                
1402:                	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
1403:                	{
1404:                	TCB_t *pxTCB;
1405:                	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
1406:                	BaseType_t xYieldRequired = pdFALSE;
1407:                
1408:                		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
1409:                
1410:                		/* Ensure the new priority is valid. */
1411:                		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
1412:                		{
1413:                			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
1414:                		}
1415:                		else
1416:                		{
1417:                			mtCOVERAGE_TEST_MARKER();
1418:                		}
1419:                
1420:                		taskENTER_CRITICAL();
1421:                		{
1422:                			/* If null is passed in here then it is the priority of the calling
1423:                			task that is being changed. */
1424:                			pxTCB = prvGetTCBFromHandle( xTask );
1425:                
1426:                			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
1427:                
1428:                			#if ( configUSE_MUTEXES == 1 )
1429:                			{
1430:                				uxCurrentBasePriority = pxTCB->uxBasePriority;
1431:                			}
1432:                			#else
1433:                			{
1434:                				uxCurrentBasePriority = pxTCB->uxPriority;
1435:                			}
1436:                			#endif
1437:                
1438:                			if( uxCurrentBasePriority != uxNewPriority )
1439:                			{
1440:                				/* The priority change may have readied a task of higher
1441:                				priority than the calling task. */
1442:                				if( uxNewPriority > uxCurrentBasePriority )
1443:                				{
1444:                					if( pxTCB != pxCurrentTCB )
1445:                					{
1446:                						/* The priority of a task other than the currently
1447:                						running task is being raised.  Is the priority being
1448:                						raised above that of the running task? */
1449:                						if( uxNewPriority >= pxCurrentTCB->uxPriority )
1450:                						{
1451:                							xYieldRequired = pdTRUE;
1452:                						}
1453:                						else
1454:                						{
1455:                							mtCOVERAGE_TEST_MARKER();
1456:                						}
1457:                					}
1458:                					else
1459:                					{
1460:                						/* The priority of the running task is being raised,
1461:                						but the running task must already be the highest
1462:                						priority task able to run so no yield is required. */
1463:                					}
1464:                				}
1465:                				else if( pxTCB == pxCurrentTCB )
1466:                				{
1467:                					/* Setting the priority of the running task down means
1468:                					there may now be another task of higher priority that
1469:                					is ready to execute. */
1470:                					xYieldRequired = pdTRUE;
1471:                				}
1472:                				else
1473:                				{
1474:                					/* Setting the priority of any other task down does not
1475:                					require a yield as the running task must be above the
1476:                					new priority of the task being modified. */
1477:                				}
1478:                
1479:                				/* Remember the ready list the task might be referenced from
1480:                				before its uxPriority member is changed so the
1481:                				taskRESET_READY_PRIORITY() macro can function correctly. */
1482:                				uxPriorityUsedOnEntry = pxTCB->uxPriority;
1483:                
1484:                				#if ( configUSE_MUTEXES == 1 )
1485:                				{
1486:                					/* Only change the priority being used if the task is not
1487:                					currently using an inherited priority. */
1488:                					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
1489:                					{
1490:                						pxTCB->uxPriority = uxNewPriority;
1491:                					}
1492:                					else
1493:                					{
1494:                						mtCOVERAGE_TEST_MARKER();
1495:                					}
1496:                
1497:                					/* The base priority gets set whatever. */
1498:                					pxTCB->uxBasePriority = uxNewPriority;
1499:                				}
1500:                				#else
1501:                				{
1502:                					pxTCB->uxPriority = uxNewPriority;
1503:                				}
1504:                				#endif
1505:                
1506:                				/* Only reset the event list item value if the value is not
1507:                				being used for anything else. */
1508:                				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
1509:                				{
1510:                					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
1511:                				}
1512:                				else
1513:                				{
1514:                					mtCOVERAGE_TEST_MARKER();
1515:                				}
1516:                
1517:                				/* If the task is in the blocked or suspended list we need do
1518:                				nothing more than change it's priority variable. However, if
1519:                				the task is in a ready list it needs to be removed and placed
1520:                				in the list appropriate to its new priority. */
1521:                				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
1522:                				{
1523:                					/* The task is currently in its ready list - remove before adding
1524:                					it to it's new ready list.  As we are in a critical section we
1525:                					can do this even if the scheduler is suspended. */
1526:                					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
1527:                					{
1528:                						/* It is known that the task is in its ready list so
1529:                						there is no need to check again and the port level
1530:                						reset macro can be called directly. */
1531:                						portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
1532:                					}
1533:                					else
1534:                					{
1535:                						mtCOVERAGE_TEST_MARKER();
1536:                					}
1537:                					prvAddTaskToReadyList( pxTCB );
1538:                				}
1539:                				else
1540:                				{
1541:                					mtCOVERAGE_TEST_MARKER();
1542:                				}
1543:                
1544:                				if( xYieldRequired != pdFALSE )
1545:                				{
1546:                					taskYIELD_IF_USING_PREEMPTION();
1547:                				}
1548:                				else
1549:                				{
1550:                					mtCOVERAGE_TEST_MARKER();
1551:                				}
1552:                
1553:                				/* Remove compiler warning about unused variables when the port
1554:                				optimised task selection is not being used. */
1555:                				( void ) uxPriorityUsedOnEntry;
1556:                			}
1557:                		}
1558:                		taskEXIT_CRITICAL();
1559:                	}
1560:                
1561:                #endif /* INCLUDE_vTaskPrioritySet */
1562:                /*-----------------------------------------------------------*/
1563:                
1564:                #if ( INCLUDE_vTaskSuspend == 1 )
1565:                
1566:                	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
1567:                	{
1568:                	TCB_t *pxTCB;
1569:                
1570:                		taskENTER_CRITICAL();
1571:                		{
1572:                			/* If null is passed in here then it is the running task that is
1573:                			being suspended. */
1574:                			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
1575:                
1576:                			traceTASK_SUSPEND( pxTCB );
1577:                
1578:                			/* Remove task from the ready/delayed list and place in the
1579:                			suspended list. */
1580:                			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
1581:                			{
1582:                				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
1583:                			}
1584:                			else
1585:                			{
1586:                				mtCOVERAGE_TEST_MARKER();
1587:                			}
1588:                
1589:                			/* Is the task waiting on an event also? */
1590:                			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
1591:                			{
1592:                				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
1593:                			}
1594:                			else
1595:                			{
1596:                				mtCOVERAGE_TEST_MARKER();
1597:                			}
1598:                
1599:                			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
1600:                		}
1601:                		taskEXIT_CRITICAL();
1602:                
1603:                		if( xSchedulerRunning != pdFALSE )
1604:                		{
1605:                			/* Reset the next expected unblock time in case it referred to the
1606:                			task that is now in the Suspended state. */
1607:                			taskENTER_CRITICAL();
1608:                			{
1609:                				prvResetNextTaskUnblockTime();
1610:                			}
1611:                			taskEXIT_CRITICAL();
1612:                		}
1613:                		else
1614:                		{
1615:                			mtCOVERAGE_TEST_MARKER();
1616:                		}
1617:                
1618:                		if( pxTCB == pxCurrentTCB )
1619:                		{
1620:                			if( xSchedulerRunning != pdFALSE )
1621:                			{
1622:                				/* The current task has just been suspended. */
1623:                				configASSERT( uxSchedulerSuspended == 0 );
1624:                				portYIELD_WITHIN_API();
1625:                			}
1626:                			else
1627:                			{
1628:                				/* The scheduler is not running, but the task that was pointed
1629:                				to by pxCurrentTCB has just been suspended and pxCurrentTCB
1630:                				must be adjusted to point to a different task. */
1631:                				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
1632:                				{
1633:                					/* No other tasks are ready, so set pxCurrentTCB back to
1634:                					NULL so when the next task is created pxCurrentTCB will
1635:                					be set to point to it no matter what its relative priority
1636:                					is. */
1637:                					pxCurrentTCB = NULL;
1638:                				}
1639:                				else
1640:                				{
1641:                					vTaskSwitchContext();
1642:                				}
1643:                			}
1644:                		}
1645:                		else
1646:                		{
1647:                			mtCOVERAGE_TEST_MARKER();
1648:                		}
1649:                	}
1650:                
1651:                #endif /* INCLUDE_vTaskSuspend */
1652:                /*-----------------------------------------------------------*/
1653:                
1654:                #if ( INCLUDE_vTaskSuspend == 1 )
1655:                
1656:                	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
1657:                	{
1658:                	BaseType_t xReturn = pdFALSE;
1659:                	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
1660:                
1661:                		/* Accesses xPendingReadyList so must be called from a critical
1662:                		section. */
1663:                
1664:                		/* It does not make sense to check if the calling task is suspended. */
1665:                		configASSERT( xTask );
1666:                
1667:                		/* Is the task being resumed actually in the suspended list? */
1668:                		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
1669:                		{
1670:                			/* Has the task already been resumed from within an ISR? */
1671:                			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
1672:                			{
1673:                				/* Is it in the suspended list because it is in the	Suspended
1674:                				state, or because is is blocked with no timeout? */
1675:                				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE )
1676:                				{
1677:                					xReturn = pdTRUE;
1678:                				}
1679:                				else
1680:                				{
1681:                					mtCOVERAGE_TEST_MARKER();
1682:                				}
1683:                			}
1684:                			else
1685:                			{
1686:                				mtCOVERAGE_TEST_MARKER();
1687:                			}
1688:                		}
1689:                		else
1690:                		{
1691:                			mtCOVERAGE_TEST_MARKER();
1692:                		}
1693:                
1694:                		return xReturn;
1695:                	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
1696:                
1697:                #endif /* INCLUDE_vTaskSuspend */
1698:                /*-----------------------------------------------------------*/
1699:                
1700:                #if ( INCLUDE_vTaskSuspend == 1 )
1701:                
1702:                	void vTaskResume( TaskHandle_t xTaskToResume )
1703:                	{
1704:                	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
1705:                
1706:                		/* It does not make sense to resume the calling task. */
1707:                		configASSERT( xTaskToResume );
1708:                
1709:                		/* The parameter cannot be NULL as it is impossible to resume the
1710:                		currently executing task. */
1711:                		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
1712:                		{
1713:                			taskENTER_CRITICAL();
1714:                			{
1715:                				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
1716:                				{
1717:                					traceTASK_RESUME( pxTCB );
1718:                
1719:                					/* As we are in a critical section we can access the ready
1720:                					lists even if the scheduler is suspended. */
1721:                					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
1722:                					prvAddTaskToReadyList( pxTCB );
1723:                
1724:                					/* We may have just resumed a higher priority task. */
1725:                					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
1726:                					{
1727:                						/* This yield may not cause the task just resumed to run,
1728:                						but will leave the lists in the correct state for the
1729:                						next yield. */
1730:                						taskYIELD_IF_USING_PREEMPTION();
1731:                					}
1732:                					else
1733:                					{
1734:                						mtCOVERAGE_TEST_MARKER();
1735:                					}
1736:                				}
1737:                				else
1738:                				{
1739:                					mtCOVERAGE_TEST_MARKER();
1740:                				}
1741:                			}
1742:                			taskEXIT_CRITICAL();
1743:                		}
1744:                		else
1745:                		{
1746:                			mtCOVERAGE_TEST_MARKER();
1747:                		}
1748:                	}
1749:                
1750:                #endif /* INCLUDE_vTaskSuspend */
1751:                
1752:                /*-----------------------------------------------------------*/
1753:                
1754:                #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
1755:                
1756:                	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
1757:                	{
1758:                	BaseType_t xYieldRequired = pdFALSE;
1759:                	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
1760:                	UBaseType_t uxSavedInterruptStatus;
1761:                
1762:                		configASSERT( xTaskToResume );
1763:                
1764:                		/* RTOS ports that support interrupt nesting have the concept of a
1765:                		maximum	system call (or maximum API call) interrupt priority.
1766:                		Interrupts that are	above the maximum system call priority are keep
1767:                		permanently enabled, even when the RTOS kernel is in a critical section,
1768:                		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
1769:                		is defined in FreeRTOSConfig.h then
1770:                		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1771:                		failure if a FreeRTOS API function is called from an interrupt that has
1772:                		been assigned a priority above the configured maximum system call
1773:                		priority.  Only FreeRTOS functions that end in FromISR can be called
1774:                		from interrupts	that have been assigned a priority at or (logically)
1775:                		below the maximum system call interrupt priority.  FreeRTOS maintains a
1776:                		separate interrupt safe API to ensure interrupt entry is as fast and as
1777:                		simple as possible.  More information (albeit Cortex-M specific) is
1778:                		provided on the following link:
1779:                		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1780:                		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1781:                
1782:                		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1783:                		{
1784:                			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
1785:                			{
1786:                				traceTASK_RESUME_FROM_ISR( pxTCB );
1787:                
1788:                				/* Check the ready lists can be accessed. */
1789:                				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
1790:                				{
1791:                					/* Ready lists can be accessed so move the task from the
1792:                					suspended list to the ready list directly. */
1793:                					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
1794:                					{
1795:                						xYieldRequired = pdTRUE;
1796:                					}
1797:                					else
1798:                					{
1799:                						mtCOVERAGE_TEST_MARKER();
1800:                					}
1801:                
1802:                					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
1803:                					prvAddTaskToReadyList( pxTCB );
1804:                				}
1805:                				else
1806:                				{
1807:                					/* The delayed or ready lists cannot be accessed so the task
1808:                					is held in the pending ready list until the scheduler is
1809:                					unsuspended. */
1810:                					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
1811:                				}
1812:                			}
1813:                			else
1814:                			{
1815:                				mtCOVERAGE_TEST_MARKER();
1816:                			}
1817:                		}
1818:                		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1819:                
1820:                		return xYieldRequired;
1821:                	}
1822:                
1823:                #endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
1824:                /*-----------------------------------------------------------*/
1825:                
1826:                void vTaskStartScheduler( void )
1827:                {
9D012844  27BDFFE0   ADDIU SP, SP, -32
9D012848  AFBF001C   SW RA, 28(SP)
1828:                BaseType_t xReturn;
1829:                
1830:                	/* Add the idle task at the lowest priority. */
1831:                	#if( configSUPPORT_STATIC_ALLOCATION == 1 )
1832:                	{
1833:                		StaticTask_t *pxIdleTaskTCBBuffer = NULL;
1834:                		StackType_t *pxIdleTaskStackBuffer = NULL;
1835:                		uint32_t ulIdleTaskStackSize;
1836:                
1837:                		/* The Idle task is created using user provided RAM - obtain the
1838:                		address of the RAM then create the idle task. */
1839:                		vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize );
1840:                		xIdleTaskHandle = xTaskCreateStatic(	prvIdleTask,
1841:                												"IDLE",
1842:                												ulIdleTaskStackSize,
1843:                												( void * ) NULL,
1844:                												( tskIDLE_PRIORITY | portPRIVILEGE_BIT ),
1845:                												pxIdleTaskStackBuffer,
1846:                												pxIdleTaskTCBBuffer ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
1847:                
1848:                		if( xIdleTaskHandle != NULL )
1849:                		{
1850:                			xReturn = pdPASS;
1851:                		}
1852:                		else
1853:                		{
1854:                			xReturn = pdFAIL;
1855:                		}
1856:                	}
1857:                	#else
1858:                	{
1859:                		/* The Idle task is being created using dynamically allocated RAM. */
1860:                		xReturn = xTaskCreate(	prvIdleTask,
9D01284C  AFA00010   SW ZERO, 16(SP)
9D012850  27828078   ADDIU V0, GP, -32648
9D012854  AFA20014   SW V0, 20(SP)
9D012858  3C049D01   LUI A0, -25343
9D01285C  248435D0   ADDIU A0, A0, 13776
9D012860  3C059D01   LUI A1, -25343
9D012864  24A55A20   ADDIU A1, A1, 23072
9D012868  24060080   ADDIU A2, ZERO, 128
9D01286C  0F40448E   JAL xTaskCreate
9D012870  00003821   ADDU A3, ZERO, ZERO
1861:                								"IDLE", configMINIMAL_STACK_SIZE,
1862:                								( void * ) NULL,
1863:                								( tskIDLE_PRIORITY | portPRIVILEGE_BIT ),
1864:                								&xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
1865:                	}
1866:                	#endif /* configSUPPORT_STATIC_ALLOCATION */
1867:                
1868:                	#if ( configUSE_TIMERS == 1 )
1869:                	{
1870:                		if( xReturn == pdPASS )
9D012874  24030001   ADDIU V1, ZERO, 1
9D012878  14430013   BNE V0, V1, 0x9D0128C8
9D01287C  8FBF001C   LW RA, 28(SP)
1871:                		{
1872:                			xReturn = xTimerCreateTimerTask();
9D012880  0F404F1E   JAL xTimerCreateTimerTask
9D012884  00000000   NOP
1873:                		}
1874:                		else
1875:                		{
1876:                			mtCOVERAGE_TEST_MARKER();
1877:                		}
1878:                	}
1879:                	#endif /* configUSE_TIMERS */
1880:                
1881:                	if( xReturn == pdPASS )
9D012888  24030001   ADDIU V1, ZERO, 1
9D01288C  1443000E   BNE V0, V1, 0x9D0128C8
9D012890  8FBF001C   LW RA, 28(SP)
1882:                	{
1883:                		/* Interrupts are turned off here, to ensure a tick does not occur
1884:                		before or during the call to xPortStartScheduler().  The stacks of
1885:                		the created tasks contain a status word with interrupts switched on
1886:                		so interrupts will automatically get re-enabled when the first task
1887:                		starts to run. */
1888:                		portDISABLE_INTERRUPTS();
9D012894  40026000   MFC0 V0, Status
9D012898  7C027A84   INS V0, ZERO, 10, 6
9D01289C  34420C00   ORI V0, V0, 3072
9D0128A0  40826000   MTC0 V0, Status
9D0128A4  000000C0   EHB
1889:                
1890:                		#if ( configUSE_NEWLIB_REENTRANT == 1 )
1891:                		{
1892:                			/* Switch Newlib's _impure_ptr variable to point to the _reent
1893:                			structure specific to the task that will run first. */
1894:                			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
1895:                		}
1896:                		#endif /* configUSE_NEWLIB_REENTRANT */
1897:                
1898:                		xNextTaskUnblockTime = portMAX_DELAY;
9D0128A8  2402FFFF   ADDIU V0, ZERO, -1
9D0128AC  AF82807C   SW V0, -32644(GP)
1899:                		xSchedulerRunning = pdTRUE;
9D0128B0  24020001   ADDIU V0, ZERO, 1
9D0128B4  AF828090   SW V0, -32624(GP)
1900:                		xTickCount = ( TickType_t ) 0U;
9D0128B8  AF808098   SW ZERO, -32616(GP)
1901:                
1902:                		/* If configGENERATE_RUN_TIME_STATS is defined then the following
1903:                		macro must be defined to configure the timer/counter used to generate
1904:                		the run time counter time base. */
1905:                		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
1906:                
1907:                		/* Setting up the timer tick is hardware specific and thus in the
1908:                		portable interface. */
1909:                		if( xPortStartScheduler() != pdFALSE )
9D0128BC  0F404F35   JAL xPortStartScheduler
9D0128C0  00000000   NOP
1910:                		{
1911:                			/* Should not reach here as if the scheduler is running the
1912:                			function will not return. */
1913:                		}
1914:                		else
1915:                		{
1916:                			/* Should only reach here if a task calls xTaskEndScheduler(). */
1917:                		}
1918:                	}
1919:                	else
1920:                	{
1921:                		/* This line will only be reached if the kernel could not be started,
1922:                		because there was not enough FreeRTOS heap to create the idle task
1923:                		or the timer task. */
1924:                		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
1925:                	}
1926:                
1927:                	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
1928:                	meaning xIdleTaskHandle is not used anywhere else. */
1929:                	( void ) xIdleTaskHandle;
1930:                }
9D0128C4  8FBF001C   LW RA, 28(SP)
9D0128C8  03E00008   JR RA
9D0128CC  27BD0020   ADDIU SP, SP, 32
1931:                /*-----------------------------------------------------------*/
1932:                
1933:                void vTaskEndScheduler( void )
1934:                {
1935:                	/* Stop the scheduler interrupts and call the portable scheduler end
1936:                	routine so the original ISRs can be restored if necessary.  The port
1937:                	layer must ensure interrupts enable	bit is left in the correct state. */
1938:                	portDISABLE_INTERRUPTS();
1939:                	xSchedulerRunning = pdFALSE;
1940:                	vPortEndScheduler();
1941:                }
1942:                /*----------------------------------------------------------*/
1943:                
1944:                void vTaskSuspendAll( void )
1945:                {
1946:                	/* A critical section is not required as the variable is of type
1947:                	BaseType_t.  Please read Richard Barry's reply in the following link to a
1948:                	post in the FreeRTOS support forum before reporting this as a bug! -
1949:                	http://goo.gl/wu4acr */
1950:                	++uxSchedulerSuspended;
9D0157C0  8F828074   LW V0, -32652(GP)
9D0157C4  24420001   ADDIU V0, V0, 1
9D0157C8  AF828074   SW V0, -32652(GP)
9D0157CC  03E00008   JR RA
9D0157D0  00000000   NOP
1951:                }
1952:                /*----------------------------------------------------------*/
1953:                
1954:                #if ( configUSE_TICKLESS_IDLE != 0 )
1955:                
1956:                	static TickType_t prvGetExpectedIdleTime( void )
1957:                	{
1958:                	TickType_t xReturn;
1959:                	UBaseType_t uxHigherPriorityReadyTasks = pdFALSE;
1960:                
1961:                		/* uxHigherPriorityReadyTasks takes care of the case where
1962:                		configUSE_PREEMPTION is 0, so there may be tasks above the idle priority
1963:                		task that are in the Ready state, even though the idle task is
1964:                		running. */
1965:                		#if( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
1966:                		{
1967:                			if( uxTopReadyPriority > tskIDLE_PRIORITY )
1968:                			{
1969:                				uxHigherPriorityReadyTasks = pdTRUE;
1970:                			}
1971:                		}
1972:                		#else
1973:                		{
1974:                			const UBaseType_t uxLeastSignificantBit = ( UBaseType_t ) 0x01;
1975:                
1976:                			/* When port optimised task selection is used the uxTopReadyPriority
1977:                			variable is used as a bit map.  If bits other than the least
1978:                			significant bit are set then there are tasks that have a priority
1979:                			above the idle priority that are in the Ready state.  This takes
1980:                			care of the case where the co-operative scheduler is in use. */
1981:                			if( uxTopReadyPriority > uxLeastSignificantBit )
9D0144C8  8F848094   LW A0, -32620(GP)
1982:                			{
1983:                				uxHigherPriorityReadyTasks = pdTRUE;
1984:                			}
1985:                		}
1986:                		#endif
1987:                
1988:                		if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
9D0144CC  8F8280A4   LW V0, -32604(GP)
9D0144D0  8C43002C   LW V1, 44(V0)
9D0144D4  1460000C   BNE V1, ZERO, 0x9D014508
9D0144D8  00001021   ADDU V0, ZERO, ZERO
1989:                		{
1990:                			xReturn = 0;
1991:                		}
1992:                		else if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > 1 )
9D0144DC  3C02A000   LUI V0, -24576
9D0144E0  8C430E30   LW V1, 3632(V0)
9D0144E4  2C630002   SLTIU V1, V1, 2
9D0144E8  10600007   BEQ V1, ZERO, 0x9D014508
9D0144EC  00001021   ADDU V0, ZERO, ZERO
1993:                		{
1994:                			/* There are other idle priority tasks in the ready state.  If
1995:                			time slicing is used then the very next tick interrupt must be
1996:                			processed. */
1997:                			xReturn = 0;
1998:                		}
1999:                		else if( uxHigherPriorityReadyTasks != pdFALSE )
9D0144F0  2C840002   SLTIU A0, A0, 2
9D0144F4  10800004   BEQ A0, ZERO, 0x9D014508
9D0144F8  00000000   NOP
2000:                		{
2001:                			/* There are tasks in the Ready state that have a priority above the
2002:                			idle priority.  This path can only be reached if
2003:                			configUSE_PREEMPTION is 0. */
2004:                			xReturn = 0;
2005:                		}
2006:                		else
2007:                		{
2008:                			xReturn = xNextTaskUnblockTime - xTickCount;
9D0144FC  8F83807C   LW V1, -32644(GP)
9D014500  8F828098   LW V0, -32616(GP)
9D014504  00621023   SUBU V0, V1, V0
2009:                		}
2010:                
2011:                		return xReturn;
2012:                	}
9D014508  03E00008   JR RA
9D01450C  00000000   NOP
2013:                
2014:                #endif /* configUSE_TICKLESS_IDLE */
2015:                /*----------------------------------------------------------*/
2016:                
2017:                BaseType_t xTaskResumeAll( void )
2018:                {
9D00DE7C  27BDFFD8   ADDIU SP, SP, -40
9D00DE80  AFBF0024   SW RA, 36(SP)
9D00DE84  AFB40020   SW S4, 32(SP)
9D00DE88  AFB3001C   SW S3, 28(SP)
9D00DE8C  AFB20018   SW S2, 24(SP)
9D00DE90  AFB10014   SW S1, 20(SP)
2019:                TCB_t *pxTCB = NULL;
2020:                BaseType_t xAlreadyYielded = pdFALSE;
2021:                
2022:                	/* If uxSchedulerSuspended is zero then this function does not match a
2023:                	previous call to vTaskSuspendAll(). */
2024:                	configASSERT( uxSchedulerSuspended );
2025:                
2026:                	/* It is possible that an ISR caused a task to be removed from an event
2027:                	list while the scheduler was suspended.  If this was the case then the
2028:                	removed task will have been added to the xPendingReadyList.  Once the
2029:                	scheduler has been resumed it is safe to move all the pending ready
2030:                	tasks from this list into their appropriate ready list. */
2031:                	taskENTER_CRITICAL();
9D00DE94  0F405144   JAL vTaskEnterCritical
9D00DE98  AFB00010   SW S0, 16(SP)
2032:                	{
2033:                		--uxSchedulerSuspended;
9D00DE9C  8F828074   LW V0, -32652(GP)
9D00DEA0  2442FFFF   ADDIU V0, V0, -1
9D00DEA4  AF828074   SW V0, -32652(GP)
2034:                
2035:                		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
9D00DEA8  8F828074   LW V0, -32652(GP)
9D00DEAC  1440003A   BNE V0, ZERO, 0x9D00DF98
9D00DEB0  00008021   ADDU S0, ZERO, ZERO
2036:                		{
2037:                			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
9D00DEB4  8F82809C   LW V0, -32612(GP)
9D00DEB8  10400037   BEQ V0, ZERO, 0x9D00DF98
9D00DEBC  3C12A000   LUI S2, -24576
2038:                			{
2039:                				/* Move any readied tasks from the pending list into the
2040:                				appropriate ready list. */
2041:                				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
9D00DF30  8E420E94   LW V0, 3732(S2)
9D00DF34  1440FFE6   BNE V0, ZERO, 0x9D00DED0
9D00DF38  26420E94   ADDIU V0, S2, 3732
2042:                				{
2043:                					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
9D00DED0  8C42000C   LW V0, 12(V0)
9D00DED4  8C50000C   LW S0, 12(V0)
2044:                					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
9D00DED8  0F4051D3   JAL uxListRemove
9D00DEDC  26040018   ADDIU A0, S0, 24
2045:                					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
9D00DEE0  26110004   ADDIU S1, S0, 4
9D00DEE4  0F4051D3   JAL uxListRemove
9D00DEE8  02202021   ADDU A0, S1, ZERO
2046:                					prvAddTaskToReadyList( pxTCB );
9D00DEC0  24130001   ADDIU S3, ZERO, 1
9D00DEC4  3C14A000   LUI S4, -24576
9D00DEC8  0B4037CC   J 0x9D00DF30
9D00DECC  26940E30   ADDIU S4, S4, 3632
9D00DEEC  8E02002C   LW V0, 44(S0)
9D00DEF0  8F838094   LW V1, -32620(GP)
9D00DEF4  00532004   SLLV A0, S3, V0
9D00DEF8  00831825   OR V1, A0, V1
9D00DEFC  AF838094   SW V1, -32620(GP)
9D00DF00  00022080   SLL A0, V0, 2
9D00DF04  00021100   SLL V0, V0, 4
9D00DF08  00822021   ADDU A0, A0, V0
9D00DF0C  02842021   ADDU A0, S4, A0
9D00DF10  0F405426   JAL vListInsertEnd
9D00DF14  02202821   ADDU A1, S1, ZERO
2047:                
2048:                					/* If the moved task has a priority higher than the current
2049:                					task then a yield must be performed. */
2050:                					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
9D00DF18  8F8280A4   LW V0, -32604(GP)
9D00DF1C  8E03002C   LW V1, 44(S0)
9D00DF20  8C42002C   LW V0, 44(V0)
9D00DF24  0062102B   SLTU V0, V1, V0
9D00DF28  50400001   BEQL V0, ZERO, 0x9D00DF30
9D00DF2C  AF938088   SW S3, -32632(GP)
2051:                					{
2052:                						xYieldPending = pdTRUE;
2053:                					}
2054:                					else
2055:                					{
2056:                						mtCOVERAGE_TEST_MARKER();
2057:                					}
2058:                				}
2059:                
2060:                				if( pxTCB != NULL )
9D00DF3C  12000003   BEQ S0, ZERO, 0x9D00DF4C
9D00DF40  00000000   NOP
2061:                				{
2062:                					/* A task was unblocked while the scheduler was suspended,
2063:                					which may have prevented the next unblock time from being
2064:                					re-calculated, in which case re-calculate it now.  Mainly
2065:                					important for low power tickless implementations, where
2066:                					this can prevent an unnecessary exit from low power
2067:                					state. */
2068:                					prvResetNextTaskUnblockTime();
9D00DF44  0F405347   JAL prvResetNextTaskUnblockTime
9D00DF48  00000000   NOP
2069:                				}
2070:                
2071:                				/* If any ticks occurred while the scheduler was suspended then
2072:                				they should be processed now.  This ensures the tick count does
2073:                				not	slip, and that any delayed tasks are resumed at the correct
2074:                				time. */
2075:                				{
2076:                					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
9D00DF4C  8F90808C   LW S0, -32628(GP)
2077:                
2078:                					if( uxPendedCounts > ( UBaseType_t ) 0U )
9D00DF50  12000009   BEQ S0, ZERO, 0x9D00DF78
9D00DF54  24110001   ADDIU S1, ZERO, 1
2079:                					{
2080:                						do
2081:                						{
2082:                							if( xTaskIncrementTick() != pdFALSE )
9D00DF58  0F403087   JAL xTaskIncrementTick
9D00DF5C  00000000   NOP
9D00DF60  54400001   BNEL V0, ZERO, 0x9D00DF68
9D00DF64  AF918088   SW S1, -32632(GP)
2083:                							{
2084:                								xYieldPending = pdTRUE;
2085:                							}
2086:                							else
2087:                							{
2088:                								mtCOVERAGE_TEST_MARKER();
2089:                							}
2090:                							--uxPendedCounts;
9D00DF68  2610FFFF   ADDIU S0, S0, -1
2091:                						} while( uxPendedCounts > ( UBaseType_t ) 0U );
9D00DF6C  1600FFFA   BNE S0, ZERO, 0x9D00DF58
9D00DF70  00000000   NOP
2092:                
2093:                						uxPendedTicks = 0;
9D00DF74  AF80808C   SW ZERO, -32628(GP)
2094:                					}
2095:                					else
2096:                					{
2097:                						mtCOVERAGE_TEST_MARKER();
2098:                					}
2099:                				}
2100:                
2101:                				if( xYieldPending != pdFALSE )
9D00DF78  8F828088   LW V0, -32632(GP)
9D00DF7C  10400006   BEQ V0, ZERO, 0x9D00DF98
9D00DF80  00008021   ADDU S0, ZERO, ZERO
2102:                				{
2103:                					#if( configUSE_PREEMPTION != 0 )
2104:                					{
2105:                						xAlreadyYielded = pdTRUE;
9D00DF94  24100001   ADDIU S0, ZERO, 1
2106:                					}
2107:                					#endif
2108:                					taskYIELD_IF_USING_PREEMPTION();
9D00DF84  40026800   MFC0 V0, Cause
9D00DF88  34420100   ORI V0, V0, 256
9D00DF8C  40826800   MTC0 V0, Cause
9D00DF90  000000C0   EHB
2109:                				}
2110:                				else
2111:                				{
2112:                					mtCOVERAGE_TEST_MARKER();
2113:                				}
2114:                			}
2115:                		}
2116:                		else
2117:                		{
2118:                			mtCOVERAGE_TEST_MARKER();
2119:                		}
2120:                	}
2121:                	taskEXIT_CRITICAL();
9D00DF98  0F404EA8   JAL vTaskExitCritical
9D00DF9C  00000000   NOP
2122:                
2123:                	return xAlreadyYielded;
2124:                }
9D00DFA0  02001021   ADDU V0, S0, ZERO
9D00DFA4  8FBF0024   LW RA, 36(SP)
9D00DFA8  8FB40020   LW S4, 32(SP)
9D00DFAC  8FB3001C   LW S3, 28(SP)
9D00DFB0  8FB20018   LW S2, 24(SP)
9D00DFB4  8FB10014   LW S1, 20(SP)
9D00DFB8  8FB00010   LW S0, 16(SP)
9D00DFBC  03E00008   JR RA
9D00DFC0  27BD0028   ADDIU SP, SP, 40
2125:                /*-----------------------------------------------------------*/
2126:                
2127:                TickType_t xTaskGetTickCount( void )
2128:                {
2129:                TickType_t xTicks;
2130:                
2131:                	/* Critical section required if running on a 16 bit processor. */
2132:                	portTICK_TYPE_ENTER_CRITICAL();
2133:                	{
2134:                		xTicks = xTickCount;
9D0159CC  8F828098   LW V0, -32616(GP)
2135:                	}
2136:                	portTICK_TYPE_EXIT_CRITICAL();
2137:                
2138:                	return xTicks;
2139:                }
9D0159D0  03E00008   JR RA
9D0159D4  00000000   NOP
2140:                /*-----------------------------------------------------------*/
2141:                
2142:                TickType_t xTaskGetTickCountFromISR( void )
2143:                {
2144:                TickType_t xReturn;
2145:                UBaseType_t uxSavedInterruptStatus;
2146:                
2147:                	/* RTOS ports that support interrupt nesting have the concept of a maximum
2148:                	system call (or maximum API call) interrupt priority.  Interrupts that are
2149:                	above the maximum system call priority are kept permanently enabled, even
2150:                	when the RTOS kernel is in a critical section, but cannot make any calls to
2151:                	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
2152:                	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
2153:                	failure if a FreeRTOS API function is called from an interrupt that has been
2154:                	assigned a priority above the configured maximum system call priority.
2155:                	Only FreeRTOS functions that end in FromISR can be called from interrupts
2156:                	that have been assigned a priority at or (logically) below the maximum
2157:                	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
2158:                	safe API to ensure interrupt entry is as fast and as simple as possible.
2159:                	More information (albeit Cortex-M specific) is provided on the following
2160:                	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
2161:                	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
2162:                
2163:                	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
2164:                	{
2165:                		xReturn = xTickCount;
2166:                	}
2167:                	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
2168:                
2169:                	return xReturn;
2170:                }
2171:                /*-----------------------------------------------------------*/
2172:                
2173:                UBaseType_t uxTaskGetNumberOfTasks( void )
2174:                {
2175:                	/* A critical section is not required because the variables are of type
2176:                	BaseType_t. */
2177:                	return uxCurrentNumberOfTasks;
2178:                }
2179:                /*-----------------------------------------------------------*/
2180:                
2181:                char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
2182:                {
2183:                TCB_t *pxTCB;
2184:                
2185:                	/* If null is passed in here then the name of the calling task is being
2186:                	queried. */
2187:                	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
2188:                	configASSERT( pxTCB );
2189:                	return &( pxTCB->pcTaskName[ 0 ] );
2190:                }
2191:                /*-----------------------------------------------------------*/
2192:                
2193:                #if ( INCLUDE_xTaskGetHandle == 1 )
2194:                
2195:                	static TCB_t *prvSearchForNameWithinSingleList( List_t *pxList, const char pcNameToQuery[] )
2196:                	{
2197:                	TCB_t *pxNextTCB, *pxFirstTCB, *pxReturn = NULL;
2198:                	UBaseType_t x;
2199:                	char cNextChar;
2200:                
2201:                		/* This function is called with the scheduler suspended. */
2202:                
2203:                		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
2204:                		{
2205:                			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
2206:                
2207:                			do
2208:                			{
2209:                				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
2210:                
2211:                				/* Check each character in the name looking for a match or
2212:                				mismatch. */
2213:                				for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
2214:                				{
2215:                					cNextChar = pxNextTCB->pcTaskName[ x ];
2216:                
2217:                					if( cNextChar != pcNameToQuery[ x ] )
2218:                					{
2219:                						/* Characters didn't match. */
2220:                						break;
2221:                					}
2222:                					else if( cNextChar == 0x00 )
2223:                					{
2224:                						/* Both strings terminated, a match must have been
2225:                						found. */
2226:                						pxReturn = pxNextTCB;
2227:                						break;
2228:                					}
2229:                					else
2230:                					{
2231:                						mtCOVERAGE_TEST_MARKER();
2232:                					}
2233:                				}
2234:                
2235:                				if( pxReturn != NULL )
2236:                				{
2237:                					/* The handle has been found. */
2238:                					break;
2239:                				}
2240:                
2241:                			} while( pxNextTCB != pxFirstTCB );
2242:                		}
2243:                		else
2244:                		{
2245:                			mtCOVERAGE_TEST_MARKER();
2246:                		}
2247:                
2248:                		return pxReturn;
2249:                	}
2250:                
2251:                #endif /* INCLUDE_xTaskGetHandle */
2252:                /*-----------------------------------------------------------*/
2253:                
2254:                #if ( INCLUDE_xTaskGetHandle == 1 )
2255:                
2256:                	TaskHandle_t xTaskGetHandle( const char *pcNameToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
2257:                	{
2258:                	UBaseType_t uxQueue = configMAX_PRIORITIES;
2259:                	TCB_t* pxTCB;
2260:                
2261:                		/* Task names will be truncated to configMAX_TASK_NAME_LEN - 1 bytes. */
2262:                		configASSERT( strlen( pcNameToQuery ) < configMAX_TASK_NAME_LEN );
2263:                
2264:                		vTaskSuspendAll();
2265:                		{
2266:                			/* Search the ready lists. */
2267:                			do
2268:                			{
2269:                				uxQueue--;
2270:                				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) &( pxReadyTasksLists[ uxQueue ] ), pcNameToQuery );
2271:                
2272:                				if( pxTCB != NULL )
2273:                				{
2274:                					/* Found the handle. */
2275:                					break;
2276:                				}
2277:                
2278:                			} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
2279:                
2280:                			/* Search the delayed lists. */
2281:                			if( pxTCB == NULL )
2282:                			{
2283:                				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) pxDelayedTaskList, pcNameToQuery );
2284:                			}
2285:                
2286:                			if( pxTCB == NULL )
2287:                			{
2288:                				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) pxOverflowDelayedTaskList, pcNameToQuery );
2289:                			}
2290:                
2291:                			#if ( INCLUDE_vTaskSuspend == 1 )
2292:                			{
2293:                				if( pxTCB == NULL )
2294:                				{
2295:                					/* Search the suspended list. */
2296:                					pxTCB = prvSearchForNameWithinSingleList( &xSuspendedTaskList, pcNameToQuery );
2297:                				}
2298:                			}
2299:                			#endif
2300:                
2301:                			#if( INCLUDE_vTaskDelete == 1 )
2302:                			{
2303:                				if( pxTCB == NULL )
2304:                				{
2305:                					/* Search the deleted list. */
2306:                					pxTCB = prvSearchForNameWithinSingleList( &xTasksWaitingTermination, pcNameToQuery );
2307:                				}
2308:                			}
2309:                			#endif
2310:                		}
2311:                		( void ) xTaskResumeAll();
2312:                
2313:                		return ( TaskHandle_t ) pxTCB;
2314:                	}
2315:                
2316:                #endif /* INCLUDE_xTaskGetHandle */
2317:                /*-----------------------------------------------------------*/
2318:                
2319:                #if ( configUSE_TRACE_FACILITY == 1 )
2320:                
2321:                	UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime )
2322:                	{
2323:                	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
2324:                
2325:                		vTaskSuspendAll();
2326:                		{
2327:                			/* Is there a space in the array for each task in the system? */
2328:                			if( uxArraySize >= uxCurrentNumberOfTasks )
2329:                			{
2330:                				/* Fill in an TaskStatus_t structure with information on each
2331:                				task in the Ready state. */
2332:                				do
2333:                				{
2334:                					uxQueue--;
2335:                					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists[ uxQueue ] ), eReady );
2336:                
2337:                				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
2338:                
2339:                				/* Fill in an TaskStatus_t structure with information on each
2340:                				task in the Blocked state. */
2341:                				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayedTaskList, eBlocked );
2342:                				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverflowDelayedTaskList, eBlocked );
2343:                
2344:                				#if( INCLUDE_vTaskDelete == 1 )
2345:                				{
2346:                					/* Fill in an TaskStatus_t structure with information on
2347:                					each task that has been deleted but not yet cleaned up. */
2348:                					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermination, eDeleted );
2349:                				}
2350:                				#endif
2351:                
2352:                				#if ( INCLUDE_vTaskSuspend == 1 )
2353:                				{
2354:                					/* Fill in an TaskStatus_t structure with information on
2355:                					each task in the Suspended state. */
2356:                					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList, eSuspended );
2357:                				}
2358:                				#endif
2359:                
2360:                				#if ( configGENERATE_RUN_TIME_STATS == 1)
2361:                				{
2362:                					if( pulTotalRunTime != NULL )
2363:                					{
2364:                						#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
2365:                							portALT_GET_RUN_TIME_COUNTER_VALUE( ( *pulTotalRunTime ) );
2366:                						#else
2367:                							*pulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
2368:                						#endif
2369:                					}
2370:                				}
2371:                				#else
2372:                				{
2373:                					if( pulTotalRunTime != NULL )
2374:                					{
2375:                						*pulTotalRunTime = 0;
2376:                					}
2377:                				}
2378:                				#endif
2379:                			}
2380:                			else
2381:                			{
2382:                				mtCOVERAGE_TEST_MARKER();
2383:                			}
2384:                		}
2385:                		( void ) xTaskResumeAll();
2386:                
2387:                		return uxTask;
2388:                	}
2389:                
2390:                #endif /* configUSE_TRACE_FACILITY */
2391:                /*----------------------------------------------------------*/
2392:                
2393:                #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
2394:                
2395:                	TaskHandle_t xTaskGetIdleTaskHandle( void )
2396:                	{
2397:                		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
2398:                		started, then xIdleTaskHandle will be NULL. */
2399:                		configASSERT( ( xIdleTaskHandle != NULL ) );
2400:                		return xIdleTaskHandle;
2401:                	}
2402:                
2403:                #endif /* INCLUDE_xTaskGetIdleTaskHandle */
2404:                /*----------------------------------------------------------*/
2405:                
2406:                /* This conditional compilation should use inequality to 0, not equality to 1.
2407:                This is to ensure vTaskStepTick() is available when user defined low power mode
2408:                implementations require configUSE_TICKLESS_IDLE to be set to a value other than
2409:                1. */
2410:                #if ( configUSE_TICKLESS_IDLE != 0 )
2411:                
2412:                	void vTaskStepTick( const TickType_t xTicksToJump )
2413:                	{
2414:                		/* Correct the tick count value after a period during which the tick
2415:                		was suppressed.  Note this does *not* call the tick hook function for
2416:                		each stepped tick. */
2417:                		configASSERT( ( xTickCount + xTicksToJump ) <= xNextTaskUnblockTime );
2418:                		xTickCount += xTicksToJump;
2419:                		traceINCREASE_TICK_COUNT( xTicksToJump );
2420:                	}
2421:                
2422:                #endif /* configUSE_TICKLESS_IDLE */
2423:                /*----------------------------------------------------------*/
2424:                
2425:                #if ( INCLUDE_xTaskAbortDelay == 1 )
2426:                
2427:                	BaseType_t xTaskAbortDelay( TaskHandle_t xTask )
2428:                	{
2429:                	TCB_t *pxTCB = ( TCB_t * ) xTask;
2430:                	BaseType_t xReturn = pdFALSE;
2431:                
2432:                		configASSERT( pxTCB );
2433:                
2434:                		vTaskSuspendAll();
2435:                		{
2436:                			/* A task can only be prematurely removed from the Blocked state if
2437:                			it is actually in the Blocked state. */
2438:                			if( eTaskGetState( xTask ) == eBlocked )
2439:                			{
2440:                				/* Remove the reference to the task from the blocked list.  An
2441:                				interrupt won't touch the xStateListItem because the
2442:                				scheduler is suspended. */
2443:                				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
2444:                
2445:                				/* Is the task waiting on an event also?  If so remove it from
2446:                				the event list too.  Interrupts can touch the event list item,
2447:                				even though the scheduler is suspended, so a critical section
2448:                				is used. */
2449:                				taskENTER_CRITICAL();
2450:                				{
2451:                					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
2452:                					{
2453:                						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
2454:                						pxTCB->ucDelayAborted = pdTRUE;
2455:                					}
2456:                					else
2457:                					{
2458:                						mtCOVERAGE_TEST_MARKER();
2459:                					}
2460:                				}
2461:                				taskEXIT_CRITICAL();
2462:                
2463:                				/* Place the unblocked task into the appropriate ready list. */
2464:                				prvAddTaskToReadyList( pxTCB );
2465:                
2466:                				/* A task being unblocked cannot cause an immediate context
2467:                				switch if preemption is turned off. */
2468:                				#if (  configUSE_PREEMPTION == 1 )
2469:                				{
2470:                					/* Preemption is on, but a context switch should only be
2471:                					performed if the unblocked task has a priority that is
2472:                					equal to or higher than the currently executing task. */
2473:                					if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
2474:                					{
2475:                						/* Pend the yield to be performed when the scheduler
2476:                						is unsuspended. */
2477:                						xYieldPending = pdTRUE;
2478:                					}
2479:                					else
2480:                					{
2481:                						mtCOVERAGE_TEST_MARKER();
2482:                					}
2483:                				}
2484:                				#endif /* configUSE_PREEMPTION */
2485:                			}
2486:                			else
2487:                			{
2488:                				mtCOVERAGE_TEST_MARKER();
2489:                			}
2490:                		}
2491:                		xTaskResumeAll();
2492:                
2493:                		return xReturn;
2494:                	}
2495:                
2496:                #endif /* INCLUDE_xTaskAbortDelay */
2497:                /*----------------------------------------------------------*/
2498:                
2499:                BaseType_t xTaskIncrementTick( void )
2500:                {
9D00C21C  27BDFFD0   ADDIU SP, SP, -48
9D00C220  AFBF002C   SW RA, 44(SP)
9D00C224  AFB50028   SW S5, 40(SP)
9D00C228  AFB40024   SW S4, 36(SP)
9D00C22C  AFB30020   SW S3, 32(SP)
9D00C230  AFB2001C   SW S2, 28(SP)
9D00C234  AFB10018   SW S1, 24(SP)
9D00C238  AFB00014   SW S0, 20(SP)
2501:                TCB_t * pxTCB;
2502:                TickType_t xItemValue;
2503:                BaseType_t xSwitchRequired = pdFALSE;
9D00C380  00008821   ADDU S1, ZERO, ZERO
2504:                
2505:                	/* Called by the portable layer each time a tick interrupt occurs.
2506:                	Increments the tick then checks to see if the new tick value will cause any
2507:                	tasks to be unblocked. */
2508:                	traceTASK_INCREMENT_TICK( xTickCount );
2509:                	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
9D00C23C  8F828074   LW V0, -32652(GP)
9D00C240  1440004C   BNE V0, ZERO, 0x9D00C374
9D00C244  00000000   NOP
2510:                	{
2511:                		/* Minor optimisation.  The tick count cannot change in this
2512:                		block. */
2513:                		const TickType_t xConstTickCount = xTickCount + 1;
9D00C248  8F948098   LW S4, -32616(GP)
9D00C24C  26940001   ADDIU S4, S4, 1
2514:                
2515:                		/* Increment the RTOS tick, switching the delayed and overflowed
2516:                		delayed lists if it wraps to 0. */
2517:                		xTickCount = xConstTickCount;
9D00C250  AF948098   SW S4, -32616(GP)
2518:                
2519:                		if( xConstTickCount == ( TickType_t ) 0U )
9D00C254  1680000A   BNE S4, ZERO, 0x9D00C280
9D00C258  00000000   NOP
2520:                		{
2521:                			taskSWITCH_DELAYED_LISTS();
9D00C25C  8F828164   LW V0, -32412(GP)
9D00C260  8F838168   LW V1, -32408(GP)
9D00C264  AF838164   SW V1, -32412(GP)
9D00C268  AF828168   SW V0, -32408(GP)
9D00C26C  8F828084   LW V0, -32636(GP)
9D00C270  24420001   ADDIU V0, V0, 1
9D00C274  AF828084   SW V0, -32636(GP)
9D00C278  0F405347   JAL prvResetNextTaskUnblockTime
9D00C27C  00000000   NOP
2522:                		}
2523:                		else
2524:                		{
2525:                			mtCOVERAGE_TEST_MARKER();
2526:                		}
2527:                
2528:                		/* See if this tick has made a timeout expire.  Tasks are stored in
2529:                		the	queue in the order of their wake time - meaning once one task
2530:                		has been found whose block time has not expired there is no need to
2531:                		look any further down the list. */
2532:                		if( xConstTickCount >= xNextTaskUnblockTime )
9D00C280  8F82807C   LW V0, -32644(GP)
9D00C284  0282102B   SLTU V0, S4, V0
9D00C288  1440002D   BNE V0, ZERO, 0x9D00C340
9D00C28C  00008821   ADDU S1, ZERO, ZERO
2533:                		{
2534:                			for( ;; )
2535:                			{
2536:                				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
9D00C29C  8F828164   LW V0, -32412(GP)
9D00C2A0  8C420000   LW V0, 0(V0)
9D00C2A4  14400004   BNE V0, ZERO, 0x9D00C2B8
9D00C2A8  2402FFFF   ADDIU V0, ZERO, -1
2537:                				{
2538:                					/* The delayed list is empty.  Set xNextTaskUnblockTime
2539:                					to the maximum possible value so it is extremely
2540:                					unlikely that the
2541:                					if( xTickCount >= xNextTaskUnblockTime ) test will pass
2542:                					next time through. */
2543:                					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
9D00C2AC  AF82807C   SW V0, -32644(GP)
2544:                					break;
9D00C2B0  0B4030D0   J 0x9D00C340
9D00C2B4  00000000   NOP
2545:                				}
2546:                				else
2547:                				{
2548:                					/* The delayed list is not empty, get the value of the
2549:                					item at the head of the delayed list.  This is the time
2550:                					at which the task at the head of the delayed list must
2551:                					be removed from the Blocked state. */
2552:                					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
9D00C2B8  8F828164   LW V0, -32412(GP)
9D00C2BC  8C42000C   LW V0, 12(V0)
9D00C2C0  8C50000C   LW S0, 12(V0)
2553:                					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
9D00C2C4  8E020004   LW V0, 4(S0)
2554:                
2555:                					if( xConstTickCount < xItemValue )
9D00C2C8  0282182B   SLTU V1, S4, V0
9D00C2CC  10600004   BEQ V1, ZERO, 0x9D00C2E0
9D00C2D0  26120004   ADDIU S2, S0, 4
2556:                					{
2557:                						/* It is not time to unblock this item yet, but the
2558:                						item value is the time at which the task at the head
2559:                						of the blocked list must be removed from the Blocked
2560:                						state -	so record the item value in
2561:                						xNextTaskUnblockTime. */
2562:                						xNextTaskUnblockTime = xItemValue;
9D00C2D4  AF82807C   SW V0, -32644(GP)
2563:                						break;
9D00C2D8  0B4030D0   J 0x9D00C340
9D00C2DC  00000000   NOP
2564:                					}
2565:                					else
2566:                					{
2567:                						mtCOVERAGE_TEST_MARKER();
2568:                					}
2569:                
2570:                					/* It is time to remove the item from the Blocked state. */
2571:                					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
9D00C2E0  0F4051D3   JAL uxListRemove
9D00C2E4  02402021   ADDU A0, S2, ZERO
2572:                
2573:                					/* Is the task waiting on an event also?  If so remove
2574:                					it from the event list. */
2575:                					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
9D00C2E8  8E020028   LW V0, 40(S0)
9D00C2EC  50400004   BEQL V0, ZERO, 0x9D00C300
9D00C2F0  8E03002C   LW V1, 44(S0)
2576:                					{
2577:                						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
9D00C2F4  0F4051D3   JAL uxListRemove
9D00C2F8  26040018   ADDIU A0, S0, 24
2578:                					}
2579:                					else
2580:                					{
2581:                						mtCOVERAGE_TEST_MARKER();
2582:                					}
2583:                
2584:                					/* Place the unblocked task into the appropriate ready
2585:                					list. */
2586:                					prvAddTaskToReadyList( pxTCB );
9D00C290  24130001   ADDIU S3, ZERO, 1
9D00C294  3C15A000   LUI S5, -24576
9D00C298  26B50E30   ADDIU S5, S5, 3632
9D00C2FC  8E03002C   LW V1, 44(S0)
9D00C300  8F828094   LW V0, -32620(GP)
9D00C304  00732004   SLLV A0, S3, V1
9D00C308  00821025   OR V0, A0, V0
9D00C30C  AF828094   SW V0, -32620(GP)
9D00C310  00032080   SLL A0, V1, 2
9D00C314  00031900   SLL V1, V1, 4
9D00C318  00832021   ADDU A0, A0, V1
9D00C31C  02A42021   ADDU A0, S5, A0
9D00C320  0F405426   JAL vListInsertEnd
9D00C324  02402821   ADDU A1, S2, ZERO
2587:                
2588:                					/* A task being unblocked cannot cause an immediate
2589:                					context switch if preemption is turned off. */
2590:                					#if (  configUSE_PREEMPTION == 1 )
2591:                					{
2592:                						/* Preemption is on, but a context switch should
2593:                						only be performed if the unblocked task has a
2594:                						priority that is equal to or higher than the
2595:                						currently executing task. */
2596:                						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
9D00C328  8F8280A4   LW V0, -32604(GP)
9D00C32C  8E03002C   LW V1, 44(S0)
9D00C330  8C42002C   LW V0, 44(V0)
9D00C334  0062102B   SLTU V0, V1, V0
9D00C338  0B4030A7   J 0x9D00C29C
9D00C33C  0262880A   MOVZ S1, S3, V0
2597:                						{
2598:                							xSwitchRequired = pdTRUE;
2599:                						}
2600:                						else
2601:                						{
2602:                							mtCOVERAGE_TEST_MARKER();
2603:                						}
2604:                					}
2605:                					#endif /* configUSE_PREEMPTION */
2606:                				}
2607:                			}
2608:                		}
2609:                
2610:                		/* Tasks of equal priority to the currently running task will share
2611:                		processing time (time slice) if preemption is on, and the application
2612:                		writer has not explicitly turned time slicing off. */
2613:                		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
2614:                		{
2615:                			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
9D00C340  8F8280A4   LW V0, -32604(GP)
9D00C344  8C42002C   LW V0, 44(V0)
9D00C348  00021880   SLL V1, V0, 2
9D00C34C  00021100   SLL V0, V0, 4
9D00C350  00621021   ADDU V0, V1, V0
9D00C354  3C03A000   LUI V1, -24576
9D00C358  24630E30   ADDIU V1, V1, 3632
9D00C35C  00431021   ADDU V0, V0, V1
9D00C360  8C430000   LW V1, 0(V0)
9D00C364  2C630002   SLTIU V1, V1, 2
2616:                			{
2617:                				xSwitchRequired = pdTRUE;
9D00C368  24020001   ADDIU V0, ZERO, 1
9D00C36C  0B4030E1   J 0x9D00C384
9D00C370  0043880A   MOVZ S1, V0, V1
2618:                			}
2619:                			else
2620:                			{
2621:                				mtCOVERAGE_TEST_MARKER();
2622:                			}
2623:                		}
2624:                		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */
2625:                
2626:                		#if ( configUSE_TICK_HOOK == 1 )
2627:                		{
2628:                			/* Guard against the tick hook being called when the pended tick
2629:                			count is being unwound (when the scheduler is being unlocked). */
2630:                			if( uxPendedTicks == ( UBaseType_t ) 0U )
2631:                			{
2632:                				vApplicationTickHook();
2633:                			}
2634:                			else
2635:                			{
2636:                				mtCOVERAGE_TEST_MARKER();
2637:                			}
2638:                		}
2639:                		#endif /* configUSE_TICK_HOOK */
2640:                	}
2641:                	else
2642:                	{
2643:                		++uxPendedTicks;
9D00C374  8F82808C   LW V0, -32628(GP)
9D00C378  24420001   ADDIU V0, V0, 1
9D00C37C  AF82808C   SW V0, -32628(GP)
2644:                
2645:                		/* The tick hook gets called at regular intervals, even if the
2646:                		scheduler is locked. */
2647:                		#if ( configUSE_TICK_HOOK == 1 )
2648:                		{
2649:                			vApplicationTickHook();
2650:                		}
2651:                		#endif
2652:                	}
2653:                
2654:                	#if ( configUSE_PREEMPTION == 1 )
2655:                	{
2656:                		if( xYieldPending != pdFALSE )
9D00C384  8F838088   LW V1, -32632(GP)
2657:                		{
2658:                			xSwitchRequired = pdTRUE;
2659:                		}
2660:                		else
2661:                		{
2662:                			mtCOVERAGE_TEST_MARKER();
2663:                		}
2664:                	}
2665:                	#endif /* configUSE_PREEMPTION */
2666:                
2667:                	return xSwitchRequired;
2668:                }
9D00C388  24020001   ADDIU V0, ZERO, 1
9D00C38C  0223100A   MOVZ V0, S1, V1
9D00C390  8FBF002C   LW RA, 44(SP)
9D00C394  8FB50028   LW S5, 40(SP)
9D00C398  8FB40024   LW S4, 36(SP)
9D00C39C  8FB30020   LW S3, 32(SP)
9D00C3A0  8FB2001C   LW S2, 28(SP)
9D00C3A4  8FB10018   LW S1, 24(SP)
9D00C3A8  8FB00014   LW S0, 20(SP)
9D00C3AC  03E00008   JR RA
9D00C3B0  27BD0030   ADDIU SP, SP, 48
2669:                /*-----------------------------------------------------------*/
2670:                
2671:                #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2672:                
2673:                	void vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction )
2674:                	{
2675:                	TCB_t *xTCB;
2676:                
2677:                		/* If xTask is NULL then it is the task hook of the calling task that is
2678:                		getting set. */
2679:                		if( xTask == NULL )
2680:                		{
2681:                			xTCB = ( TCB_t * ) pxCurrentTCB;
2682:                		}
2683:                		else
2684:                		{
2685:                			xTCB = ( TCB_t * ) xTask;
2686:                		}
2687:                
2688:                		/* Save the hook function in the TCB.  A critical section is required as
2689:                		the value can be accessed from an interrupt. */
2690:                		taskENTER_CRITICAL();
2691:                			xTCB->pxTaskTag = pxHookFunction;
2692:                		taskEXIT_CRITICAL();
2693:                	}
2694:                
2695:                #endif /* configUSE_APPLICATION_TASK_TAG */
2696:                /*-----------------------------------------------------------*/
2697:                
2698:                #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2699:                
2700:                	TaskHookFunction_t xTaskGetApplicationTaskTag( TaskHandle_t xTask )
2701:                	{
2702:                	TCB_t *xTCB;
2703:                	TaskHookFunction_t xReturn;
2704:                
2705:                		/* If xTask is NULL then we are setting our own task hook. */
2706:                		if( xTask == NULL )
2707:                		{
2708:                			xTCB = ( TCB_t * ) pxCurrentTCB;
2709:                		}
2710:                		else
2711:                		{
2712:                			xTCB = ( TCB_t * ) xTask;
2713:                		}
2714:                
2715:                		/* Save the hook function in the TCB.  A critical section is required as
2716:                		the value can be accessed from an interrupt. */
2717:                		taskENTER_CRITICAL();
2718:                		{
2719:                			xReturn = xTCB->pxTaskTag;
2720:                		}
2721:                		taskEXIT_CRITICAL();
2722:                
2723:                		return xReturn;
2724:                	}
2725:                
2726:                #endif /* configUSE_APPLICATION_TASK_TAG */
2727:                /*-----------------------------------------------------------*/
2728:                
2729:                #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2730:                
2731:                	BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter )
2732:                	{
2733:                	TCB_t *xTCB;
2734:                	BaseType_t xReturn;
2735:                
2736:                		/* If xTask is NULL then we are calling our own task hook. */
2737:                		if( xTask == NULL )
2738:                		{
2739:                			xTCB = ( TCB_t * ) pxCurrentTCB;
2740:                		}
2741:                		else
2742:                		{
2743:                			xTCB = ( TCB_t * ) xTask;
2744:                		}
2745:                
2746:                		if( xTCB->pxTaskTag != NULL )
2747:                		{
2748:                			xReturn = xTCB->pxTaskTag( pvParameter );
2749:                		}
2750:                		else
2751:                		{
2752:                			xReturn = pdFAIL;
2753:                		}
2754:                
2755:                		return xReturn;
2756:                	}
2757:                
2758:                #endif /* configUSE_APPLICATION_TASK_TAG */
2759:                /*-----------------------------------------------------------*/
2760:                
2761:                void vTaskSwitchContext( void )
2762:                {
9D010A18  27BDFFE8   ADDIU SP, SP, -24
9D010A1C  AFBF0014   SW RA, 20(SP)
2763:                	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
9D010A20  8F828074   LW V0, -32652(GP)
9D010A24  10400004   BEQ V0, ZERO, 0x9D010A38
9D010A28  24020001   ADDIU V0, ZERO, 1
2764:                	{
2765:                		/* The scheduler is currently suspended - do not allow a context
2766:                		switch. */
2767:                		xYieldPending = pdTRUE;
9D010A2C  AF828088   SW V0, -32632(GP)
9D010A30  0B4042BC   J 0x9D010AF0
9D010A34  8FBF0014   LW RA, 20(SP)
2768:                	}
2769:                	else
2770:                	{
2771:                		xYieldPending = pdFALSE;
9D010A38  AF808088   SW ZERO, -32632(GP)
2772:                		traceTASK_SWITCHED_OUT();
2773:                
2774:                		#if ( configGENERATE_RUN_TIME_STATS == 1 )
2775:                		{
2776:                				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
2777:                					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
2778:                				#else
2779:                					ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
2780:                				#endif
2781:                
2782:                				/* Add the amount of time the task has been running to the
2783:                				accumulated time so far.  The time the task started running was
2784:                				stored in ulTaskSwitchedInTime.  Note that there is no overflow
2785:                				protection here so count values are only valid until the timer
2786:                				overflows.  The guard against negative values is to protect
2787:                				against suspect run time stat counter implementations - which
2788:                				are provided by the application, not the kernel. */
2789:                				if( ulTotalRunTime > ulTaskSwitchedInTime )
2790:                				{
2791:                					pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
2792:                				}
2793:                				else
2794:                				{
2795:                					mtCOVERAGE_TEST_MARKER();
2796:                				}
2797:                				ulTaskSwitchedInTime = ulTotalRunTime;
2798:                		}
2799:                		#endif /* configGENERATE_RUN_TIME_STATS */
2800:                
2801:                		/* Check for stack overflow, if configured. */
2802:                		taskCHECK_FOR_STACK_OVERFLOW();
9D010A3C  8F8280A4   LW V0, -32604(GP)
9D010A40  8C420030   LW V0, 48(V0)
9D010A44  8C440000   LW A0, 0(V0)
9D010A48  3C03A5A5   LUI V1, -23131
9D010A4C  3463A5A5   ORI V1, V1, -23131
9D010A50  1483000E   BNE A0, V1, 0x9D010A8C
9D010A54  3C03A5A5   LUI V1, -23131
9D010A58  8C440004   LW A0, 4(V0)
9D010A5C  3463A5A5   ORI V1, V1, -23131
9D010A60  1483000A   BNE A0, V1, 0x9D010A8C
9D010A64  3C03A5A5   LUI V1, -23131
9D010A68  8C440008   LW A0, 8(V0)
9D010A6C  3463A5A5   ORI V1, V1, -23131
9D010A70  14830006   BNE A0, V1, 0x9D010A8C
9D010A74  00000000   NOP
9D010A78  8C43000C   LW V1, 12(V0)
9D010A7C  3C02A5A5   LUI V0, -23131
9D010A80  3442A5A5   ORI V0, V0, -23131
9D010A84  10620005   BEQ V1, V0, 0x9D010A9C
9D010A88  00000000   NOP
9D010A8C  8F8480A4   LW A0, -32604(GP)
9D010A90  8F8580A4   LW A1, -32604(GP)
9D010A94  0F405525   JAL vApplicationStackOverflowHook
9D010A98  24A50034   ADDIU A1, A1, 52
2803:                
2804:                		/* Select a new task to run using either the generic C or port
2805:                		optimised asm code. */
2806:                		taskSELECT_HIGHEST_PRIORITY_TASK();
9D010A9C  8F838094   LW V1, -32620(GP)
9D010AA0  70631820   CLZ V1, V1
9D010AA4  2402001F   ADDIU V0, ZERO, 31
9D010AA8  00431823   SUBU V1, V0, V1
9D010AAC  00031080   SLL V0, V1, 2
9D010AB0  00031900   SLL V1, V1, 4
9D010AB4  00431821   ADDU V1, V0, V1
9D010AB8  3C02A000   LUI V0, -24576
9D010ABC  24420E30   ADDIU V0, V0, 3632
9D010AC0  00431021   ADDU V0, V0, V1
9D010AC4  8C430004   LW V1, 4(V0)
9D010AC8  8C630004   LW V1, 4(V1)
9D010ACC  24440008   ADDIU A0, V0, 8
9D010AD0  14640003   BNE V1, A0, 0x9D010AE0
9D010AD4  AC430004   SW V1, 4(V0)
9D010AD8  8C630004   LW V1, 4(V1)
9D010ADC  AC430004   SW V1, 4(V0)
9D010AE0  8C420004   LW V0, 4(V0)
9D010AE4  8C42000C   LW V0, 12(V0)
9D010AE8  AF8280A4   SW V0, -32604(GP)
2807:                		traceTASK_SWITCHED_IN();
2808:                
2809:                		#if ( configUSE_NEWLIB_REENTRANT == 1 )
2810:                		{
2811:                			/* Switch Newlib's _impure_ptr variable to point to the _reent
2812:                			structure specific to this task. */
2813:                			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
2814:                		}
2815:                		#endif /* configUSE_NEWLIB_REENTRANT */
2816:                	}
2817:                }
9D010AEC  8FBF0014   LW RA, 20(SP)
2818:                /*-----------------------------------------------------------*/
2819:                
2820:                void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
2821:                {
9D014D54  27BDFFE8   ADDIU SP, SP, -24
9D014D58  AFBF0014   SW RA, 20(SP)
9D014D5C  AFB00010   SW S0, 16(SP)
9D014D60  00A08021   ADDU S0, A1, ZERO
2822:                	configASSERT( pxEventList );
2823:                
2824:                	/* THIS FUNCTION MUST BE CALLED WITH EITHER INTERRUPTS DISABLED OR THE
2825:                	SCHEDULER SUSPENDED AND THE QUEUE BEING ACCESSED LOCKED. */
2826:                
2827:                	/* Place the event list item of the TCB in the appropriate event list.
2828:                	This is placed in the list in priority order so the highest priority task
2829:                	is the first to be woken by the event.  The queue that contains the event
2830:                	list is locked, preventing simultaneous access from interrupts. */
2831:                	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
9D014D64  8F8580A4   LW A1, -32604(GP)
9D014D68  0F404F07   JAL vListInsert
9D014D6C  24A50018   ADDIU A1, A1, 24
2832:                
2833:                	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
9D014D70  02002021   ADDU A0, S0, ZERO
9D014D74  0F40424D   JAL prvAddCurrentTaskToDelayedList
9D014D78  24050001   ADDIU A1, ZERO, 1
2834:                }
9D014D7C  8FBF0014   LW RA, 20(SP)
2835:                /*-----------------------------------------------------------*/
2836:                
2837:                void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
2838:                {
2839:                	configASSERT( pxEventList );
2840:                
2841:                	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
2842:                	the event groups implementation. */
2843:                	configASSERT( uxSchedulerSuspended != 0 );
2844:                
2845:                	/* Store the item value in the event list item.  It is safe to access the
2846:                	event list item here as interrupts won't access the event list item of a
2847:                	task that is not in the Blocked state. */
2848:                	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
2849:                
2850:                	/* Place the event list item of the TCB at the end of the appropriate event
2851:                	list.  It is safe to access the event list here because it is part of an
2852:                	event group implementation - and interrupts don't access event groups
2853:                	directly (instead they access them indirectly by pending function calls to
2854:                	the task level). */
2855:                	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
2856:                
2857:                	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
2858:                }
2859:                /*-----------------------------------------------------------*/
2860:                
2861:                #if( configUSE_TIMERS == 1 )
2862:                
2863:                	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
2864:                	{
9D014558  27BDFFE0   ADDIU SP, SP, -32
9D01455C  AFBF001C   SW RA, 28(SP)
9D014560  AFB10018   SW S1, 24(SP)
9D014564  AFB00014   SW S0, 20(SP)
9D014568  00A08821   ADDU S1, A1, ZERO
9D01456C  00C08021   ADDU S0, A2, ZERO
2865:                		configASSERT( pxEventList );
2866:                
2867:                		/* This function should not be called by application code hence the
2868:                		'Restricted' in its name.  It is not part of the public API.  It is
2869:                		designed for use by kernel code, and has special calling requirements -
2870:                		it should be called with the scheduler suspended. */
2871:                
2872:                
2873:                		/* Place the event list item of the TCB in the appropriate event list.
2874:                		In this case it is assume that this is the only task that is going to
2875:                		be waiting on this event list, so the faster vListInsertEnd() function
2876:                		can be used in place of vListInsert. */
2877:                		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
9D014570  8F8580A4   LW A1, -32604(GP)
9D014574  0F405426   JAL vListInsertEnd
9D014578  24A50018   ADDIU A1, A1, 24
2878:                
2879:                		/* If the task should block indefinitely then set the block time to a
2880:                		value that will be recognised as an indefinite delay inside the
2881:                		prvAddCurrentTaskToDelayedList() function. */
2882:                		if( xWaitIndefinitely != pdFALSE )
2883:                		{
2884:                			xTicksToWait = portMAX_DELAY;
2885:                		}
2886:                
2887:                		traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
2888:                		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
9D01457C  2404FFFF   ADDIU A0, ZERO, -1
9D014580  0230200A   MOVZ A0, S1, S0
9D014584  0F40424D   JAL prvAddCurrentTaskToDelayedList
9D014588  02002821   ADDU A1, S0, ZERO
2889:                	}
9D01458C  8FBF001C   LW RA, 28(SP)
2890:                
2891:                #endif /* configUSE_TIMERS */
2892:                /*-----------------------------------------------------------*/
2893:                
2894:                BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
2895:                {
9D010F24  27BDFFE0   ADDIU SP, SP, -32
9D010F28  AFBF001C   SW RA, 28(SP)
9D010F2C  AFB10018   SW S1, 24(SP)
9D010F30  AFB00014   SW S0, 20(SP)
2896:                TCB_t *pxUnblockedTCB;
2897:                BaseType_t xReturn;
2898:                
2899:                	/* THIS FUNCTION MUST BE CALLED FROM A CRITICAL SECTION.  It can also be
2900:                	called from a critical section within an ISR. */
2901:                
2902:                	/* The event list is sorted in priority order, so the first in the list can
2903:                	be removed as it is known to be the highest priority.  Remove the TCB from
2904:                	the delayed list, and add it to the ready list.
2905:                
2906:                	If an event is for a queue that is locked then this function will never
2907:                	get called - the lock count on the queue will get modified instead.  This
2908:                	means exclusive access to the event list is guaranteed here.
2909:                
2910:                	This function assumes that a check has already been made to ensure that
2911:                	pxEventList is not empty. */
2912:                	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
9D010F34  8C82000C   LW V0, 12(A0)
9D010F38  8C50000C   LW S0, 12(V0)
2913:                	configASSERT( pxUnblockedTCB );
2914:                	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
9D010F3C  26110018   ADDIU S1, S0, 24
9D010F40  0F4051D3   JAL uxListRemove
9D010F44  02202021   ADDU A0, S1, ZERO
2915:                
2916:                	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
9D010F48  8F828074   LW V0, -32652(GP)
9D010F4C  14400014   BNE V0, ZERO, 0x9D010FA0
9D010F50  3C04A000   LUI A0, -24576
2917:                	{
2918:                		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
9D010F54  26110004   ADDIU S1, S0, 4
9D010F58  0F4051D3   JAL uxListRemove
9D010F5C  02202021   ADDU A0, S1, ZERO
2919:                		prvAddTaskToReadyList( pxUnblockedTCB );
9D010F60  8E02002C   LW V0, 44(S0)
9D010F64  8F848094   LW A0, -32620(GP)
9D010F68  24030001   ADDIU V1, ZERO, 1
9D010F6C  00431804   SLLV V1, V1, V0
9D010F70  00641825   OR V1, V1, A0
9D010F74  AF838094   SW V1, -32620(GP)
9D010F78  00021880   SLL V1, V0, 2
9D010F7C  00021100   SLL V0, V0, 4
9D010F80  00621021   ADDU V0, V1, V0
9D010F84  3C04A000   LUI A0, -24576
9D010F88  24840E30   ADDIU A0, A0, 3632
9D010F8C  00822021   ADDU A0, A0, V0
9D010F90  0F405426   JAL vListInsertEnd
9D010F94  02202821   ADDU A1, S1, ZERO
9D010F98  0B4043EB   J 0x9D010FAC
9D010F9C  00000000   NOP
2920:                	}
2921:                	else
2922:                	{
2923:                		/* The delayed and ready lists cannot be accessed, so hold this task
2924:                		pending until the scheduler is resumed. */
2925:                		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
9D010FA0  24840E94   ADDIU A0, A0, 3732
9D010FA4  0F405426   JAL vListInsertEnd
9D010FA8  02202821   ADDU A1, S1, ZERO
2926:                	}
2927:                
2928:                	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
9D010FAC  8F8280A4   LW V0, -32604(GP)
9D010FB0  8E03002C   LW V1, 44(S0)
9D010FB4  8C42002C   LW V0, 44(V0)
9D010FB8  0043102B   SLTU V0, V0, V1
9D010FBC  10400004   BEQ V0, ZERO, 0x9D010FD0
9D010FC0  00008021   ADDU S0, ZERO, ZERO
2929:                	{
2930:                		/* Return true if the task removed from the event list has a higher
2931:                		priority than the calling task.  This allows the calling task to know if
2932:                		it should force a context switch now. */
2933:                		xReturn = pdTRUE;
9D010FCC  24100001   ADDIU S0, ZERO, 1
2934:                
2935:                		/* Mark that a yield is pending in case the user is not using the
2936:                		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
2937:                		xYieldPending = pdTRUE;
9D010FC4  24020001   ADDIU V0, ZERO, 1
9D010FC8  AF828088   SW V0, -32632(GP)
2938:                	}
2939:                	else
2940:                	{
2941:                		xReturn = pdFALSE;
2942:                	}
2943:                
2944:                	#if( configUSE_TICKLESS_IDLE != 0 )
2945:                	{
2946:                		/* If a task is blocked on a kernel object then xNextTaskUnblockTime
2947:                		might be set to the blocked task's time out time.  If the task is
2948:                		unblocked for a reason other than a timeout xNextTaskUnblockTime is
2949:                		normally left unchanged, because it is automatically reset to a new
2950:                		value when the tick count equals xNextTaskUnblockTime.  However if
2951:                		tickless idling is used it might be more important to enter sleep mode
2952:                		at the earliest possible time - so reset xNextTaskUnblockTime here to
2953:                		ensure it is updated at the earliest possible time. */
2954:                		prvResetNextTaskUnblockTime();
9D010FD0  0F405347   JAL prvResetNextTaskUnblockTime
9D010FD4  00000000   NOP
2955:                	}
2956:                	#endif
2957:                
2958:                	return xReturn;
2959:                }
9D010FD8  02001021   ADDU V0, S0, ZERO
9D010FDC  8FBF001C   LW RA, 28(SP)
9D010FE0  8FB10018   LW S1, 24(SP)
9D010FE4  8FB00014   LW S0, 20(SP)
9D010FE8  03E00008   JR RA
9D010FEC  27BD0020   ADDIU SP, SP, 32
2960:                /*-----------------------------------------------------------*/
2961:                
2962:                BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
2963:                {
2964:                TCB_t *pxUnblockedTCB;
2965:                BaseType_t xReturn;
2966:                
2967:                	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
2968:                	the event flags implementation. */
2969:                	configASSERT( uxSchedulerSuspended != pdFALSE );
2970:                
2971:                	/* Store the new item value in the event list. */
2972:                	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
2973:                
2974:                	/* Remove the event list form the event flag.  Interrupts do not access
2975:                	event flags. */
2976:                	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
2977:                	configASSERT( pxUnblockedTCB );
2978:                	( void ) uxListRemove( pxEventListItem );
2979:                
2980:                	/* Remove the task from the delayed list and add it to the ready list.  The
2981:                	scheduler is suspended so interrupts will not be accessing the ready
2982:                	lists. */
2983:                	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
2984:                	prvAddTaskToReadyList( pxUnblockedTCB );
2985:                
2986:                	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
2987:                	{
2988:                		/* Return true if the task removed from the event list has
2989:                		a higher priority than the calling task.  This allows
2990:                		the calling task to know if it should force a context
2991:                		switch now. */
2992:                		xReturn = pdTRUE;
2993:                
2994:                		/* Mark that a yield is pending in case the user is not using the
2995:                		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
2996:                		xYieldPending = pdTRUE;
2997:                	}
2998:                	else
2999:                	{
3000:                		xReturn = pdFALSE;
3001:                	}
3002:                
3003:                	return xReturn;
3004:                }
3005:                /*-----------------------------------------------------------*/
3006:                
3007:                void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
3008:                {
3009:                	configASSERT( pxTimeOut );
3010:                	pxTimeOut->xOverflowCount = xNumOfOverflows;
9D0157D4  8F828084   LW V0, -32636(GP)
9D0157D8  AC820000   SW V0, 0(A0)
3011:                	pxTimeOut->xTimeOnEntering = xTickCount;
9D0157DC  8F828098   LW V0, -32616(GP)
9D0157E0  03E00008   JR RA
9D0157E4  AC820004   SW V0, 4(A0)
3012:                }
3013:                /*-----------------------------------------------------------*/
3014:                
3015:                BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
3016:                {
9D011E60  27BDFFE0   ADDIU SP, SP, -32
9D011E64  AFBF001C   SW RA, 28(SP)
9D011E68  AFB20018   SW S2, 24(SP)
9D011E6C  AFB10014   SW S1, 20(SP)
9D011E70  AFB00010   SW S0, 16(SP)
9D011E74  00808021   ADDU S0, A0, ZERO
3017:                BaseType_t xReturn;
3018:                
3019:                	configASSERT( pxTimeOut );
3020:                	configASSERT( pxTicksToWait );
3021:                
3022:                	taskENTER_CRITICAL();
9D011E78  0F405144   JAL vTaskEnterCritical
9D011E7C  00A09021   ADDU S2, A1, ZERO
3023:                	{
3024:                		/* Minor optimisation.  The tick count cannot change in this block. */
3025:                		const TickType_t xConstTickCount = xTickCount;
9D011E80  8F828098   LW V0, -32616(GP)
3026:                
3027:                		#if( INCLUDE_xTaskAbortDelay == 1 )
3028:                			if( pxCurrentTCB->ucDelayAborted != pdFALSE )
3029:                			{
3030:                				/* The delay was aborted, which is not the same as a time out,
3031:                				but has the same result. */
3032:                				pxCurrentTCB->ucDelayAborted = pdFALSE;
3033:                				xReturn = pdTRUE;
3034:                			}
3035:                			else
3036:                		#endif
3037:                
3038:                		#if ( INCLUDE_vTaskSuspend == 1 )
3039:                			if( *pxTicksToWait == portMAX_DELAY )
9D011E84  8E430000   LW V1, 0(S2)
9D011E88  2404FFFF   ADDIU A0, ZERO, -1
9D011E8C  50640013   BEQL V1, A0, 0x9D011EDC
9D011E90  00008821   ADDU S1, ZERO, ZERO
3040:                			{
3041:                				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
3042:                				specified is the maximum block time then the task should block
3043:                				indefinitely, and therefore never time out. */
3044:                				xReturn = pdFALSE;
3045:                			}
3046:                			else
3047:                		#endif
3048:                
3049:                		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
9D011E94  8F848084   LW A0, -32636(GP)
9D011E98  8E050000   LW A1, 0(S0)
9D011E9C  10A40005   BEQ A1, A0, 0x9D011EB4
9D011EA0  8E040004   LW A0, 4(S0)
9D011EA4  0044202B   SLTU A0, V0, A0
9D011EA8  1080000C   BEQ A0, ZERO, 0x9D011EDC
9D011EAC  24110001   ADDIU S1, ZERO, 1
3050:                		{
3051:                			/* The tick count is greater than the time at which
3052:                			vTaskSetTimeout() was called, but has also overflowed since
3053:                			vTaskSetTimeOut() was called.  It must have wrapped all the way
3054:                			around and gone past again. This passed since vTaskSetTimeout()
3055:                			was called. */
3056:                			xReturn = pdTRUE;
3057:                		}
3058:                		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
9D011EB0  8E040004   LW A0, 4(S0)
9D011EB4  00442823   SUBU A1, V0, A0
9D011EB8  00A3282B   SLTU A1, A1, V1
9D011EBC  10A00007   BEQ A1, ZERO, 0x9D011EDC
9D011EC0  24110001   ADDIU S1, ZERO, 1
3059:                		{
3060:                			/* Not a genuine timeout. Adjust parameters for time remaining. */
3061:                			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
9D011EC4  00821023   SUBU V0, A0, V0
9D011EC8  00431821   ADDU V1, V0, V1
9D011ECC  AE430000   SW V1, 0(S2)
3062:                			vTaskSetTimeOutState( pxTimeOut );
9D011ED0  0F4055F5   JAL vTaskSetTimeOutState
9D011ED4  02002021   ADDU A0, S0, ZERO
9D011ED8  00008821   ADDU S1, ZERO, ZERO
3063:                			xReturn = pdFALSE;
3064:                		}
3065:                		else
3066:                		{
3067:                			xReturn = pdTRUE;
3068:                		}
3069:                	}
3070:                	taskEXIT_CRITICAL();
9D011EDC  0F404EA8   JAL vTaskExitCritical
9D011EE0  00000000   NOP
3071:                
3072:                	return xReturn;
3073:                }
9D011EE4  02201021   ADDU V0, S1, ZERO
9D011EE8  8FBF001C   LW RA, 28(SP)
9D011EEC  8FB20018   LW S2, 24(SP)
9D011EF0  8FB10014   LW S1, 20(SP)
9D011EF4  8FB00010   LW S0, 16(SP)
9D011EF8  03E00008   JR RA
9D011EFC  27BD0020   ADDIU SP, SP, 32
3074:                /*-----------------------------------------------------------*/
3075:                
3076:                void vTaskMissedYield( void )
3077:                {
3078:                	xYieldPending = pdTRUE;
9D015934  24020001   ADDIU V0, ZERO, 1
9D015938  AF828088   SW V0, -32632(GP)
9D01593C  03E00008   JR RA
9D015940  00000000   NOP
3079:                }
3080:                /*-----------------------------------------------------------*/
3081:                
3082:                #if ( configUSE_TRACE_FACILITY == 1 )
3083:                
3084:                	UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask )
3085:                	{
3086:                	UBaseType_t uxReturn;
3087:                	TCB_t *pxTCB;
3088:                
3089:                		if( xTask != NULL )
3090:                		{
3091:                			pxTCB = ( TCB_t * ) xTask;
3092:                			uxReturn = pxTCB->uxTaskNumber;
3093:                		}
3094:                		else
3095:                		{
3096:                			uxReturn = 0U;
3097:                		}
3098:                
3099:                		return uxReturn;
3100:                	}
3101:                
3102:                #endif /* configUSE_TRACE_FACILITY */
3103:                /*-----------------------------------------------------------*/
3104:                
3105:                #if ( configUSE_TRACE_FACILITY == 1 )
3106:                
3107:                	void vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle )
3108:                	{
3109:                	TCB_t *pxTCB;
3110:                
3111:                		if( xTask != NULL )
3112:                		{
3113:                			pxTCB = ( TCB_t * ) xTask;
3114:                			pxTCB->uxTaskNumber = uxHandle;
3115:                		}
3116:                	}
3117:                
3118:                #endif /* configUSE_TRACE_FACILITY */
3119:                
3120:                /*
3121:                 * -----------------------------------------------------------
3122:                 * The Idle task.
3123:                 * ----------------------------------------------------------
3124:                 *
3125:                 * The portTASK_FUNCTION() macro is used to allow port/compiler specific
3126:                 * language extensions.  The equivalent prototype for this function is:
3127:                 *
3128:                 * void prvIdleTask( void *pvParameters );
3129:                 *
3130:                 */
3131:                static portTASK_FUNCTION( prvIdleTask, pvParameters )
3132:                {
9D0135D0  27BDFFE8   ADDIU SP, SP, -24
9D0135D4  AFBF0014   SW RA, 20(SP)
9D0135D8  AFB00010   SW S0, 16(SP)
3133:                	/* Stop warnings. */
3134:                	( void ) pvParameters;
3135:                
3136:                	/** THIS IS THE RTOS IDLE TASK - WHICH IS CREATED AUTOMATICALLY WHEN THE
3137:                	SCHEDULER IS STARTED. **/
3138:                
3139:                	for( ;; )
3140:                	{
3141:                		/* See if any tasks have deleted themselves - if so then the idle task
3142:                		is responsible for freeing the deleted task's TCB and stack. */
3143:                		prvCheckTasksWaitingTermination();
9D0135E0  0F404984   JAL prvCheckTasksWaitingTermination
9D0135E4  00000000   NOP
3144:                
3145:                		#if ( configUSE_PREEMPTION == 0 )
3146:                		{
3147:                			/* If we are not using preemption we keep forcing a task switch to
3148:                			see if any other task has become available.  If we are using
3149:                			preemption we don't need to do this as any task becoming available
3150:                			will automatically get the processor anyway. */
3151:                			taskYIELD();
3152:                		}
3153:                		#endif /* configUSE_PREEMPTION */
3154:                
3155:                		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
3156:                		{
3157:                			/* When using preemption tasks of equal priority will be
3158:                			timesliced.  If a task that is sharing the idle priority is ready
3159:                			to run then the idle task should yield before the end of the
3160:                			timeslice.
3161:                
3162:                			A critical region is not required here as we are just reading from
3163:                			the list, and an occasional incorrect value will not matter.  If
3164:                			the ready list at the idle priority contains more than one task
3165:                			then a task other than the idle task is ready to execute. */
3166:                			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
9D0135DC  3C10A000   LUI S0, -24576
9D0135E8  8E020E30   LW V0, 3632(S0)
9D0135EC  2C420002   SLTIU V0, V0, 2
9D0135F0  14400005   BNE V0, ZERO, 0x9D013608
9D0135F4  00000000   NOP
3167:                			{
3168:                				taskYIELD();
9D0135F8  40026800   MFC0 V0, Cause
9D0135FC  34420100   ORI V0, V0, 256
9D013600  40826800   MTC0 V0, Cause
9D013604  000000C0   EHB
3169:                			}
3170:                			else
3171:                			{
3172:                				mtCOVERAGE_TEST_MARKER();
3173:                			}
3174:                		}
3175:                		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */
3176:                
3177:                		#if ( configUSE_IDLE_HOOK == 1 )
3178:                		{
3179:                			extern void vApplicationIdleHook( void );
3180:                
3181:                			/* Call the user defined function from within the idle task.  This
3182:                			allows the application designer to add background functionality
3183:                			without the overhead of a separate task.
3184:                			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
3185:                			CALL A FUNCTION THAT MIGHT BLOCK. */
3186:                			vApplicationIdleHook();
3187:                		}
3188:                		#endif /* configUSE_IDLE_HOOK */
3189:                
3190:                		/* This conditional compilation should use inequality to 0, not equality
3191:                		to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
3192:                		user defined low power mode	implementations require
3193:                		configUSE_TICKLESS_IDLE to be set to a value other than 1. */
3194:                		#if ( configUSE_TICKLESS_IDLE != 0 )
3195:                		{
3196:                		TickType_t xExpectedIdleTime;
3197:                
3198:                			/* It is not desirable to suspend then resume the scheduler on
3199:                			each iteration of the idle task.  Therefore, a preliminary
3200:                			test of the expected idle time is performed without the
3201:                			scheduler suspended.  The result here is not necessarily
3202:                			valid. */
3203:                			xExpectedIdleTime = prvGetExpectedIdleTime();
9D013608  0F405132   JAL prvGetExpectedIdleTime
9D01360C  00000000   NOP
3204:                
3205:                			if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
9D013610  2C420002   SLTIU V0, V0, 2
9D013614  1440FFF2   BNE V0, ZERO, 0x9D0135E0
9D013618  00000000   NOP
3206:                			{
3207:                				vTaskSuspendAll();
9D01361C  0F4055F0   JAL vTaskSuspendAll
9D013620  00000000   NOP
3208:                				{
3209:                					/* Now the scheduler is suspended, the expected idle
3210:                					time can be sampled again, and this time its value can
3211:                					be used. */
3212:                					configASSERT( xNextTaskUnblockTime >= xTickCount );
3213:                					xExpectedIdleTime = prvGetExpectedIdleTime();
9D013624  0F405132   JAL prvGetExpectedIdleTime
9D013628  00000000   NOP
3214:                
3215:                					if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
3216:                					{
3217:                						traceLOW_POWER_IDLE_BEGIN();
3218:                						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
3219:                						traceLOW_POWER_IDLE_END();
3220:                					}
3221:                					else
3222:                					{
3223:                						mtCOVERAGE_TEST_MARKER();
3224:                					}
3225:                				}
3226:                				( void ) xTaskResumeAll();
9D01362C  0F40379F   JAL xTaskResumeAll
9D013630  00000000   NOP
9D013634  0B404D78   J 0x9D0135E0
9D013638  00000000   NOP
3227:                			}
3228:                			else
3229:                			{
3230:                				mtCOVERAGE_TEST_MARKER();
3231:                			}
3232:                		}
3233:                		#endif /* configUSE_TICKLESS_IDLE */
3234:                	}
3235:                }
3236:                /*-----------------------------------------------------------*/
3237:                
3238:                #if( configUSE_TICKLESS_IDLE != 0 )
3239:                
3240:                	eSleepModeStatus eTaskConfirmSleepModeStatus( void )
3241:                	{
3242:                	/* The idle task exists in addition to the application tasks. */
3243:                	const UBaseType_t uxNonApplicationTasks = 1;
3244:                	eSleepModeStatus eReturn = eStandardSleep;
3245:                
3246:                		if( listCURRENT_LIST_LENGTH( &xPendingReadyList ) != 0 )
3247:                		{
3248:                			/* A task was made ready while the scheduler was suspended. */
3249:                			eReturn = eAbortSleep;
3250:                		}
3251:                		else if( xYieldPending != pdFALSE )
3252:                		{
3253:                			/* A yield was pended while the scheduler was suspended. */
3254:                			eReturn = eAbortSleep;
3255:                		}
3256:                		else
3257:                		{
3258:                			/* If all the tasks are in the suspended list (which might mean they
3259:                			have an infinite block time rather than actually being suspended)
3260:                			then it is safe to turn all clocks off and just wait for external
3261:                			interrupts. */
3262:                			if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == ( uxCurrentNumberOfTasks - uxNonApplicationTasks ) )
3263:                			{
3264:                				eReturn = eNoTasksWaitingTimeout;
3265:                			}
3266:                			else
3267:                			{
3268:                				mtCOVERAGE_TEST_MARKER();
3269:                			}
3270:                		}
3271:                
3272:                		return eReturn;
3273:                	}
3274:                
3275:                #endif /* configUSE_TICKLESS_IDLE */
3276:                /*-----------------------------------------------------------*/
3277:                
3278:                #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
3279:                
3280:                	void vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet, BaseType_t xIndex, void *pvValue )
3281:                	{
3282:                	TCB_t *pxTCB;
3283:                
3284:                		if( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS )
3285:                		{
3286:                			pxTCB = prvGetTCBFromHandle( xTaskToSet );
3287:                			pxTCB->pvThreadLocalStoragePointers[ xIndex ] = pvValue;
3288:                		}
3289:                	}
3290:                
3291:                #endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
3292:                /*-----------------------------------------------------------*/
3293:                
3294:                #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
3295:                
3296:                	void *pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery, BaseType_t xIndex )
3297:                	{
3298:                	void *pvReturn = NULL;
3299:                	TCB_t *pxTCB;
3300:                
3301:                		if( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS )
3302:                		{
3303:                			pxTCB = prvGetTCBFromHandle( xTaskToQuery );
3304:                			pvReturn = pxTCB->pvThreadLocalStoragePointers[ xIndex ];
3305:                		}
3306:                		else
3307:                		{
3308:                			pvReturn = NULL;
3309:                		}
3310:                
3311:                		return pvReturn;
3312:                	}
3313:                
3314:                #endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
3315:                /*-----------------------------------------------------------*/
3316:                
3317:                #if ( portUSING_MPU_WRAPPERS == 1 )
3318:                
3319:                	void vTaskAllocateMPURegions( TaskHandle_t xTaskToModify, const MemoryRegion_t * const xRegions )
3320:                	{
3321:                	TCB_t *pxTCB;
3322:                
3323:                		/* If null is passed in here then we are modifying the MPU settings of
3324:                		the calling task. */
3325:                		pxTCB = prvGetTCBFromHandle( xTaskToModify );
3326:                
3327:                		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
3328:                	}
3329:                
3330:                #endif /* portUSING_MPU_WRAPPERS */
3331:                /*-----------------------------------------------------------*/
3332:                
3333:                static void prvInitialiseTaskLists( void )
3334:                {
9D012580  27BDFFE0   ADDIU SP, SP, -32
9D012584  AFBF001C   SW RA, 28(SP)
9D012588  AFB10018   SW S1, 24(SP)
9D01258C  AFB00014   SW S0, 20(SP)
9D012590  3C10A000   LUI S0, -24576
9D012594  26100E30   ADDIU S0, S0, 3632
9D012598  26110064   ADDIU S1, S0, 100
3335:                UBaseType_t uxPriority;
3336:                
3337:                	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
9D0125A8  1611FFFC   BNE S0, S1, 0x9D01259C
9D0125AC  00000000   NOP
3338:                	{
3339:                		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
9D01259C  0F405559   JAL vListInitialise
9D0125A0  02002021   ADDU A0, S0, ZERO
9D0125A4  26100014   ADDIU S0, S0, 20
3340:                	}
3341:                
3342:                	vListInitialise( &xDelayedTaskList1 );
9D0125B0  3C11A000   LUI S1, -24576
9D0125B4  0F405559   JAL vListInitialise
9D0125B8  26240EBC   ADDIU A0, S1, 3772
3343:                	vListInitialise( &xDelayedTaskList2 );
9D0125BC  3C10A000   LUI S0, -24576
9D0125C0  0F405559   JAL vListInitialise
9D0125C4  26040EE4   ADDIU A0, S0, 3812
3344:                	vListInitialise( &xPendingReadyList );
9D0125C8  3C04A000   LUI A0, -24576
9D0125CC  0F405559   JAL vListInitialise
9D0125D0  24840E94   ADDIU A0, A0, 3732
3345:                
3346:                	#if ( INCLUDE_vTaskDelete == 1 )
3347:                	{
3348:                		vListInitialise( &xTasksWaitingTermination );
9D0125D4  3C04A000   LUI A0, -24576
9D0125D8  0F405559   JAL vListInitialise
9D0125DC  24840ED0   ADDIU A0, A0, 3792
3349:                	}
3350:                	#endif /* INCLUDE_vTaskDelete */
3351:                
3352:                	#if ( INCLUDE_vTaskSuspend == 1 )
3353:                	{
3354:                		vListInitialise( &xSuspendedTaskList );
9D0125E0  3C04A000   LUI A0, -24576
9D0125E4  0F405559   JAL vListInitialise
9D0125E8  24840EA8   ADDIU A0, A0, 3752
3355:                	}
3356:                	#endif /* INCLUDE_vTaskSuspend */
3357:                
3358:                	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
3359:                	using list2. */
3360:                	pxDelayedTaskList = &xDelayedTaskList1;
9D0125EC  26310EBC   ADDIU S1, S1, 3772
9D0125F0  AF918164   SW S1, -32412(GP)
3361:                	pxOverflowDelayedTaskList = &xDelayedTaskList2;
9D0125F4  26100EE4   ADDIU S0, S0, 3812
9D0125F8  AF908168   SW S0, -32408(GP)
3362:                }
9D0125FC  8FBF001C   LW RA, 28(SP)
9D012600  8FB10018   LW S1, 24(SP)
9D012604  8FB00014   LW S0, 20(SP)
9D012608  03E00008   JR RA
9D01260C  27BD0020   ADDIU SP, SP, 32
3363:                /*-----------------------------------------------------------*/
3364:                
3365:                static void prvCheckTasksWaitingTermination( void )
3366:                {
9D012610  27BDFFE0   ADDIU SP, SP, -32
9D012614  AFBF001C   SW RA, 28(SP)
9D012618  AFB10018   SW S1, 24(SP)
9D01261C  AFB00014   SW S0, 20(SP)
3367:                
3368:                	/** THIS FUNCTION IS CALLED FROM THE RTOS IDLE TASK **/
3369:                
3370:                	#if ( INCLUDE_vTaskDelete == 1 )
3371:                	{
3372:                		BaseType_t xListIsEmpty;
3373:                
3374:                		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
3375:                		too often in the idle task. */
3376:                		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
9D012620  0B4049A1   J 0x9D012684
9D012624  3C11A000   LUI S1, -24576
9D012684  8F8280A0   LW V0, -32608(GP)
9D012688  1440FFE7   BNE V0, ZERO, 0x9D012628
9D01268C  8FBF001C   LW RA, 28(SP)
3377:                		{
3378:                			vTaskSuspendAll();
9D012628  0F4055F0   JAL vTaskSuspendAll
9D01262C  00000000   NOP
3379:                			{
3380:                				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
3381:                			}
3382:                			( void ) xTaskResumeAll();
9D012630  0F40379F   JAL xTaskResumeAll
9D012634  8E300ED0   LW S0, 3792(S1)
3383:                
3384:                			if( xListIsEmpty == pdFALSE )
9D012638  12000012   BEQ S0, ZERO, 0x9D012684
9D01263C  00000000   NOP
3385:                			{
3386:                				TCB_t *pxTCB;
3387:                
3388:                				taskENTER_CRITICAL();
9D012640  0F405144   JAL vTaskEnterCritical
9D012644  00000000   NOP
3389:                				{
3390:                					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
9D012648  26220ED0   ADDIU V0, S1, 3792
9D01264C  8C42000C   LW V0, 12(V0)
9D012650  8C50000C   LW S0, 12(V0)
3391:                					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
9D012654  0F4051D3   JAL uxListRemove
9D012658  26040004   ADDIU A0, S0, 4
3392:                					--uxCurrentNumberOfTasks;
9D01265C  8F82809C   LW V0, -32612(GP)
9D012660  2442FFFF   ADDIU V0, V0, -1
9D012664  AF82809C   SW V0, -32612(GP)
3393:                					--uxDeletedTasksWaitingCleanUp;
9D012668  8F8280A0   LW V0, -32608(GP)
9D01266C  2442FFFF   ADDIU V0, V0, -1
9D012670  AF8280A0   SW V0, -32608(GP)
3394:                				}
3395:                				taskEXIT_CRITICAL();
9D012674  0F404EA8   JAL vTaskExitCritical
9D012678  00000000   NOP
3396:                
3397:                				prvDeleteTCB( pxTCB );
9D01267C  0F405432   JAL prvDeleteTCB
9D012680  02002021   ADDU A0, S0, ZERO
3398:                			}
3399:                			else
3400:                			{
3401:                				mtCOVERAGE_TEST_MARKER();
3402:                			}
3403:                		}
3404:                	}
3405:                	#endif /* INCLUDE_vTaskDelete */
3406:                }
9D012690  8FB10018   LW S1, 24(SP)
9D012694  8FB00014   LW S0, 20(SP)
9D012698  03E00008   JR RA
9D01269C  27BD0020   ADDIU SP, SP, 32
3407:                /*-----------------------------------------------------------*/
3408:                
3409:                #if( configUSE_TRACE_FACILITY == 1 )
3410:                
3411:                	void vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState )
3412:                	{
3413:                	TCB_t *pxTCB;
3414:                
3415:                		/* xTask is NULL then get the state of the calling task. */
3416:                		pxTCB = prvGetTCBFromHandle( xTask );
3417:                
3418:                		pxTaskStatus->xHandle = ( TaskHandle_t ) pxTCB;
3419:                		pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName [ 0 ] );
3420:                		pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
3421:                		pxTaskStatus->pxStackBase = pxTCB->pxStack;
3422:                		pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;
3423:                
3424:                		#if ( INCLUDE_vTaskSuspend == 1 )
3425:                		{
3426:                			/* If the task is in the suspended list then there is a chance it is
3427:                			actually just blocked indefinitely - so really it should be reported as
3428:                			being in the Blocked state. */
3429:                			if( pxTaskStatus->eCurrentState == eSuspended )
3430:                			{
3431:                				vTaskSuspendAll();
3432:                				{
3433:                					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
3434:                					{
3435:                						pxTaskStatus->eCurrentState = eBlocked;
3436:                					}
3437:                				}
3438:                				xTaskResumeAll();
3439:                			}
3440:                		}
3441:                		#endif /* INCLUDE_vTaskSuspend */
3442:                
3443:                		#if ( configUSE_MUTEXES == 1 )
3444:                		{
3445:                			pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
3446:                		}
3447:                		#else
3448:                		{
3449:                			pxTaskStatus->uxBasePriority = 0;
3450:                		}
3451:                		#endif
3452:                
3453:                		#if ( configGENERATE_RUN_TIME_STATS == 1 )
3454:                		{
3455:                			pxTaskStatus->ulRunTimeCounter = pxTCB->ulRunTimeCounter;
3456:                		}
3457:                		#else
3458:                		{
3459:                			pxTaskStatus->ulRunTimeCounter = 0;
3460:                		}
3461:                		#endif
3462:                
3463:                		/* Obtaining the task state is a little fiddly, so is only done if the value
3464:                		of eState passed into this function is eInvalid - otherwise the state is
3465:                		just set to whatever is passed in. */
3466:                		if( eState != eInvalid )
3467:                		{
3468:                			pxTaskStatus->eCurrentState = eState;
3469:                		}
3470:                		else
3471:                		{
3472:                			pxTaskStatus->eCurrentState = eTaskGetState( xTask );
3473:                		}
3474:                
3475:                		/* Obtaining the stack space takes some time, so the xGetFreeStackSpace
3476:                		parameter is provided to allow it to be skipped. */
3477:                		if( xGetFreeStackSpace != pdFALSE )
3478:                		{
3479:                			#if ( portSTACK_GROWTH > 0 )
3480:                			{
3481:                				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxEndOfStack );
3482:                			}
3483:                			#else
3484:                			{
3485:                				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxStack );
3486:                			}
3487:                			#endif
3488:                		}
3489:                		else
3490:                		{
3491:                			pxTaskStatus->usStackHighWaterMark = 0;
3492:                		}
3493:                	}
3494:                
3495:                #endif /* configUSE_TRACE_FACILITY */
3496:                /*-----------------------------------------------------------*/
3497:                
3498:                #if ( configUSE_TRACE_FACILITY == 1 )
3499:                
3500:                	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )
3501:                	{
3502:                	volatile TCB_t *pxNextTCB, *pxFirstTCB;
3503:                	UBaseType_t uxTask = 0;
3504:                
3505:                		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
3506:                		{
3507:                			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
3508:                
3509:                			/* Populate an TaskStatus_t structure within the
3510:                			pxTaskStatusArray array for each task that is referenced from
3511:                			pxList.  See the definition of TaskStatus_t in task.h for the
3512:                			meaning of each TaskStatus_t structure member. */
3513:                			do
3514:                			{
3515:                				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
3516:                				vTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE, eState );
3517:                				uxTask++;
3518:                			} while( pxNextTCB != pxFirstTCB );
3519:                		}
3520:                		else
3521:                		{
3522:                			mtCOVERAGE_TEST_MARKER();
3523:                		}
3524:                
3525:                		return uxTask;
3526:                	}
3527:                
3528:                #endif /* configUSE_TRACE_FACILITY */
3529:                /*-----------------------------------------------------------*/
3530:                
3531:                #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
3532:                
3533:                	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
3534:                	{
3535:                	uint32_t ulCount = 0U;
3536:                
3537:                		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
3538:                		{
3539:                			pucStackByte -= portSTACK_GROWTH;
3540:                			ulCount++;
3541:                		}
3542:                
3543:                		ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller architectures. */
3544:                
3545:                		return ( uint16_t ) ulCount;
3546:                	}
3547:                
3548:                #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) */
3549:                /*-----------------------------------------------------------*/
3550:                
3551:                #if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
3552:                
3553:                	UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )
3554:                	{
3555:                	TCB_t *pxTCB;
3556:                	uint8_t *pucEndOfStack;
3557:                	UBaseType_t uxReturn;
3558:                
3559:                		pxTCB = prvGetTCBFromHandle( xTask );
3560:                
3561:                		#if portSTACK_GROWTH < 0
3562:                		{
3563:                			pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
3564:                		}
3565:                		#else
3566:                		{
3567:                			pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
3568:                		}
3569:                		#endif
3570:                
3571:                		uxReturn = ( UBaseType_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );
3572:                
3573:                		return uxReturn;
3574:                	}
3575:                
3576:                #endif /* INCLUDE_uxTaskGetStackHighWaterMark */
3577:                /*-----------------------------------------------------------*/
3578:                
3579:                #if ( INCLUDE_vTaskDelete == 1 )
3580:                
3581:                	static void prvDeleteTCB( TCB_t *pxTCB )
3582:                	{
9D0150C8  27BDFFE8   ADDIU SP, SP, -24
9D0150CC  AFBF0014   SW RA, 20(SP)
9D0150D0  AFB00010   SW S0, 16(SP)
9D0150D4  00808021   ADDU S0, A0, ZERO
3583:                		/* This call is required specifically for the TriCore port.  It must be
3584:                		above the vPortFree() calls.  The call is also used by ports/demos that
3585:                		want to allocate and clean RAM statically. */
3586:                		portCLEAN_UP_TCB( pxTCB );
3587:                
3588:                		/* Free up the memory allocated by the scheduler for the task.  It is up
3589:                		to the task to free any memory allocated at the application level. */
3590:                		#if ( configUSE_NEWLIB_REENTRANT == 1 )
3591:                		{
3592:                			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
3593:                		}
3594:                		#endif /* configUSE_NEWLIB_REENTRANT */
3595:                
3596:                		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
3597:                		{
3598:                			/* The task can only have been allocated dynamically - free both
3599:                			the stack and TCB. */
3600:                			vPortFree( pxTCB->pxStack );
9D0150D8  0F404C97   JAL vPortFree
9D0150DC  8C840030   LW A0, 48(A0)
3601:                			vPortFree( pxTCB );
9D0150E0  0F404C97   JAL vPortFree
9D0150E4  02002021   ADDU A0, S0, ZERO
3602:                		}
3603:                		#elif( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE == 1 )
3604:                		{
3605:                			/* The task could have been allocated statically or dynamically, so
3606:                			check what was statically allocated before trying to free the
3607:                			memory. */
3608:                			if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
3609:                			{
3610:                				/* Both the stack and TCB were allocated dynamically, so both
3611:                				must be freed. */
3612:                				vPortFree( pxTCB->pxStack );
3613:                				vPortFree( pxTCB );
3614:                			}
3615:                			else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
3616:                			{
3617:                				/* Only the stack was statically allocated, so the TCB is the
3618:                				only memory that must be freed. */
3619:                				vPortFree( pxTCB );
3620:                			}
3621:                			else
3622:                			{
3623:                				/* Neither the stack nor the TCB were allocated dynamically, so
3624:                				nothing needs to be freed. */
3625:                				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	)
3626:                				mtCOVERAGE_TEST_MARKER();
3627:                			}
3628:                		}
3629:                		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
3630:                	}
9D0150E8  8FBF0014   LW RA, 20(SP)
9D0150EC  8FB00010   LW S0, 16(SP)
9D0150F0  03E00008   JR RA
9D0150F4  27BD0018   ADDIU SP, SP, 24
3631:                
3632:                #endif /* INCLUDE_vTaskDelete */
3633:                /*-----------------------------------------------------------*/
3634:                
3635:                static void prvResetNextTaskUnblockTime( void )
3636:                {
3637:                TCB_t *pxTCB;
3638:                
3639:                	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
9D014D1C  8F828164   LW V0, -32412(GP)
9D014D20  8C420000   LW V0, 0(V0)
9D014D24  14400004   BNE V0, ZERO, 0x9D014D38
9D014D28  2402FFFF   ADDIU V0, ZERO, -1
3640:                	{
3641:                		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
3642:                		the maximum possible value so it is	extremely unlikely that the
3643:                		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
3644:                		there is an item in the delayed list. */
3645:                		xNextTaskUnblockTime = portMAX_DELAY;
9D014D2C  AF82807C   SW V0, -32644(GP)
9D014D30  03E00008   JR RA
9D014D34  00000000   NOP
3646:                	}
3647:                	else
3648:                	{
3649:                		/* The new current delayed list is not empty, get the value of
3650:                		the item at the head of the delayed list.  This is the time at
3651:                		which the task at the head of the delayed list should be removed
3652:                		from the Blocked state. */
3653:                		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
9D014D38  8F828164   LW V0, -32412(GP)
9D014D3C  8C42000C   LW V0, 12(V0)
3654:                		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
9D014D40  8C42000C   LW V0, 12(V0)
9D014D44  8C420004   LW V0, 4(V0)
9D014D48  AF82807C   SW V0, -32644(GP)
9D014D4C  03E00008   JR RA
9D014D50  00000000   NOP
3655:                	}
3656:                }
3657:                /*-----------------------------------------------------------*/
3658:                
3659:                #if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
3660:                
3661:                	TaskHandle_t xTaskGetCurrentTaskHandle( void )
3662:                	{
3663:                	TaskHandle_t xReturn;
3664:                
3665:                		/* A critical section is not required as this is not called from
3666:                		an interrupt and the current TCB will always be the same for any
3667:                		individual execution thread. */
3668:                		xReturn = pxCurrentTCB;
3669:                
3670:                		return xReturn;
3671:                	}
3672:                
3673:                #endif /* ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) ) */
3674:                /*-----------------------------------------------------------*/
3675:                
3676:                #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
3677:                
3678:                	BaseType_t xTaskGetSchedulerState( void )
3679:                	{
3680:                	BaseType_t xReturn;
3681:                
3682:                		if( xSchedulerRunning == pdFALSE )
9D015584  8F838090   LW V1, -32624(GP)
9D015588  10600004   BEQ V1, ZERO, 0x9D01559C
9D01558C  24020001   ADDIU V0, ZERO, 1
3683:                		{
3684:                			xReturn = taskSCHEDULER_NOT_STARTED;
3685:                		}
3686:                		else
3687:                		{
3688:                			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
9D015590  8F838074   LW V1, -32652(GP)
3689:                			{
3690:                				xReturn = taskSCHEDULER_RUNNING;
9D015594  24020002   ADDIU V0, ZERO, 2
9D015598  0003100B   MOVN V0, ZERO, V1
3691:                			}
3692:                			else
3693:                			{
3694:                				xReturn = taskSCHEDULER_SUSPENDED;
3695:                			}
3696:                		}
3697:                
3698:                		return xReturn;
3699:                	}
9D01559C  03E00008   JR RA
9D0155A0  00000000   NOP
3700:                
3701:                #endif /* ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) ) */
3702:                /*-----------------------------------------------------------*/
3703:                
3704:                #if ( configUSE_MUTEXES == 1 )
3705:                
3706:                	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
3707:                	{
9D00E970  27BDFFE0   ADDIU SP, SP, -32
9D00E974  AFBF001C   SW RA, 28(SP)
9D00E978  AFB10018   SW S1, 24(SP)
9D00E97C  AFB00014   SW S0, 20(SP)
3708:                	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
3709:                
3710:                		/* If the mutex was given back by an interrupt while the queue was
3711:                		locked then the mutex holder might now be NULL. */
3712:                		if( pxMutexHolder != NULL )
9D00E980  10800041   BEQ A0, ZERO, 0x9D00EA88
9D00E984  00808021   ADDU S0, A0, ZERO
3713:                		{
3714:                			/* If the holder of the mutex has a priority below the priority of
3715:                			the task attempting to obtain the mutex then it will temporarily
3716:                			inherit the priority of the task attempting to obtain the mutex. */
3717:                			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
9D00E988  8C82002C   LW V0, 44(A0)
9D00E98C  8F8380A4   LW V1, -32604(GP)
9D00E990  8C63002C   LW V1, 44(V1)
9D00E994  0043182B   SLTU V1, V0, V1
9D00E998  5060003C   BEQL V1, ZERO, 0x9D00EA8C
9D00E99C  8FBF001C   LW RA, 28(SP)
3718:                			{
3719:                				/* Adjust the mutex holder state to account for its new
3720:                				priority.  Only reset the event list item value if the value is
3721:                				not	being used for anything else. */
3722:                				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
9D00E9A0  8C830018   LW V1, 24(A0)
9D00E9A4  04600007   BLTZ V1, 0x9D00E9C4
9D00E9A8  00021880   SLL V1, V0, 2
3723:                				{
3724:                					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
9D00E9AC  8F8380A4   LW V1, -32604(GP)
9D00E9B0  8C63002C   LW V1, 44(V1)
9D00E9B4  24040005   ADDIU A0, ZERO, 5
9D00E9B8  00831823   SUBU V1, A0, V1
9D00E9BC  AE030018   SW V1, 24(S0)
3725:                				}
3726:                				else
3727:                				{
3728:                					mtCOVERAGE_TEST_MARKER();
3729:                				}
3730:                
3731:                				/* If the task being modified is in the ready state it will need
3732:                				to be moved into a new list. */
3733:                				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
9D00E9C0  00021880   SLL V1, V0, 2
9D00E9C4  00021100   SLL V0, V0, 4
9D00E9C8  00621021   ADDU V0, V1, V0
9D00E9CC  3C03A000   LUI V1, -24576
9D00E9D0  24630E30   ADDIU V1, V1, 3632
9D00E9D4  00621021   ADDU V0, V1, V0
9D00E9D8  8E030014   LW V1, 20(S0)
9D00E9DC  14620027   BNE V1, V0, 0x9D00EA7C
9D00E9E0  26110004   ADDIU S1, S0, 4
3734:                				{
3735:                					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
9D00E9E4  0F4051D3   JAL uxListRemove
9D00E9E8  02202021   ADDU A0, S1, ZERO
9D00E9EC  14400011   BNE V0, ZERO, 0x9D00EA34
9D00E9F0  00000000   NOP
3736:                					{
3737:                						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
9D00E9F4  8E02002C   LW V0, 44(S0)
9D00E9F8  00022080   SLL A0, V0, 2
9D00E9FC  00021900   SLL V1, V0, 4
9D00EA00  00831821   ADDU V1, A0, V1
9D00EA04  3C04A000   LUI A0, -24576
9D00EA08  24840E30   ADDIU A0, A0, 3632
9D00EA0C  00641821   ADDU V1, V1, A0
9D00EA10  8C630000   LW V1, 0(V1)
9D00EA14  14600007   BNE V1, ZERO, 0x9D00EA34
9D00EA18  00000000   NOP
9D00EA1C  8F838094   LW V1, -32620(GP)
9D00EA20  24040001   ADDIU A0, ZERO, 1
9D00EA24  00441004   SLLV V0, A0, V0
9D00EA28  00021027   NOR V0, ZERO, V0
9D00EA2C  00431024   AND V0, V0, V1
9D00EA30  AF828094   SW V0, -32620(GP)
3738:                					}
3739:                					else
3740:                					{
3741:                						mtCOVERAGE_TEST_MARKER();
3742:                					}
3743:                
3744:                					/* Inherit the priority before being moved into the new list. */
3745:                					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
9D00EA34  8F8280A4   LW V0, -32604(GP)
9D00EA38  8C42002C   LW V0, 44(V0)
9D00EA3C  AE02002C   SW V0, 44(S0)
3746:                					prvAddTaskToReadyList( pxTCB );
9D00EA40  8F848094   LW A0, -32620(GP)
9D00EA44  24030001   ADDIU V1, ZERO, 1
9D00EA48  00431804   SLLV V1, V1, V0
9D00EA4C  00641825   OR V1, V1, A0
9D00EA50  AF838094   SW V1, -32620(GP)
9D00EA54  00021880   SLL V1, V0, 2
9D00EA58  00021100   SLL V0, V0, 4
9D00EA5C  00621021   ADDU V0, V1, V0
9D00EA60  3C04A000   LUI A0, -24576
9D00EA64  24840E30   ADDIU A0, A0, 3632
9D00EA68  00822021   ADDU A0, A0, V0
9D00EA6C  0F405426   JAL vListInsertEnd
9D00EA70  02202821   ADDU A1, S1, ZERO
9D00EA74  0B403AA3   J 0x9D00EA8C
9D00EA78  8FBF001C   LW RA, 28(SP)
3747:                				}
3748:                				else
3749:                				{
3750:                					/* Just inherit the priority. */
3751:                					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
9D00EA7C  8F8280A4   LW V0, -32604(GP)
9D00EA80  8C42002C   LW V0, 44(V0)
9D00EA84  AE02002C   SW V0, 44(S0)
3752:                				}
3753:                
3754:                				traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
3755:                			}
3756:                			else
3757:                			{
3758:                				mtCOVERAGE_TEST_MARKER();
3759:                			}
3760:                		}
3761:                		else
3762:                		{
3763:                			mtCOVERAGE_TEST_MARKER();
3764:                		}
3765:                	}
9D00EA88  8FBF001C   LW RA, 28(SP)
9D00EA8C  8FB10018   LW S1, 24(SP)
9D00EA90  8FB00014   LW S0, 20(SP)
9D00EA94  03E00008   JR RA
9D00EA98  27BD0020   ADDIU SP, SP, 32
3766:                
3767:                #endif /* configUSE_MUTEXES */
3768:                /*-----------------------------------------------------------*/
3769:                
3770:                #if ( configUSE_MUTEXES == 1 )
3771:                
3772:                	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
3773:                	{
9D00FEF4  27BDFFE0   ADDIU SP, SP, -32
9D00FEF8  AFBF001C   SW RA, 28(SP)
9D00FEFC  AFB10018   SW S1, 24(SP)
9D00FF00  AFB00014   SW S0, 20(SP)
3774:                	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
3775:                	BaseType_t xReturn = pdFALSE;
3776:                
3777:                		if( pxMutexHolder != NULL )
9D00FF04  10800033   BEQ A0, ZERO, 0x9D00FFD4
9D00FF08  00808021   ADDU S0, A0, ZERO
3778:                		{
3779:                			/* A task can only have an inherited priority if it holds the mutex.
3780:                			If the mutex is held by a task then it cannot be given from an
3781:                			interrupt, and if a mutex is given by the holding task then it must
3782:                			be the running state task. */
3783:                			configASSERT( pxTCB == pxCurrentTCB );
3784:                
3785:                			configASSERT( pxTCB->uxMutexesHeld );
3786:                			( pxTCB->uxMutexesHeld )--;
9D00FF0C  8C83004C   LW V1, 76(A0)
9D00FF10  2463FFFF   ADDIU V1, V1, -1
9D00FF14  AC83004C   SW V1, 76(A0)
3787:                
3788:                			/* Has the holder of the mutex inherited the priority of another
3789:                			task? */
3790:                			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
9D00FF18  8C84002C   LW A0, 44(A0)
9D00FF1C  8E020048   LW V0, 72(S0)
9D00FF20  1082002D   BEQ A0, V0, 0x9D00FFD8
9D00FF24  00001021   ADDU V0, ZERO, ZERO
3791:                			{
3792:                				/* Only disinherit if no other mutexes are held. */
3793:                				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
9D00FF28  1460002C   BNE V1, ZERO, 0x9D00FFDC
9D00FF2C  8FBF001C   LW RA, 28(SP)
3794:                				{
3795:                					/* A task can only have an inherited priority if it holds
3796:                					the mutex.  If the mutex is held by a task then it cannot be
3797:                					given from an interrupt, and if a mutex is given by the
3798:                					holding	task then it must be the running state task.  Remove
3799:                					the	holding task from the ready	list. */
3800:                					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
9D00FF30  26110004   ADDIU S1, S0, 4
9D00FF34  0F4051D3   JAL uxListRemove
9D00FF38  02202021   ADDU A0, S1, ZERO
9D00FF3C  54400012   BNEL V0, ZERO, 0x9D00FF88
9D00FF40  8E020048   LW V0, 72(S0)
3801:                					{
3802:                						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
9D00FF44  8E02002C   LW V0, 44(S0)
9D00FF48  00022080   SLL A0, V0, 2
9D00FF4C  00021900   SLL V1, V0, 4
9D00FF50  00831821   ADDU V1, A0, V1
9D00FF54  3C04A000   LUI A0, -24576
9D00FF58  24840E30   ADDIU A0, A0, 3632
9D00FF5C  00641821   ADDU V1, V1, A0
9D00FF60  8C630000   LW V1, 0(V1)
9D00FF64  54600008   BNEL V1, ZERO, 0x9D00FF88
9D00FF68  8E020048   LW V0, 72(S0)
9D00FF6C  8F838094   LW V1, -32620(GP)
9D00FF70  24040001   ADDIU A0, ZERO, 1
9D00FF74  00441004   SLLV V0, A0, V0
9D00FF78  00021027   NOR V0, ZERO, V0
9D00FF7C  00431024   AND V0, V0, V1
9D00FF80  AF828094   SW V0, -32620(GP)
3803:                					}
3804:                					else
3805:                					{
3806:                						mtCOVERAGE_TEST_MARKER();
3807:                					}
3808:                
3809:                					/* Disinherit the priority before adding the task into the
3810:                					new	ready list. */
3811:                					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
3812:                					pxTCB->uxPriority = pxTCB->uxBasePriority;
9D00FF84  8E020048   LW V0, 72(S0)
9D00FF88  AE02002C   SW V0, 44(S0)
3813:                
3814:                					/* Reset the event list item value.  It cannot be in use for
3815:                					any other purpose if this task is running, and it must be
3816:                					running to give back the mutex. */
3817:                					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
9D00FF8C  24030005   ADDIU V1, ZERO, 5
9D00FF90  00621823   SUBU V1, V1, V0
9D00FF94  AE030018   SW V1, 24(S0)
3818:                					prvAddTaskToReadyList( pxTCB );
9D00FF98  8F848094   LW A0, -32620(GP)
9D00FF9C  24030001   ADDIU V1, ZERO, 1
9D00FFA0  00431804   SLLV V1, V1, V0
9D00FFA4  00641825   OR V1, V1, A0
9D00FFA8  AF838094   SW V1, -32620(GP)
9D00FFAC  00021880   SLL V1, V0, 2
9D00FFB0  00021100   SLL V0, V0, 4
9D00FFB4  00621021   ADDU V0, V1, V0
9D00FFB8  3C04A000   LUI A0, -24576
9D00FFBC  24840E30   ADDIU A0, A0, 3632
9D00FFC0  00822021   ADDU A0, A0, V0
9D00FFC4  0F405426   JAL vListInsertEnd
9D00FFC8  02202821   ADDU A1, S1, ZERO
9D00FFCC  0B403FF6   J 0x9D00FFD8
9D00FFD0  24020001   ADDIU V0, ZERO, 1
9D00FFD4  00001021   ADDU V0, ZERO, ZERO
3819:                
3820:                					/* Return true to indicate that a context switch is required.
3821:                					This is only actually required in the corner case whereby
3822:                					multiple mutexes were held and the mutexes were given back
3823:                					in an order different to that in which they were taken.
3824:                					If a context switch did not occur when the first mutex was
3825:                					returned, even if a task was waiting on it, then a context
3826:                					switch should occur when the last mutex is returned whether
3827:                					a task is waiting on it or not. */
3828:                					xReturn = pdTRUE;
3829:                				}
3830:                				else
3831:                				{
3832:                					mtCOVERAGE_TEST_MARKER();
3833:                				}
3834:                			}
3835:                			else
3836:                			{
3837:                				mtCOVERAGE_TEST_MARKER();
3838:                			}
3839:                		}
3840:                		else
3841:                		{
3842:                			mtCOVERAGE_TEST_MARKER();
3843:                		}
3844:                
3845:                		return xReturn;
3846:                	}
9D00FFD8  8FBF001C   LW RA, 28(SP)
9D00FFDC  8FB10018   LW S1, 24(SP)
9D00FFE0  8FB00014   LW S0, 20(SP)
9D00FFE4  03E00008   JR RA
9D00FFE8  27BD0020   ADDIU SP, SP, 32
3847:                
3848:                #endif /* configUSE_MUTEXES */
3849:                /*-----------------------------------------------------------*/
3850:                
3851:                #if ( portCRITICAL_NESTING_IN_TCB == 1 )
3852:                
3853:                	void vTaskEnterCritical( void )
3854:                	{
9D014510  27BDFFF8   ADDIU SP, SP, -8
9D014514  AFBF0004   SW RA, 4(SP)
3855:                		portDISABLE_INTERRUPTS();
9D014518  40026000   MFC0 V0, Status
9D01451C  7C027A84   INS V0, ZERO, 10, 6
9D014520  34420C00   ORI V0, V0, 3072
9D014524  40826000   MTC0 V0, Status
9D014528  000000C0   EHB
3856:                
3857:                		if( xSchedulerRunning != pdFALSE )
9D01452C  8F828090   LW V0, -32624(GP)
9D014530  10400007   BEQ V0, ZERO, 0x9D014550
9D014534  8FBF0004   LW RA, 4(SP)
3858:                		{
3859:                			( pxCurrentTCB->uxCriticalNesting )++;
9D014538  8F8280A4   LW V0, -32604(GP)
9D01453C  8C430044   LW V1, 68(V0)
9D014540  24630001   ADDIU V1, V1, 1
9D014544  AC430044   SW V1, 68(V0)
3860:                
3861:                			/* This is not the interrupt safe version of the enter critical
3862:                			function so	assert() if it is being called from an interrupt
3863:                			context.  Only API functions that end in "FromISR" can be used in an
3864:                			interrupt.  Only assert if the critical nesting count is 1 to
3865:                			protect against recursive calls if the assert function also uses a
3866:                			critical section. */
3867:                			if( pxCurrentTCB->uxCriticalNesting == 1 )
9D014548  8F8280A4   LW V0, -32604(GP)
3868:                			{
3869:                				portASSERT_IF_IN_ISR();
3870:                			}
3871:                		}
3872:                		else
3873:                		{
3874:                			mtCOVERAGE_TEST_MARKER();
3875:                		}
3876:                	}
9D01454C  8FBF0004   LW RA, 4(SP)
9D014550  03E00008   JR RA
9D014554  27BD0008   ADDIU SP, SP, 8
3877:                
3878:                #endif /* portCRITICAL_NESTING_IN_TCB */
3879:                /*-----------------------------------------------------------*/
3880:                
3881:                #if ( portCRITICAL_NESTING_IN_TCB == 1 )
3882:                
3883:                	void vTaskExitCritical( void )
3884:                	{
9D013AA0  27BDFFF8   ADDIU SP, SP, -8
9D013AA4  AFBF0004   SW RA, 4(SP)
3885:                		if( xSchedulerRunning != pdFALSE )
9D013AA8  8F828090   LW V0, -32624(GP)
9D013AAC  50400012   BEQL V0, ZERO, 0x9D013AF8
9D013AB0  8FBF0004   LW RA, 4(SP)
3886:                		{
3887:                			if( pxCurrentTCB->uxCriticalNesting > 0U )
9D013AB4  8F8280A4   LW V0, -32604(GP)
9D013AB8  8C420044   LW V0, 68(V0)
9D013ABC  1040000E   BEQ V0, ZERO, 0x9D013AF8
9D013AC0  8FBF0004   LW RA, 4(SP)
3888:                			{
3889:                				( pxCurrentTCB->uxCriticalNesting )--;
9D013AC4  8F8280A4   LW V0, -32604(GP)
9D013AC8  8C430044   LW V1, 68(V0)
9D013ACC  2463FFFF   ADDIU V1, V1, -1
9D013AD0  AC430044   SW V1, 68(V0)
3890:                
3891:                				if( pxCurrentTCB->uxCriticalNesting == 0U )
9D013AD4  8F8280A4   LW V0, -32604(GP)
9D013AD8  8C420044   LW V0, 68(V0)
9D013ADC  14400006   BNE V0, ZERO, 0x9D013AF8
9D013AE0  8FBF0004   LW RA, 4(SP)
3892:                				{
3893:                					portENABLE_INTERRUPTS();
9D013AE4  40026000   MFC0 V0, Status
9D013AE8  7C027A84   INS V0, ZERO, 10, 6
9D013AEC  40826000   MTC0 V0, Status
9D013AF0  000000C0   EHB
3894:                				}
3895:                				else
3896:                				{
3897:                					mtCOVERAGE_TEST_MARKER();
3898:                				}
3899:                			}
3900:                			else
3901:                			{
3902:                				mtCOVERAGE_TEST_MARKER();
3903:                			}
3904:                		}
3905:                		else
3906:                		{
3907:                			mtCOVERAGE_TEST_MARKER();
3908:                		}
3909:                	}
9D013AF4  8FBF0004   LW RA, 4(SP)
9D013AF8  03E00008   JR RA
9D013AFC  27BD0008   ADDIU SP, SP, 8
3910:                
3911:                #endif /* portCRITICAL_NESTING_IN_TCB */
3912:                /*-----------------------------------------------------------*/
3913:                
3914:                #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
3915:                
3916:                	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName )
3917:                	{
3918:                	size_t x;
3919:                
3920:                		/* Start by copying the entire string. */
3921:                		strcpy( pcBuffer, pcTaskName );
3922:                
3923:                		/* Pad the end of the string with spaces to ensure columns line up when
3924:                		printed out. */
3925:                		for( x = strlen( pcBuffer ); x < ( size_t ) ( configMAX_TASK_NAME_LEN - 1 ); x++ )
3926:                		{
3927:                			pcBuffer[ x ] = ' ';
3928:                		}
3929:                
3930:                		/* Terminate. */
3931:                		pcBuffer[ x ] = 0x00;
3932:                
3933:                		/* Return the new end of string. */
3934:                		return &( pcBuffer[ x ] );
3935:                	}
3936:                
3937:                #endif /* ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) */
3938:                /*-----------------------------------------------------------*/
3939:                
3940:                #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
3941:                
3942:                	void vTaskList( char * pcWriteBuffer )
3943:                	{
3944:                	TaskStatus_t *pxTaskStatusArray;
3945:                	volatile UBaseType_t uxArraySize, x;
3946:                	char cStatus;
3947:                
3948:                		/*
3949:                		 * PLEASE NOTE:
3950:                		 *
3951:                		 * This function is provided for convenience only, and is used by many
3952:                		 * of the demo applications.  Do not consider it to be part of the
3953:                		 * scheduler.
3954:                		 *
3955:                		 * vTaskList() calls uxTaskGetSystemState(), then formats part of the
3956:                		 * uxTaskGetSystemState() output into a human readable table that
3957:                		 * displays task names, states and stack usage.
3958:                		 *
3959:                		 * vTaskList() has a dependency on the sprintf() C library function that
3960:                		 * might bloat the code size, use a lot of stack, and provide different
3961:                		 * results on different platforms.  An alternative, tiny, third party,
3962:                		 * and limited functionality implementation of sprintf() is provided in
3963:                		 * many of the FreeRTOS/Demo sub-directories in a file called
3964:                		 * printf-stdarg.c (note printf-stdarg.c does not provide a full
3965:                		 * snprintf() implementation!).
3966:                		 *
3967:                		 * It is recommended that production systems call uxTaskGetSystemState()
3968:                		 * directly to get access to raw stats data, rather than indirectly
3969:                		 * through a call to vTaskList().
3970:                		 */
3971:                
3972:                
3973:                		/* Make sure the write buffer does not contain a string. */
3974:                		*pcWriteBuffer = 0x00;
3975:                
3976:                		/* Take a snapshot of the number of tasks in case it changes while this
3977:                		function is executing. */
3978:                		uxArraySize = uxCurrentNumberOfTasks;
3979:                
3980:                		/* Allocate an array index for each task.  NOTE!  if
3981:                		configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
3982:                		equate to NULL. */
3983:                		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) );
3984:                
3985:                		if( pxTaskStatusArray != NULL )
3986:                		{
3987:                			/* Generate the (binary) data. */
3988:                			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, NULL );
3989:                
3990:                			/* Create a human readable table from the binary data. */
3991:                			for( x = 0; x < uxArraySize; x++ )
3992:                			{
3993:                				switch( pxTaskStatusArray[ x ].eCurrentState )
3994:                				{
3995:                					case eReady:		cStatus = tskREADY_CHAR;
3996:                										break;
3997:                
3998:                					case eBlocked:		cStatus = tskBLOCKED_CHAR;
3999:                										break;
4000:                
4001:                					case eSuspended:	cStatus = tskSUSPENDED_CHAR;
4002:                										break;
4003:                
4004:                					case eDeleted:		cStatus = tskDELETED_CHAR;
4005:                										break;
4006:                
4007:                					default:			/* Should not get here, but it is included
4008:                										to prevent static checking errors. */
4009:                										cStatus = 0x00;
4010:                										break;
4011:                				}
4012:                
4013:                				/* Write the task name to the string, padding with spaces so it
4014:                				can be printed in tabular form more easily. */
4015:                				pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
4016:                
4017:                				/* Write the rest of the string. */
4018:                				sprintf( pcWriteBuffer, "\t%c\t%u\t%u\t%u\r\n", cStatus, ( unsigned int ) pxTaskStatusArray[ x ].uxCurrentPriority, ( unsigned int ) pxTaskStatusArray[ x ].usStackHighWaterMark, ( unsigned int ) pxTaskStatusArray[ x ].xTaskNumber );
4019:                				pcWriteBuffer += strlen( pcWriteBuffer );
4020:                			}
4021:                
4022:                			/* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
4023:                			is 0 then vPortFree() will be #defined to nothing. */
4024:                			vPortFree( pxTaskStatusArray );
4025:                		}
4026:                		else
4027:                		{
4028:                			mtCOVERAGE_TEST_MARKER();
4029:                		}
4030:                	}
4031:                
4032:                #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) ) */
4033:                /*----------------------------------------------------------*/
4034:                
4035:                #if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
4036:                
4037:                	void vTaskGetRunTimeStats( char *pcWriteBuffer )
4038:                	{
4039:                	TaskStatus_t *pxTaskStatusArray;
4040:                	volatile UBaseType_t uxArraySize, x;
4041:                	uint32_t ulTotalTime, ulStatsAsPercentage;
4042:                
4043:                		#if( configUSE_TRACE_FACILITY != 1 )
4044:                		{
4045:                			#error configUSE_TRACE_FACILITY must also be set to 1 in FreeRTOSConfig.h to use vTaskGetRunTimeStats().
4046:                		}
4047:                		#endif
4048:                
4049:                		/*
4050:                		 * PLEASE NOTE:
4051:                		 *
4052:                		 * This function is provided for convenience only, and is used by many
4053:                		 * of the demo applications.  Do not consider it to be part of the
4054:                		 * scheduler.
4055:                		 *
4056:                		 * vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part
4057:                		 * of the uxTaskGetSystemState() output into a human readable table that
4058:                		 * displays the amount of time each task has spent in the Running state
4059:                		 * in both absolute and percentage terms.
4060:                		 *
4061:                		 * vTaskGetRunTimeStats() has a dependency on the sprintf() C library
4062:                		 * function that might bloat the code size, use a lot of stack, and
4063:                		 * provide different results on different platforms.  An alternative,
4064:                		 * tiny, third party, and limited functionality implementation of
4065:                		 * sprintf() is provided in many of the FreeRTOS/Demo sub-directories in
4066:                		 * a file called printf-stdarg.c (note printf-stdarg.c does not provide
4067:                		 * a full snprintf() implementation!).
4068:                		 *
4069:                		 * It is recommended that production systems call uxTaskGetSystemState()
4070:                		 * directly to get access to raw stats data, rather than indirectly
4071:                		 * through a call to vTaskGetRunTimeStats().
4072:                		 */
4073:                
4074:                		/* Make sure the write buffer does not contain a string. */
4075:                		*pcWriteBuffer = 0x00;
4076:                
4077:                		/* Take a snapshot of the number of tasks in case it changes while this
4078:                		function is executing. */
4079:                		uxArraySize = uxCurrentNumberOfTasks;
4080:                
4081:                		/* Allocate an array index for each task.  NOTE!  If
4082:                		configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
4083:                		equate to NULL. */
4084:                		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) );
4085:                
4086:                		if( pxTaskStatusArray != NULL )
4087:                		{
4088:                			/* Generate the (binary) data. */
4089:                			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalTime );
4090:                
4091:                			/* For percentage calculations. */
4092:                			ulTotalTime /= 100UL;
4093:                
4094:                			/* Avoid divide by zero errors. */
4095:                			if( ulTotalTime > 0 )
4096:                			{
4097:                				/* Create a human readable table from the binary data. */
4098:                				for( x = 0; x < uxArraySize; x++ )
4099:                				{
4100:                					/* What percentage of the total run time has the task used?
4101:                					This will always be rounded down to the nearest integer.
4102:                					ulTotalRunTimeDiv100 has already been divided by 100. */
4103:                					ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalTime;
4104:                
4105:                					/* Write the task name to the string, padding with
4106:                					spaces so it can be printed in tabular form more
4107:                					easily. */
4108:                					pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
4109:                
4110:                					if( ulStatsAsPercentage > 0UL )
4111:                					{
4112:                						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
4113:                						{
4114:                							sprintf( pcWriteBuffer, "\t%lu\t\t%lu%%\r\n", pxTaskStatusArray[ x ].ulRunTimeCounter, ulStatsAsPercentage );
4115:                						}
4116:                						#else
4117:                						{
4118:                							/* sizeof( int ) == sizeof( long ) so a smaller
4119:                							printf() library can be used. */
4120:                							sprintf( pcWriteBuffer, "\t%u\t\t%u%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTimeCounter, ( unsigned int ) ulStatsAsPercentage );
4121:                						}
4122:                						#endif
4123:                					}
4124:                					else
4125:                					{
4126:                						/* If the percentage is zero here then the task has
4127:                						consumed less than 1% of the total run time. */
4128:                						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
4129:                						{
4130:                							sprintf( pcWriteBuffer, "\t%lu\t\t<1%%\r\n", pxTaskStatusArray[ x ].ulRunTimeCounter );
4131:                						}
4132:                						#else
4133:                						{
4134:                							/* sizeof( int ) == sizeof( long ) so a smaller
4135:                							printf() library can be used. */
4136:                							sprintf( pcWriteBuffer, "\t%u\t\t<1%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTimeCounter );
4137:                						}
4138:                						#endif
4139:                					}
4140:                
4141:                					pcWriteBuffer += strlen( pcWriteBuffer );
4142:                				}
4143:                			}
4144:                			else
4145:                			{
4146:                				mtCOVERAGE_TEST_MARKER();
4147:                			}
4148:                
4149:                			/* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
4150:                			is 0 then vPortFree() will be #defined to nothing. */
4151:                			vPortFree( pxTaskStatusArray );
4152:                		}
4153:                		else
4154:                		{
4155:                			mtCOVERAGE_TEST_MARKER();
4156:                		}
4157:                	}
4158:                
4159:                #endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) ) */
4160:                /*-----------------------------------------------------------*/
4161:                
4162:                TickType_t uxTaskResetEventItemValue( void )
4163:                {
4164:                TickType_t uxReturn;
4165:                
4166:                	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
4167:                
4168:                	/* Reset the event list item to its normal value - so it can be used with
4169:                	queues and semaphores. */
4170:                	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
4171:                
4172:                	return uxReturn;
4173:                }
4174:                /*-----------------------------------------------------------*/
4175:                
4176:                #if ( configUSE_MUTEXES == 1 )
4177:                
4178:                	void *pvTaskIncrementMutexHeldCount( void )
4179:                	{
4180:                		/* If xSemaphoreCreateMutex() is called before any tasks have been created
4181:                		then pxCurrentTCB will be NULL. */
4182:                		if( pxCurrentTCB != NULL )
9D0152D4  8F8280A4   LW V0, -32604(GP)
9D0152D8  10400005   BEQ V0, ZERO, 0x9D0152F0
9D0152DC  00000000   NOP
4183:                		{
4184:                			( pxCurrentTCB->uxMutexesHeld )++;
9D0152E0  8F8280A4   LW V0, -32604(GP)
9D0152E4  8C43004C   LW V1, 76(V0)
9D0152E8  24630001   ADDIU V1, V1, 1
9D0152EC  AC43004C   SW V1, 76(V0)
4185:                		}
4186:                
4187:                		return pxCurrentTCB;
9D0152F0  8F8280A4   LW V0, -32604(GP)
4188:                	}
9D0152F4  03E00008   JR RA
9D0152F8  00000000   NOP
4189:                
4190:                #endif /* configUSE_MUTEXES */
4191:                /*-----------------------------------------------------------*/
4192:                
4193:                #if( configUSE_TASK_NOTIFICATIONS == 1 )
4194:                
4195:                	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
4196:                	{
4197:                	uint32_t ulReturn;
4198:                
4199:                		taskENTER_CRITICAL();
4200:                		{
4201:                			/* Only block if the notification count is not already non-zero. */
4202:                			if( pxCurrentTCB->ulNotifiedValue == 0UL )
4203:                			{
4204:                				/* Mark this task as waiting for a notification. */
4205:                				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
4206:                
4207:                				if( xTicksToWait > ( TickType_t ) 0 )
4208:                				{
4209:                					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
4210:                					traceTASK_NOTIFY_TAKE_BLOCK();
4211:                
4212:                					/* All ports are written to allow a yield in a critical
4213:                					section (some will yield immediately, others wait until the
4214:                					critical section exits) - but it is not something that
4215:                					application code should ever do. */
4216:                					portYIELD_WITHIN_API();
4217:                				}
4218:                				else
4219:                				{
4220:                					mtCOVERAGE_TEST_MARKER();
4221:                				}
4222:                			}
4223:                			else
4224:                			{
4225:                				mtCOVERAGE_TEST_MARKER();
4226:                			}
4227:                		}
4228:                		taskEXIT_CRITICAL();
4229:                
4230:                		taskENTER_CRITICAL();
4231:                		{
4232:                			traceTASK_NOTIFY_TAKE();
4233:                			ulReturn = pxCurrentTCB->ulNotifiedValue;
4234:                
4235:                			if( ulReturn != 0UL )
4236:                			{
4237:                				if( xClearCountOnExit != pdFALSE )
4238:                				{
4239:                					pxCurrentTCB->ulNotifiedValue = 0UL;
4240:                				}
4241:                				else
4242:                				{
4243:                					pxCurrentTCB->ulNotifiedValue = ulReturn - 1;
4244:                				}
4245:                			}
4246:                			else
4247:                			{
4248:                				mtCOVERAGE_TEST_MARKER();
4249:                			}
4250:                
4251:                			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
4252:                		}
4253:                		taskEXIT_CRITICAL();
4254:                
4255:                		return ulReturn;
4256:                	}
4257:                
4258:                #endif /* configUSE_TASK_NOTIFICATIONS */
4259:                /*-----------------------------------------------------------*/
4260:                
4261:                #if( configUSE_TASK_NOTIFICATIONS == 1 )
4262:                
4263:                	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
4264:                	{
4265:                	BaseType_t xReturn;
4266:                
4267:                		taskENTER_CRITICAL();
4268:                		{
4269:                			/* Only block if a notification is not already pending. */
4270:                			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
4271:                			{
4272:                				/* Clear bits in the task's notification value as bits may get
4273:                				set	by the notifying task or interrupt.  This can be used to
4274:                				clear the value to zero. */
4275:                				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
4276:                
4277:                				/* Mark this task as waiting for a notification. */
4278:                				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
4279:                
4280:                				if( xTicksToWait > ( TickType_t ) 0 )
4281:                				{
4282:                					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
4283:                					traceTASK_NOTIFY_WAIT_BLOCK();
4284:                
4285:                					/* All ports are written to allow a yield in a critical
4286:                					section (some will yield immediately, others wait until the
4287:                					critical section exits) - but it is not something that
4288:                					application code should ever do. */
4289:                					portYIELD_WITHIN_API();
4290:                				}
4291:                				else
4292:                				{
4293:                					mtCOVERAGE_TEST_MARKER();
4294:                				}
4295:                			}
4296:                			else
4297:                			{
4298:                				mtCOVERAGE_TEST_MARKER();
4299:                			}
4300:                		}
4301:                		taskEXIT_CRITICAL();
4302:                
4303:                		taskENTER_CRITICAL();
4304:                		{
4305:                			traceTASK_NOTIFY_WAIT();
4306:                
4307:                			if( pulNotificationValue != NULL )
4308:                			{
4309:                				/* Output the current notification value, which may or may not
4310:                				have changed. */
4311:                				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
4312:                			}
4313:                
4314:                			/* If ucNotifyValue is set then either the task never entered the
4315:                			blocked state (because a notification was already pending) or the
4316:                			task unblocked because of a notification.  Otherwise the task
4317:                			unblocked because of a timeout. */
4318:                			if( pxCurrentTCB->ucNotifyState == taskWAITING_NOTIFICATION )
4319:                			{
4320:                				/* A notification was not received. */
4321:                				xReturn = pdFALSE;
4322:                			}
4323:                			else
4324:                			{
4325:                				/* A notification was already pending or a notification was
4326:                				received while the task was waiting. */
4327:                				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
4328:                				xReturn = pdTRUE;
4329:                			}
4330:                
4331:                			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
4332:                		}
4333:                		taskEXIT_CRITICAL();
4334:                
4335:                		return xReturn;
4336:                	}
4337:                
4338:                #endif /* configUSE_TASK_NOTIFICATIONS */
4339:                /*-----------------------------------------------------------*/
4340:                
4341:                #if( configUSE_TASK_NOTIFICATIONS == 1 )
4342:                
4343:                	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
4344:                	{
4345:                	TCB_t * pxTCB;
4346:                	BaseType_t xReturn = pdPASS;
4347:                	uint8_t ucOriginalNotifyState;
4348:                
4349:                		configASSERT( xTaskToNotify );
4350:                		pxTCB = ( TCB_t * ) xTaskToNotify;
4351:                
4352:                		taskENTER_CRITICAL();
4353:                		{
4354:                			if( pulPreviousNotificationValue != NULL )
4355:                			{
4356:                				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
4357:                			}
4358:                
4359:                			ucOriginalNotifyState = pxTCB->ucNotifyState;
4360:                
4361:                			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
4362:                
4363:                			switch( eAction )
4364:                			{
4365:                				case eSetBits	:
4366:                					pxTCB->ulNotifiedValue |= ulValue;
4367:                					break;
4368:                
4369:                				case eIncrement	:
4370:                					( pxTCB->ulNotifiedValue )++;
4371:                					break;
4372:                
4373:                				case eSetValueWithOverwrite	:
4374:                					pxTCB->ulNotifiedValue = ulValue;
4375:                					break;
4376:                
4377:                				case eSetValueWithoutOverwrite :
4378:                					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
4379:                					{
4380:                						pxTCB->ulNotifiedValue = ulValue;
4381:                					}
4382:                					else
4383:                					{
4384:                						/* The value could not be written to the task. */
4385:                						xReturn = pdFAIL;
4386:                					}
4387:                					break;
4388:                
4389:                				case eNoAction:
4390:                					/* The task is being notified without its notify value being
4391:                					updated. */
4392:                					break;
4393:                			}
4394:                
4395:                			traceTASK_NOTIFY();
4396:                
4397:                			/* If the task is in the blocked state specifically to wait for a
4398:                			notification then unblock it now. */
4399:                			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
4400:                			{
4401:                				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
4402:                				prvAddTaskToReadyList( pxTCB );
4403:                
4404:                				/* The task should not have been on an event list. */
4405:                				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
4406:                
4407:                				#if( configUSE_TICKLESS_IDLE != 0 )
4408:                				{
4409:                					/* If a task is blocked waiting for a notification then
4410:                					xNextTaskUnblockTime might be set to the blocked task's time
4411:                					out time.  If the task is unblocked for a reason other than
4412:                					a timeout xNextTaskUnblockTime is normally left unchanged,
4413:                					because it will automatically get reset to a new value when
4414:                					the tick count equals xNextTaskUnblockTime.  However if
4415:                					tickless idling is used it might be more important to enter
4416:                					sleep mode at the earliest possible time - so reset
4417:                					xNextTaskUnblockTime here to ensure it is updated at the
4418:                					earliest possible time. */
4419:                					prvResetNextTaskUnblockTime();
4420:                				}
4421:                				#endif
4422:                
4423:                				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
4424:                				{
4425:                					/* The notified task has a priority above the currently
4426:                					executing task so a yield is required. */
4427:                					taskYIELD_IF_USING_PREEMPTION();
4428:                				}
4429:                				else
4430:                				{
4431:                					mtCOVERAGE_TEST_MARKER();
4432:                				}
4433:                			}
4434:                			else
4435:                			{
4436:                				mtCOVERAGE_TEST_MARKER();
4437:                			}
4438:                		}
4439:                		taskEXIT_CRITICAL();
4440:                
4441:                		return xReturn;
4442:                	}
4443:                
4444:                #endif /* configUSE_TASK_NOTIFICATIONS */
4445:                /*-----------------------------------------------------------*/
4446:                
4447:                #if( configUSE_TASK_NOTIFICATIONS == 1 )
4448:                
4449:                	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
4450:                	{
4451:                	TCB_t * pxTCB;
4452:                	uint8_t ucOriginalNotifyState;
4453:                	BaseType_t xReturn = pdPASS;
4454:                	UBaseType_t uxSavedInterruptStatus;
4455:                
4456:                		configASSERT( xTaskToNotify );
4457:                
4458:                		/* RTOS ports that support interrupt nesting have the concept of a
4459:                		maximum	system call (or maximum API call) interrupt priority.
4460:                		Interrupts that are	above the maximum system call priority are keep
4461:                		permanently enabled, even when the RTOS kernel is in a critical section,
4462:                		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
4463:                		is defined in FreeRTOSConfig.h then
4464:                		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
4465:                		failure if a FreeRTOS API function is called from an interrupt that has
4466:                		been assigned a priority above the configured maximum system call
4467:                		priority.  Only FreeRTOS functions that end in FromISR can be called
4468:                		from interrupts	that have been assigned a priority at or (logically)
4469:                		below the maximum system call interrupt priority.  FreeRTOS maintains a
4470:                		separate interrupt safe API to ensure interrupt entry is as fast and as
4471:                		simple as possible.  More information (albeit Cortex-M specific) is
4472:                		provided on the following link:
4473:                		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
4474:                		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
4475:                
4476:                		pxTCB = ( TCB_t * ) xTaskToNotify;
4477:                
4478:                		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
4479:                		{
4480:                			if( pulPreviousNotificationValue != NULL )
4481:                			{
4482:                				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
4483:                			}
4484:                
4485:                			ucOriginalNotifyState = pxTCB->ucNotifyState;
4486:                			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
4487:                
4488:                			switch( eAction )
4489:                			{
4490:                				case eSetBits	:
4491:                					pxTCB->ulNotifiedValue |= ulValue;
4492:                					break;
4493:                
4494:                				case eIncrement	:
4495:                					( pxTCB->ulNotifiedValue )++;
4496:                					break;
4497:                
4498:                				case eSetValueWithOverwrite	:
4499:                					pxTCB->ulNotifiedValue = ulValue;
4500:                					break;
4501:                
4502:                				case eSetValueWithoutOverwrite :
4503:                					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
4504:                					{
4505:                						pxTCB->ulNotifiedValue = ulValue;
4506:                					}
4507:                					else
4508:                					{
4509:                						/* The value could not be written to the task. */
4510:                						xReturn = pdFAIL;
4511:                					}
4512:                					break;
4513:                
4514:                				case eNoAction :
4515:                					/* The task is being notified without its notify value being
4516:                					updated. */
4517:                					break;
4518:                			}
4519:                
4520:                			traceTASK_NOTIFY_FROM_ISR();
4521:                
4522:                			/* If the task is in the blocked state specifically to wait for a
4523:                			notification then unblock it now. */
4524:                			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
4525:                			{
4526:                				/* The task should not have been on an event list. */
4527:                				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
4528:                
4529:                				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
4530:                				{
4531:                					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
4532:                					prvAddTaskToReadyList( pxTCB );
4533:                				}
4534:                				else
4535:                				{
4536:                					/* The delayed and ready lists cannot be accessed, so hold
4537:                					this task pending until the scheduler is resumed. */
4538:                					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
4539:                				}
4540:                
4541:                				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
4542:                				{
4543:                					/* The notified task has a priority above the currently
4544:                					executing task so a yield is required. */
4545:                					if( pxHigherPriorityTaskWoken != NULL )
4546:                					{
4547:                						*pxHigherPriorityTaskWoken = pdTRUE;
4548:                					}
4549:                					else
4550:                					{
4551:                						/* Mark that a yield is pending in case the user is not
4552:                						using the "xHigherPriorityTaskWoken" parameter to an ISR
4553:                						safe FreeRTOS function. */
4554:                						xYieldPending = pdTRUE;
4555:                					}
4556:                				}
4557:                				else
4558:                				{
4559:                					mtCOVERAGE_TEST_MARKER();
4560:                				}
4561:                			}
4562:                		}
4563:                		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
4564:                
4565:                		return xReturn;
4566:                	}
4567:                
4568:                #endif /* configUSE_TASK_NOTIFICATIONS */
4569:                /*-----------------------------------------------------------*/
4570:                
4571:                #if( configUSE_TASK_NOTIFICATIONS == 1 )
4572:                
4573:                	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
4574:                	{
4575:                	TCB_t * pxTCB;
4576:                	uint8_t ucOriginalNotifyState;
4577:                	UBaseType_t uxSavedInterruptStatus;
4578:                
4579:                		configASSERT( xTaskToNotify );
4580:                
4581:                		/* RTOS ports that support interrupt nesting have the concept of a
4582:                		maximum	system call (or maximum API call) interrupt priority.
4583:                		Interrupts that are	above the maximum system call priority are keep
4584:                		permanently enabled, even when the RTOS kernel is in a critical section,
4585:                		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
4586:                		is defined in FreeRTOSConfig.h then
4587:                		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
4588:                		failure if a FreeRTOS API function is called from an interrupt that has
4589:                		been assigned a priority above the configured maximum system call
4590:                		priority.  Only FreeRTOS functions that end in FromISR can be called
4591:                		from interrupts	that have been assigned a priority at or (logically)
4592:                		below the maximum system call interrupt priority.  FreeRTOS maintains a
4593:                		separate interrupt safe API to ensure interrupt entry is as fast and as
4594:                		simple as possible.  More information (albeit Cortex-M specific) is
4595:                		provided on the following link:
4596:                		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
4597:                		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
4598:                
4599:                		pxTCB = ( TCB_t * ) xTaskToNotify;
4600:                
4601:                		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
4602:                		{
4603:                			ucOriginalNotifyState = pxTCB->ucNotifyState;
4604:                			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
4605:                
4606:                			/* 'Giving' is equivalent to incrementing a count in a counting
4607:                			semaphore. */
4608:                			( pxTCB->ulNotifiedValue )++;
4609:                
4610:                			traceTASK_NOTIFY_GIVE_FROM_ISR();
4611:                
4612:                			/* If the task is in the blocked state specifically to wait for a
4613:                			notification then unblock it now. */
4614:                			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
4615:                			{
4616:                				/* The task should not have been on an event list. */
4617:                				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
4618:                
4619:                				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
4620:                				{
4621:                					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
4622:                					prvAddTaskToReadyList( pxTCB );
4623:                				}
4624:                				else
4625:                				{
4626:                					/* The delayed and ready lists cannot be accessed, so hold
4627:                					this task pending until the scheduler is resumed. */
4628:                					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
4629:                				}
4630:                
4631:                				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
4632:                				{
4633:                					/* The notified task has a priority above the currently
4634:                					executing task so a yield is required. */
4635:                					if( pxHigherPriorityTaskWoken != NULL )
4636:                					{
4637:                						*pxHigherPriorityTaskWoken = pdTRUE;
4638:                					}
4639:                					else
4640:                					{
4641:                						/* Mark that a yield is pending in case the user is not
4642:                						using the "xHigherPriorityTaskWoken" parameter in an ISR
4643:                						safe FreeRTOS function. */
4644:                						xYieldPending = pdTRUE;
4645:                					}
4646:                				}
4647:                				else
4648:                				{
4649:                					mtCOVERAGE_TEST_MARKER();
4650:                				}
4651:                			}
4652:                		}
4653:                		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
4654:                	}
4655:                
4656:                #endif /* configUSE_TASK_NOTIFICATIONS */
4657:                
4658:                /*-----------------------------------------------------------*/
4659:                
4660:                #if( configUSE_TASK_NOTIFICATIONS == 1 )
4661:                
4662:                	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
4663:                	{
4664:                	TCB_t *pxTCB;
4665:                	BaseType_t xReturn;
4666:                
4667:                		/* If null is passed in here then it is the calling task that is having
4668:                		its notification state cleared. */
4669:                		pxTCB = prvGetTCBFromHandle( xTask );
4670:                
4671:                		taskENTER_CRITICAL();
4672:                		{
4673:                			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
4674:                			{
4675:                				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
4676:                				xReturn = pdPASS;
4677:                			}
4678:                			else
4679:                			{
4680:                				xReturn = pdFAIL;
4681:                			}
4682:                		}
4683:                		taskEXIT_CRITICAL();
4684:                
4685:                		return xReturn;
4686:                	}
4687:                
4688:                #endif /* configUSE_TASK_NOTIFICATIONS */
4689:                /*-----------------------------------------------------------*/
4690:                
4691:                
4692:                static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
4693:                {
9D010934  27BDFFE0   ADDIU SP, SP, -32
9D010938  AFBF001C   SW RA, 28(SP)
9D01093C  AFB20018   SW S2, 24(SP)
9D010940  AFB10014   SW S1, 20(SP)
9D010944  AFB00010   SW S0, 16(SP)
9D010948  00808021   ADDU S0, A0, ZERO
9D01094C  00A09021   ADDU S2, A1, ZERO
4694:                TickType_t xTimeToWake;
4695:                const TickType_t xConstTickCount = xTickCount;
9D010950  8F918098   LW S1, -32616(GP)
4696:                
4697:                	#if( INCLUDE_xTaskAbortDelay == 1 )
4698:                	{
4699:                		/* About to enter a delayed list, so ensure the ucDelayAborted flag is
4700:                		reset to pdFALSE so it can be detected as having been set to pdTRUE
4701:                		when the task leaves the Blocked state. */
4702:                		pxCurrentTCB->ucDelayAborted = pdFALSE;
4703:                	}
4704:                	#endif
4705:                
4706:                	/* Remove the task from the ready list before adding it to the blocked list
4707:                	as the same list item is used for both lists. */
4708:                	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
9D010954  8F8480A4   LW A0, -32604(GP)
9D010958  0F4051D3   JAL uxListRemove
9D01095C  24840004   ADDIU A0, A0, 4
9D010960  1440000A   BNE V0, ZERO, 0x9D01098C
9D010964  2402FFFF   ADDIU V0, ZERO, -1
4709:                	{
4710:                		/* The current task must be in a ready list, so there is no need to
4711:                		check, and the port reset macro can be called directly. */
4712:                		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
9D010968  8F8280A4   LW V0, -32604(GP)
9D01096C  8F838094   LW V1, -32620(GP)
9D010970  8C42002C   LW V0, 44(V0)
9D010974  24040001   ADDIU A0, ZERO, 1
9D010978  00441004   SLLV V0, A0, V0
9D01097C  00021027   NOR V0, ZERO, V0
9D010980  00431024   AND V0, V0, V1
9D010984  AF828094   SW V0, -32620(GP)
4713:                	}
4714:                	else
4715:                	{
4716:                		mtCOVERAGE_TEST_MARKER();
4717:                	}
4718:                
4719:                	#if ( INCLUDE_vTaskSuspend == 1 )
4720:                	{
4721:                		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
9D010988  2402FFFF   ADDIU V0, ZERO, -1
9D01098C  1602000A   BNE S0, V0, 0x9D0109B8
9D010990  02118021   ADDU S0, S0, S1
9D010994  12400008   BEQ S2, ZERO, 0x9D0109B8
9D010998  00000000   NOP
4722:                		{
4723:                			/* Add the task to the suspended task list instead of a delayed task
4724:                			list to ensure it is not woken by a timing event.  It will block
4725:                			indefinitely. */
4726:                			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
9D01099C  8F8580A4   LW A1, -32604(GP)
9D0109A0  3C04A000   LUI A0, -24576
9D0109A4  24840EA8   ADDIU A0, A0, 3752
9D0109A8  0F405426   JAL vListInsertEnd
9D0109AC  24A50004   ADDIU A1, A1, 4
9D0109B0  0B404281   J 0x9D010A04
9D0109B4  8FBF001C   LW RA, 28(SP)
4727:                		}
4728:                		else
4729:                		{
4730:                			/* Calculate the time at which the task should be woken if the event
4731:                			does not occur.  This may overflow but this doesn't matter, the
4732:                			kernel will manage it correctly. */
4733:                			xTimeToWake = xConstTickCount + xTicksToWait;
4734:                
4735:                			/* The list item will be inserted in wake time order. */
4736:                			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
9D0109B8  8F8280A4   LW V0, -32604(GP)
4737:                
4738:                			if( xTimeToWake < xConstTickCount )
9D0109BC  0211882B   SLTU S1, S0, S1
9D0109C0  12200007   BEQ S1, ZERO, 0x9D0109E0
9D0109C4  AC500004   SW S0, 4(V0)
4739:                			{
4740:                				/* Wake time has overflowed.  Place this item in the overflow
4741:                				list. */
4742:                				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
9D0109C8  8F848168   LW A0, -32408(GP)
9D0109CC  8F8580A4   LW A1, -32604(GP)
9D0109D0  0F404F07   JAL vListInsert
9D0109D4  24A50004   ADDIU A1, A1, 4
9D0109D8  0B404281   J 0x9D010A04
9D0109DC  8FBF001C   LW RA, 28(SP)
4743:                			}
4744:                			else
4745:                			{
4746:                				/* The wake time has not overflowed, so the current block list
4747:                				is used. */
4748:                				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
9D0109E0  8F848164   LW A0, -32412(GP)
9D0109E4  8F8580A4   LW A1, -32604(GP)
9D0109E8  0F404F07   JAL vListInsert
9D0109EC  24A50004   ADDIU A1, A1, 4
4749:                
4750:                				/* If the task entering the blocked state was placed at the
4751:                				head of the list of blocked tasks then xNextTaskUnblockTime
4752:                				needs to be updated too. */
4753:                				if( xTimeToWake < xNextTaskUnblockTime )
9D0109F0  8F82807C   LW V0, -32644(GP)
9D0109F4  0202102B   SLTU V0, S0, V0
9D0109F8  54400001   BNEL V0, ZERO, 0x9D010A00
9D0109FC  AF90807C   SW S0, -32644(GP)
4754:                				{
4755:                					xNextTaskUnblockTime = xTimeToWake;
4756:                				}
4757:                				else
4758:                				{
4759:                					mtCOVERAGE_TEST_MARKER();
4760:                				}
4761:                			}
4762:                		}
4763:                	}
4764:                	#else /* INCLUDE_vTaskSuspend */
4765:                	{
4766:                		/* Calculate the time at which the task should be woken if the event
4767:                		does not occur.  This may overflow but this doesn't matter, the kernel
4768:                		will manage it correctly. */
4769:                		xTimeToWake = xConstTickCount + xTicksToWait;
4770:                
4771:                		/* The list item will be inserted in wake time order. */
4772:                		listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
4773:                
4774:                		if( xTimeToWake < xConstTickCount )
4775:                		{
4776:                			/* Wake time has overflowed.  Place this item in the overflow list. */
4777:                			vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
4778:                		}
4779:                		else
4780:                		{
4781:                			/* The wake time has not overflowed, so the current block list is used. */
4782:                			vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
4783:                
4784:                			/* If the task entering the blocked state was placed at the head of the
4785:                			list of blocked tasks then xNextTaskUnblockTime needs to be updated
4786:                			too. */
4787:                			if( xTimeToWake < xNextTaskUnblockTime )
4788:                			{
4789:                				xNextTaskUnblockTime = xTimeToWake;
4790:                			}
4791:                			else
4792:                			{
4793:                				mtCOVERAGE_TEST_MARKER();
4794:                			}
4795:                		}
4796:                
4797:                		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
4798:                		( void ) xCanBlockIndefinitely;
4799:                	}
4800:                	#endif /* INCLUDE_vTaskSuspend */
4801:                }
9D010A00  8FBF001C   LW RA, 28(SP)
9D010A04  8FB20018   LW S2, 24(SP)
9D010A08  8FB10014   LW S1, 20(SP)
9D010A0C  8FB00010   LW S0, 16(SP)
9D010A10  03E00008   JR RA
9D010A14  27BD0020   ADDIU SP, SP, 32
4802:                
4803:                
4804:                #ifdef FREERTOS_MODULE_TEST
4805:                	#include "tasks_test_access_functions.h"
4806:                #endif
4807:                
---  /home/whatisthis/microchip/harmony/v2_04/third_party/rtos/FreeRTOS/Source/queue.c  -----------------
1:                   /*
2:                       FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
3:                       All rights reserved
4:                   
5:                       VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
6:                   
7:                       This file is part of the FreeRTOS distribution.
8:                   
9:                       FreeRTOS is free software; you can redistribute it and/or modify it under
10:                      the terms of the GNU General Public License (version 2) as published by the
11:                      Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
12:                  
13:                      ***************************************************************************
14:                      >>!   NOTE: The modification to the GPL is included to allow you to     !<<
15:                      >>!   distribute a combined work that includes FreeRTOS without being   !<<
16:                      >>!   obliged to provide the source code for proprietary components     !<<
17:                      >>!   outside of the FreeRTOS kernel.                                   !<<
18:                      ***************************************************************************
19:                  
20:                      FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
21:                      WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
22:                      FOR A PARTICULAR PURPOSE.  Full license text is available on the following
23:                      link: http://www.freertos.org/a00114.html
24:                  
25:                      ***************************************************************************
26:                       *                                                                       *
27:                       *    FreeRTOS provides completely free yet professionally developed,    *
28:                       *    robust, strictly quality controlled, supported, and cross          *
29:                       *    platform software that is more than just the market leader, it     *
30:                       *    is the industry's de facto standard.                               *
31:                       *                                                                       *
32:                       *    Help yourself get started quickly while simultaneously helping     *
33:                       *    to support the FreeRTOS project by purchasing a FreeRTOS           *
34:                       *    tutorial book, reference manual, or both:                          *
35:                       *    http://www.FreeRTOS.org/Documentation                              *
36:                       *                                                                       *
37:                      ***************************************************************************
38:                  
39:                      http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
40:                      the FAQ page "My application does not run, what could be wrong?".  Have you
41:                      defined configASSERT()?
42:                  
43:                      http://www.FreeRTOS.org/support - In return for receiving this top quality
44:                      embedded software for free we request you assist our global community by
45:                      participating in the support forum.
46:                  
47:                      http://www.FreeRTOS.org/training - Investing in training allows your team to
48:                      be as productive as possible as early as possible.  Now you can receive
49:                      FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
50:                      Ltd, and the world's leading authority on the world's leading RTOS.
51:                  
52:                      http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
53:                      including FreeRTOS+Trace - an indispensable productivity tool, a DOS
54:                      compatible FAT file system, and our tiny thread aware UDP/IP stack.
55:                  
56:                      http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
57:                      Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
58:                  
59:                      http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
60:                      Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
61:                      licenses offer ticketed support, indemnification and commercial middleware.
62:                  
63:                      http://www.SafeRTOS.com - High Integrity Systems also provide a safety
64:                      engineered and independently SIL3 certified version for use in safety and
65:                      mission critical applications that require provable dependability.
66:                  
67:                      1 tab == 4 spaces!
68:                  */
69:                  
70:                  #include <stdlib.h>
71:                  #include <string.h>
72:                  
73:                  /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
74:                  all the API functions to use the MPU wrappers.  That should only be done when
75:                  task.h is included from an application file. */
76:                  #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
77:                  
78:                  #include "FreeRTOS.h"
79:                  #include "task.h"
80:                  #include "queue.h"
81:                  
82:                  #if ( configUSE_CO_ROUTINES == 1 )
83:                  	#include "croutine.h"
84:                  #endif
85:                  
86:                  /* Lint e961 and e750 are suppressed as a MISRA exception justified because the
87:                  MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
88:                  header files above, but not in this file, in order to generate the correct
89:                  privileged Vs unprivileged linkage and placement. */
90:                  #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
91:                  
92:                  
93:                  /* Constants used with the cRxLock and cTxLock structure members. */
94:                  #define queueUNLOCKED					( ( int8_t ) -1 )
95:                  #define queueLOCKED_UNMODIFIED			( ( int8_t ) 0 )
96:                  
97:                  /* When the Queue_t structure is used to represent a base queue its pcHead and
98:                  pcTail members are used as pointers into the queue storage area.  When the
99:                  Queue_t structure is used to represent a mutex pcHead and pcTail pointers are
100:                 not necessary, and the pcHead pointer is set to NULL to indicate that the
101:                 pcTail pointer actually points to the mutex holder (if any).  Map alternative
102:                 names to the pcHead and pcTail structure members to ensure the readability of
103:                 the code is maintained despite this dual use of two structure members.  An
104:                 alternative implementation would be to use a union, but use of a union is
105:                 against the coding standard (although an exception to the standard has been
106:                 permitted where the dual use also significantly changes the type of the
107:                 structure member). */
108:                 #define pxMutexHolder					pcTail
109:                 #define uxQueueType						pcHead
110:                 #define queueQUEUE_IS_MUTEX				NULL
111:                 
112:                 /* Semaphores do not actually store or copy data, so have an item size of
113:                 zero. */
114:                 #define queueSEMAPHORE_QUEUE_ITEM_LENGTH ( ( UBaseType_t ) 0 )
115:                 #define queueMUTEX_GIVE_BLOCK_TIME		 ( ( TickType_t ) 0U )
116:                 
117:                 #if( configUSE_PREEMPTION == 0 )
118:                 	/* If the cooperative scheduler is being used then a yield should not be
119:                 	performed just because a higher priority task has been woken. */
120:                 	#define queueYIELD_IF_USING_PREEMPTION()
121:                 #else
122:                 	#define queueYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
123:                 #endif
124:                 
125:                 /*
126:                  * Definition of the queue used by the scheduler.
127:                  * Items are queued by copy, not reference.  See the following link for the
128:                  * rationale: http://www.freertos.org/Embedded-RTOS-Queues.html
129:                  */
130:                 typedef struct QueueDefinition
131:                 {
132:                 	int8_t *pcHead;					/*< Points to the beginning of the queue storage area. */
133:                 	int8_t *pcTail;					/*< Points to the byte at the end of the queue storage area.  Once more byte is allocated than necessary to store the queue items, this is used as a marker. */
134:                 	int8_t *pcWriteTo;				/*< Points to the free next place in the storage area. */
135:                 
136:                 	union							/* Use of a union is an exception to the coding standard to ensure two mutually exclusive structure members don't appear simultaneously (wasting RAM). */
137:                 	{
138:                 		int8_t *pcReadFrom;			/*< Points to the last place that a queued item was read from when the structure is used as a queue. */
139:                 		UBaseType_t uxRecursiveCallCount;/*< Maintains a count of the number of times a recursive mutex has been recursively 'taken' when the structure is used as a mutex. */
140:                 	} u;
141:                 
142:                 	List_t xTasksWaitingToSend;		/*< List of tasks that are blocked waiting to post onto this queue.  Stored in priority order. */
143:                 	List_t xTasksWaitingToReceive;	/*< List of tasks that are blocked waiting to read from this queue.  Stored in priority order. */
144:                 
145:                 	volatile UBaseType_t uxMessagesWaiting;/*< The number of items currently in the queue. */
146:                 	UBaseType_t uxLength;			/*< The length of the queue defined as the number of items it will hold, not the number of bytes. */
147:                 	UBaseType_t uxItemSize;			/*< The size of each items that the queue will hold. */
148:                 
149:                 	volatile int8_t cRxLock;		/*< Stores the number of items received from the queue (removed from the queue) while the queue was locked.  Set to queueUNLOCKED when the queue is not locked. */
150:                 	volatile int8_t cTxLock;		/*< Stores the number of items transmitted to the queue (added to the queue) while the queue was locked.  Set to queueUNLOCKED when the queue is not locked. */
151:                 
152:                 	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
153:                 		uint8_t ucStaticallyAllocated;	/*< Set to pdTRUE if the memory used by the queue was statically allocated to ensure no attempt is made to free the memory. */
154:                 	#endif
155:                 
156:                 	#if ( configUSE_QUEUE_SETS == 1 )
157:                 		struct QueueDefinition *pxQueueSetContainer;
158:                 	#endif
159:                 
160:                 	#if ( configUSE_TRACE_FACILITY == 1 )
161:                 		UBaseType_t uxQueueNumber;
162:                 		uint8_t ucQueueType;
163:                 	#endif
164:                 
165:                 } xQUEUE;
166:                 
167:                 /* The old xQUEUE name is maintained above then typedefed to the new Queue_t
168:                 name below to enable the use of older kernel aware debuggers. */
169:                 typedef xQUEUE Queue_t;
170:                 
171:                 /*-----------------------------------------------------------*/
172:                 
173:                 /*
174:                  * The queue registry is just a means for kernel aware debuggers to locate
175:                  * queue structures.  It has no other purpose so is an optional component.
176:                  */
177:                 #if ( configQUEUE_REGISTRY_SIZE > 0 )
178:                 
179:                 	/* The type stored within the queue registry array.  This allows a name
180:                 	to be assigned to each queue making kernel aware debugging a little
181:                 	more user friendly. */
182:                 	typedef struct QUEUE_REGISTRY_ITEM
183:                 	{
184:                 		const char *pcQueueName; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
185:                 		QueueHandle_t xHandle;
186:                 	} xQueueRegistryItem;
187:                 
188:                 	/* The old xQueueRegistryItem name is maintained above then typedefed to the
189:                 	new xQueueRegistryItem name below to enable the use of older kernel aware
190:                 	debuggers. */
191:                 	typedef xQueueRegistryItem QueueRegistryItem_t;
192:                 
193:                 	/* The queue registry is simply an array of QueueRegistryItem_t structures.
194:                 	The pcQueueName member of a structure being NULL is indicative of the
195:                 	array position being vacant. */
196:                 	PRIVILEGED_DATA QueueRegistryItem_t xQueueRegistry[ configQUEUE_REGISTRY_SIZE ];
197:                 
198:                 #endif /* configQUEUE_REGISTRY_SIZE */
199:                 
200:                 /*
201:                  * Unlocks a queue locked by a call to prvLockQueue.  Locking a queue does not
202:                  * prevent an ISR from adding or removing items to the queue, but does prevent
203:                  * an ISR from removing tasks from the queue event lists.  If an ISR finds a
204:                  * queue is locked it will instead increment the appropriate queue lock count
205:                  * to indicate that a task may require unblocking.  When the queue in unlocked
206:                  * these lock counts are inspected, and the appropriate action taken.
207:                  */
208:                 static void prvUnlockQueue( Queue_t * const pxQueue ) PRIVILEGED_FUNCTION;
209:                 
210:                 /*
211:                  * Uses a critical section to determine if there is any data in a queue.
212:                  *
213:                  * @return pdTRUE if the queue contains no items, otherwise pdFALSE.
214:                  */
215:                 static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue ) PRIVILEGED_FUNCTION;
216:                 
217:                 /*
218:                  * Uses a critical section to determine if there is any space in a queue.
219:                  *
220:                  * @return pdTRUE if there is no space, otherwise pdFALSE;
221:                  */
222:                 static BaseType_t prvIsQueueFull( const Queue_t *pxQueue ) PRIVILEGED_FUNCTION;
223:                 
224:                 /*
225:                  * Copies an item into the queue, either at the front of the queue or the
226:                  * back of the queue.
227:                  */
228:                 static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition ) PRIVILEGED_FUNCTION;
229:                 
230:                 /*
231:                  * Copies an item out of a queue.
232:                  */
233:                 static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer ) PRIVILEGED_FUNCTION;
234:                 
235:                 #if ( configUSE_QUEUE_SETS == 1 )
236:                 	/*
237:                 	 * Checks to see if a queue is a member of a queue set, and if so, notifies
238:                 	 * the queue set that the queue contains data.
239:                 	 */
240:                 	static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue, const BaseType_t xCopyPosition ) PRIVILEGED_FUNCTION;
241:                 #endif
242:                 
243:                 /*
244:                  * Called after a Queue_t structure has been allocated either statically or
245:                  * dynamically to fill in the structure's members.
246:                  */
247:                 static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue ) PRIVILEGED_FUNCTION;
248:                 
249:                 /*
250:                  * Mutexes are a special type of queue.  When a mutex is created, first the
251:                  * queue is created, then prvInitialiseMutex() is called to configure the queue
252:                  * as a mutex.
253:                  */
254:                 #if( configUSE_MUTEXES == 1 )
255:                 	static void prvInitialiseMutex( Queue_t *pxNewQueue ) PRIVILEGED_FUNCTION;
256:                 #endif
257:                 
258:                 /*-----------------------------------------------------------*/
259:                 
260:                 /*
261:                  * Macro to mark a queue as locked.  Locking a queue prevents an ISR from
262:                  * accessing the queue event lists.
263:                  */
264:                 #define prvLockQueue( pxQueue )								\
265:                 	taskENTER_CRITICAL();									\
266:                 	{														\
267:                 		if( ( pxQueue )->cRxLock == queueUNLOCKED )			\
268:                 		{													\
269:                 			( pxQueue )->cRxLock = queueLOCKED_UNMODIFIED;	\
270:                 		}													\
271:                 		if( ( pxQueue )->cTxLock == queueUNLOCKED )			\
272:                 		{													\
273:                 			( pxQueue )->cTxLock = queueLOCKED_UNMODIFIED;	\
274:                 		}													\
275:                 	}														\
276:                 	taskEXIT_CRITICAL()
277:                 /*-----------------------------------------------------------*/
278:                 
279:                 BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
280:                 {
9D011178  27BDFFE0   ADDIU SP, SP, -32
9D01117C  AFBF001C   SW RA, 28(SP)
9D011180  AFB10018   SW S1, 24(SP)
9D011184  AFB00014   SW S0, 20(SP)
9D011188  00808021   ADDU S0, A0, ZERO
281:                 Queue_t * const pxQueue = ( Queue_t * ) xQueue;
282:                 
283:                 	configASSERT( pxQueue );
284:                 
285:                 	taskENTER_CRITICAL();
9D01118C  0F405144   JAL vTaskEnterCritical
9D011190  00A08821   ADDU S1, A1, ZERO
286:                 	{
287:                 		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
9D011194  8E020000   LW V0, 0(S0)
9D011198  8E030040   LW V1, 64(S0)
9D01119C  8E04003C   LW A0, 60(S0)
9D0111A0  70642002   MUL A0, V1, A0
9D0111A4  00442821   ADDU A1, V0, A0
9D0111A8  AE050004   SW A1, 4(S0)
288:                 		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
9D0111AC  AE000038   SW ZERO, 56(S0)
289:                 		pxQueue->pcWriteTo = pxQueue->pcHead;
9D0111B0  AE020008   SW V0, 8(S0)
290:                 		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
9D0111B4  00831823   SUBU V1, A0, V1
9D0111B8  00431021   ADDU V0, V0, V1
9D0111BC  AE02000C   SW V0, 12(S0)
291:                 		pxQueue->cRxLock = queueUNLOCKED;
9D0111C0  2402FFFF   ADDIU V0, ZERO, -1
9D0111C4  A2020044   SB V0, 68(S0)
292:                 		pxQueue->cTxLock = queueUNLOCKED;
9D0111C8  A2020045   SB V0, 69(S0)
293:                 
294:                 		if( xNewQueue == pdFALSE )
9D0111CC  1620000E   BNE S1, ZERO, 0x9D011208
9D0111D0  00000000   NOP
295:                 		{
296:                 			/* If there are tasks blocked waiting to read from the queue, then
297:                 			the tasks will remain blocked as after this function exits the queue
298:                 			will still be empty.  If there are tasks blocked waiting to write to
299:                 			the queue, then one should be unblocked as after this function exits
300:                 			it will be possible to write to it. */
301:                 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
9D0111D4  8E020010   LW V0, 16(S0)
9D0111D8  1040000F   BEQ V0, ZERO, 0x9D011218
9D0111DC  00000000   NOP
302:                 			{
303:                 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
9D0111E0  0F4043C9   JAL xTaskRemoveFromEventList
9D0111E4  26040010   ADDIU A0, S0, 16
9D0111E8  1040000B   BEQ V0, ZERO, 0x9D011218
9D0111EC  00000000   NOP
304:                 				{
305:                 					queueYIELD_IF_USING_PREEMPTION();
9D0111F0  40026800   MFC0 V0, Cause
9D0111F4  34420100   ORI V0, V0, 256
9D0111F8  40826800   MTC0 V0, Cause
9D0111FC  000000C0   EHB
9D011200  0B404486   J 0x9D011218
9D011204  00000000   NOP
306:                 				}
307:                 				else
308:                 				{
309:                 					mtCOVERAGE_TEST_MARKER();
310:                 				}
311:                 			}
312:                 			else
313:                 			{
314:                 				mtCOVERAGE_TEST_MARKER();
315:                 			}
316:                 		}
317:                 		else
318:                 		{
319:                 			/* Ensure the event queues start in the correct state. */
320:                 			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
9D011208  0F405559   JAL vListInitialise
9D01120C  26040010   ADDIU A0, S0, 16
321:                 			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
9D011210  0F405559   JAL vListInitialise
9D011214  26040024   ADDIU A0, S0, 36
322:                 		}
323:                 	}
324:                 	taskEXIT_CRITICAL();
9D011218  0F404EA8   JAL vTaskExitCritical
9D01121C  00000000   NOP
325:                 
326:                 	/* A value is returned for calling semantic consistency with previous
327:                 	versions. */
328:                 	return pdPASS;
329:                 }
9D011220  24020001   ADDIU V0, ZERO, 1
9D011224  8FBF001C   LW RA, 28(SP)
9D011228  8FB10018   LW S1, 24(SP)
9D01122C  8FB00014   LW S0, 20(SP)
9D011230  03E00008   JR RA
9D011234  27BD0020   ADDIU SP, SP, 32
330:                 /*-----------------------------------------------------------*/
331:                 
332:                 #if( configSUPPORT_STATIC_ALLOCATION == 1 )
333:                 
334:                 	QueueHandle_t xQueueGenericCreateStatic( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, StaticQueue_t *pxStaticQueue, const uint8_t ucQueueType )
335:                 	{
336:                 	Queue_t *pxNewQueue;
337:                 
338:                 		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
339:                 
340:                 		/* The StaticQueue_t structure and the queue storage area must be
341:                 		supplied. */
342:                 		configASSERT( pxStaticQueue != NULL );
343:                 
344:                 		/* A queue storage area should be provided if the item size is not 0, and
345:                 		should not be provided if the item size is 0. */
346:                 		configASSERT( !( ( pucQueueStorage != NULL ) && ( uxItemSize == 0 ) ) );
347:                 		configASSERT( !( ( pucQueueStorage == NULL ) && ( uxItemSize != 0 ) ) );
348:                 
349:                 		#if( configASSERT_DEFINED == 1 )
350:                 		{
351:                 			/* Sanity check that the size of the structure used to declare a
352:                 			variable of type StaticQueue_t or StaticSemaphore_t equals the size of
353:                 			the real queue and semaphore structures. */
354:                 			volatile size_t xSize = sizeof( StaticQueue_t );
355:                 			configASSERT( xSize == sizeof( Queue_t ) );
356:                 		}
357:                 		#endif /* configASSERT_DEFINED */
358:                 
359:                 		/* The address of a statically allocated queue was passed in, use it.
360:                 		The address of a statically allocated storage area was also passed in
361:                 		but is already set. */
362:                 		pxNewQueue = ( Queue_t * ) pxStaticQueue; /*lint !e740 Unusual cast is ok as the structures are designed to have the same alignment, and the size is checked by an assert. */
363:                 
364:                 		if( pxNewQueue != NULL )
365:                 		{
366:                 			#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
367:                 			{
368:                 				/* Queues can be allocated wither statically or dynamically, so
369:                 				note this queue was allocated statically in case the queue is
370:                 				later deleted. */
371:                 				pxNewQueue->ucStaticallyAllocated = pdTRUE;
372:                 			}
373:                 			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
374:                 
375:                 			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
376:                 		}
377:                 
378:                 		return pxNewQueue;
379:                 	}
380:                 
381:                 #endif /* configSUPPORT_STATIC_ALLOCATION */
382:                 /*-----------------------------------------------------------*/
383:                 
384:                 #if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
385:                 
386:                 	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
387:                 	{
9D012334  27BDFFE0   ADDIU SP, SP, -32
9D012338  AFBF001C   SW RA, 28(SP)
9D01233C  AFB20018   SW S2, 24(SP)
9D012340  AFB10014   SW S1, 20(SP)
9D012344  AFB00010   SW S0, 16(SP)
9D012348  00809021   ADDU S2, A0, ZERO
388:                 	Queue_t *pxNewQueue;
389:                 	size_t xQueueSizeInBytes;
390:                 	uint8_t *pucQueueStorage;
391:                 
392:                 		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
393:                 
394:                 		if( uxItemSize == ( UBaseType_t ) 0 )
9D01234C  10A00013   BEQ A1, ZERO, 0x9D01239C
9D012350  00A08821   ADDU S1, A1, ZERO
395:                 		{
396:                 			/* There is not going to be a queue storage area. */
397:                 			xQueueSizeInBytes = ( size_t ) 0;
398:                 		}
399:                 		else
400:                 		{
401:                 			/* Allocate enough space to hold the maximum number of items that
402:                 			can be in the queue at any time. */
403:                 			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
9D012354  70A42002   MUL A0, A1, A0
404:                 		}
405:                 
406:                 		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
9D012358  0F402EE8   JAL pvPortMalloc
9D01235C  2484004C   ADDIU A0, A0, 76
9D01239C  0F402EE8   JAL pvPortMalloc
9D0123A0  2404004C   ADDIU A0, ZERO, 76
407:                 
408:                 		if( pxNewQueue != NULL )
9D012360  14400005   BNE V0, ZERO, 0x9D012378
9D012364  00408021   ADDU S0, V0, ZERO
9D0123A4  1440FFF2   BNE V0, ZERO, 0x9D012370
9D0123A8  00408021   ADDU S0, V0, ZERO
409:                 		{
410:                 			/* Jump past the queue structure to find the location of the queue
411:                 			storage area. */
412:                 			pucQueueStorage = ( ( uint8_t * ) pxNewQueue ) + sizeof( Queue_t );
9D012378  2442004C   ADDIU V0, V0, 76
413:                 
414:                 			#if( configSUPPORT_STATIC_ALLOCATION == 1 )
415:                 			{
416:                 				/* Queues can be created either statically or dynamically, so
417:                 				note this task was created dynamically in case it is later
418:                 				deleted. */
419:                 				pxNewQueue->ucStaticallyAllocated = pdFALSE;
420:                 			}
421:                 			#endif /* configSUPPORT_STATIC_ALLOCATION */
422:                 
423:                 			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
424:                 		}
425:                 
426:                 		return pxNewQueue;
427:                 	}
9D012368  0B4048EC   J 0x9D0123B0
9D01236C  02001021   ADDU V0, S0, ZERO
9D0123AC  02001021   ADDU V0, S0, ZERO
428:                 
429:                 #endif /* configSUPPORT_STATIC_ALLOCATION */
430:                 /*-----------------------------------------------------------*/
431:                 
432:                 static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
433:                 {
434:                 	/* Remove compiler warnings about unused parameters should
435:                 	configUSE_TRACE_FACILITY not be set to 1. */
436:                 	( void ) ucQueueType;
437:                 
438:                 	if( uxItemSize == ( UBaseType_t ) 0 )
439:                 	{
440:                 		/* No RAM was allocated for the queue storage area, but PC head cannot
441:                 		be set to NULL because NULL is used as a key to say the queue is used as
442:                 		a mutex.  Therefore just set pcHead to point to the queue as a benign
443:                 		value that is known to be within the memory map. */
444:                 		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
9D012370  0B4048E0   J 0x9D012380
9D012374  AE100000   SW S0, 0(S0)
445:                 	}
446:                 	else
447:                 	{
448:                 		/* Set the head to the start of the queue storage area. */
449:                 		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
9D01237C  AE020000   SW V0, 0(S0)
450:                 	}
451:                 
452:                 	/* Initialise the queue members as described where the queue type is
453:                 	defined. */
454:                 	pxNewQueue->uxLength = uxQueueLength;
9D012380  AE12003C   SW S2, 60(S0)
455:                 	pxNewQueue->uxItemSize = uxItemSize;
9D012384  AE110040   SW S1, 64(S0)
456:                 	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
9D012388  02002021   ADDU A0, S0, ZERO
457:                 
458:                 	#if ( configUSE_TRACE_FACILITY == 1 )
459:                 	{
460:                 		pxNewQueue->ucQueueType = ucQueueType;
461:                 	}
462:                 	#endif /* configUSE_TRACE_FACILITY */
463:                 
464:                 	#if( configUSE_QUEUE_SETS == 1 )
465:                 	{
466:                 		pxNewQueue->pxQueueSetContainer = NULL;
9D012394  0B4048EB   J 0x9D0123AC
9D012398  AE000048   SW ZERO, 72(S0)
9D01239C  0F402EE8   JAL pvPortMalloc
9D0123A0  2404004C   ADDIU A0, ZERO, 76
9D0123A4  1440FFF2   BNE V0, ZERO, 0x9D012370
9D0123A8  00408021   ADDU S0, V0, ZERO
9D0123AC  02001021   ADDU V0, S0, ZERO
9D0123B0  8FBF001C   LW RA, 28(SP)
9D0123B4  8FB20018   LW S2, 24(SP)
9D0123B8  8FB10014   LW S1, 20(SP)
9D0123BC  8FB00010   LW S0, 16(SP)
9D0123C0  03E00008   JR RA
9D0123C4  27BD0020   ADDIU SP, SP, 32
467:                 	}
468:                 	#endif /* configUSE_QUEUE_SETS */
469:                 
470:                 	traceQUEUE_CREATE( pxNewQueue );
471:                 }
472:                 /*-----------------------------------------------------------*/
473:                 
474:                 #if( configUSE_MUTEXES == 1 )
475:                 
476:                 	static void prvInitialiseMutex( Queue_t *pxNewQueue )
477:                 	{
478:                 		if( pxNewQueue != NULL )
9D013FC8  10400009   BEQ V0, ZERO, 0x9D013FF0
479:                 		{
480:                 			/* The queue create function will set all the queue structure members
481:                 			correctly for a generic queue, but this function is creating a
482:                 			mutex.  Overwrite those members that need to be set differently -
483:                 			in particular the information required for priority inheritance. */
484:                 			pxNewQueue->pxMutexHolder = NULL;
9D013FD0  AC400004   SW ZERO, 4(V0)
485:                 			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
9D013FD4  AC400000   SW ZERO, 0(V0)
486:                 
487:                 			/* In case this is a recursive mutex. */
488:                 			pxNewQueue->u.uxRecursiveCallCount = 0;
9D013FD8  AC40000C   SW ZERO, 12(V0)
489:                 
490:                 			traceCREATE_MUTEX( pxNewQueue );
491:                 
492:                 			/* Start with the semaphore in the expected state. */
493:                 			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
9D013FDC  00402021   ADDU A0, V0, ZERO
9D013FE0  00002821   ADDU A1, ZERO, ZERO
9D013FE4  00003021   ADDU A2, ZERO, ZERO
9D013FE8  0F401FB3   JAL xQueueGenericSend
9D013FEC  00003821   ADDU A3, ZERO, ZERO
494:                 		}
495:                 		else
496:                 		{
497:                 			traceCREATE_MUTEX_FAILED();
498:                 		}
499:                 	}
500:                 
501:                 #endif /* configUSE_MUTEXES */
502:                 /*-----------------------------------------------------------*/
503:                 
504:                 #if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
505:                 
506:                 	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
507:                 	{
9D013FAC  27BDFFE8   ADDIU SP, SP, -24
9D013FB0  AFBF0014   SW RA, 20(SP)
9D013FB4  AFB00010   SW S0, 16(SP)
9D013FB8  00803021   ADDU A2, A0, ZERO
508:                 	Queue_t *pxNewQueue;
509:                 	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
510:                 
511:                 		pxNewQueue = ( Queue_t * ) xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
9D013FBC  24040001   ADDIU A0, ZERO, 1
9D013FC0  0F4048CD   JAL xQueueGenericCreate
9D013FC4  00002821   ADDU A1, ZERO, ZERO
512:                 		prvInitialiseMutex( pxNewQueue );
513:                 
514:                 		return pxNewQueue;
515:                 	}
9D013FF0  02001021   ADDU V0, S0, ZERO
9D013FF4  8FBF0014   LW RA, 20(SP)
9D013FF8  8FB00010   LW S0, 16(SP)
9D013FFC  03E00008   JR RA
9D014000  27BD0018   ADDIU SP, SP, 24
516:                 
517:                 #endif /* configUSE_MUTEXES */
518:                 /*-----------------------------------------------------------*/
519:                 
520:                 #if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
521:                 
522:                 	QueueHandle_t xQueueCreateMutexStatic( const uint8_t ucQueueType, StaticQueue_t *pxStaticQueue )
523:                 	{
524:                 	Queue_t *pxNewQueue;
525:                 	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
526:                 
527:                 		/* Prevent compiler warnings about unused parameters if
528:                 		configUSE_TRACE_FACILITY does not equal 1. */
529:                 		( void ) ucQueueType;
530:                 
531:                 		pxNewQueue = ( Queue_t * ) xQueueGenericCreateStatic( uxMutexLength, uxMutexSize, NULL, pxStaticQueue, ucQueueType );
532:                 		prvInitialiseMutex( pxNewQueue );
533:                 
534:                 		return pxNewQueue;
535:                 	}
536:                 
537:                 #endif /* configUSE_MUTEXES */
538:                 /*-----------------------------------------------------------*/
539:                 
540:                 #if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )
541:                 
542:                 	void* xQueueGetMutexHolder( QueueHandle_t xSemaphore )
543:                 	{
544:                 	void *pxReturn;
545:                 
546:                 		/* This function is called by xSemaphoreGetMutexHolder(), and should not
547:                 		be called directly.  Note:  This is a good way of determining if the
548:                 		calling task is the mutex holder, but not a good way of determining the
549:                 		identity of the mutex holder, as the holder may change between the
550:                 		following critical section exiting and the function returning. */
551:                 		taskENTER_CRITICAL();
552:                 		{
553:                 			if( ( ( Queue_t * ) xSemaphore )->uxQueueType == queueQUEUE_IS_MUTEX )
554:                 			{
555:                 				pxReturn = ( void * ) ( ( Queue_t * ) xSemaphore )->pxMutexHolder;
556:                 			}
557:                 			else
558:                 			{
559:                 				pxReturn = NULL;
560:                 			}
561:                 		}
562:                 		taskEXIT_CRITICAL();
563:                 
564:                 		return pxReturn;
565:                 	} /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
566:                 
567:                 #endif
568:                 /*-----------------------------------------------------------*/
569:                 
570:                 #if ( configUSE_RECURSIVE_MUTEXES == 1 )
571:                 
572:                 	BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )
573:                 	{
574:                 	BaseType_t xReturn;
575:                 	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
576:                 
577:                 		configASSERT( pxMutex );
578:                 
579:                 		/* If this is the task that holds the mutex then pxMutexHolder will not
580:                 		change outside of this task.  If this task does not hold the mutex then
581:                 		pxMutexHolder can never coincidentally equal the tasks handle, and as
582:                 		this is the only condition we are interested in it does not matter if
583:                 		pxMutexHolder is accessed simultaneously by another task.  Therefore no
584:                 		mutual exclusion is required to test the pxMutexHolder variable. */
585:                 		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Not a redundant cast as TaskHandle_t is a typedef. */
586:                 		{
587:                 			traceGIVE_MUTEX_RECURSIVE( pxMutex );
588:                 
589:                 			/* uxRecursiveCallCount cannot be zero if pxMutexHolder is equal to
590:                 			the task handle, therefore no underflow check is required.  Also,
591:                 			uxRecursiveCallCount is only modified by the mutex holder, and as
592:                 			there can only be one, no mutual exclusion is required to modify the
593:                 			uxRecursiveCallCount member. */
594:                 			( pxMutex->u.uxRecursiveCallCount )--;
595:                 
596:                 			/* Has the recursive call count unwound to 0? */
597:                 			if( pxMutex->u.uxRecursiveCallCount == ( UBaseType_t ) 0 )
598:                 			{
599:                 				/* Return the mutex.  This will automatically unblock any other
600:                 				task that might be waiting to access the mutex. */
601:                 				( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
602:                 			}
603:                 			else
604:                 			{
605:                 				mtCOVERAGE_TEST_MARKER();
606:                 			}
607:                 
608:                 			xReturn = pdPASS;
609:                 		}
610:                 		else
611:                 		{
612:                 			/* The mutex cannot be given because the calling task is not the
613:                 			holder. */
614:                 			xReturn = pdFAIL;
615:                 
616:                 			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
617:                 		}
618:                 
619:                 		return xReturn;
620:                 	}
621:                 
622:                 #endif /* configUSE_RECURSIVE_MUTEXES */
623:                 /*-----------------------------------------------------------*/
624:                 
625:                 #if ( configUSE_RECURSIVE_MUTEXES == 1 )
626:                 
627:                 	BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait )
628:                 	{
629:                 	BaseType_t xReturn;
630:                 	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
631:                 
632:                 		configASSERT( pxMutex );
633:                 
634:                 		/* Comments regarding mutual exclusion as per those within
635:                 		xQueueGiveMutexRecursive(). */
636:                 
637:                 		traceTAKE_MUTEX_RECURSIVE( pxMutex );
638:                 
639:                 		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
640:                 		{
641:                 			( pxMutex->u.uxRecursiveCallCount )++;
642:                 			xReturn = pdPASS;
643:                 		}
644:                 		else
645:                 		{
646:                 			xReturn = xQueueGenericReceive( pxMutex, NULL, xTicksToWait, pdFALSE );
647:                 
648:                 			/* pdPASS will only be returned if the mutex was successfully
649:                 			obtained.  The calling task may have entered the Blocked state
650:                 			before reaching here. */
651:                 			if( xReturn != pdFAIL )
652:                 			{
653:                 				( pxMutex->u.uxRecursiveCallCount )++;
654:                 			}
655:                 			else
656:                 			{
657:                 				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
658:                 			}
659:                 		}
660:                 
661:                 		return xReturn;
662:                 	}
663:                 
664:                 #endif /* configUSE_RECURSIVE_MUTEXES */
665:                 /*-----------------------------------------------------------*/
666:                 
667:                 #if( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
668:                 
669:                 	QueueHandle_t xQueueCreateCountingSemaphoreStatic( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount, StaticQueue_t *pxStaticQueue )
670:                 	{
671:                 	QueueHandle_t xHandle;
672:                 
673:                 		configASSERT( uxMaxCount != 0 );
674:                 		configASSERT( uxInitialCount <= uxMaxCount );
675:                 
676:                 		xHandle = xQueueGenericCreateStatic( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, NULL, pxStaticQueue, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
677:                 
678:                 		if( xHandle != NULL )
679:                 		{
680:                 			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
681:                 
682:                 			traceCREATE_COUNTING_SEMAPHORE();
683:                 		}
684:                 		else
685:                 		{
686:                 			traceCREATE_COUNTING_SEMAPHORE_FAILED();
687:                 		}
688:                 
689:                 		return xHandle;
690:                 	}
691:                 
692:                 #endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
693:                 /*-----------------------------------------------------------*/
694:                 
695:                 #if( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
696:                 
697:                 	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount )
698:                 	{
9D014F6C  27BDFFE8   ADDIU SP, SP, -24
9D014F70  AFBF0014   SW RA, 20(SP)
9D014F74  AFB00010   SW S0, 16(SP)
9D014F78  00A08021   ADDU S0, A1, ZERO
699:                 	QueueHandle_t xHandle;
700:                 
701:                 		configASSERT( uxMaxCount != 0 );
702:                 		configASSERT( uxInitialCount <= uxMaxCount );
703:                 
704:                 		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
9D014F7C  00002821   ADDU A1, ZERO, ZERO
9D014F80  0F4048CD   JAL xQueueGenericCreate
9D014F84  24060002   ADDIU A2, ZERO, 2
705:                 
706:                 		if( xHandle != NULL )
9D014F88  54400001   BNEL V0, ZERO, 0x9D014F90
9D014F8C  AC500038   SW S0, 56(V0)
707:                 		{
708:                 			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
709:                 
710:                 			traceCREATE_COUNTING_SEMAPHORE();
711:                 		}
712:                 		else
713:                 		{
714:                 			traceCREATE_COUNTING_SEMAPHORE_FAILED();
715:                 		}
716:                 
717:                 		return xHandle;
718:                 	}
9D014F90  8FBF0014   LW RA, 20(SP)
9D014F94  8FB00010   LW S0, 16(SP)
9D014F98  03E00008   JR RA
9D014F9C  27BD0018   ADDIU SP, SP, 24
719:                 
720:                 #endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
721:                 /*-----------------------------------------------------------*/
722:                 
723:                 BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
724:                 {
9D007ECC  27BDFFC0   ADDIU SP, SP, -64
9D007ED0  AFBF003C   SW RA, 60(SP)
9D007ED4  AFBE0038   SW S8, 56(SP)
9D007ED8  AFB70034   SW S7, 52(SP)
9D007EDC  AFB60030   SW S6, 48(SP)
9D007EE0  AFB5002C   SW S5, 44(SP)
9D007EE4  AFB40028   SW S4, 40(SP)
9D007EE8  AFB30024   SW S3, 36(SP)
9D007EEC  AFB20020   SW S2, 32(SP)
9D007EF0  AFB1001C   SW S1, 28(SP)
9D007EF4  AFB00018   SW S0, 24(SP)
9D007EF8  00808021   ADDU S0, A0, ZERO
9D007EFC  00A0B021   ADDU S6, A1, ZERO
9D007F00  AFA60048   SW A2, 72(SP)
9D007F04  00E09821   ADDU S3, A3, ZERO
725:                 BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
9D007F08  00009021   ADDU S2, ZERO, ZERO
726:                 TimeOut_t xTimeOut;
727:                 Queue_t * const pxQueue = ( Queue_t * ) xQueue;
728:                 
729:                 	configASSERT( pxQueue );
730:                 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
731:                 	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
732:                 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
733:                 	{
734:                 		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
735:                 	}
736:                 	#endif
737:                 
738:                 
739:                 	/* This function relaxes the coding standard somewhat to allow return
740:                 	statements within the function itself.  This is done in the interest
741:                 	of execution time efficiency. */
742:                 	for( ;; )
743:                 	{
744:                 		taskENTER_CRITICAL();
9D007F18  0F405144   JAL vTaskEnterCritical
9D007F1C  00000000   NOP
745:                 		{
746:                 			/* Is there room on the queue now?  The running task must be the
747:                 			highest priority task wanting to access the queue.  If the head item
748:                 			in the queue is to be overwritten then it does not matter if the
749:                 			queue is full. */
750:                 			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
9D007F0C  24140002   ADDIU S4, ZERO, 2
9D007F20  8E030038   LW V1, 56(S0)
9D007F24  8E02003C   LW V0, 60(S0)
9D007F28  0062102B   SLTU V0, V1, V0
9D007F2C  14400004   BNE V0, ZERO, 0x9D007F40
9D007F30  02002021   ADDU A0, S0, ZERO
9D007F34  16740029   BNE S3, S4, 0x9D007FDC
9D007F38  8FA20048   LW V0, 72(SP)
751:                 			{
752:                 				traceQUEUE_SEND( pxQueue );
753:                 				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
9D007F3C  02002021   ADDU A0, S0, ZERO
9D007F40  02C02821   ADDU A1, S6, ZERO
9D007F44  0F404075   JAL prvCopyDataToQueue
9D007F48  02603021   ADDU A2, S3, ZERO
754:                 
755:                 				#if ( configUSE_QUEUE_SETS == 1 )
756:                 				{
757:                 					if( pxQueue->pxQueueSetContainer != NULL )
9D007F4C  8E030048   LW V1, 72(S0)
9D007F50  1060000B   BEQ V1, ZERO, 0x9D007F80
9D007F54  02002021   ADDU A0, S0, ZERO
758:                 					{
759:                 						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
9D007F58  0F404747   JAL prvNotifyQueueSetContainer
9D007F5C  02602821   ADDU A1, S3, ZERO
9D007F60  1040001A   BEQ V0, ZERO, 0x9D007FCC
9D007F64  00000000   NOP
760:                 						{
761:                 							/* The queue is a member of a queue set, and posting
762:                 							to the queue set caused a higher priority task to
763:                 							unblock. A context switch is required. */
764:                 							queueYIELD_IF_USING_PREEMPTION();
9D007F68  40026800   MFC0 V0, Cause
9D007F6C  34420100   ORI V0, V0, 256
9D007F70  40826800   MTC0 V0, Cause
9D007F74  000000C0   EHB
9D007F78  0B401FF3   J 0x9D007FCC
9D007F7C  00000000   NOP
765:                 						}
766:                 						else
767:                 						{
768:                 							mtCOVERAGE_TEST_MARKER();
769:                 						}
770:                 					}
771:                 					else
772:                 					{
773:                 						/* If there was a task waiting for data to arrive on the
774:                 						queue then unblock it now. */
775:                 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
9D007F80  8E030024   LW V1, 36(S0)
9D007F84  1060000B   BEQ V1, ZERO, 0x9D007FB4
9D007F88  00000000   NOP
776:                 						{
777:                 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
9D007F8C  0F4043C9   JAL xTaskRemoveFromEventList
9D007F90  26040024   ADDIU A0, S0, 36
9D007F94  1040000D   BEQ V0, ZERO, 0x9D007FCC
9D007F98  00000000   NOP
778:                 							{
779:                 								/* The unblocked task has a priority higher than
780:                 								our own so yield immediately.  Yes it is ok to
781:                 								do this from within the critical section - the
782:                 								kernel takes care of that. */
783:                 								queueYIELD_IF_USING_PREEMPTION();
9D007F9C  40026800   MFC0 V0, Cause
9D007FA0  34420100   ORI V0, V0, 256
9D007FA4  40826800   MTC0 V0, Cause
9D007FA8  000000C0   EHB
9D007FAC  0B401FF3   J 0x9D007FCC
9D007FB0  00000000   NOP
784:                 							}
785:                 							else
786:                 							{
787:                 								mtCOVERAGE_TEST_MARKER();
788:                 							}
789:                 						}
790:                 						else if( xYieldRequired != pdFALSE )
9D007FB4  10400005   BEQ V0, ZERO, 0x9D007FCC
9D007FB8  00000000   NOP
791:                 						{
792:                 							/* This path is a special case that will only get
793:                 							executed if the task was holding multiple mutexes
794:                 							and the mutexes were given back in an order that is
795:                 							different to that in which they were taken. */
796:                 							queueYIELD_IF_USING_PREEMPTION();
9D007FBC  40026800   MFC0 V0, Cause
9D007FC0  34420100   ORI V0, V0, 256
9D007FC4  40826800   MTC0 V0, Cause
9D007FC8  000000C0   EHB
797:                 						}
798:                 						else
799:                 						{
800:                 							mtCOVERAGE_TEST_MARKER();
801:                 						}
802:                 					}
803:                 				}
804:                 				#else /* configUSE_QUEUE_SETS */
805:                 				{
806:                 					/* If there was a task waiting for data to arrive on the
807:                 					queue then unblock it now. */
808:                 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
809:                 					{
810:                 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
811:                 						{
812:                 							/* The unblocked task has a priority higher than
813:                 							our own so yield immediately.  Yes it is ok to do
814:                 							this from within the critical section - the kernel
815:                 							takes care of that. */
816:                 							queueYIELD_IF_USING_PREEMPTION();
817:                 						}
818:                 						else
819:                 						{
820:                 							mtCOVERAGE_TEST_MARKER();
821:                 						}
822:                 					}
823:                 					else if( xYieldRequired != pdFALSE )
824:                 					{
825:                 						/* This path is a special case that will only get
826:                 						executed if the task was holding multiple mutexes and
827:                 						the mutexes were given back in an order that is
828:                 						different to that in which they were taken. */
829:                 						queueYIELD_IF_USING_PREEMPTION();
830:                 					}
831:                 					else
832:                 					{
833:                 						mtCOVERAGE_TEST_MARKER();
834:                 					}
835:                 				}
836:                 				#endif /* configUSE_QUEUE_SETS */
837:                 
838:                 				taskEXIT_CRITICAL();
9D007FCC  0F404EA8   JAL vTaskExitCritical
9D007FD0  00000000   NOP
839:                 				return pdPASS;
9D007FD4  0B402037   J 0x9D0080DC
9D007FD8  24020001   ADDIU V0, ZERO, 1
840:                 			}
841:                 			else
842:                 			{
843:                 				if( xTicksToWait == ( TickType_t ) 0 )
9D007FDC  14400005   BNE V0, ZERO, 0x9D007FF4
9D007FE0  00000000   NOP
844:                 				{
845:                 					/* The queue was full and no block time is specified (or
846:                 					the block time has expired) so leave now. */
847:                 					taskEXIT_CRITICAL();
9D007FE4  0F404EA8   JAL vTaskExitCritical
9D007FE8  00000000   NOP
848:                 
849:                 					/* Return to the original privilege level before exiting
850:                 					the function. */
851:                 					traceQUEUE_SEND_FAILED( pxQueue );
852:                 					return errQUEUE_FULL;
9D007FEC  0B402037   J 0x9D0080DC
9D007FF0  00001021   ADDU V0, ZERO, ZERO
853:                 				}
854:                 				else if( xEntryTimeSet == pdFALSE )
9D007FF4  16400004   BNE S2, ZERO, 0x9D008008
9D007FF8  00000000   NOP
855:                 				{
856:                 					/* The queue was full and a block time was specified so
857:                 					configure the timeout structure. */
858:                 					vTaskSetTimeOutState( &xTimeOut );
9D007FFC  0F4055F5   JAL vTaskSetTimeOutState
9D008000  27A40010   ADDIU A0, SP, 16
859:                 					xEntryTimeSet = pdTRUE;
9D008004  24120001   ADDIU S2, ZERO, 1
860:                 				}
861:                 				else
862:                 				{
863:                 					/* Entry time was already set. */
864:                 					mtCOVERAGE_TEST_MARKER();
865:                 				}
866:                 			}
867:                 		}
868:                 		taskEXIT_CRITICAL();
9D008008  0F404EA8   JAL vTaskExitCritical
9D00800C  00000000   NOP
869:                 
870:                 		/* Interrupts and other tasks can send to and receive from the queue
871:                 		now the critical section has been exited. */
872:                 
873:                 		vTaskSuspendAll();
9D008010  0F4055F0   JAL vTaskSuspendAll
9D008014  00000000   NOP
874:                 		prvLockQueue( pxQueue );
9D007F10  2411FFFF   ADDIU S1, ZERO, -1
9D008018  0F405144   JAL vTaskEnterCritical
9D00801C  00000000   NOP
9D008020  92020044   LBU V0, 68(S0)
9D008024  7C021420   SEB V0, V0
9D008028  50510001   BEQL V0, S1, 0x9D008030
9D00802C  A2000044   SB ZERO, 68(S0)
9D008030  92020045   LBU V0, 69(S0)
9D008034  7C021420   SEB V0, V0
9D008038  50510001   BEQL V0, S1, 0x9D008040
9D00803C  A2000045   SB ZERO, 69(S0)
9D008040  0F404EA8   JAL vTaskExitCritical
9D008044  00000000   NOP
875:                 
876:                 		/* Update the timeout state to see if it has expired yet. */
877:                 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
9D008048  27A40010   ADDIU A0, SP, 16
9D00804C  0F404798   JAL xTaskCheckForTimeOut
9D008050  27A50048   ADDIU A1, SP, 72
9D008054  1440001C   BNE V0, ZERO, 0x9D0080C8
9D008058  00000000   NOP
878:                 		{
879:                 			if( prvIsQueueFull( pxQueue ) != pdFALSE )
9D008070  17D7000F   BNE S8, S7, 0x9D0080B0
9D008074  02A02021   ADDU A0, S5, ZERO
880:                 			{
881:                 				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
882:                 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
9D007F14  24950010   ADDIU S5, A0, 16
9D008078  0F405355   JAL vTaskPlaceOnEventList
9D00807C  8FA50048   LW A1, 72(SP)
883:                 
884:                 				/* Unlocking the queue means queue events can effect the
885:                 				event list.  It is possible	that interrupts occurring now
886:                 				remove this task from the event	list again - but as the
887:                 				scheduler is suspended the task will go onto the pending
888:                 				ready last instead of the actual ready list. */
889:                 				prvUnlockQueue( pxQueue );
9D008080  0F403CF0   JAL prvUnlockQueue
9D008084  02002021   ADDU A0, S0, ZERO
890:                 
891:                 				/* Resuming the scheduler will move tasks from the pending
892:                 				ready list into the ready list - so it is feasible that this
893:                 				task is already in a ready list before it yields - in which
894:                 				case the yield will not cause a context switch unless there
895:                 				is also a higher priority task in the pending ready list. */
896:                 				if( xTaskResumeAll() == pdFALSE )
9D008088  0F40379F   JAL xTaskResumeAll
9D00808C  00000000   NOP
9D008090  1440FFA1   BNE V0, ZERO, 0x9D007F18
9D008094  00000000   NOP
897:                 				{
898:                 					portYIELD_WITHIN_API();
9D008098  40026800   MFC0 V0, Cause
9D00809C  34420100   ORI V0, V0, 256
9D0080A0  40826800   MTC0 V0, Cause
9D0080A4  000000C0   EHB
9D0080A8  0B401FC6   J 0x9D007F18
9D0080AC  00000000   NOP
899:                 				}
900:                 			}
901:                 			else
902:                 			{
903:                 				/* Try again. */
904:                 				prvUnlockQueue( pxQueue );
9D0080B0  0F403CF0   JAL prvUnlockQueue
9D0080B4  02002021   ADDU A0, S0, ZERO
905:                 				( void ) xTaskResumeAll();
9D0080B8  0F40379F   JAL xTaskResumeAll
9D0080BC  00000000   NOP
9D0080C0  0B401FC6   J 0x9D007F18
9D0080C4  00000000   NOP
906:                 			}
907:                 		}
908:                 		else
909:                 		{
910:                 			/* The timeout has expired. */
911:                 			prvUnlockQueue( pxQueue );
9D0080C8  0F403CF0   JAL prvUnlockQueue
9D0080CC  02002021   ADDU A0, S0, ZERO
912:                 			( void ) xTaskResumeAll();
9D0080D0  0F40379F   JAL xTaskResumeAll
9D0080D4  00000000   NOP
913:                 
914:                 			traceQUEUE_SEND_FAILED( pxQueue );
915:                 			return errQUEUE_FULL;
9D0080D8  00001021   ADDU V0, ZERO, ZERO
916:                 		}
917:                 	}
918:                 }
9D0080DC  8FBF003C   LW RA, 60(SP)
919:                 /*-----------------------------------------------------------*/
920:                 
921:                 BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
922:                 {
9D00EE1C  27BDFFD0   ADDIU SP, SP, -48
9D00EE20  AFBF002C   SW RA, 44(SP)
9D00EE24  AFB60028   SW S6, 40(SP)
9D00EE28  AFB50024   SW S5, 36(SP)
9D00EE2C  AFB40020   SW S4, 32(SP)
9D00EE30  AFB3001C   SW S3, 28(SP)
9D00EE34  AFB20018   SW S2, 24(SP)
9D00EE38  AFB10014   SW S1, 20(SP)
9D00EE3C  AFB00010   SW S0, 16(SP)
9D00EE40  00808021   ADDU S0, A0, ZERO
9D00EE44  00A0A021   ADDU S4, A1, ZERO
9D00EE48  00C0A821   ADDU S5, A2, ZERO
923:                 BaseType_t xReturn;
924:                 UBaseType_t uxSavedInterruptStatus;
925:                 Queue_t * const pxQueue = ( Queue_t * ) xQueue;
926:                 
927:                 	configASSERT( pxQueue );
928:                 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
929:                 	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
930:                 
931:                 	/* RTOS ports that support interrupt nesting have the concept of a maximum
932:                 	system call (or maximum API call) interrupt priority.  Interrupts that are
933:                 	above the maximum system call priority are kept permanently enabled, even
934:                 	when the RTOS kernel is in a critical section, but cannot make any calls to
935:                 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
936:                 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
937:                 	failure if a FreeRTOS API function is called from an interrupt that has been
938:                 	assigned a priority above the configured maximum system call priority.
939:                 	Only FreeRTOS functions that end in FromISR can be called from interrupts
940:                 	that have been assigned a priority at or (logically) below the maximum
941:                 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
942:                 	safe API to ensure interrupt entry is as fast and as simple as possible.
943:                 	More information (albeit Cortex-M specific) is provided on the following
944:                 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
945:                 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
946:                 
947:                 	/* Similar to xQueueGenericSend, except without blocking if there is no room
948:                 	in the queue.  Also don't directly wake a task that was blocked on a queue
949:                 	read, instead return a flag to say whether a context switch is required or
950:                 	not (i.e. has a task with a higher priority than us been woken by this
951:                 	post). */
952:                 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
9D00EE4C  0F4052D3   JAL uxPortSetInterruptMaskFromISR
9D00EE50  00E08821   ADDU S1, A3, ZERO
9D00EE54  00409821   ADDU S3, V0, ZERO
953:                 	{
954:                 		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
9D00EE58  8E030038   LW V1, 56(S0)
9D00EE5C  8E02003C   LW V0, 60(S0)
9D00EE60  0062102B   SLTU V0, V1, V0
9D00EE64  14400003   BNE V0, ZERO, 0x9D00EE74
9D00EE68  24020002   ADDIU V0, ZERO, 2
9D00EE6C  16220027   BNE S1, V0, 0x9D00EF0C
9D00EE70  00009021   ADDU S2, ZERO, ZERO
955:                 		{
956:                 			const int8_t cTxLock = pxQueue->cTxLock;
9D00EE74  92120045   LBU S2, 69(S0)
9D00EE78  7C12B420   SEB S6, S2
957:                 
958:                 			traceQUEUE_SEND_FROM_ISR( pxQueue );
959:                 
960:                 			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
961:                 			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
962:                 			in a task disinheriting a priority and prvCopyDataToQueue() can be
963:                 			called here even though the disinherit function does not check if
964:                 			the scheduler is suspended before accessing the ready lists. */
965:                 			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
9D00EE7C  02002021   ADDU A0, S0, ZERO
9D00EE80  02802821   ADDU A1, S4, ZERO
9D00EE84  0F404075   JAL prvCopyDataToQueue
9D00EE88  02203021   ADDU A2, S1, ZERO
966:                 
967:                 			/* The event list is not altered if the queue is locked.  This will
968:                 			be done when the queue is unlocked later. */
969:                 			if( cTxLock == queueUNLOCKED )
9D00EE8C  2402FFFF   ADDIU V0, ZERO, -1
9D00EE90  56C20017   BNEL S6, V0, 0x9D00EEF0
9D00EE94  26520001   ADDIU S2, S2, 1
970:                 			{
971:                 				#if ( configUSE_QUEUE_SETS == 1 )
972:                 				{
973:                 					if( pxQueue->pxQueueSetContainer != NULL )
9D00EE98  8E020048   LW V0, 72(S0)
9D00EE9C  10400009   BEQ V0, ZERO, 0x9D00EEC4
9D00EEA0  02002021   ADDU A0, S0, ZERO
974:                 					{
975:                 						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
9D00EEA4  0F404747   JAL prvNotifyQueueSetContainer
9D00EEA8  02202821   ADDU A1, S1, ZERO
9D00EEAC  10400017   BEQ V0, ZERO, 0x9D00EF0C
9D00EEB0  24120001   ADDIU S2, ZERO, 1
976:                 						{
977:                 							/* The queue is a member of a queue set, and posting
978:                 							to the queue set caused a higher priority task to
979:                 							unblock.  A context switch is required. */
980:                 							if( pxHigherPriorityTaskWoken != NULL )
9D00EEB4  12A00012   BEQ S5, ZERO, 0x9D00EF00
9D00EEB8  24020001   ADDIU V0, ZERO, 1
9D00EEBC  0B403BC3   J 0x9D00EF0C
9D00EEC0  AEA20000   SW V0, 0(S5)
981:                 							{
982:                 								*pxHigherPriorityTaskWoken = pdTRUE;
983:                 							}
984:                 							else
985:                 							{
986:                 								mtCOVERAGE_TEST_MARKER();
987:                 							}
988:                 						}
989:                 						else
990:                 						{
991:                 							mtCOVERAGE_TEST_MARKER();
992:                 						}
993:                 					}
994:                 					else
995:                 					{
996:                 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
9D00EEC4  8E020024   LW V0, 36(S0)
9D00EEC8  10400010   BEQ V0, ZERO, 0x9D00EF0C
9D00EECC  24120001   ADDIU S2, ZERO, 1
997:                 						{
998:                 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
9D00EED0  0F4043C9   JAL xTaskRemoveFromEventList
9D00EED4  26040024   ADDIU A0, S0, 36
9D00EED8  1040000C   BEQ V0, ZERO, 0x9D00EF0C
9D00EEDC  00000000   NOP
999:                 							{
1000:                								/* The task waiting has a higher priority so
1001:                								record that a context switch is required. */
1002:                								if( pxHigherPriorityTaskWoken != NULL )
9D00EEE0  12A00009   BEQ S5, ZERO, 0x9D00EF08
9D00EEE4  24020001   ADDIU V0, ZERO, 1
9D00EEE8  0B403BC3   J 0x9D00EF0C
9D00EEEC  AEA20000   SW V0, 0(S5)
1003:                								{
1004:                									*pxHigherPriorityTaskWoken = pdTRUE;
1005:                								}
1006:                								else
1007:                								{
1008:                									mtCOVERAGE_TEST_MARKER();
1009:                								}
1010:                							}
1011:                							else
1012:                							{
1013:                								mtCOVERAGE_TEST_MARKER();
1014:                							}
1015:                						}
1016:                						else
1017:                						{
1018:                							mtCOVERAGE_TEST_MARKER();
1019:                						}
1020:                					}
1021:                				}
1022:                				#else /* configUSE_QUEUE_SETS */
1023:                				{
1024:                					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1025:                					{
1026:                						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1027:                						{
1028:                							/* The task waiting has a higher priority so record that a
1029:                							context	switch is required. */
1030:                							if( pxHigherPriorityTaskWoken != NULL )
1031:                							{
1032:                								*pxHigherPriorityTaskWoken = pdTRUE;
1033:                							}
1034:                							else
1035:                							{
1036:                								mtCOVERAGE_TEST_MARKER();
1037:                							}
1038:                						}
1039:                						else
1040:                						{
1041:                							mtCOVERAGE_TEST_MARKER();
1042:                						}
1043:                					}
1044:                					else
1045:                					{
1046:                						mtCOVERAGE_TEST_MARKER();
1047:                					}
1048:                				}
1049:                				#endif /* configUSE_QUEUE_SETS */
1050:                			}
1051:                			else
1052:                			{
1053:                				/* Increment the lock count so the task that unlocks the queue
1054:                				knows that data was posted while it was locked. */
1055:                				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
9D00EEF0  7C129420   SEB S2, S2
9D00EEF4  A2120045   SB S2, 69(S0)
1056:                			}
1057:                
1058:                			xReturn = pdPASS;
9D00EEF8  0B403BC3   J 0x9D00EF0C
9D00EEFC  24120001   ADDIU S2, ZERO, 1
9D00EF00  0B403BC3   J 0x9D00EF0C
9D00EF04  24120001   ADDIU S2, ZERO, 1
9D00EF08  24120001   ADDIU S2, ZERO, 1
1059:                		}
1060:                		else
1061:                		{
1062:                			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
1063:                			xReturn = errQUEUE_FULL;
1064:                		}
1065:                	}
1066:                	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
9D00EF0C  0F4055A7   JAL vPortClearInterruptMaskFromISR
9D00EF10  02602021   ADDU A0, S3, ZERO
1067:                
1068:                	return xReturn;
1069:                }
9D00EF14  02401021   ADDU V0, S2, ZERO
9D00EF18  8FBF002C   LW RA, 44(SP)
9D00EF1C  8FB60028   LW S6, 40(SP)
9D00EF20  8FB50024   LW S5, 36(SP)
9D00EF24  8FB40020   LW S4, 32(SP)
9D00EF28  8FB3001C   LW S3, 28(SP)
9D00EF2C  8FB20018   LW S2, 24(SP)
9D00EF30  8FB10014   LW S1, 20(SP)
9D00EF34  8FB00010   LW S0, 16(SP)
9D00EF38  03E00008   JR RA
9D00EF3C  27BD0030   ADDIU SP, SP, 48
1070:                /*-----------------------------------------------------------*/
1071:                
1072:                BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
1073:                {
9D0102C8  27BDFFD8   ADDIU SP, SP, -40
9D0102CC  AFBF0024   SW RA, 36(SP)
9D0102D0  AFB30020   SW S3, 32(SP)
9D0102D4  AFB2001C   SW S2, 28(SP)
9D0102D8  AFB10018   SW S1, 24(SP)
9D0102DC  AFB00014   SW S0, 20(SP)
9D0102E0  00808021   ADDU S0, A0, ZERO
1074:                BaseType_t xReturn;
1075:                UBaseType_t uxSavedInterruptStatus;
1076:                Queue_t * const pxQueue = ( Queue_t * ) xQueue;
1077:                
1078:                	/* Similar to xQueueGenericSendFromISR() but used with semaphores where the
1079:                	item size is 0.  Don't directly wake a task that was blocked on a queue
1080:                	read, instead return a flag to say whether a context switch is required or
1081:                	not (i.e. has a task with a higher priority than us been woken by this
1082:                	post). */
1083:                
1084:                	configASSERT( pxQueue );
1085:                
1086:                	/* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()
1087:                	if the item size is not 0. */
1088:                	configASSERT( pxQueue->uxItemSize == 0 );
1089:                
1090:                	/* Normally a mutex would not be given from an interrupt, especially if
1091:                	there is a mutex holder, as priority inheritance makes no sense for an
1092:                	interrupts, only tasks. */
1093:                	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->pxMutexHolder != NULL ) ) );
1094:                
1095:                	/* RTOS ports that support interrupt nesting have the concept of a maximum
1096:                	system call (or maximum API call) interrupt priority.  Interrupts that are
1097:                	above the maximum system call priority are kept permanently enabled, even
1098:                	when the RTOS kernel is in a critical section, but cannot make any calls to
1099:                	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1100:                	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1101:                	failure if a FreeRTOS API function is called from an interrupt that has been
1102:                	assigned a priority above the configured maximum system call priority.
1103:                	Only FreeRTOS functions that end in FromISR can be called from interrupts
1104:                	that have been assigned a priority at or (logically) below the maximum
1105:                	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1106:                	safe API to ensure interrupt entry is as fast and as simple as possible.
1107:                	More information (albeit Cortex-M specific) is provided on the following
1108:                	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1109:                	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1110:                
1111:                	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
9D0102E4  0F4052D3   JAL uxPortSetInterruptMaskFromISR
9D0102E8  00A09821   ADDU S3, A1, ZERO
9D0102EC  00409021   ADDU S2, V0, ZERO
1112:                	{
1113:                		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
9D0102F0  8E030038   LW V1, 56(S0)
1114:                
1115:                		/* When the queue is used to implement a semaphore no data is ever
1116:                		moved through the queue but it is still valid to see if the queue 'has
1117:                		space'. */
1118:                		if( uxMessagesWaiting < pxQueue->uxLength )
9D0102F4  8E02003C   LW V0, 60(S0)
9D0102F8  0062102B   SLTU V0, V1, V0
9D0102FC  10400025   BEQ V0, ZERO, 0x9D010394
9D010300  00008821   ADDU S1, ZERO, ZERO
1119:                		{
1120:                			const int8_t cTxLock = pxQueue->cTxLock;
9D010304  92020045   LBU V0, 69(S0)
9D010308  7C022420   SEB A0, V0
1121:                
1122:                			traceQUEUE_SEND_FROM_ISR( pxQueue );
1123:                
1124:                			/* A task can only have an inherited priority if it is a mutex
1125:                			holder - and if there is a mutex holder then the mutex cannot be
1126:                			given from an ISR.  As this is the ISR version of the function it
1127:                			can be assumed there is no mutex holder and no need to determine if
1128:                			priority disinheritance is needed.  Simply increase the count of
1129:                			messages (semaphores) available. */
1130:                			pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
9D01030C  24630001   ADDIU V1, V1, 1
9D010310  AE030038   SW V1, 56(S0)
1131:                
1132:                			/* The event list is not altered if the queue is locked.  This will
1133:                			be done when the queue is unlocked later. */
1134:                			if( cTxLock == queueUNLOCKED )
9D010314  2403FFFF   ADDIU V1, ZERO, -1
9D010318  14830017   BNE A0, V1, 0x9D010378
9D01031C  24420001   ADDIU V0, V0, 1
1135:                			{
1136:                				#if ( configUSE_QUEUE_SETS == 1 )
1137:                				{
1138:                					if( pxQueue->pxQueueSetContainer != NULL )
9D010320  8E020048   LW V0, 72(S0)
9D010324  10400009   BEQ V0, ZERO, 0x9D01034C
9D010328  02002021   ADDU A0, S0, ZERO
1139:                					{
1140:                						if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) != pdFALSE )
9D01032C  0F404747   JAL prvNotifyQueueSetContainer
9D010330  00002821   ADDU A1, ZERO, ZERO
9D010334  10400017   BEQ V0, ZERO, 0x9D010394
9D010338  24110001   ADDIU S1, ZERO, 1
1141:                						{
1142:                							/* The semaphore is a member of a queue set, and
1143:                							posting	to the queue set caused a higher priority
1144:                							task to	unblock.  A context switch is required. */
1145:                							if( pxHigherPriorityTaskWoken != NULL )
9D01033C  12600012   BEQ S3, ZERO, 0x9D010388
9D010340  24020001   ADDIU V0, ZERO, 1
9D010344  0B4040E5   J 0x9D010394
9D010348  AE620000   SW V0, 0(S3)
1146:                							{
1147:                								*pxHigherPriorityTaskWoken = pdTRUE;
1148:                							}
1149:                							else
1150:                							{
1151:                								mtCOVERAGE_TEST_MARKER();
1152:                							}
1153:                						}
1154:                						else
1155:                						{
1156:                							mtCOVERAGE_TEST_MARKER();
1157:                						}
1158:                					}
1159:                					else
1160:                					{
1161:                						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
9D01034C  8E020024   LW V0, 36(S0)
9D010350  10400010   BEQ V0, ZERO, 0x9D010394
9D010354  24110001   ADDIU S1, ZERO, 1
1162:                						{
1163:                							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
9D010358  0F4043C9   JAL xTaskRemoveFromEventList
9D01035C  26040024   ADDIU A0, S0, 36
9D010360  1040000C   BEQ V0, ZERO, 0x9D010394
9D010364  00000000   NOP
1164:                							{
1165:                								/* The task waiting has a higher priority so
1166:                								record that a context switch is required. */
1167:                								if( pxHigherPriorityTaskWoken != NULL )
9D010368  12600009   BEQ S3, ZERO, 0x9D010390
9D01036C  24020001   ADDIU V0, ZERO, 1
9D010370  0B4040E5   J 0x9D010394
9D010374  AE620000   SW V0, 0(S3)
1168:                								{
1169:                									*pxHigherPriorityTaskWoken = pdTRUE;
1170:                								}
1171:                								else
1172:                								{
1173:                									mtCOVERAGE_TEST_MARKER();
1174:                								}
1175:                							}
1176:                							else
1177:                							{
1178:                								mtCOVERAGE_TEST_MARKER();
1179:                							}
1180:                						}
1181:                						else
1182:                						{
1183:                							mtCOVERAGE_TEST_MARKER();
1184:                						}
1185:                					}
1186:                				}
1187:                				#else /* configUSE_QUEUE_SETS */
1188:                				{
1189:                					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1190:                					{
1191:                						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1192:                						{
1193:                							/* The task waiting has a higher priority so record that a
1194:                							context	switch is required. */
1195:                							if( pxHigherPriorityTaskWoken != NULL )
1196:                							{
1197:                								*pxHigherPriorityTaskWoken = pdTRUE;
1198:                							}
1199:                							else
1200:                							{
1201:                								mtCOVERAGE_TEST_MARKER();
1202:                							}
1203:                						}
1204:                						else
1205:                						{
1206:                							mtCOVERAGE_TEST_MARKER();
1207:                						}
1208:                					}
1209:                					else
1210:                					{
1211:                						mtCOVERAGE_TEST_MARKER();
1212:                					}
1213:                				}
1214:                				#endif /* configUSE_QUEUE_SETS */
1215:                			}
1216:                			else
1217:                			{
1218:                				/* Increment the lock count so the task that unlocks the queue
1219:                				knows that data was posted while it was locked. */
1220:                				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
9D010378  7C021420   SEB V0, V0
9D01037C  A2020045   SB V0, 69(S0)
1221:                			}
1222:                
1223:                			xReturn = pdPASS;
9D010380  0B4040E5   J 0x9D010394
9D010384  24110001   ADDIU S1, ZERO, 1
9D010388  0B4040E5   J 0x9D010394
9D01038C  24110001   ADDIU S1, ZERO, 1
9D010390  24110001   ADDIU S1, ZERO, 1
1224:                		}
1225:                		else
1226:                		{
1227:                			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
1228:                			xReturn = errQUEUE_FULL;
1229:                		}
1230:                	}
1231:                	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
9D010394  0F4055A7   JAL vPortClearInterruptMaskFromISR
9D010398  02402021   ADDU A0, S2, ZERO
1232:                
1233:                	return xReturn;
1234:                }
9D01039C  02201021   ADDU V0, S1, ZERO
1235:                /*-----------------------------------------------------------*/
1236:                
1237:                BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
1238:                {
9D007A04  27BDFFC8   ADDIU SP, SP, -56
9D007A08  AFBF0034   SW RA, 52(SP)
9D007A0C  AFB60030   SW S6, 48(SP)
9D007A10  AFB5002C   SW S5, 44(SP)
9D007A14  AFB40028   SW S4, 40(SP)
9D007A18  AFB30024   SW S3, 36(SP)
9D007A1C  AFB20020   SW S2, 32(SP)
9D007A20  AFB1001C   SW S1, 28(SP)
9D007A24  AFB00018   SW S0, 24(SP)
9D007A28  00808021   ADDU S0, A0, ZERO
9D007A2C  00A0B021   ADDU S6, A1, ZERO
9D007A30  AFA60040   SW A2, 64(SP)
9D007A34  00E0A821   ADDU S5, A3, ZERO
1239:                BaseType_t xEntryTimeSet = pdFALSE;
9D007A38  00009821   ADDU S3, ZERO, ZERO
1240:                TimeOut_t xTimeOut;
1241:                int8_t *pcOriginalReadPosition;
1242:                Queue_t * const pxQueue = ( Queue_t * ) xQueue;
1243:                
1244:                	configASSERT( pxQueue );
1245:                	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
1246:                	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
1247:                	{
1248:                		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
1249:                	}
1250:                	#endif
1251:                
1252:                	/* This function relaxes the coding standard somewhat to allow return
1253:                	statements within the function itself.  This is done in the interest
1254:                	of execution time efficiency. */
1255:                
1256:                	for( ;; )
1257:                	{
1258:                		taskENTER_CRITICAL();
9D007A44  0F405144   JAL vTaskEnterCritical
9D007A48  00000000   NOP
1259:                		{
1260:                			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
9D007A4C  8E110038   LW S1, 56(S0)
1261:                
1262:                			/* Is there data in the queue now?  To be running the calling task
1263:                			must be the highest priority task wanting to access the queue. */
1264:                			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
9D007A50  1220002B   BEQ S1, ZERO, 0x9D007B00
9D007A54  8FA20040   LW V0, 64(SP)
1265:                			{
1266:                				/* Remember the read position in case the queue is only being
1267:                				peeked. */
1268:                				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
9D007A58  8E12000C   LW S2, 12(S0)
1269:                
1270:                				prvCopyDataFromQueue( pxQueue, pvBuffer );
9D007A5C  02002021   ADDU A0, S0, ZERO
9D007A60  0F4050BF   JAL prvCopyDataFromQueue
9D007A64  02C02821   ADDU A1, S6, ZERO
1271:                
1272:                				if( xJustPeeking == pdFALSE )
9D007A68  56A00016   BNEL S5, ZERO, 0x9D007AC4
9D007A6C  AE12000C   SW S2, 12(S0)
1273:                				{
1274:                					traceQUEUE_RECEIVE( pxQueue );
1275:                
1276:                					/* Actually removing data, not just peeking. */
1277:                					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
9D007A70  2631FFFF   ADDIU S1, S1, -1
9D007A74  AE110038   SW S1, 56(S0)
1278:                
1279:                					#if ( configUSE_MUTEXES == 1 )
1280:                					{
1281:                						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
9D007A78  8E020000   LW V0, 0(S0)
9D007A7C  54400005   BNEL V0, ZERO, 0x9D007A94
9D007A80  8E020010   LW V0, 16(S0)
1282:                						{
1283:                							/* Record the information required to implement
1284:                							priority inheritance should it become necessary. */
1285:                							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
9D007A84  0F4054B5   JAL pvTaskIncrementMutexHeldCount
9D007A88  00000000   NOP
9D007A8C  AE020004   SW V0, 4(S0)
1286:                						}
1287:                						else
1288:                						{
1289:                							mtCOVERAGE_TEST_MARKER();
1290:                						}
1291:                					}
1292:                					#endif /* configUSE_MUTEXES */
1293:                
1294:                					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
9D007A90  8E020010   LW V0, 16(S0)
9D007A94  10400016   BEQ V0, ZERO, 0x9D007AF0
9D007A98  00000000   NOP
1295:                					{
1296:                						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
9D007A9C  0F4043C9   JAL xTaskRemoveFromEventList
9D007AA0  26040010   ADDIU A0, S0, 16
9D007AA4  10400012   BEQ V0, ZERO, 0x9D007AF0
9D007AA8  00000000   NOP
1297:                						{
1298:                							queueYIELD_IF_USING_PREEMPTION();
9D007AAC  40026800   MFC0 V0, Cause
9D007AB0  34420100   ORI V0, V0, 256
9D007AB4  40826800   MTC0 V0, Cause
9D007AB8  000000C0   EHB
9D007ABC  0B401EBC   J 0x9D007AF0
9D007AC0  00000000   NOP
1299:                						}
1300:                						else
1301:                						{
1302:                							mtCOVERAGE_TEST_MARKER();
1303:                						}
1304:                					}
1305:                					else
1306:                					{
1307:                						mtCOVERAGE_TEST_MARKER();
1308:                					}
1309:                				}
1310:                				else
1311:                				{
1312:                					traceQUEUE_PEEK( pxQueue );
1313:                
1314:                					/* The data is not being removed, so reset the read
1315:                					pointer. */
1316:                					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
1317:                
1318:                					/* The data is being left in the queue, so see if there are
1319:                					any other tasks waiting for the data. */
1320:                					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
9D007AC4  8E020024   LW V0, 36(S0)
9D007AC8  10400009   BEQ V0, ZERO, 0x9D007AF0
9D007ACC  00000000   NOP
1321:                					{
1322:                						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
9D007AD0  0F4043C9   JAL xTaskRemoveFromEventList
9D007AD4  26040024   ADDIU A0, S0, 36
9D007AD8  10400005   BEQ V0, ZERO, 0x9D007AF0
9D007ADC  00000000   NOP
1323:                						{
1324:                							/* The task waiting has a higher priority than this task. */
1325:                							queueYIELD_IF_USING_PREEMPTION();
9D007AE0  40026800   MFC0 V0, Cause
9D007AE4  34420100   ORI V0, V0, 256
9D007AE8  40826800   MTC0 V0, Cause
9D007AEC  000000C0   EHB
1326:                						}
1327:                						else
1328:                						{
1329:                							mtCOVERAGE_TEST_MARKER();
1330:                						}
1331:                					}
1332:                					else
1333:                					{
1334:                						mtCOVERAGE_TEST_MARKER();
1335:                					}
1336:                				}
1337:                
1338:                				taskEXIT_CRITICAL();
9D007AF0  0F404EA8   JAL vTaskExitCritical
9D007AF4  00000000   NOP
1339:                				return pdPASS;
9D007AF8  0B401F10   J 0x9D007C40
9D007AFC  24020001   ADDIU V0, ZERO, 1
1340:                			}
1341:                			else
1342:                			{
1343:                				if( xTicksToWait == ( TickType_t ) 0 )
9D007B00  14400005   BNE V0, ZERO, 0x9D007B18
9D007B04  00000000   NOP
1344:                				{
1345:                					/* The queue was empty and no block time is specified (or
1346:                					the block time has expired) so leave now. */
1347:                					taskEXIT_CRITICAL();
9D007B08  0F404EA8   JAL vTaskExitCritical
9D007B0C  00000000   NOP
1348:                					traceQUEUE_RECEIVE_FAILED( pxQueue );
1349:                					return errQUEUE_EMPTY;
9D007B10  0B401F10   J 0x9D007C40
9D007B14  00001021   ADDU V0, ZERO, ZERO
1350:                				}
1351:                				else if( xEntryTimeSet == pdFALSE )
9D007B18  16600004   BNE S3, ZERO, 0x9D007B2C
9D007B1C  00000000   NOP
1352:                				{
1353:                					/* The queue was empty and a block time was specified so
1354:                					configure the timeout structure. */
1355:                					vTaskSetTimeOutState( &xTimeOut );
9D007B20  0F4055F5   JAL vTaskSetTimeOutState
9D007B24  27A40010   ADDIU A0, SP, 16
1356:                					xEntryTimeSet = pdTRUE;
9D007B28  24130001   ADDIU S3, ZERO, 1
1357:                				}
1358:                				else
1359:                				{
1360:                					/* Entry time was already set. */
1361:                					mtCOVERAGE_TEST_MARKER();
1362:                				}
1363:                			}
1364:                		}
1365:                		taskEXIT_CRITICAL();
9D007B2C  0F404EA8   JAL vTaskExitCritical
9D007B30  00000000   NOP
1366:                
1367:                		/* Interrupts and other tasks can send to and receive from the queue
1368:                		now the critical section has been exited. */
1369:                
1370:                		vTaskSuspendAll();
9D007B34  0F4055F0   JAL vTaskSuspendAll
9D007B38  00000000   NOP
1371:                		prvLockQueue( pxQueue );
9D007A3C  2412FFFF   ADDIU S2, ZERO, -1
9D007B3C  0F405144   JAL vTaskEnterCritical
9D007B40  00000000   NOP
9D007B44  92020044   LBU V0, 68(S0)
9D007B48  7C021420   SEB V0, V0
9D007B4C  50520001   BEQL V0, S2, 0x9D007B54
9D007B50  A2000044   SB ZERO, 68(S0)
9D007B54  92020045   LBU V0, 69(S0)
9D007B58  7C021420   SEB V0, V0
9D007B5C  50520001   BEQL V0, S2, 0x9D007B64
9D007B60  A2000045   SB ZERO, 69(S0)
9D007B64  0F404EA8   JAL vTaskExitCritical
9D007B68  00000000   NOP
1372:                
1373:                		/* Update the timeout state to see if it has expired yet. */
1374:                		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
9D007B6C  27A40010   ADDIU A0, SP, 16
9D007B70  0F404798   JAL xTaskCheckForTimeOut
9D007B74  27A50040   ADDIU A1, SP, 64
9D007B78  14400026   BNE V0, ZERO, 0x9D007C14
9D007B7C  00000000   NOP
1375:                		{
1376:                			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
9D007B94  16200019   BNE S1, ZERO, 0x9D007BFC
9D007B98  00000000   NOP
1377:                			{
1378:                				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
1379:                
1380:                				#if ( configUSE_MUTEXES == 1 )
1381:                				{
1382:                					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
9D007B9C  8E020000   LW V0, 0(S0)
9D007BA0  54400008   BNEL V0, ZERO, 0x9D007BC4
9D007BA4  02802021   ADDU A0, S4, ZERO
1383:                					{
1384:                						taskENTER_CRITICAL();
9D007BA8  0F405144   JAL vTaskEnterCritical
9D007BAC  00000000   NOP
1385:                						{
1386:                							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
9D007BB0  0F403A5C   JAL vTaskPriorityInherit
9D007BB4  8E040004   LW A0, 4(S0)
1387:                						}
1388:                						taskEXIT_CRITICAL();
9D007BB8  0F404EA8   JAL vTaskExitCritical
9D007BBC  00000000   NOP
1389:                					}
1390:                					else
1391:                					{
1392:                						mtCOVERAGE_TEST_MARKER();
1393:                					}
1394:                				}
1395:                				#endif
1396:                
1397:                				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
9D007A40  24940024   ADDIU S4, A0, 36
9D007BC0  02802021   ADDU A0, S4, ZERO
9D007BC4  0F405355   JAL vTaskPlaceOnEventList
9D007BC8  8FA50040   LW A1, 64(SP)
1398:                				prvUnlockQueue( pxQueue );
9D007BCC  0F403CF0   JAL prvUnlockQueue
9D007BD0  02002021   ADDU A0, S0, ZERO
1399:                				if( xTaskResumeAll() == pdFALSE )
9D007BD4  0F40379F   JAL xTaskResumeAll
9D007BD8  00000000   NOP
9D007BDC  1440FF99   BNE V0, ZERO, 0x9D007A44
9D007BE0  00000000   NOP
1400:                				{
1401:                					portYIELD_WITHIN_API();
9D007BE4  40026800   MFC0 V0, Cause
9D007BE8  34420100   ORI V0, V0, 256
9D007BEC  40826800   MTC0 V0, Cause
9D007BF0  000000C0   EHB
9D007BF4  0B401E91   J 0x9D007A44
9D007BF8  00000000   NOP
1402:                				}
1403:                				else
1404:                				{
1405:                					mtCOVERAGE_TEST_MARKER();
1406:                				}
1407:                			}
1408:                			else
1409:                			{
1410:                				/* Try again. */
1411:                				prvUnlockQueue( pxQueue );
9D007BFC  0F403CF0   JAL prvUnlockQueue
9D007C00  02002021   ADDU A0, S0, ZERO
1412:                				( void ) xTaskResumeAll();
9D007C04  0F40379F   JAL xTaskResumeAll
9D007C08  00000000   NOP
9D007C0C  0B401E91   J 0x9D007A44
9D007C10  00000000   NOP
1413:                			}
1414:                		}
1415:                		else
1416:                		{
1417:                			prvUnlockQueue( pxQueue );
9D007C14  0F403CF0   JAL prvUnlockQueue
9D007C18  02002021   ADDU A0, S0, ZERO
1418:                			( void ) xTaskResumeAll();
9D007C1C  0F40379F   JAL xTaskResumeAll
9D007C20  00000000   NOP
1419:                
1420:                			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
9D007C38  1620FF82   BNE S1, ZERO, 0x9D007A44
9D007C3C  00001021   ADDU V0, ZERO, ZERO
1421:                			{
1422:                				traceQUEUE_RECEIVE_FAILED( pxQueue );
1423:                				return errQUEUE_EMPTY;
1424:                			}
1425:                			else
1426:                			{
1427:                				mtCOVERAGE_TEST_MARKER();
1428:                			}
1429:                		}
1430:                	}
1431:                }
9D007C40  8FBF0034   LW RA, 52(SP)
1432:                /*-----------------------------------------------------------*/
1433:                
1434:                BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
1435:                {
1436:                BaseType_t xReturn;
1437:                UBaseType_t uxSavedInterruptStatus;
1438:                Queue_t * const pxQueue = ( Queue_t * ) xQueue;
1439:                
1440:                	configASSERT( pxQueue );
1441:                	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
1442:                
1443:                	/* RTOS ports that support interrupt nesting have the concept of a maximum
1444:                	system call (or maximum API call) interrupt priority.  Interrupts that are
1445:                	above the maximum system call priority are kept permanently enabled, even
1446:                	when the RTOS kernel is in a critical section, but cannot make any calls to
1447:                	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1448:                	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1449:                	failure if a FreeRTOS API function is called from an interrupt that has been
1450:                	assigned a priority above the configured maximum system call priority.
1451:                	Only FreeRTOS functions that end in FromISR can be called from interrupts
1452:                	that have been assigned a priority at or (logically) below the maximum
1453:                	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1454:                	safe API to ensure interrupt entry is as fast and as simple as possible.
1455:                	More information (albeit Cortex-M specific) is provided on the following
1456:                	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1457:                	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1458:                
1459:                	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1460:                	{
1461:                		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
1462:                
1463:                		/* Cannot block in an ISR, so check there is data available. */
1464:                		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
1465:                		{
1466:                			const int8_t cRxLock = pxQueue->cRxLock;
1467:                
1468:                			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
1469:                
1470:                			prvCopyDataFromQueue( pxQueue, pvBuffer );
1471:                			pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
1472:                
1473:                			/* If the queue is locked the event list will not be modified.
1474:                			Instead update the lock count so the task that unlocks the queue
1475:                			will know that an ISR has removed data while the queue was
1476:                			locked. */
1477:                			if( cRxLock == queueUNLOCKED )
1478:                			{
1479:                				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
1480:                				{
1481:                					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
1482:                					{
1483:                						/* The task waiting has a higher priority than us so
1484:                						force a context switch. */
1485:                						if( pxHigherPriorityTaskWoken != NULL )
1486:                						{
1487:                							*pxHigherPriorityTaskWoken = pdTRUE;
1488:                						}
1489:                						else
1490:                						{
1491:                							mtCOVERAGE_TEST_MARKER();
1492:                						}
1493:                					}
1494:                					else
1495:                					{
1496:                						mtCOVERAGE_TEST_MARKER();
1497:                					}
1498:                				}
1499:                				else
1500:                				{
1501:                					mtCOVERAGE_TEST_MARKER();
1502:                				}
1503:                			}
1504:                			else
1505:                			{
1506:                				/* Increment the lock count so the task that unlocks the queue
1507:                				knows that data was removed while it was locked. */
1508:                				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
1509:                			}
1510:                
1511:                			xReturn = pdPASS;
1512:                		}
1513:                		else
1514:                		{
1515:                			xReturn = pdFAIL;
1516:                			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
1517:                		}
1518:                	}
1519:                	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1520:                
1521:                	return xReturn;
1522:                }
1523:                /*-----------------------------------------------------------*/
1524:                
1525:                BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
1526:                {
1527:                BaseType_t xReturn;
1528:                UBaseType_t uxSavedInterruptStatus;
1529:                int8_t *pcOriginalReadPosition;
1530:                Queue_t * const pxQueue = ( Queue_t * ) xQueue;
1531:                
1532:                	configASSERT( pxQueue );
1533:                	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
1534:                	configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
1535:                
1536:                	/* RTOS ports that support interrupt nesting have the concept of a maximum
1537:                	system call (or maximum API call) interrupt priority.  Interrupts that are
1538:                	above the maximum system call priority are kept permanently enabled, even
1539:                	when the RTOS kernel is in a critical section, but cannot make any calls to
1540:                	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1541:                	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1542:                	failure if a FreeRTOS API function is called from an interrupt that has been
1543:                	assigned a priority above the configured maximum system call priority.
1544:                	Only FreeRTOS functions that end in FromISR can be called from interrupts
1545:                	that have been assigned a priority at or (logically) below the maximum
1546:                	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1547:                	safe API to ensure interrupt entry is as fast and as simple as possible.
1548:                	More information (albeit Cortex-M specific) is provided on the following
1549:                	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1550:                	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1551:                
1552:                	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1553:                	{
1554:                		/* Cannot block in an ISR, so check there is data available. */
1555:                		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
1556:                		{
1557:                			traceQUEUE_PEEK_FROM_ISR( pxQueue );
1558:                
1559:                			/* Remember the read position so it can be reset as nothing is
1560:                			actually being removed from the queue. */
1561:                			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
1562:                			prvCopyDataFromQueue( pxQueue, pvBuffer );
1563:                			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
1564:                
1565:                			xReturn = pdPASS;
1566:                		}
1567:                		else
1568:                		{
1569:                			xReturn = pdFAIL;
1570:                			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
1571:                		}
1572:                	}
1573:                	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1574:                
1575:                	return xReturn;
1576:                }
1577:                /*-----------------------------------------------------------*/
1578:                
1579:                UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
1580:                {
1581:                UBaseType_t uxReturn;
1582:                
1583:                	configASSERT( xQueue );
1584:                
1585:                	taskENTER_CRITICAL();
1586:                	{
1587:                		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
1588:                	}
1589:                	taskEXIT_CRITICAL();
1590:                
1591:                	return uxReturn;
1592:                } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
1593:                /*-----------------------------------------------------------*/
1594:                
1595:                UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
1596:                {
1597:                UBaseType_t uxReturn;
1598:                Queue_t *pxQueue;
1599:                
1600:                	pxQueue = ( Queue_t * ) xQueue;
1601:                	configASSERT( pxQueue );
1602:                
1603:                	taskENTER_CRITICAL();
1604:                	{
1605:                		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
1606:                	}
1607:                	taskEXIT_CRITICAL();
1608:                
1609:                	return uxReturn;
1610:                } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
1611:                /*-----------------------------------------------------------*/
1612:                
1613:                UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
1614:                {
1615:                UBaseType_t uxReturn;
1616:                
1617:                	configASSERT( xQueue );
1618:                
1619:                	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
1620:                
1621:                	return uxReturn;
1622:                } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
1623:                /*-----------------------------------------------------------*/
1624:                
1625:                void vQueueDelete( QueueHandle_t xQueue )
1626:                {
1627:                Queue_t * const pxQueue = ( Queue_t * ) xQueue;
1628:                
1629:                	configASSERT( pxQueue );
1630:                	traceQUEUE_DELETE( pxQueue );
1631:                
1632:                	#if ( configQUEUE_REGISTRY_SIZE > 0 )
1633:                	{
1634:                		vQueueUnregisterQueue( pxQueue );
1635:                	}
1636:                	#endif
1637:                
1638:                	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
1639:                	{
1640:                		/* The queue can only have been allocated dynamically - free it
1641:                		again. */
1642:                		vPortFree( pxQueue );
1643:                	}
1644:                	#elif( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
1645:                	{
1646:                		/* The queue could have been allocated statically or dynamically, so
1647:                		check before attempting to free the memory. */
1648:                		if( pxQueue->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
1649:                		{
1650:                			vPortFree( pxQueue );
1651:                		}
1652:                		else
1653:                		{
1654:                			mtCOVERAGE_TEST_MARKER();
1655:                		}
1656:                	}
1657:                	#else
1658:                	{
1659:                		/* The queue must have been statically allocated, so is not going to be
1660:                		deleted.  Avoid compiler warnings about the unused parameter. */
1661:                		( void ) pxQueue;
1662:                	}
1663:                	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
1664:                }
1665:                /*-----------------------------------------------------------*/
1666:                
1667:                #if ( configUSE_TRACE_FACILITY == 1 )
1668:                
1669:                	UBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue )
1670:                	{
1671:                		return ( ( Queue_t * ) xQueue )->uxQueueNumber;
1672:                	}
1673:                
1674:                #endif /* configUSE_TRACE_FACILITY */
1675:                /*-----------------------------------------------------------*/
1676:                
1677:                #if ( configUSE_TRACE_FACILITY == 1 )
1678:                
1679:                	void vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber )
1680:                	{
1681:                		( ( Queue_t * ) xQueue )->uxQueueNumber = uxQueueNumber;
1682:                	}
1683:                
1684:                #endif /* configUSE_TRACE_FACILITY */
1685:                /*-----------------------------------------------------------*/
1686:                
1687:                #if ( configUSE_TRACE_FACILITY == 1 )
1688:                
1689:                	uint8_t ucQueueGetQueueType( QueueHandle_t xQueue )
1690:                	{
1691:                		return ( ( Queue_t * ) xQueue )->ucQueueType;
1692:                	}
1693:                
1694:                #endif /* configUSE_TRACE_FACILITY */
1695:                /*-----------------------------------------------------------*/
1696:                
1697:                static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
1698:                {
9D0101D4  27BDFFE0   ADDIU SP, SP, -32
9D0101D8  AFBF001C   SW RA, 28(SP)
9D0101DC  AFB20018   SW S2, 24(SP)
9D0101E0  AFB10014   SW S1, 20(SP)
9D0101E4  AFB00010   SW S0, 16(SP)
9D0101E8  00808021   ADDU S0, A0, ZERO
9D0101EC  00C09021   ADDU S2, A2, ZERO
1699:                BaseType_t xReturn = pdFALSE;
1700:                UBaseType_t uxMessagesWaiting;
1701:                
1702:                	/* This function is called from a critical section. */
1703:                
1704:                	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
9D0101F0  8C910038   LW S1, 56(A0)
1705:                
1706:                	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
9D0101F4  8C860040   LW A2, 64(A0)
9D0101F8  14C00008   BNE A2, ZERO, 0x9D01021C
9D0101FC  00000000   NOP
1707:                	{
1708:                		#if ( configUSE_MUTEXES == 1 )
1709:                		{
1710:                			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
9D010200  8C830000   LW V1, 0(A0)
9D010204  14600028   BNE V1, ZERO, 0x9D0102A8
9D010208  00001021   ADDU V0, ZERO, ZERO
1711:                			{
1712:                				/* The mutex is no longer being held. */
1713:                				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
9D01020C  0F403FBD   JAL xTaskPriorityDisinherit
9D010210  8C840004   LW A0, 4(A0)
9D010214  0B4040AA   J 0x9D0102A8
9D010218  AE000004   SW ZERO, 4(S0)
1714:                				pxQueue->pxMutexHolder = NULL;
1715:                			}
1716:                			else
1717:                			{
1718:                				mtCOVERAGE_TEST_MARKER();
1719:                			}
1720:                		}
1721:                		#endif /* configUSE_MUTEXES */
1722:                	}
1723:                	else if( xPosition == queueSEND_TO_BACK )
9D01021C  1640000F   BNE S2, ZERO, 0x9D01025C
9D010220  00000000   NOP
1724:                	{
1725:                		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
9D010224  0F40343F   JAL memcpy
9D010228  8C840008   LW A0, 8(A0)
1726:                		pxQueue->pcWriteTo += pxQueue->uxItemSize;
9D01022C  8E030008   LW V1, 8(S0)
9D010230  8E020040   LW V0, 64(S0)
9D010234  00621021   ADDU V0, V1, V0
9D010238  AE020008   SW V0, 8(S0)
1727:                		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
9D01023C  8E030004   LW V1, 4(S0)
9D010240  0043182B   SLTU V1, V0, V1
9D010244  14600018   BNE V1, ZERO, 0x9D0102A8
9D010248  00001021   ADDU V0, ZERO, ZERO
1728:                		{
1729:                			pxQueue->pcWriteTo = pxQueue->pcHead;
9D01024C  8E020000   LW V0, 0(S0)
9D010250  AE020008   SW V0, 8(S0)
9D010254  0B4040AA   J 0x9D0102A8
9D010258  00001021   ADDU V0, ZERO, ZERO
1730:                		}
1731:                		else
1732:                		{
1733:                			mtCOVERAGE_TEST_MARKER();
1734:                		}
1735:                	}
1736:                	else
1737:                	{
1738:                		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
9D01025C  0F40343F   JAL memcpy
9D010260  8C84000C   LW A0, 12(A0)
1739:                		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
9D010264  8E030040   LW V1, 64(S0)
9D010268  00031823   SUBU V1, ZERO, V1
9D01026C  8E02000C   LW V0, 12(S0)
9D010270  00431021   ADDU V0, V0, V1
9D010274  AE02000C   SW V0, 12(S0)
1740:                		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
9D010278  8E040000   LW A0, 0(S0)
9D01027C  0044102B   SLTU V0, V0, A0
9D010280  50400005   BEQL V0, ZERO, 0x9D010298
9D010284  24030002   ADDIU V1, ZERO, 2
1741:                		{
1742:                			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
9D010288  8E020004   LW V0, 4(S0)
9D01028C  00431821   ADDU V1, V0, V1
9D010290  AE03000C   SW V1, 12(S0)
1743:                		}
1744:                		else
1745:                		{
1746:                			mtCOVERAGE_TEST_MARKER();
1747:                		}
1748:                
1749:                		if( xPosition == queueOVERWRITE )
9D010294  24030002   ADDIU V1, ZERO, 2
9D010298  16430003   BNE S2, V1, 0x9D0102A8
9D01029C  00001021   ADDU V0, ZERO, ZERO
1750:                		{
1751:                			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
9D0102A0  56200001   BNEL S1, ZERO, 0x9D0102A8
9D0102A4  2631FFFF   ADDIU S1, S1, -1
1752:                			{
1753:                				/* An item is not being added but overwritten, so subtract
1754:                				one from the recorded number of items in the queue so when
1755:                				one is added again below the number of recorded items remains
1756:                				correct. */
1757:                				--uxMessagesWaiting;
1758:                			}
1759:                			else
1760:                			{
1761:                				mtCOVERAGE_TEST_MARKER();
1762:                			}
1763:                		}
1764:                		else
1765:                		{
1766:                			mtCOVERAGE_TEST_MARKER();
1767:                		}
1768:                	}
1769:                
1770:                	pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
9D0102A8  26310001   ADDIU S1, S1, 1
9D0102AC  AE110038   SW S1, 56(S0)
1771:                
1772:                	return xReturn;
1773:                }
9D0102B0  8FBF001C   LW RA, 28(SP)
9D0102B4  8FB20018   LW S2, 24(SP)
9D0102B8  8FB10014   LW S1, 20(SP)
9D0102BC  8FB00010   LW S0, 16(SP)
9D0102C0  03E00008   JR RA
9D0102C4  27BD0020   ADDIU SP, SP, 32
1774:                /*-----------------------------------------------------------*/
1775:                
1776:                static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
1777:                {
9D014308  27BDFFE8   ADDIU SP, SP, -24
9D01430C  AFBF0014   SW RA, 20(SP)
1778:                	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
9D0142FC  8C860040   LW A2, 64(A0)
9D014300  10C00010   BEQ A2, ZERO, 0x9D014344
9D014304  00801021   ADDU V0, A0, ZERO
1779:                	{
1780:                		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
9D014310  8C83000C   LW V1, 12(A0)
9D014314  00661821   ADDU V1, V1, A2
9D014318  AC83000C   SW V1, 12(A0)
1781:                		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
9D01431C  8C840004   LW A0, 4(A0)
9D014320  0064182B   SLTU V1, V1, A0
9D014324  14600003   BNE V1, ZERO, 0x9D014334
9D014328  00A02021   ADDU A0, A1, ZERO
1782:                		{
1783:                			pxQueue->u.pcReadFrom = pxQueue->pcHead;
9D01432C  8C430000   LW V1, 0(V0)
9D014330  AC43000C   SW V1, 12(V0)
1784:                		}
1785:                		else
1786:                		{
1787:                			mtCOVERAGE_TEST_MARKER();
1788:                		}
1789:                		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
9D014334  0F40343F   JAL memcpy
9D014338  8C45000C   LW A1, 12(V0)
1790:                	}
1791:                }
9D01433C  8FBF0014   LW RA, 20(SP)
9D014340  27BD0018   ADDIU SP, SP, 24
9D014344  03E00008   JR RA
9D014348  00000000   NOP
1792:                /*-----------------------------------------------------------*/
1793:                
1794:                static void prvUnlockQueue( Queue_t * const pxQueue )
1795:                {
9D00F3C0  27BDFFE0   ADDIU SP, SP, -32
9D00F3C4  AFBF001C   SW RA, 28(SP)
9D00F3C8  AFB20018   SW S2, 24(SP)
9D00F3CC  AFB10014   SW S1, 20(SP)
9D00F3D0  AFB00010   SW S0, 16(SP)
1796:                	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
1797:                
1798:                	/* The lock counts contains the number of extra data items placed or
1799:                	removed from the queue while the queue was locked.  When a queue is
1800:                	locked items can be added or removed, but the event lists cannot be
1801:                	updated. */
1802:                	taskENTER_CRITICAL();
9D00F3D4  0F405144   JAL vTaskEnterCritical
9D00F3D8  00808821   ADDU S1, A0, ZERO
1803:                	{
1804:                		int8_t cTxLock = pxQueue->cTxLock;
9D00F3DC  92300045   LBU S0, 69(S1)
9D00F3E0  7C108420   SEB S0, S0
1805:                
1806:                		/* See if data was added to the queue while it was locked. */
1807:                		while( cTxLock > queueLOCKED_UNMODIFIED )
9D00F3E4  1A00001A   BLEZ S0, 0x9D00F450
9D00F3E8  2402FFFF   ADDIU V0, ZERO, -1
9D00F444  5600FFEB   BNEL S0, ZERO, 0x9D00F3F4
9D00F448  8E220048   LW V0, 72(S1)
1808:                		{
1809:                			/* Data was posted while the queue was locked.  Are any tasks
1810:                			blocked waiting for data to become available? */
1811:                			#if ( configUSE_QUEUE_SETS == 1 )
1812:                			{
1813:                				if( pxQueue->pxQueueSetContainer != NULL )
9D00F3F0  8E220048   LW V0, 72(S1)
9D00F3F4  10400009   BEQ V0, ZERO, 0x9D00F41C
9D00F3F8  02202021   ADDU A0, S1, ZERO
1814:                				{
1815:                					if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) != pdFALSE )
9D00F3FC  0F404747   JAL prvNotifyQueueSetContainer
9D00F400  00002821   ADDU A1, ZERO, ZERO
9D00F404  1040000E   BEQ V0, ZERO, 0x9D00F440
9D00F408  2610FFFF   ADDIU S0, S0, -1
1816:                					{
1817:                						/* The queue is a member of a queue set, and posting to
1818:                						the queue set caused a higher priority task to unblock.
1819:                						A context switch is required. */
1820:                						vTaskMissedYield();
9D00F40C  0F40564D   JAL vTaskMissedYield
9D00F410  00000000   NOP
9D00F414  0B403D11   J 0x9D00F444
9D00F418  7C108420   SEB S0, S0
1821:                					}
1822:                					else
1823:                					{
1824:                						mtCOVERAGE_TEST_MARKER();
1825:                					}
1826:                				}
1827:                				else
1828:                				{
1829:                					/* Tasks that are removed from the event list will get
1830:                					added to the pending ready list as the scheduler is still
1831:                					suspended. */
1832:                					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
9D00F41C  8E220024   LW V0, 36(S1)
9D00F420  1040000B   BEQ V0, ZERO, 0x9D00F450
9D00F424  2402FFFF   ADDIU V0, ZERO, -1
1833:                					{
1834:                						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
9D00F3EC  26320024   ADDIU S2, S1, 36
9D00F428  0F4043C9   JAL xTaskRemoveFromEventList
9D00F42C  02402021   ADDU A0, S2, ZERO
9D00F430  10400003   BEQ V0, ZERO, 0x9D00F440
9D00F434  2610FFFF   ADDIU S0, S0, -1
1835:                						{
1836:                							/* The task waiting has a higher priority so record that a
1837:                							context	switch is required. */
1838:                							vTaskMissedYield();
9D00F438  0F40564D   JAL vTaskMissedYield
9D00F43C  00000000   NOP
1839:                						}
1840:                						else
1841:                						{
1842:                							mtCOVERAGE_TEST_MARKER();
1843:                						}
1844:                					}
1845:                					else
1846:                					{
1847:                						break;
1848:                					}
1849:                				}
1850:                			}
1851:                			#else /* configUSE_QUEUE_SETS */
1852:                			{
1853:                				/* Tasks that are removed from the event list will get added to
1854:                				the pending ready list as the scheduler is still suspended. */
1855:                				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1856:                				{
1857:                					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1858:                					{
1859:                						/* The task waiting has a higher priority so record that
1860:                						a context switch is required. */
1861:                						vTaskMissedYield();
1862:                					}
1863:                					else
1864:                					{
1865:                						mtCOVERAGE_TEST_MARKER();
1866:                					}
1867:                				}
1868:                				else
1869:                				{
1870:                					break;
1871:                				}
1872:                			}
1873:                			#endif /* configUSE_QUEUE_SETS */
1874:                
1875:                			--cTxLock;
9D00F440  7C108420   SEB S0, S0
1876:                		}
1877:                
1878:                		pxQueue->cTxLock = queueUNLOCKED;
9D00F44C  2402FFFF   ADDIU V0, ZERO, -1
9D00F450  A2220045   SB V0, 69(S1)
1879:                	}
1880:                	taskEXIT_CRITICAL();
9D00F454  0F404EA8   JAL vTaskExitCritical
9D00F458  00000000   NOP
1881:                
1882:                	/* Do the same for the Rx lock. */
1883:                	taskENTER_CRITICAL();
9D00F45C  0F405144   JAL vTaskEnterCritical
9D00F460  00000000   NOP
1884:                	{
1885:                		int8_t cRxLock = pxQueue->cRxLock;
9D00F464  92300044   LBU S0, 68(S1)
9D00F468  7C108420   SEB S0, S0
1886:                
1887:                		while( cRxLock > queueLOCKED_UNMODIFIED )
9D00F46C  1A000012   BLEZ S0, 0x9D00F4B8
9D00F470  2402FFFF   ADDIU V0, ZERO, -1
9D00F4AC  5600FFF6   BNEL S0, ZERO, 0x9D00F488
9D00F4B0  8E220010   LW V0, 16(S1)
1888:                		{
1889:                			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
9D00F474  8E220010   LW V0, 16(S1)
9D00F478  1040000E   BEQ V0, ZERO, 0x9D00F4B4
9D00F47C  26320010   ADDIU S2, S1, 16
9D00F480  0B403D24   J 0x9D00F490
9D00F484  00000000   NOP
9D00F488  1040000B   BEQ V0, ZERO, 0x9D00F4B8
9D00F48C  2402FFFF   ADDIU V0, ZERO, -1
1890:                			{
1891:                				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
9D00F490  0F4043C9   JAL xTaskRemoveFromEventList
9D00F494  02402021   ADDU A0, S2, ZERO
9D00F498  10400003   BEQ V0, ZERO, 0x9D00F4A8
9D00F49C  2610FFFF   ADDIU S0, S0, -1
1892:                				{
1893:                					vTaskMissedYield();
9D00F4A0  0F40564D   JAL vTaskMissedYield
9D00F4A4  00000000   NOP
1894:                				}
1895:                				else
1896:                				{
1897:                					mtCOVERAGE_TEST_MARKER();
1898:                				}
1899:                
1900:                				--cRxLock;
9D00F4A8  7C108420   SEB S0, S0
1901:                			}
1902:                			else
1903:                			{
1904:                				break;
1905:                			}
1906:                		}
1907:                
1908:                		pxQueue->cRxLock = queueUNLOCKED;
9D00F4B4  2402FFFF   ADDIU V0, ZERO, -1
9D00F4B8  A2220044   SB V0, 68(S1)
1909:                	}
1910:                	taskEXIT_CRITICAL();
9D00F4BC  0F404EA8   JAL vTaskExitCritical
9D00F4C0  00000000   NOP
1911:                }
9D00F4C4  8FBF001C   LW RA, 28(SP)
9D00F4C8  8FB20018   LW S2, 24(SP)
9D00F4CC  8FB10014   LW S1, 20(SP)
9D00F4D0  8FB00010   LW S0, 16(SP)
9D00F4D4  03E00008   JR RA
9D00F4D8  27BD0020   ADDIU SP, SP, 32
1912:                /*-----------------------------------------------------------*/
1913:                
1914:                static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
1915:                {
1916:                BaseType_t xReturn;
1917:                
1918:                	taskENTER_CRITICAL();
9D007B80  0F405144   JAL vTaskEnterCritical
9D007C24  0F405144   JAL vTaskEnterCritical
1919:                	{
1920:                		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
9D007B88  8E110038   LW S1, 56(S0)
9D007C2C  8E110038   LW S1, 56(S0)
1921:                		{
1922:                			xReturn = pdTRUE;
1923:                		}
1924:                		else
1925:                		{
1926:                			xReturn = pdFALSE;
1927:                		}
1928:                	}
1929:                	taskEXIT_CRITICAL();
9D007B8C  0F404EA8   JAL vTaskExitCritical
9D007C30  0F404EA8   JAL vTaskExitCritical
9D007C34  00000000   NOP
1930:                
1931:                	return xReturn;
1932:                }
1933:                /*-----------------------------------------------------------*/
1934:                
1935:                BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
1936:                {
1937:                BaseType_t xReturn;
1938:                
1939:                	configASSERT( xQueue );
1940:                	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
1941:                	{
1942:                		xReturn = pdTRUE;
1943:                	}
1944:                	else
1945:                	{
1946:                		xReturn = pdFALSE;
1947:                	}
1948:                
1949:                	return xReturn;
1950:                } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
1951:                /*-----------------------------------------------------------*/
1952:                
1953:                static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
1954:                {
1955:                BaseType_t xReturn;
1956:                
1957:                	taskENTER_CRITICAL();
9D00805C  0F405144   JAL vTaskEnterCritical
1958:                	{
1959:                		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
9D008064  8E1E0038   LW S8, 56(S0)
1960:                		{
1961:                			xReturn = pdTRUE;
1962:                		}
1963:                		else
1964:                		{
1965:                			xReturn = pdFALSE;
1966:                		}
1967:                	}
1968:                	taskEXIT_CRITICAL();
9D008068  0F404EA8   JAL vTaskExitCritical
9D00806C  8E17003C   LW S7, 60(S0)
1969:                
1970:                	return xReturn;
1971:                }
1972:                /*-----------------------------------------------------------*/
1973:                
1974:                BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
1975:                {
1976:                BaseType_t xReturn;
1977:                
1978:                	configASSERT( xQueue );
1979:                	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
1980:                	{
1981:                		xReturn = pdTRUE;
1982:                	}
1983:                	else
1984:                	{
1985:                		xReturn = pdFALSE;
1986:                	}
1987:                
1988:                	return xReturn;
1989:                } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
1990:                /*-----------------------------------------------------------*/
1991:                
1992:                #if ( configUSE_CO_ROUTINES == 1 )
1993:                
1994:                	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait )
1995:                	{
1996:                	BaseType_t xReturn;
1997:                	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
1998:                
1999:                		/* If the queue is already full we may have to block.  A critical section
2000:                		is required to prevent an interrupt removing something from the queue
2001:                		between the check to see if the queue is full and blocking on the queue. */
2002:                		portDISABLE_INTERRUPTS();
2003:                		{
2004:                			if( prvIsQueueFull( pxQueue ) != pdFALSE )
2005:                			{
2006:                				/* The queue is full - do we want to block or just leave without
2007:                				posting? */
2008:                				if( xTicksToWait > ( TickType_t ) 0 )
2009:                				{
2010:                					/* As this is called from a coroutine we cannot block directly, but
2011:                					return indicating that we need to block. */
2012:                					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
2013:                					portENABLE_INTERRUPTS();
2014:                					return errQUEUE_BLOCKED;
2015:                				}
2016:                				else
2017:                				{
2018:                					portENABLE_INTERRUPTS();
2019:                					return errQUEUE_FULL;
2020:                				}
2021:                			}
2022:                		}
2023:                		portENABLE_INTERRUPTS();
2024:                
2025:                		portDISABLE_INTERRUPTS();
2026:                		{
2027:                			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
2028:                			{
2029:                				/* There is room in the queue, copy the data into the queue. */
2030:                				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
2031:                				xReturn = pdPASS;
2032:                
2033:                				/* Were any co-routines waiting for data to become available? */
2034:                				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
2035:                				{
2036:                					/* In this instance the co-routine could be placed directly
2037:                					into the ready list as we are within a critical section.
2038:                					Instead the same pending ready list mechanism is used as if
2039:                					the event were caused from within an interrupt. */
2040:                					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
2041:                					{
2042:                						/* The co-routine waiting has a higher priority so record
2043:                						that a yield might be appropriate. */
2044:                						xReturn = errQUEUE_YIELD;
2045:                					}
2046:                					else
2047:                					{
2048:                						mtCOVERAGE_TEST_MARKER();
2049:                					}
2050:                				}
2051:                				else
2052:                				{
2053:                					mtCOVERAGE_TEST_MARKER();
2054:                				}
2055:                			}
2056:                			else
2057:                			{
2058:                				xReturn = errQUEUE_FULL;
2059:                			}
2060:                		}
2061:                		portENABLE_INTERRUPTS();
2062:                
2063:                		return xReturn;
2064:                	}
2065:                
2066:                #endif /* configUSE_CO_ROUTINES */
2067:                /*-----------------------------------------------------------*/
2068:                
2069:                #if ( configUSE_CO_ROUTINES == 1 )
2070:                
2071:                	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )
2072:                	{
2073:                	BaseType_t xReturn;
2074:                	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
2075:                
2076:                		/* If the queue is already empty we may have to block.  A critical section
2077:                		is required to prevent an interrupt adding something to the queue
2078:                		between the check to see if the queue is empty and blocking on the queue. */
2079:                		portDISABLE_INTERRUPTS();
2080:                		{
2081:                			if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
2082:                			{
2083:                				/* There are no messages in the queue, do we want to block or just
2084:                				leave with nothing? */
2085:                				if( xTicksToWait > ( TickType_t ) 0 )
2086:                				{
2087:                					/* As this is a co-routine we cannot block directly, but return
2088:                					indicating that we need to block. */
2089:                					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
2090:                					portENABLE_INTERRUPTS();
2091:                					return errQUEUE_BLOCKED;
2092:                				}
2093:                				else
2094:                				{
2095:                					portENABLE_INTERRUPTS();
2096:                					return errQUEUE_FULL;
2097:                				}
2098:                			}
2099:                			else
2100:                			{
2101:                				mtCOVERAGE_TEST_MARKER();
2102:                			}
2103:                		}
2104:                		portENABLE_INTERRUPTS();
2105:                
2106:                		portDISABLE_INTERRUPTS();
2107:                		{
2108:                			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
2109:                			{
2110:                				/* Data is available from the queue. */
2111:                				pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
2112:                				if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
2113:                				{
2114:                					pxQueue->u.pcReadFrom = pxQueue->pcHead;
2115:                				}
2116:                				else
2117:                				{
2118:                					mtCOVERAGE_TEST_MARKER();
2119:                				}
2120:                				--( pxQueue->uxMessagesWaiting );
2121:                				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
2122:                
2123:                				xReturn = pdPASS;
2124:                
2125:                				/* Were any co-routines waiting for space to become available? */
2126:                				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
2127:                				{
2128:                					/* In this instance the co-routine could be placed directly
2129:                					into the ready list as we are within a critical section.
2130:                					Instead the same pending ready list mechanism is used as if
2131:                					the event were caused from within an interrupt. */
2132:                					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
2133:                					{
2134:                						xReturn = errQUEUE_YIELD;
2135:                					}
2136:                					else
2137:                					{
2138:                						mtCOVERAGE_TEST_MARKER();
2139:                					}
2140:                				}
2141:                				else
2142:                				{
2143:                					mtCOVERAGE_TEST_MARKER();
2144:                				}
2145:                			}
2146:                			else
2147:                			{
2148:                				xReturn = pdFAIL;
2149:                			}
2150:                		}
2151:                		portENABLE_INTERRUPTS();
2152:                
2153:                		return xReturn;
2154:                	}
2155:                
2156:                #endif /* configUSE_CO_ROUTINES */
2157:                /*-----------------------------------------------------------*/
2158:                
2159:                #if ( configUSE_CO_ROUTINES == 1 )
2160:                
2161:                	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken )
2162:                	{
2163:                	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
2164:                
2165:                		/* Cannot block within an ISR so if there is no space on the queue then
2166:                		exit without doing anything. */
2167:                		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
2168:                		{
2169:                			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
2170:                
2171:                			/* We only want to wake one co-routine per ISR, so check that a
2172:                			co-routine has not already been woken. */
2173:                			if( xCoRoutinePreviouslyWoken == pdFALSE )
2174:                			{
2175:                				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
2176:                				{
2177:                					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
2178:                					{
2179:                						return pdTRUE;
2180:                					}
2181:                					else
2182:                					{
2183:                						mtCOVERAGE_TEST_MARKER();
2184:                					}
2185:                				}
2186:                				else
2187:                				{
2188:                					mtCOVERAGE_TEST_MARKER();
2189:                				}
2190:                			}
2191:                			else
2192:                			{
2193:                				mtCOVERAGE_TEST_MARKER();
2194:                			}
2195:                		}
2196:                		else
2197:                		{
2198:                			mtCOVERAGE_TEST_MARKER();
2199:                		}
2200:                
2201:                		return xCoRoutinePreviouslyWoken;
2202:                	}
2203:                
2204:                #endif /* configUSE_CO_ROUTINES */
2205:                /*-----------------------------------------------------------*/
2206:                
2207:                #if ( configUSE_CO_ROUTINES == 1 )
2208:                
2209:                	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWoken )
2210:                	{
2211:                	BaseType_t xReturn;
2212:                	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
2213:                
2214:                		/* We cannot block from an ISR, so check there is data available. If
2215:                		not then just leave without doing anything. */
2216:                		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
2217:                		{
2218:                			/* Copy the data from the queue. */
2219:                			pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
2220:                			if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
2221:                			{
2222:                				pxQueue->u.pcReadFrom = pxQueue->pcHead;
2223:                			}
2224:                			else
2225:                			{
2226:                				mtCOVERAGE_TEST_MARKER();
2227:                			}
2228:                			--( pxQueue->uxMessagesWaiting );
2229:                			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
2230:                
2231:                			if( ( *pxCoRoutineWoken ) == pdFALSE )
2232:                			{
2233:                				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
2234:                				{
2235:                					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
2236:                					{
2237:                						*pxCoRoutineWoken = pdTRUE;
2238:                					}
2239:                					else
2240:                					{
2241:                						mtCOVERAGE_TEST_MARKER();
2242:                					}
2243:                				}
2244:                				else
2245:                				{
2246:                					mtCOVERAGE_TEST_MARKER();
2247:                				}
2248:                			}
2249:                			else
2250:                			{
2251:                				mtCOVERAGE_TEST_MARKER();
2252:                			}
2253:                
2254:                			xReturn = pdPASS;
2255:                		}
2256:                		else
2257:                		{
2258:                			xReturn = pdFAIL;
2259:                		}
2260:                
2261:                		return xReturn;
2262:                	}
2263:                
2264:                #endif /* configUSE_CO_ROUTINES */
2265:                /*-----------------------------------------------------------*/
2266:                
2267:                #if ( configQUEUE_REGISTRY_SIZE > 0 )
2268:                
2269:                	void vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcQueueName ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
2270:                	{
2271:                	UBaseType_t ux;
2272:                
2273:                		/* See if there is an empty space in the registry.  A NULL name denotes
2274:                		a free slot. */
2275:                		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
9D013A54  24030001   ADDIU V1, ZERO, 1
9D013A58  24070008   ADDIU A3, ZERO, 8
9D013A70  00001821   ADDU V1, ZERO, ZERO
9D013A90  1467FFF2   BNE V1, A3, 0x9D013A5C
2276:                		{
2277:                			if( xQueueRegistry[ ux ].pcQueueName == NULL )
9D013A40  3C02A000   LUI V0, -24576
9D013A44  8C420DF0   LW V0, 3568(V0)
9D013A48  10400009   BEQ V0, ZERO, 0x9D013A70
9D013A4C  3C02A000   LUI V0, -24576
9D013A50  24420DF8   ADDIU V0, V0, 3576
9D013A5C  8C460000   LW A2, 0(V0)
9D013A60  54C0000B   BNEL A2, ZERO, 0x9D013A90
9D013A64  24630001   ADDIU V1, V1, 1
2278:                			{
2279:                				/* Store the information on this queue. */
2280:                				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
9D013A68  0B404E9E   J 0x9D013A78
9D013A6C  000318C0   SLL V1, V1, 3
9D013A74  000318C0   SLL V1, V1, 3
9D013A78  3C02A000   LUI V0, -24576
9D013A7C  24420DF0   ADDIU V0, V0, 3568
9D013A80  00621821   ADDU V1, V1, V0
9D013A84  AC650000   SW A1, 0(V1)
2281:                				xQueueRegistry[ ux ].xHandle = xQueue;
2282:                
2283:                				traceQUEUE_REGISTRY_ADD( xQueue, pcQueueName );
2284:                				break;
9D013A88  03E00008   JR RA
9D013A8C  AC640004   SW A0, 4(V1)
9D013A90  1467FFF2   BNE V1, A3, 0x9D013A5C
9D013A94  24420008   ADDIU V0, V0, 8
9D013A98  03E00008   JR RA
9D013A9C  00000000   NOP
2285:                			}
2286:                			else
2287:                			{
2288:                				mtCOVERAGE_TEST_MARKER();
2289:                			}
2290:                		}
2291:                	}
2292:                
2293:                #endif /* configQUEUE_REGISTRY_SIZE */
2294:                /*-----------------------------------------------------------*/
2295:                
2296:                #if ( configQUEUE_REGISTRY_SIZE > 0 )
2297:                
2298:                	const char *pcQueueGetName( QueueHandle_t xQueue ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
2299:                	{
2300:                	UBaseType_t ux;
2301:                	const char *pcReturn = NULL; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
2302:                
2303:                		/* Note there is nothing here to protect against another task adding or
2304:                		removing entries from the registry while it is being searched. */
2305:                		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
2306:                		{
2307:                			if( xQueueRegistry[ ux ].xHandle == xQueue )
2308:                			{
2309:                				pcReturn = xQueueRegistry[ ux ].pcQueueName;
2310:                				break;
2311:                			}
2312:                			else
2313:                			{
2314:                				mtCOVERAGE_TEST_MARKER();
2315:                			}
2316:                		}
2317:                
2318:                		return pcReturn;
2319:                	}
2320:                
2321:                #endif /* configQUEUE_REGISTRY_SIZE */
2322:                /*-----------------------------------------------------------*/
2323:                
2324:                #if ( configQUEUE_REGISTRY_SIZE > 0 )
2325:                
2326:                	void vQueueUnregisterQueue( QueueHandle_t xQueue )
2327:                	{
2328:                	UBaseType_t ux;
2329:                
2330:                		/* See if the handle of the queue being unregistered in actually in the
2331:                		registry. */
2332:                		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
2333:                		{
2334:                			if( xQueueRegistry[ ux ].xHandle == xQueue )
2335:                			{
2336:                				/* Set the name to NULL to show that this slot if free again. */
2337:                				xQueueRegistry[ ux ].pcQueueName = NULL;
2338:                
2339:                				/* Set the handle to NULL to ensure the same queue handle cannot
2340:                				appear in the registry twice if it is added, removed, then
2341:                				added again. */
2342:                				xQueueRegistry[ ux ].xHandle = ( QueueHandle_t ) 0;
2343:                				break;
2344:                			}
2345:                			else
2346:                			{
2347:                				mtCOVERAGE_TEST_MARKER();
2348:                			}
2349:                		}
2350:                
2351:                	} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
2352:                
2353:                #endif /* configQUEUE_REGISTRY_SIZE */
2354:                /*-----------------------------------------------------------*/
2355:                
2356:                #if ( configUSE_TIMERS == 1 )
2357:                
2358:                	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
2359:                	{
9D0127B8  27BDFFE0   ADDIU SP, SP, -32
9D0127BC  AFBF001C   SW RA, 28(SP)
9D0127C0  AFB20018   SW S2, 24(SP)
9D0127C4  AFB10014   SW S1, 20(SP)
9D0127C8  AFB00010   SW S0, 16(SP)
9D0127CC  00808021   ADDU S0, A0, ZERO
9D0127D0  00A09021   ADDU S2, A1, ZERO
2360:                	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
2361:                
2362:                		/* This function should not be called by application code hence the
2363:                		'Restricted' in its name.  It is not part of the public API.  It is
2364:                		designed for use by kernel code, and has special calling requirements.
2365:                		It can result in vListInsert() being called on a list that can only
2366:                		possibly ever have one item in it, so the list will be fast, but even
2367:                		so it should be called with the scheduler locked and not from a critical
2368:                		section. */
2369:                
2370:                		/* Only do anything if there are no messages in the queue.  This function
2371:                		will not actually cause the task to block, just place it on a blocked
2372:                		list.  It will not block until the scheduler is unlocked - at which
2373:                		time a yield will be performed.  If an item is added to the queue while
2374:                		the queue is locked, and the calling task blocks on the queue, then the
2375:                		calling task will be immediately unblocked when the queue is unlocked. */
2376:                		prvLockQueue( pxQueue );
9D0127D4  0F405144   JAL vTaskEnterCritical
9D0127D8  00C08821   ADDU S1, A2, ZERO
9D0127DC  92030044   LBU V1, 68(S0)
9D0127E0  7C031C20   SEB V1, V1
9D0127E4  2402FFFF   ADDIU V0, ZERO, -1
9D0127E8  50620001   BEQL V1, V0, 0x9D0127F0
9D0127EC  A2000044   SB ZERO, 68(S0)
9D0127F0  92030045   LBU V1, 69(S0)
9D0127F4  7C031C20   SEB V1, V1
9D0127F8  2402FFFF   ADDIU V0, ZERO, -1
9D0127FC  50620001   BEQL V1, V0, 0x9D012804
9D012800  A2000045   SB ZERO, 69(S0)
9D012804  0F404EA8   JAL vTaskExitCritical
9D012808  00000000   NOP
2377:                		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
9D01280C  8E020038   LW V0, 56(S0)
9D012810  14400004   BNE V0, ZERO, 0x9D012824
9D012814  26040024   ADDIU A0, S0, 36
2378:                		{
2379:                			/* There is nothing in the queue, block for the specified period. */
2380:                			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
9D012818  02402821   ADDU A1, S2, ZERO
9D01281C  0F405156   JAL vTaskPlaceOnEventListRestricted
9D012820  02203021   ADDU A2, S1, ZERO
2381:                		}
2382:                		else
2383:                		{
2384:                			mtCOVERAGE_TEST_MARKER();
2385:                		}
2386:                		prvUnlockQueue( pxQueue );
9D012824  0F403CF0   JAL prvUnlockQueue
9D012828  02002021   ADDU A0, S0, ZERO
2387:                	}
9D01282C  8FBF001C   LW RA, 28(SP)
9D012830  8FB20018   LW S2, 24(SP)
9D012834  8FB10014   LW S1, 20(SP)
9D012838  8FB00010   LW S0, 16(SP)
9D01283C  03E00008   JR RA
9D012840  27BD0020   ADDIU SP, SP, 32
2388:                
2389:                #endif /* configUSE_TIMERS */
2390:                /*-----------------------------------------------------------*/
2391:                
2392:                #if( ( configUSE_QUEUE_SETS == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
2393:                
2394:                	QueueSetHandle_t xQueueCreateSet( const UBaseType_t uxEventQueueLength )
2395:                	{
2396:                	QueueSetHandle_t pxQueue;
2397:                
2398:                		pxQueue = xQueueGenericCreate( uxEventQueueLength, sizeof( Queue_t * ), queueQUEUE_TYPE_SET );
2399:                
2400:                		return pxQueue;
2401:                	}
2402:                
2403:                #endif /* configUSE_QUEUE_SETS */
2404:                /*-----------------------------------------------------------*/
2405:                
2406:                #if ( configUSE_QUEUE_SETS == 1 )
2407:                
2408:                	BaseType_t xQueueAddToSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet )
2409:                	{
2410:                	BaseType_t xReturn;
2411:                
2412:                		taskENTER_CRITICAL();
2413:                		{
2414:                			if( ( ( Queue_t * ) xQueueOrSemaphore )->pxQueueSetContainer != NULL )
2415:                			{
2416:                				/* Cannot add a queue/semaphore to more than one queue set. */
2417:                				xReturn = pdFAIL;
2418:                			}
2419:                			else if( ( ( Queue_t * ) xQueueOrSemaphore )->uxMessagesWaiting != ( UBaseType_t ) 0 )
2420:                			{
2421:                				/* Cannot add a queue/semaphore to a queue set if there are already
2422:                				items in the queue/semaphore. */
2423:                				xReturn = pdFAIL;
2424:                			}
2425:                			else
2426:                			{
2427:                				( ( Queue_t * ) xQueueOrSemaphore )->pxQueueSetContainer = xQueueSet;
2428:                				xReturn = pdPASS;
2429:                			}
2430:                		}
2431:                		taskEXIT_CRITICAL();
2432:                
2433:                		return xReturn;
2434:                	}
2435:                
2436:                #endif /* configUSE_QUEUE_SETS */
2437:                /*-----------------------------------------------------------*/
2438:                
2439:                #if ( configUSE_QUEUE_SETS == 1 )
2440:                
2441:                	BaseType_t xQueueRemoveFromSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet )
2442:                	{
2443:                	BaseType_t xReturn;
2444:                	Queue_t * const pxQueueOrSemaphore = ( Queue_t * ) xQueueOrSemaphore;
2445:                
2446:                		if( pxQueueOrSemaphore->pxQueueSetContainer != xQueueSet )
2447:                		{
2448:                			/* The queue was not a member of the set. */
2449:                			xReturn = pdFAIL;
2450:                		}
2451:                		else if( pxQueueOrSemaphore->uxMessagesWaiting != ( UBaseType_t ) 0 )
2452:                		{
2453:                			/* It is dangerous to remove a queue from a set when the queue is
2454:                			not empty because the queue set will still hold pending events for
2455:                			the queue. */
2456:                			xReturn = pdFAIL;
2457:                		}
2458:                		else
2459:                		{
2460:                			taskENTER_CRITICAL();
2461:                			{
2462:                				/* The queue is no longer contained in the set. */
2463:                				pxQueueOrSemaphore->pxQueueSetContainer = NULL;
2464:                			}
2465:                			taskEXIT_CRITICAL();
2466:                			xReturn = pdPASS;
2467:                		}
2468:                
2469:                		return xReturn;
2470:                	} /*lint !e818 xQueueSet could not be declared as pointing to const as it is a typedef. */
2471:                
2472:                #endif /* configUSE_QUEUE_SETS */
2473:                /*-----------------------------------------------------------*/
2474:                
2475:                #if ( configUSE_QUEUE_SETS == 1 )
2476:                
2477:                	QueueSetMemberHandle_t xQueueSelectFromSet( QueueSetHandle_t xQueueSet, TickType_t const xTicksToWait )
2478:                	{
2479:                	QueueSetMemberHandle_t xReturn = NULL;
2480:                
2481:                		( void ) xQueueGenericReceive( ( QueueHandle_t ) xQueueSet, &xReturn, xTicksToWait, pdFALSE ); /*lint !e961 Casting from one typedef to another is not redundant. */
2482:                		return xReturn;
2483:                	}
2484:                
2485:                #endif /* configUSE_QUEUE_SETS */
2486:                /*-----------------------------------------------------------*/
2487:                
2488:                #if ( configUSE_QUEUE_SETS == 1 )
2489:                
2490:                	QueueSetMemberHandle_t xQueueSelectFromSetFromISR( QueueSetHandle_t xQueueSet )
2491:                	{
2492:                	QueueSetMemberHandle_t xReturn = NULL;
2493:                
2494:                		( void ) xQueueReceiveFromISR( ( QueueHandle_t ) xQueueSet, &xReturn, NULL ); /*lint !e961 Casting from one typedef to another is not redundant. */
2495:                		return xReturn;
2496:                	}
2497:                
2498:                #endif /* configUSE_QUEUE_SETS */
2499:                /*-----------------------------------------------------------*/
2500:                
2501:                #if ( configUSE_QUEUE_SETS == 1 )
2502:                
2503:                	static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue, const BaseType_t xCopyPosition )
2504:                	{
9D011D1C  27BDFFD8   ADDIU SP, SP, -40
9D011D20  AFBF0024   SW RA, 36(SP)
9D011D24  AFB30020   SW S3, 32(SP)
9D011D28  AFB2001C   SW S2, 28(SP)
9D011D2C  AFB10018   SW S1, 24(SP)
9D011D30  AFB00014   SW S0, 20(SP)
9D011D34  AFA40028   SW A0, 40(SP)
2505:                	Queue_t *pxQueueSetContainer = pxQueue->pxQueueSetContainer;
9D011D38  8C900048   LW S0, 72(A0)
2506:                	BaseType_t xReturn = pdFALSE;
2507:                
2508:                		/* This function must be called form a critical section. */
2509:                
2510:                		configASSERT( pxQueueSetContainer );
2511:                		configASSERT( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength );
2512:                
2513:                		if( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength )
9D011D3C  8E030038   LW V1, 56(S0)
9D011D40  8E02003C   LW V0, 60(S0)
9D011D44  0062102B   SLTU V0, V1, V0
9D011D48  10400015   BEQ V0, ZERO, 0x9D011DA0
9D011D4C  00008821   ADDU S1, ZERO, ZERO
9D011D50  00A03021   ADDU A2, A1, ZERO
2514:                		{
2515:                			const int8_t cTxLock = pxQueueSetContainer->cTxLock;
9D011D54  92120045   LBU S2, 69(S0)
9D011D58  7C129C20   SEB S3, S2
2516:                
2517:                			traceQUEUE_SEND( pxQueueSetContainer );
2518:                
2519:                			/* The data copied is the handle of the queue that contains data. */
2520:                			xReturn = prvCopyDataToQueue( pxQueueSetContainer, &pxQueue, xCopyPosition );
9D011D5C  02002021   ADDU A0, S0, ZERO
9D011D60  0F404075   JAL prvCopyDataToQueue
9D011D64  27A50028   ADDIU A1, SP, 40
9D011D68  00408821   ADDU S1, V0, ZERO
2521:                
2522:                			if( cTxLock == queueUNLOCKED )
9D011D6C  2402FFFF   ADDIU V0, ZERO, -1
9D011D70  16620009   BNE S3, V0, 0x9D011D98
9D011D74  26520001   ADDIU S2, S2, 1
2523:                			{
2524:                				if( listLIST_IS_EMPTY( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) == pdFALSE )
9D011D78  8E020024   LW V0, 36(S0)
9D011D7C  10400009   BEQ V0, ZERO, 0x9D011DA4
9D011D80  02201021   ADDU V0, S1, ZERO
2525:                				{
2526:                					if( xTaskRemoveFromEventList( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) != pdFALSE )
9D011D84  0F4043C9   JAL xTaskRemoveFromEventList
9D011D88  26040024   ADDIU A0, S0, 36
2527:                					{
2528:                						/* The task waiting has a higher priority. */
2529:                						xReturn = pdTRUE;
9D011D8C  24030001   ADDIU V1, ZERO, 1
9D011D90  0B404768   J 0x9D011DA0
9D011D94  0062880B   MOVN S1, V1, V0
2530:                					}
2531:                					else
2532:                					{
2533:                						mtCOVERAGE_TEST_MARKER();
2534:                					}
2535:                				}
2536:                				else
2537:                				{
2538:                					mtCOVERAGE_TEST_MARKER();
2539:                				}
2540:                			}
2541:                			else
2542:                			{
2543:                				pxQueueSetContainer->cTxLock = ( int8_t ) ( cTxLock + 1 );
9D011D98  7C129420   SEB S2, S2
9D011D9C  A2120045   SB S2, 69(S0)
2544:                			}
2545:                		}
2546:                		else
2547:                		{
2548:                			mtCOVERAGE_TEST_MARKER();
2549:                		}
2550:                
2551:                		return xReturn;
2552:                	}
9D011DA0  02201021   ADDU V0, S1, ZERO
9D011DA4  8FBF0024   LW RA, 36(SP)
9D011DA8  8FB30020   LW S3, 32(SP)
9D011DAC  8FB2001C   LW S2, 28(SP)
9D011DB0  8FB10018   LW S1, 24(SP)
9D011DB4  8FB00014   LW S0, 20(SP)
9D011DB8  03E00008   JR RA
9D011DBC  27BD0028   ADDIU SP, SP, 40
2553:                
2554:                #endif /* configUSE_QUEUE_SETS */
2555:                
2556:                
2557:                
2558:                
2559:                
2560:                
2561:                
2562:                
2563:                
2564:                
2565:                
2566:                
---  /home/whatisthis/microchip/harmony/v2_04/third_party/rtos/FreeRTOS/Source/portable/MemMang/heap_4.c  
1:                   /*
2:                       FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
3:                       All rights reserved
4:                   
5:                       VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
6:                   
7:                       This file is part of the FreeRTOS distribution.
8:                   
9:                       FreeRTOS is free software; you can redistribute it and/or modify it under
10:                      the terms of the GNU General Public License (version 2) as published by the
11:                      Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
12:                  
13:                      ***************************************************************************
14:                      >>!   NOTE: The modification to the GPL is included to allow you to     !<<
15:                      >>!   distribute a combined work that includes FreeRTOS without being   !<<
16:                      >>!   obliged to provide the source code for proprietary components     !<<
17:                      >>!   outside of the FreeRTOS kernel.                                   !<<
18:                      ***************************************************************************
19:                  
20:                      FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
21:                      WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
22:                      FOR A PARTICULAR PURPOSE.  Full license text is available on the following
23:                      link: http://www.freertos.org/a00114.html
24:                  
25:                      ***************************************************************************
26:                       *                                                                       *
27:                       *    FreeRTOS provides completely free yet professionally developed,    *
28:                       *    robust, strictly quality controlled, supported, and cross          *
29:                       *    platform software that is more than just the market leader, it     *
30:                       *    is the industry's de facto standard.                               *
31:                       *                                                                       *
32:                       *    Help yourself get started quickly while simultaneously helping     *
33:                       *    to support the FreeRTOS project by purchasing a FreeRTOS           *
34:                       *    tutorial book, reference manual, or both:                          *
35:                       *    http://www.FreeRTOS.org/Documentation                              *
36:                       *                                                                       *
37:                      ***************************************************************************
38:                  
39:                      http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
40:                      the FAQ page "My application does not run, what could be wrong?".  Have you
41:                      defined configASSERT()?
42:                  
43:                      http://www.FreeRTOS.org/support - In return for receiving this top quality
44:                      embedded software for free we request you assist our global community by
45:                      participating in the support forum.
46:                  
47:                      http://www.FreeRTOS.org/training - Investing in training allows your team to
48:                      be as productive as possible as early as possible.  Now you can receive
49:                      FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
50:                      Ltd, and the world's leading authority on the world's leading RTOS.
51:                  
52:                      http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
53:                      including FreeRTOS+Trace - an indispensable productivity tool, a DOS
54:                      compatible FAT file system, and our tiny thread aware UDP/IP stack.
55:                  
56:                      http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
57:                      Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
58:                  
59:                      http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
60:                      Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
61:                      licenses offer ticketed support, indemnification and commercial middleware.
62:                  
63:                      http://www.SafeRTOS.com - High Integrity Systems also provide a safety
64:                      engineered and independently SIL3 certified version for use in safety and
65:                      mission critical applications that require provable dependability.
66:                  
67:                      1 tab == 4 spaces!
68:                  */
69:                  
70:                  /*
71:                   * A sample implementation of pvPortMalloc() and vPortFree() that combines
72:                   * (coalescences) adjacent memory blocks as they are freed, and in so doing
73:                   * limits memory fragmentation.
74:                   *
75:                   * See heap_1.c, heap_2.c and heap_3.c for alternative implementations, and the
76:                   * memory management pages of http://www.FreeRTOS.org for more information.
77:                   */
78:                  #include <stdlib.h>
79:                  
80:                  /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
81:                  all the API functions to use the MPU wrappers.  That should only be done when
82:                  task.h is included from an application file. */
83:                  #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
84:                  
85:                  #include "FreeRTOS.h"
86:                  #include "task.h"
87:                  
88:                  #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
89:                  
90:                  #if( configSUPPORT_DYNAMIC_ALLOCATION == 0 )
91:                  	#error This file must not be used if configSUPPORT_DYNAMIC_ALLOCATION is 0
92:                  #endif
93:                  
94:                  /* Block sizes must not get too small. */
95:                  #define heapMINIMUM_BLOCK_SIZE	( ( size_t ) ( xHeapStructSize << 1 ) )
96:                  
97:                  /* Assumes 8bit bytes! */
98:                  #define heapBITS_PER_BYTE		( ( size_t ) 8 )
99:                  
100:                 /* Allocate the memory for the heap. */
101:                 #if( configAPPLICATION_ALLOCATED_HEAP == 1 )
102:                 	/* The application writer has already defined the array used for the RTOS
103:                 	heap - probably so it can be placed in a special segment or address. */
104:                 	extern uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];
105:                 #else
106:                 	static uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];
107:                 #endif /* configAPPLICATION_ALLOCATED_HEAP */
108:                 
109:                 /* Define the linked list structure.  This is used to link free blocks in order
110:                 of their memory address. */
111:                 typedef struct A_BLOCK_LINK
112:                 {
113:                 	struct A_BLOCK_LINK *pxNextFreeBlock;	/*<< The next free block in the list. */
114:                 	size_t xBlockSize;						/*<< The size of the free block. */
115:                 } BlockLink_t;
116:                 
117:                 /*-----------------------------------------------------------*/
118:                 
119:                 /*
120:                  * Inserts a block of memory that is being freed into the correct position in
121:                  * the list of free memory blocks.  The block being freed will be merged with
122:                  * the block in front it and/or the block behind it if the memory blocks are
123:                  * adjacent to each other.
124:                  */
125:                 static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert );
126:                 
127:                 /*
128:                  * Called automatically to setup the required heap structures the first time
129:                  * pvPortMalloc() is called.
130:                  */
131:                 static void prvHeapInit( void );
132:                 
133:                 /*-----------------------------------------------------------*/
134:                 
135:                 /* The size of the structure placed at the beginning of each allocated memory
136:                 block must by correctly byte aligned. */
137:                 static const size_t xHeapStructSize	= ( sizeof( BlockLink_t ) + ( ( size_t ) ( portBYTE_ALIGNMENT - 1 ) ) ) & ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
138:                 
139:                 /* Create a couple of list links to mark the start and end of the list. */
140:                 static BlockLink_t xStart, *pxEnd = NULL;
141:                 
142:                 /* Keeps track of the number of free bytes remaining, but says nothing about
143:                 fragmentation. */
144:                 static size_t xFreeBytesRemaining = 0U;
145:                 static size_t xMinimumEverFreeBytesRemaining = 0U;
146:                 
147:                 /* Gets set to the top bit of an size_t type.  When this bit in the xBlockSize
148:                 member of an BlockLink_t structure is set then the block belongs to the
149:                 application.  When the bit is free the block is still part of the free heap
150:                 space. */
151:                 static size_t xBlockAllocatedBit = 0;
152:                 
153:                 /*-----------------------------------------------------------*/
154:                 
155:                 void *pvPortMalloc( size_t xWantedSize )
156:                 {
9D00BBA0  27BDFFD8   ADDIU SP, SP, -40
9D00BBA4  AFBF0024   SW RA, 36(SP)
9D00BBA8  AFB30020   SW S3, 32(SP)
9D00BBAC  AFB2001C   SW S2, 28(SP)
9D00BBB0  AFB10018   SW S1, 24(SP)
9D00BBB4  AFB00014   SW S0, 20(SP)
157:                 BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
158:                 void *pvReturn = NULL;
159:                 
160:                 	vTaskSuspendAll();
9D00BBB8  0F4055F0   JAL vTaskSuspendAll
9D00BBBC  00808021   ADDU S0, A0, ZERO
161:                 	{
162:                 		/* If this is the first call to malloc then the heap will require
163:                 		initialisation to setup the list of free blocks. */
164:                 		if( pxEnd == NULL )
9D00BBC0  8F8280C8   LW V0, -32568(GP)
9D00BBC4  1440001C   BNE V0, ZERO, 0x9D00BC38
9D00BBC8  8F9280BC   LW S2, -32580(GP)
165:                 		{
166:                 			prvHeapInit();
167:                 		}
168:                 		else
169:                 		{
170:                 			mtCOVERAGE_TEST_MARKER();
171:                 		}
172:                 
173:                 		/* Check the requested block size is not so large that the top bit is
174:                 		set.  The top bit of the block size member of the BlockLink_t structure
175:                 		is used to determine who owns the block - the application or the
176:                 		kernel, so it must be free. */
177:                 		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
9D00BC34  8F9280BC   LW S2, -32580(GP)
9D00BC38  02121024   AND V0, S0, S2
9D00BC3C  14400037   BNE V0, ZERO, 0x9D00BD1C
9D00BC40  00000000   NOP
178:                 		{
179:                 			/* The wanted size is increased so it can contain a BlockLink_t
180:                 			structure in addition to the requested amount of bytes. */
181:                 			if( xWantedSize > 0 )
9D00BC44  12000035   BEQ S0, ZERO, 0x9D00BD1C
9D00BC48  26030008   ADDIU V1, S0, 8
182:                 			{
183:                 				xWantedSize += xHeapStructSize;
184:                 
185:                 				/* Ensure that blocks are always aligned to the required number
186:                 				of bytes. */
187:                 				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
9D00BC4C  30620007   ANDI V0, V1, 7
9D00BC50  10400003   BEQ V0, ZERO, 0x9D00BC60
9D00BC54  00000000   NOP
188:                 				{
189:                 					/* Byte alignment required. */
190:                 					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
9D00BC58  7C031004   INS V1, ZERO, 0, 3
9D00BC5C  24630008   ADDIU V1, V1, 8
191:                 					configASSERT( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) == 0 );
192:                 				}
193:                 				else
194:                 				{
195:                 					mtCOVERAGE_TEST_MARKER();
196:                 				}
197:                 			}
198:                 			else
199:                 			{
200:                 				mtCOVERAGE_TEST_MARKER();
201:                 			}
202:                 
203:                 			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
9D00BC60  1060002E   BEQ V1, ZERO, 0x9D00BD1C
9D00BC64  8F9380C4   LW S3, -32572(GP)
9D00BC68  0263102B   SLTU V0, S3, V1
9D00BC6C  1440002B   BNE V0, ZERO, 0x9D00BD1C
9D00BC70  8F9080CC   LW S0, -32564(GP)
204:                 			{
205:                 				/* Traverse the list from the start	(lowest address) block until
206:                 				one	of adequate size is found. */
207:                 				pxPreviousBlock = &xStart;
9D00BC74  278480CC   ADDIU A0, GP, -32564
208:                 				pxBlock = xStart.pxNextFreeBlock;
209:                 				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
9D00BC78  8E020004   LW V0, 4(S0)
9D00BC7C  0043102B   SLTU V0, V0, V1
9D00BC80  10400007   BEQ V0, ZERO, 0x9D00BCA0
9D00BC84  8F8280C8   LW V0, -32568(GP)
9D00BC88  8E020000   LW V0, 0(S0)
9D00BC8C  50400004   BEQL V0, ZERO, 0x9D00BCA0
9D00BC90  8F8280C8   LW V0, -32568(GP)
9D00BC94  02002021   ADDU A0, S0, ZERO
210:                 				{
211:                 					pxPreviousBlock = pxBlock;
212:                 					pxBlock = pxBlock->pxNextFreeBlock;
9D00BC98  0B402F1E   J 0x9D00BC78
9D00BC9C  00408021   ADDU S0, V0, ZERO
213:                 				}
214:                 
215:                 				/* If the end marker was reached then a block of adequate size
216:                 				was	not found. */
217:                 				if( pxBlock != pxEnd )
9D00BCA0  1202001E   BEQ S0, V0, 0x9D00BD1C
9D00BCA4  00000000   NOP
218:                 				{
219:                 					/* Return the memory space pointed to - jumping over the
220:                 					BlockLink_t structure at its start. */
221:                 					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
9D00BCA8  8C910000   LW S1, 0(A0)
222:                 
223:                 					/* This block is being returned for use so must be taken out
224:                 					of the list of free blocks. */
225:                 					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
9D00BCAC  8E020000   LW V0, 0(S0)
9D00BCB0  AC820000   SW V0, 0(A0)
226:                 
227:                 					/* If the block is larger than required it can be split into
228:                 					two. */
229:                 					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
9D00BCB4  8E020004   LW V0, 4(S0)
9D00BCB8  00431023   SUBU V0, V0, V1
9D00BCBC  2C440011   SLTIU A0, V0, 17
9D00BCC0  14800005   BNE A0, ZERO, 0x9D00BCD8
9D00BCC4  26310008   ADDIU S1, S1, 8
230:                 					{
231:                 						/* This block is to be split into two.  Create a new
232:                 						block following the number of bytes requested. The void
233:                 						cast is used to prevent byte alignment warnings from the
234:                 						compiler. */
235:                 						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
9D00BCC8  02032021   ADDU A0, S0, V1
236:                 						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
237:                 
238:                 						/* Calculate the sizes of two blocks split from the
239:                 						single block. */
240:                 						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
9D00BCCC  AC820004   SW V0, 4(A0)
241:                 						pxBlock->xBlockSize = xWantedSize;
242:                 
243:                 						/* Insert the new block into the list of free blocks. */
244:                 						prvInsertBlockIntoFreeList( pxNewBlockLink );
9D00BCD0  0F404BE2   JAL prvInsertBlockIntoFreeList
9D00BCD4  AE030004   SW V1, 4(S0)
245:                 					}
246:                 					else
247:                 					{
248:                 						mtCOVERAGE_TEST_MARKER();
249:                 					}
250:                 
251:                 					xFreeBytesRemaining -= pxBlock->xBlockSize;
9D00BCD8  8E030004   LW V1, 4(S0)
9D00BCDC  02631023   SUBU V0, S3, V1
9D00BCE0  AF8280C4   SW V0, -32572(GP)
252:                 
253:                 					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
9D00BCE4  8F8480C0   LW A0, -32576(GP)
9D00BCE8  0044202B   SLTU A0, V0, A0
9D00BCEC  54800001   BNEL A0, ZERO, 0x9D00BCF4
9D00BCF0  AF8280C0   SW V0, -32576(GP)
254:                 					{
255:                 						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
256:                 					}
257:                 					else
258:                 					{
259:                 						mtCOVERAGE_TEST_MARKER();
260:                 					}
261:                 
262:                 					/* The block is being returned - it is allocated and owned
263:                 					by the application and has no "next" block. */
264:                 					pxBlock->xBlockSize |= xBlockAllocatedBit;
9D00BCF4  00729025   OR S2, V1, S2
9D00BCF8  AE120004   SW S2, 4(S0)
265:                 					pxBlock->pxNextFreeBlock = NULL;
266:                 				}
267:                 				else
268:                 				{
269:                 					mtCOVERAGE_TEST_MARKER();
270:                 				}
271:                 			}
272:                 			else
273:                 			{
274:                 				mtCOVERAGE_TEST_MARKER();
275:                 			}
276:                 		}
277:                 		else
278:                 		{
279:                 			mtCOVERAGE_TEST_MARKER();
280:                 		}
281:                 
282:                 		traceMALLOC( pvReturn, xWantedSize );
283:                 	}
284:                 	( void ) xTaskResumeAll();
9D00BCFC  0F40379F   JAL xTaskResumeAll
9D00BD00  AE000000   SW ZERO, 0(S0)
9D00BD1C  0F40379F   JAL xTaskResumeAll
9D00BD20  00008821   ADDU S1, ZERO, ZERO
9D00BD24  0B402F43   J 0x9D00BD0C
9D00BD28  00000000   NOP
285:                 
286:                 	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
287:                 	{
288:                 		if( pvReturn == NULL )
9D00BD04  56200009   BNEL S1, ZERO, 0x9D00BD2C
9D00BD08  02201021   ADDU V0, S1, ZERO
289:                 		{
290:                 			extern void vApplicationMallocFailedHook( void );
291:                 			vApplicationMallocFailedHook();
9D00BD0C  0F40552E   JAL vApplicationMallocFailedHook
9D00BD10  00000000   NOP
9D00BD14  0B402F4B   J 0x9D00BD2C
9D00BD18  02201021   ADDU V0, S1, ZERO
292:                 		}
293:                 		else
294:                 		{
295:                 			mtCOVERAGE_TEST_MARKER();
296:                 		}
297:                 	}
298:                 	#endif
299:                 
300:                 	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
301:                 	return pvReturn;
302:                 }
9D00BD2C  8FBF0024   LW RA, 36(SP)
303:                 /*-----------------------------------------------------------*/
304:                 
305:                 void vPortFree( void *pv )
306:                 {
9D01325C  27BDFFE8   ADDIU SP, SP, -24
9D013260  AFBF0014   SW RA, 20(SP)
9D013264  AFB00010   SW S0, 16(SP)
307:                 uint8_t *puc = ( uint8_t * ) pv;
308:                 BlockLink_t *pxLink;
309:                 
310:                 	if( pv != NULL )
9D013268  10800015   BEQ A0, ZERO, 0x9D0132C0
9D01326C  00808021   ADDU S0, A0, ZERO
311:                 	{
312:                 		/* The memory being freed will have an BlockLink_t structure immediately
313:                 		before it. */
314:                 		puc -= xHeapStructSize;
315:                 
316:                 		/* This casting is to keep the compiler from issuing warnings. */
317:                 		pxLink = ( void * ) puc;
318:                 
319:                 		/* Check the block is actually allocated. */
320:                 		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
321:                 		configASSERT( pxLink->pxNextFreeBlock == NULL );
322:                 
323:                 		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
9D013270  8C82FFFC   LW V0, -4(A0)
9D013274  8F8380BC   LW V1, -32580(GP)
9D013278  00622024   AND A0, V1, V0
9D01327C  10800011   BEQ A0, ZERO, 0x9D0132C4
9D013280  8FBF0014   LW RA, 20(SP)
324:                 		{
325:                 			if( pxLink->pxNextFreeBlock == NULL )
9D013284  8E04FFF8   LW A0, -8(S0)
9D013288  5480000F   BNEL A0, ZERO, 0x9D0132C8
9D01328C  8FB00010   LW S0, 16(SP)
326:                 			{
327:                 				/* The block is being returned to the heap - it is no longer
328:                 				allocated. */
329:                 				pxLink->xBlockSize &= ~xBlockAllocatedBit;
9D013290  00031827   NOR V1, ZERO, V1
9D013294  00621024   AND V0, V1, V0
330:                 
331:                 				vTaskSuspendAll();
9D013298  0F4055F0   JAL vTaskSuspendAll
9D01329C  AE02FFFC   SW V0, -4(S0)
332:                 				{
333:                 					/* Add this block to the list of free blocks. */
334:                 					xFreeBytesRemaining += pxLink->xBlockSize;
9D0132A0  8E02FFFC   LW V0, -4(S0)
9D0132A4  8F8380C4   LW V1, -32572(GP)
9D0132A8  00621021   ADDU V0, V1, V0
9D0132AC  AF8280C4   SW V0, -32572(GP)
335:                 					traceFREE( pv, pxLink->xBlockSize );
336:                 					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
9D0132B0  0F404BE2   JAL prvInsertBlockIntoFreeList
9D0132B4  2604FFF8   ADDIU A0, S0, -8
337:                 				}
338:                 				( void ) xTaskResumeAll();
9D0132B8  0F40379F   JAL xTaskResumeAll
9D0132BC  00000000   NOP
339:                 			}
340:                 			else
341:                 			{
342:                 				mtCOVERAGE_TEST_MARKER();
343:                 			}
344:                 		}
345:                 		else
346:                 		{
347:                 			mtCOVERAGE_TEST_MARKER();
348:                 		}
349:                 	}
350:                 }
9D0132C0  8FBF0014   LW RA, 20(SP)
9D0132C4  8FB00010   LW S0, 16(SP)
9D0132C8  03E00008   JR RA
9D0132CC  27BD0018   ADDIU SP, SP, 24
351:                 /*-----------------------------------------------------------*/
352:                 
353:                 size_t xPortGetFreeHeapSize( void )
354:                 {
355:                 	return xFreeBytesRemaining;
356:                 }
357:                 /*-----------------------------------------------------------*/
358:                 
359:                 size_t xPortGetMinimumEverFreeHeapSize( void )
360:                 {
361:                 	return xMinimumEverFreeBytesRemaining;
362:                 }
363:                 /*-----------------------------------------------------------*/
364:                 
365:                 void vPortInitialiseBlocks( void )
366:                 {
367:                 	/* This just exists to keep the linker quiet. */
368:                 }
369:                 /*-----------------------------------------------------------*/
370:                 
371:                 static void prvHeapInit( void )
372:                 {
373:                 BlockLink_t *pxFirstFreeBlock;
374:                 uint8_t *pucAlignedHeap;
375:                 size_t uxAddress;
376:                 size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;
9D00BBF4  24034A38   ADDIU V1, ZERO, 19000
377:                 
378:                 	/* Ensure the heap starts on a correctly aligned boundary. */
379:                 	uxAddress = ( size_t ) ucHeap;
9D00BBCC  3C03A000   LUI V1, -24576
9D00BBD0  24631D10   ADDIU V1, V1, 7440
9D00BBF0  00601021   ADDU V0, V1, ZERO
380:                 
381:                 	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
9D00BBD4  30620007   ANDI V0, V1, 7
9D00BBD8  10400005   BEQ V0, ZERO, pvPortMalloc::prvHeapInit
9D00BBDC  24620007   ADDIU V0, V1, 7
382:                 	{
383:                 		uxAddress += ( portBYTE_ALIGNMENT - 1 );
384:                 		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
9D00BBE0  7C021004   INS V0, ZERO, 0, 3
385:                 		xTotalHeapSize -= uxAddress - ( size_t ) ucHeap;
9D00BBE4  24634A38   ADDIU V1, V1, 19000
9D00BBE8  0B402EFE   J 0x9D00BBF8
9D00BBEC  00621823   SUBU V1, V1, V0
386:                 	}
387:                 
388:                 	pucAlignedHeap = ( uint8_t * ) uxAddress;
389:                 
390:                 	/* xStart is used to hold a pointer to the first item in the list of free
391:                 	blocks.  The void cast is used to prevent compiler warnings. */
392:                 	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
9D00BBF8  AF8280CC   SW V0, -32564(GP)
393:                 	xStart.xBlockSize = ( size_t ) 0;
9D00BBFC  AF8080D0   SW ZERO, -32560(GP)
394:                 
395:                 	/* pxEnd is used to mark the end of the list of free blocks and is inserted
396:                 	at the end of the heap space. */
397:                 	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
9D00BC00  00431821   ADDU V1, V0, V1
398:                 	uxAddress -= xHeapStructSize;
9D00BC04  2463FFF8   ADDIU V1, V1, -8
399:                 	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
9D00BC08  7C031004   INS V1, ZERO, 0, 3
400:                 	pxEnd = ( void * ) uxAddress;
9D00BC0C  AF8380C8   SW V1, -32568(GP)
401:                 	pxEnd->xBlockSize = 0;
9D00BC10  AC600004   SW ZERO, 4(V1)
402:                 	pxEnd->pxNextFreeBlock = NULL;
9D00BC14  AC600000   SW ZERO, 0(V1)
403:                 
404:                 	/* To start with there is a single free block that is sized to take up the
405:                 	entire heap space, minus the space taken by pxEnd. */
406:                 	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
407:                 	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
9D00BC18  00622023   SUBU A0, V1, V0
9D00BC1C  AC440004   SW A0, 4(V0)
408:                 	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
9D00BC20  AC430000   SW V1, 0(V0)
409:                 
410:                 	/* Only one block exists - and it covers the entire usable heap space. */
411:                 	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
9D00BC24  AF8480C0   SW A0, -32576(GP)
412:                 	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
9D00BC28  AF8480C4   SW A0, -32572(GP)
413:                 
414:                 	/* Work out the position of the top bit in a size_t variable. */
415:                 	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
9D00BC2C  3C028000   LUI V0, -32768
9D00BC30  AF8280BC   SW V0, -32580(GP)
9D00BC34  8F9280BC   LW S2, -32580(GP)
9D00BC38  02121024   AND V0, S0, S2
9D00BC3C  14400037   BNE V0, ZERO, 0x9D00BD1C
9D00BC40  00000000   NOP
9D00BC44  12000035   BEQ S0, ZERO, 0x9D00BD1C
9D00BC48  26030008   ADDIU V1, S0, 8
9D00BC4C  30620007   ANDI V0, V1, 7
9D00BC50  10400003   BEQ V0, ZERO, 0x9D00BC60
9D00BC54  00000000   NOP
9D00BC58  7C031004   INS V1, ZERO, 0, 3
9D00BC5C  24630008   ADDIU V1, V1, 8
9D00BC60  1060002E   BEQ V1, ZERO, 0x9D00BD1C
9D00BC64  8F9380C4   LW S3, -32572(GP)
9D00BC68  0263102B   SLTU V0, S3, V1
9D00BC6C  1440002B   BNE V0, ZERO, 0x9D00BD1C
9D00BC70  8F9080CC   LW S0, -32564(GP)
9D00BC74  278480CC   ADDIU A0, GP, -32564
9D00BC78  8E020004   LW V0, 4(S0)
9D00BC7C  0043102B   SLTU V0, V0, V1
9D00BC80  10400007   BEQ V0, ZERO, 0x9D00BCA0
9D00BC84  8F8280C8   LW V0, -32568(GP)
9D00BC88  8E020000   LW V0, 0(S0)
9D00BC8C  50400004   BEQL V0, ZERO, 0x9D00BCA0
9D00BC90  8F8280C8   LW V0, -32568(GP)
9D00BC94  02002021   ADDU A0, S0, ZERO
9D00BC98  0B402F1E   J 0x9D00BC78
9D00BC9C  00408021   ADDU S0, V0, ZERO
9D00BCA0  1202001E   BEQ S0, V0, 0x9D00BD1C
9D00BCA4  00000000   NOP
9D00BCA8  8C910000   LW S1, 0(A0)
9D00BCAC  8E020000   LW V0, 0(S0)
9D00BCB0  AC820000   SW V0, 0(A0)
9D00BCB4  8E020004   LW V0, 4(S0)
9D00BCB8  00431023   SUBU V0, V0, V1
9D00BCBC  2C440011   SLTIU A0, V0, 17
9D00BCC0  14800005   BNE A0, ZERO, 0x9D00BCD8
9D00BCC4  26310008   ADDIU S1, S1, 8
9D00BCC8  02032021   ADDU A0, S0, V1
9D00BCCC  AC820004   SW V0, 4(A0)
9D00BCD0  0F404BE2   JAL prvInsertBlockIntoFreeList
9D00BCD4  AE030004   SW V1, 4(S0)
9D00BCD8  8E030004   LW V1, 4(S0)
9D00BCDC  02631023   SUBU V0, S3, V1
9D00BCE0  AF8280C4   SW V0, -32572(GP)
9D00BCE4  8F8480C0   LW A0, -32576(GP)
9D00BCE8  0044202B   SLTU A0, V0, A0
9D00BCEC  54800001   BNEL A0, ZERO, 0x9D00BCF4
9D00BCF0  AF8280C0   SW V0, -32576(GP)
9D00BCF4  00729025   OR S2, V1, S2
9D00BCF8  AE120004   SW S2, 4(S0)
9D00BCFC  0F40379F   JAL xTaskResumeAll
9D00BD00  AE000000   SW ZERO, 0(S0)
9D00BD04  56200009   BNEL S1, ZERO, 0x9D00BD2C
9D00BD08  02201021   ADDU V0, S1, ZERO
9D00BD0C  0F40552E   JAL vApplicationMallocFailedHook
9D00BD10  00000000   NOP
9D00BD14  0B402F4B   J 0x9D00BD2C
9D00BD18  02201021   ADDU V0, S1, ZERO
9D00BD1C  0F40379F   JAL xTaskResumeAll
9D00BD20  00008821   ADDU S1, ZERO, ZERO
9D00BD24  0B402F43   J 0x9D00BD0C
9D00BD28  00000000   NOP
9D00BD2C  8FBF0024   LW RA, 36(SP)
9D00BD30  8FB30020   LW S3, 32(SP)
9D00BD34  8FB2001C   LW S2, 28(SP)
9D00BD38  8FB10018   LW S1, 24(SP)
9D00BD3C  8FB00014   LW S0, 20(SP)
9D00BD40  03E00008   JR RA
9D00BD44  27BD0028   ADDIU SP, SP, 40
416:                 }
417:                 /*-----------------------------------------------------------*/
418:                 
419:                 static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
420:                 {
421:                 BlockLink_t *pxIterator;
422:                 uint8_t *puc;
423:                 
424:                 	/* Iterate through the list until a block is found that has a higher address
425:                 	than the block being inserted. */
426:                 	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
9D012F88  278380CC   ADDIU V1, GP, -32564
9D012F8C  8C620000   LW V0, 0(V1)
9D012F90  0044282B   SLTU A1, V0, A0
9D012F94  50A00003   BEQL A1, ZERO, 0x9D012FA4
9D012F98  8C660004   LW A2, 4(V1)
9D012F9C  0B404BE3   J 0x9D012F8C
9D012FA0  00401821   ADDU V1, V0, ZERO
427:                 	{
428:                 		/* Nothing to do here, just iterate to the right position. */
429:                 	}
430:                 
431:                 	/* Do the block being inserted, and the block it is being inserted after
432:                 	make a contiguous block of memory? */
433:                 	puc = ( uint8_t * ) pxIterator;
434:                 	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
9D012FA4  00663821   ADDU A3, V1, A2
9D012FA8  14E40005   BNE A3, A0, 0x9D012FC0
9D012FAC  00602821   ADDU A1, V1, ZERO
435:                 	{
436:                 		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
9D012FB0  8CE40004   LW A0, 4(A3)
9D012FB4  00863021   ADDU A2, A0, A2
9D012FB8  AC660004   SW A2, 4(V1)
9D012FBC  00602021   ADDU A0, V1, ZERO
437:                 		pxBlockToInsert = pxIterator;
438:                 	}
439:                 	else
440:                 	{
441:                 		mtCOVERAGE_TEST_MARKER();
442:                 	}
443:                 
444:                 	/* Do the block being inserted, and the block it is being inserted before
445:                 	make a contiguous block of memory? */
446:                 	puc = ( uint8_t * ) pxBlockToInsert;
447:                 	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
9D012FC0  8C830004   LW V1, 4(A0)
9D012FC4  00833021   ADDU A2, A0, V1
9D012FC8  5446000A   BNEL V0, A2, 0x9D012FF4
9D012FCC  AC820000   SW V0, 0(A0)
448:                 	{
449:                 		if( pxIterator->pxNextFreeBlock != pxEnd )
9D012FD0  8F8680C8   LW A2, -32568(GP)
9D012FD4  50C20007   BEQL A2, V0, 0x9D012FF4
9D012FD8  AC820000   SW V0, 0(A0)
450:                 		{
451:                 			/* Form one big block from the two blocks. */
452:                 			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
9D012FDC  8C420004   LW V0, 4(V0)
9D012FE0  00431821   ADDU V1, V0, V1
9D012FE4  AC830004   SW V1, 4(A0)
453:                 			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
9D012FE8  8CA20000   LW V0, 0(A1)
9D012FEC  8C420000   LW V0, 0(V0)
9D012FF0  AC820000   SW V0, 0(A0)
454:                 		}
455:                 		else
456:                 		{
457:                 			pxBlockToInsert->pxNextFreeBlock = pxEnd;
458:                 		}
459:                 	}
460:                 	else
461:                 	{
462:                 		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
463:                 	}
464:                 
465:                 	/* If the block being inserted plugged a gab, so was merged with the block
466:                 	before and the block after, then it's pxNextFreeBlock pointer will have
467:                 	already been set, and should not be set here as that would make it point
468:                 	to itself. */
469:                 	if( pxIterator != pxBlockToInsert )
9D012FF4  54A40001   BNEL A1, A0, 0x9D012FFC
9D012FF8  ACA40000   SW A0, 0(A1)
9D012FFC  03E00008   JR RA
9D013000  00000000   NOP
470:                 	{
471:                 		pxIterator->pxNextFreeBlock = pxBlockToInsert;
472:                 	}
473:                 	else
474:                 	{
475:                 		mtCOVERAGE_TEST_MARKER();
476:                 	}
477:                 }
478:                 
---  /home/whatisthis/microchip/harmony/v2_04/third_party/rtos/FreeRTOS/Source/portable/MPLAB/PIC32MX/port_asm.S
                                                  1:     /*
                                                  2:         FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
                                                  3:         All rights reserved
                                                  4:     
                                                  5:         VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
                                                  6:     
                                                  7:         This file is part of the FreeRTOS distribution.
                                                  8:     
                                                  9:         FreeRTOS is free software; you can redistribute it and/or modify it under
                                                  10:        the terms of the GNU General Public License (version 2) as published by the
                                                  11:        Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
                                                  12:    
                                                  13:        ***************************************************************************
                                                  14:        >>!   NOTE: The modification to the GPL is included to allow you to     !<<
                                                  15:        >>!   distribute a combined work that includes FreeRTOS without being   !<<
                                                  16:        >>!   obliged to provide the source code for proprietary components     !<<
                                                  17:        >>!   outside of the FreeRTOS kernel.                                   !<<
                                                  18:        ***************************************************************************
                                                  19:    
                                                  20:        FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
                                                  21:        WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
                                                  22:        FOR A PARTICULAR PURPOSE.  Full license text is available on the following
                                                  23:        link: http://www.freertos.org/a00114.html
                                                  24:    
                                                  25:        ***************************************************************************
                                                  26:         *                                                                       *
                                                  27:         *    FreeRTOS provides completely free yet professionally developed,    *
                                                  28:         *    robust, strictly quality controlled, supported, and cross          *
                                                  29:         *    platform software that is more than just the market leader, it     *
                                                  30:         *    is the industry's de facto standard.                               *
                                                  31:         *                                                                       *
                                                  32:         *    Help yourself get started quickly while simultaneously helping     *
                                                  33:         *    to support the FreeRTOS project by purchasing a FreeRTOS           *
                                                  34:         *    tutorial book, reference manual, or both:                          *
                                                  35:         *    http://www.FreeRTOS.org/Documentation                              *
                                                  36:         *                                                                       *
                                                  37:        ***************************************************************************
                                                  38:    
                                                  39:        http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
                                                  40:        the FAQ page "My application does not run, what could be wrong?".  Have you
                                                  41:        defined configASSERT()?
                                                  42:    
                                                  43:        http://www.FreeRTOS.org/support - In return for receiving this top quality
                                                  44:        embedded software for free we request you assist our global community by
                                                  45:        participating in the support forum.
                                                  46:    
                                                  47:        http://www.FreeRTOS.org/training - Investing in training allows your team to
                                                  48:        be as productive as possible as early as possible.  Now you can receive
                                                  49:        FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
                                                  50:        Ltd, and the world's leading authority on the world's leading RTOS.
                                                  51:    
                                                  52:        http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
                                                  53:        including FreeRTOS+Trace - an indispensable productivity tool, a DOS
                                                  54:        compatible FAT file system, and our tiny thread aware UDP/IP stack.
                                                  55:    
                                                  56:        http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
                                                  57:        Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
                                                  58:    
                                                  59:        http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
                                                  60:        Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
                                                  61:        licenses offer ticketed support, indemnification and commercial middleware.
                                                  62:    
                                                  63:        http://www.SafeRTOS.com - High Integrity Systems also provide a safety
                                                  64:        engineered and independently SIL3 certified version for use in safety and
                                                  65:        mission critical applications that require provable dependability.
                                                  66:    
                                                  67:        1 tab == 4 spaces!
                                                  68:    */
                                                  69:    
                                                  70:    #include <xc.h>
                                                  71:    #include <sys/asm.h>
                                                  72:    #include "ISR_Support.h"
                                                  73:    
                                                  74:    
                                                  75:    	.set	nomips16
                                                  76:     	.set 	noreorder
                                                  77:    
                                                  78:     	.extern pxCurrentTCB
                                                  79:     	.extern vTaskSwitchContext
                                                  80:     	.extern vPortIncrementTick
                                                  81:    	.extern xISRStackTop
                                                  82:    
                                                  83:     	.global vPortStartFirstTask
                                                  84:    	.global vPortYieldISR
                                                  85:    	.global vPortTickInterruptHandler
                                                  86:    
                                                  87:    
                                                  88:    /******************************************************************/
                                                  89:    
                                                  90:     	.set		noreorder
                                                  91:    	.set 		noat
                                                  92:     	.ent		vPortTickInterruptHandler
                                                  93:    
                                                  94:    vPortTickInterruptHandler:
                                                  95:    
9D005414  401A6800   MFC0 K0, Cause               96:    	portSAVE_CONTEXT
                                                  97:    
9D0054F0  0F405082   JAL 0x9D014208               98:    	jal 		vPortIncrementTick
9D0054F4  00000000   NOP                          99:    	nop
                                                  100:   
9D0054F8  3C16A000   LUI S6, -24576               101:   	portRESTORE_CONTEXT
                                                  102:   
                                                  103:   	.end vPortTickInterruptHandler
                                                  104:   
                                                  105:   /******************************************************************/
                                                  106:   
                                                  107:    	.set		noreorder
                                                  108:   	.set 		noat
                                                  109:    	.ent		vPortStartFirstTask
                                                  110:   
                                                  111:   vPortStartFirstTask:
                                                  112:   
                                                  113:   	/* Simply restore the context of the highest priority task that has been
                                                  114:   	created so far. */
9D0055C0  3C16A000   LUI S6, -24576               115:   	portRESTORE_CONTEXT
                                                  116:   
                                                  117:   	.end vPortStartFirstTask
                                                  118:   
                                                  119:   
                                                  120:   
                                                  121:   /*******************************************************************/
                                                  122:   
                                                  123:   	.set		noreorder
                                                  124:   	.set 		noat
                                                  125:   	.ent		vPortYieldISR
                                                  126:   
                                                  127:   vPortYieldISR:
                                                  128:   
                                                  129:   	/* Make room for the context. First save the current status so it can be
                                                  130:   	manipulated. */
9D005688  27BDFF7C   ADDIU SP, SP, -132           131:   	addiu		sp, sp, -portCONTEXT_SIZE
9D00568C  401B6000   MFC0 K1, Status              132:   	mfc0		k1, _CP0_STATUS
                                                  133:   
                                                  134:   	/* Also save s6 and s5 so they can be used.  Any nesting interrupts should
                                                  135:   	maintain the values of these registers across the ISR. */
9D005690  AFB6002C   SW S6, 44(SP)                136:   	sw			s6, 44(sp)
9D005694  AFB50028   SW S5, 40(SP)                137:   	sw			s5, 40(sp)
9D005698  AFBB0080   SW K1, 128(SP)               138:   	sw			k1, portSTATUS_STACK_LOCATION(sp)
                                                  139:   
                                                  140:   	/* Prepare to re-enabled interrupt above the kernel priority. */
9D00569C  7C1B7A84   INS K1, ZERO, 10, 6          141:   	ins 		k1, zero, 10, 6
9D0056A0  377B0C00   ORI K1, K1, 3072             142:   	ori			k1, k1, ( configMAX_SYSCALL_INTERRUPT_PRIORITY << 10 )
9D0056A4  7C1B2044   INS K1, ZERO, 1, 4           143:   	ins			k1, zero, 1, 4
                                                  144:   
                                                  145:   	/* s5 is used as the frame pointer. */
9D0056A8  001DA820   ADD S5, ZERO, SP             146:   	add			s5, zero, sp
                                                  147:   
                                                  148:   	/* Swap to the system stack.  This is not conditional on the nesting
                                                  149:   	count as this interrupt is always the lowest priority and therefore
                                                  150:   	the nesting is always 0. */
9D0056AC  3C1D9D01   LUI SP, -25343               151:   	la			sp, xISRStackTop
9D0056B4  8FBD0000   LW SP, 0(SP)                 152:   	lw			sp, (sp)
                                                  153:   
                                                  154:   	/* Set the nesting count. */
9D0056B8  3C1AA000   LUI K0, -24576               155:   	la			k0, uxInterruptNesting
9D0056C0  24160001   ADDIU S6, ZERO, 1            156:   	addiu		s6, zero, 1
9D0056C4  AF560000   SW S6, 0(K0)                 157:   	sw			s6, 0(k0)
                                                  158:   
                                                  159:   	/* s6 holds the EPC value, this is saved with the rest of the context
                                                  160:   	after interrupts are enabled. */
9D0056C8  40167000   MFC0 S6, EPC                 161:   	mfc0 		s6, _CP0_EPC
                                                  162:   
                                                  163:   	/* Re-enable interrupts above configMAX_SYSCALL_INTERRUPT_PRIORITY. */
9D0056CC  409B6000   MTC0 K1, Status              164:   	mtc0		k1, _CP0_STATUS
                                                  165:   
                                                  166:   	/* Save the context into the space just created.  s6 is saved again
                                                  167:   	here as it now contains the EPC value. */
9D0056D0  AEBF0078   SW RA, 120(S5)               168:   	sw			ra, 120(s5)
9D0056D4  AEBE0074   SW S8, 116(S5)               169:   	sw			s8, 116(s5)
9D0056D8  AEB90070   SW T9, 112(S5)               170:   	sw			t9, 112(s5)
9D0056DC  AEB8006C   SW T8, 108(S5)               171:   	sw			t8, 108(s5)
9D0056E0  AEAF0068   SW T7, 104(S5)               172:   	sw			t7, 104(s5)
9D0056E4  AEAE0064   SW T6, 100(S5)               173:   	sw			t6, 100(s5)
9D0056E8  AEAD0060   SW T5, 96(S5)                174:   	sw			t5, 96(s5)
9D0056EC  AEAC005C   SW T4, 92(S5)                175:   	sw			t4, 92(s5)
9D0056F0  AEAB0058   SW T3, 88(S5)                176:   	sw			t3, 88(s5)
9D0056F4  AEAA0054   SW T2, 84(S5)                177:   	sw			t2, 84(s5)
9D0056F8  AEA90050   SW T1, 80(S5)                178:   	sw			t1, 80(s5)
9D0056FC  AEA8004C   SW T0, 76(S5)                179:   	sw			t0, 76(s5)
9D005700  AEA70048   SW A3, 72(S5)                180:   	sw			a3, 72(s5)
9D005704  AEA60044   SW A2, 68(S5)                181:   	sw			a2, 68(s5)
9D005708  AEA50040   SW A1, 64(S5)                182:   	sw			a1, 64(s5)
9D00570C  AEA4003C   SW A0, 60(S5)                183:   	sw			a0, 60(s5)
9D005710  AEA30038   SW V1, 56(S5)                184:   	sw			v1, 56(s5)
9D005714  AEA20034   SW V0, 52(S5)                185:   	sw			v0, 52(s5)
9D005718  AEB70030   SW S7, 48(S5)                186:   	sw			s7, 48(s5)
9D00571C  AEB6007C   SW S6, 124(S5)               187:   	sw			s6, portEPC_STACK_LOCATION(s5)
                                                  188:   	/* s5 and s6 has already been saved. */
9D005720  AEB40024   SW S4, 36(S5)                189:   	sw			s4, 36(s5)
9D005724  AEB30020   SW S3, 32(S5)                190:   	sw			s3, 32(s5)
9D005728  AEB2001C   SW S2, 28(S5)                191:   	sw			s2, 28(s5)
9D00572C  AEB10018   SW S1, 24(S5)                192:   	sw			s1, 24(s5)
9D005730  AEB00014   SW S0, 20(S5)                193:   	sw			s0, 20(s5)
9D005734  AEA10010   SW AT, 16(S5)                194:   	sw			$1, 16(s5)
                                                  195:   
                                                  196:   	/* s7 is used as a scratch register as this should always be saved across
                                                  197:   	nesting interrupts. */
9D005738  0000B810   MFHI S7                      198:   	mfhi		s7
9D00573C  AEB7000C   SW S7, 12(S5)                199:   	sw			s7, 12(s5)
9D005740  0000B812   MFLO S7                      200:   	mflo		s7
9D005744  AEB70008   SW S7, 8(S5)                 201:   	sw			s7, 8(s5)
                                                  202:   
                                                  203:   	/* Save the stack pointer to the task. */
9D005748  3C17A000   LUI S7, -24576               204:   	la			s7, pxCurrentTCB
9D005750  8EF70000   LW S7, 0(S7)                 205:   	lw			s7, (s7)
9D005754  AEF50000   SW S5, 0(S7)                 206:   	sw			s5, (s7)
                                                  207:   
                                                  208:   	/* Set the interrupt mask to the max priority that can use the API.  The
                                                  209:   	yield handler will only be called at configKERNEL_INTERRUPT_PRIORITY which
                                                  210:   	is below configMAX_SYSCALL_INTERRUPT_PRIORITY - so this can only ever
                                                  211:   	raise the IPL value and never lower it. */
9D005758  41606000   DI ZERO                      212:   	di
9D00575C  000000C0   EHB                          213:   	ehb
9D005760  40176000   MFC0 S7, Status              214:   	mfc0		s7, _CP0_STATUS
9D005764  7C177A84   INS S7, ZERO, 10, 6          215:   	ins 		s7, zero, 10, 6
9D005768  36F60C01   ORI S6, S7, 3073             216:   	ori			s6, s7, ( configMAX_SYSCALL_INTERRUPT_PRIORITY << 10 ) | 1
                                                  217:   
                                                  218:   	/* This mtc0 re-enables interrupts, but only above
                                                  219:   	configMAX_SYSCALL_INTERRUPT_PRIORITY. */
9D00576C  40966000   MTC0 S6, Status              220:   	mtc0		s6, _CP0_STATUS
9D005770  000000C0   EHB                          221:   	ehb
                                                  222:   
                                                  223:   	/* Clear the software interrupt in the core. */
9D005774  40166800   MFC0 S6, Cause               224:   	mfc0		s6, _CP0_CAUSE
9D005778  7C164204   INS S6, ZERO, 8, 1           225:   	ins			s6, zero, 8, 1
9D00577C  40966800   MTC0 S6, Cause               226:   	mtc0		s6, _CP0_CAUSE
9D005780  000000C0   EHB                          227:   	ehb
                                                  228:   
                                                  229:   	/* Clear the interrupt in the interrupt controller. */
9D005784  3C16BF88   LUI S6, -16504               230:   	la			s6, IFS0CLR
9D00578C  24140002   ADDIU S4, ZERO, 2            231:   	addiu		s4, zero, 2
9D005790  AED40000   SW S4, 0(S6)                 232:   	sw			s4, (s6)
                                                  233:   
9D005794  0F404286   JAL 0x9D010A18               234:   	jal			vTaskSwitchContext
9D005798  00000000   NOP                          235:   	nop
                                                  236:   
                                                  237:   	/* Clear the interrupt mask again.  The saved status value is still in s7. */
9D00579C  40976000   MTC0 S7, Status              238:   	mtc0		s7, _CP0_STATUS
9D0057A0  000000C0   EHB                          239:   	ehb
                                                  240:   
                                                  241:   	/* Restore the stack pointer from the TCB. */
9D0057A4  3C10A000   LUI S0, -24576               242:   	la			s0, pxCurrentTCB
9D0057AC  8E100000   LW S0, 0(S0)                 243:   	lw			s0, (s0)
9D0057B0  8E150000   LW S5, 0(S0)                 244:   	lw			s5, (s0)
                                                  245:   
                                                  246:   	/* Restore the rest of the context. */
9D0057B4  8EB00008   LW S0, 8(S5)                 247:   	lw			s0, 8(s5)
9D0057B8  02000013   MTLO S0                      248:   	mtlo		s0
9D0057BC  8EB0000C   LW S0, 12(S5)                249:   	lw			s0, 12(s5)
9D0057C0  02000011   MTHI S0                      250:   	mthi		s0
9D0057C4  8EA10010   LW AT, 16(S5)                251:   	lw			$1, 16(s5)
9D0057C8  8EB00014   LW S0, 20(S5)                252:   	lw			s0, 20(s5)
9D0057CC  8EB10018   LW S1, 24(S5)                253:   	lw			s1, 24(s5)
9D0057D0  8EB2001C   LW S2, 28(S5)                254:   	lw			s2, 28(s5)
9D0057D4  8EB30020   LW S3, 32(S5)                255:   	lw			s3, 32(s5)
9D0057D8  8EB40024   LW S4, 36(S5)                256:   	lw			s4, 36(s5)
                                                  257:   	/* s5 is loaded later. */
9D0057DC  8EB6002C   LW S6, 44(S5)                258:   	lw			s6, 44(s5)
9D0057E0  8EB70030   LW S7, 48(S5)                259:   	lw			s7, 48(s5)
9D0057E4  8EA20034   LW V0, 52(S5)                260:   	lw			v0, 52(s5)
9D0057E8  8EA30038   LW V1, 56(S5)                261:   	lw			v1, 56(s5)
9D0057EC  8EA4003C   LW A0, 60(S5)                262:   	lw			a0, 60(s5)
9D0057F0  8EA50040   LW A1, 64(S5)                263:   	lw			a1, 64(s5)
9D0057F4  8EA60044   LW A2, 68(S5)                264:   	lw			a2, 68(s5)
9D0057F8  8EA70048   LW A3, 72(S5)                265:   	lw			a3, 72(s5)
9D0057FC  8EA8004C   LW T0, 76(S5)                266:   	lw			t0, 76(s5)
9D005800  8EA90050   LW T1, 80(S5)                267:   	lw			t1, 80(s5)
9D005804  8EAA0054   LW T2, 84(S5)                268:   	lw			t2, 84(s5)
9D005808  8EAB0058   LW T3, 88(S5)                269:   	lw			t3, 88(s5)
9D00580C  8EAC005C   LW T4, 92(S5)                270:   	lw			t4, 92(s5)
9D005810  8EAD0060   LW T5, 96(S5)                271:   	lw			t5, 96(s5)
9D005814  8EAE0064   LW T6, 100(S5)               272:   	lw			t6, 100(s5)
9D005818  8EAF0068   LW T7, 104(S5)               273:   	lw			t7, 104(s5)
9D00581C  8EB8006C   LW T8, 108(S5)               274:   	lw			t8, 108(s5)
9D005820  8EB90070   LW T9, 112(S5)               275:   	lw			t9, 112(s5)
9D005824  8EBE0074   LW S8, 116(S5)               276:   	lw			s8, 116(s5)
9D005828  8EBF0078   LW RA, 120(S5)               277:   	lw			ra, 120(s5)
                                                  278:   
                                                  279:   	/* Protect access to the k registers, and others. */
9D00582C  41606000   DI ZERO                      280:   	di
9D005830  000000C0   EHB                          281:   	ehb
                                                  282:   
                                                  283:   	/* Set nesting back to zero.  As the lowest priority interrupt this
                                                  284:   	interrupt cannot have nested. */
9D005834  3C1AA000   LUI K0, -24576               285:   	la			k0, uxInterruptNesting
9D00583C  AF400000   SW ZERO, 0(K0)               286:   	sw			zero, 0(k0)
                                                  287:   
                                                  288:   	/* Switch back to use the real stack pointer. */
9D005840  0015E820   ADD SP, ZERO, S5             289:   	add			sp, zero, s5
                                                  290:   
                                                  291:   	/* Restore the real s5 value. */
9D005844  8FB50028   LW S5, 40(SP)                292:   	lw			s5, 40(sp)
                                                  293:   
                                                  294:   	/* Pop the status and epc values. */
9D005848  8FBB0080   LW K1, 128(SP)               295:   	lw			k1, portSTATUS_STACK_LOCATION(sp)
9D00584C  8FBA007C   LW K0, 124(SP)               296:   	lw			k0, portEPC_STACK_LOCATION(sp)
                                                  297:   
                                                  298:   	/* Remove stack frame. */
9D005850  27BD0084   ADDIU SP, SP, 132            299:   	addiu		sp, sp, portCONTEXT_SIZE
                                                  300:   
9D005854  409B6000   MTC0 K1, Status              301:   	mtc0		k1, _CP0_STATUS
9D005858  409A7000   MTC0 K0, EPC                 302:   	mtc0 		k0, _CP0_EPC
9D00585C  000000C0   EHB                          303:   	ehb
9D005860  42000018   ERET                         304:   	eret
9D005864  00000000   NOP                          305:   	nop
                                                  306:   
                                                  307:   	.end		vPortYieldISR
                                                  308:   
                                                  309:   
                                                  310:   
---  /home/whatisthis/microchip/harmony/v2_04/third_party/rtos/FreeRTOS/Source/portable/MPLAB/PIC32MX/port.c
1:                   /*
2:                       FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
3:                       All rights reserved
4:                   
5:                       VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
6:                   
7:                       This file is part of the FreeRTOS distribution.
8:                   
9:                       FreeRTOS is free software; you can redistribute it and/or modify it under
10:                      the terms of the GNU General Public License (version 2) as published by the
11:                      Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
12:                  
13:                      ***************************************************************************
14:                      >>!   NOTE: The modification to the GPL is included to allow you to     !<<
15:                      >>!   distribute a combined work that includes FreeRTOS without being   !<<
16:                      >>!   obliged to provide the source code for proprietary components     !<<
17:                      >>!   outside of the FreeRTOS kernel.                                   !<<
18:                      ***************************************************************************
19:                  
20:                      FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
21:                      WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
22:                      FOR A PARTICULAR PURPOSE.  Full license text is available on the following
23:                      link: http://www.freertos.org/a00114.html
24:                  
25:                      ***************************************************************************
26:                       *                                                                       *
27:                       *    FreeRTOS provides completely free yet professionally developed,    *
28:                       *    robust, strictly quality controlled, supported, and cross          *
29:                       *    platform software that is more than just the market leader, it     *
30:                       *    is the industry's de facto standard.                               *
31:                       *                                                                       *
32:                       *    Help yourself get started quickly while simultaneously helping     *
33:                       *    to support the FreeRTOS project by purchasing a FreeRTOS           *
34:                       *    tutorial book, reference manual, or both:                          *
35:                       *    http://www.FreeRTOS.org/Documentation                              *
36:                       *                                                                       *
37:                      ***************************************************************************
38:                  
39:                      http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
40:                      the FAQ page "My application does not run, what could be wrong?".  Have you
41:                      defined configASSERT()?
42:                  
43:                      http://www.FreeRTOS.org/support - In return for receiving this top quality
44:                      embedded software for free we request you assist our global community by
45:                      participating in the support forum.
46:                  
47:                      http://www.FreeRTOS.org/training - Investing in training allows your team to
48:                      be as productive as possible as early as possible.  Now you can receive
49:                      FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
50:                      Ltd, and the world's leading authority on the world's leading RTOS.
51:                  
52:                      http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
53:                      including FreeRTOS+Trace - an indispensable productivity tool, a DOS
54:                      compatible FAT file system, and our tiny thread aware UDP/IP stack.
55:                  
56:                      http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
57:                      Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
58:                  
59:                      http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
60:                      Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
61:                      licenses offer ticketed support, indemnification and commercial middleware.
62:                  
63:                      http://www.SafeRTOS.com - High Integrity Systems also provide a safety
64:                      engineered and independently SIL3 certified version for use in safety and
65:                      mission critical applications that require provable dependability.
66:                  
67:                      1 tab == 4 spaces!
68:                  */
69:                  
70:                  /*-----------------------------------------------------------
71:                   * Implementation of functions defined in portable.h for the PIC32MX port.
72:                    *----------------------------------------------------------*/
73:                  
74:                  #ifndef __XC
75:                      #error This port is designed to work with XC32.  Please update your C compiler version.
76:                  #endif
77:                  
78:                  /* Scheduler include files. */
79:                  #include "FreeRTOS.h"
80:                  #include "task.h"
81:                  
82:                  /* Hardware specifics. */
83:                  #define portTIMER_PRESCALE	8
84:                  #define portPRESCALE_BITS	1
85:                  
86:                  /* Bits within various registers. */
87:                  #define portIE_BIT						( 0x00000001 )
88:                  #define portEXL_BIT						( 0x00000002 )
89:                  
90:                  /* Bits within the CAUSE register. */
91:                  #define portCORE_SW_0					( 0x00000100 )
92:                  #define portCORE_SW_1					( 0x00000200 )
93:                  
94:                  /* The EXL bit is set to ensure interrupts do not occur while the context of
95:                  the first task is being restored. */
96:                  #define portINITIAL_SR					( portIE_BIT | portEXL_BIT )
97:                  
98:                  /*
99:                  By default port.c generates its tick interrupt from TIMER1.  The user can
100:                 override this behaviour by:
101:                 	1: Providing their own implementation of vApplicationSetupTickTimerInterrupt(),
102:                 	   which is the function that configures the timer.  The function is defined
103:                 	   as a weak symbol in this file so if the same function name is used in the
104:                 	   application code then the version in the application code will be linked
105:                 	   into the application in preference to the version defined in this file.
106:                 	2: Define configTICK_INTERRUPT_VECTOR to the vector number of the timer used
107:                 	   to generate the tick interrupt.  For example, when timer 1 is used then
108:                 	   configTICK_INTERRUPT_VECTOR is set to _TIMER_1_VECTOR.
109:                 	   configTICK_INTERRUPT_VECTOR should be defined in FreeRTOSConfig.h.
110:                 	3: Define configCLEAR_TICK_TIMER_INTERRUPT() to clear the interrupt in the
111:                 	   timer used to generate the tick interrupt.  For example, when timer 1 is
112:                 	   used configCLEAR_TICK_TIMER_INTERRUPT() is defined to
113:                 	   IFS0CLR = _IFS0_T1IF_MASK.
114:                 */
115:                 #ifndef configTICK_INTERRUPT_VECTOR
116:                 	#define configTICK_INTERRUPT_VECTOR _TIMER_1_VECTOR
117:                 	#define configCLEAR_TICK_TIMER_INTERRUPT() IFS0CLR = _IFS0_T1IF_MASK
118:                 #else
119:                 	#ifndef configCLEAR_TICK_TIMER_INTERRUPT
120:                 		#error If configTICK_INTERRUPT_VECTOR is defined in application code then configCLEAR_TICK_TIMER_INTERRUPT must also be defined in application code.
121:                 	#endif
122:                 #endif
123:                 
124:                 /* Let the user override the pre-loading of the initial RA with the address of
125:                 prvTaskExitError() in case it messes up unwinding of the stack in the
126:                 debugger - in which case configTASK_RETURN_ADDRESS can be defined as 0 (NULL). */
127:                 #ifdef configTASK_RETURN_ADDRESS
128:                 	#define portTASK_RETURN_ADDRESS	configTASK_RETURN_ADDRESS
129:                 #else
130:                 	#define portTASK_RETURN_ADDRESS	prvTaskExitError
131:                 #endif
132:                 
133:                 /* Set configCHECK_FOR_STACK_OVERFLOW to 3 to add ISR stack checking to task
134:                 stack checking.  A problem in the ISR stack will trigger an assert, not call the
135:                 stack overflow hook function (because the stack overflow hook is specific to a
136:                 task stack, not the ISR stack). */
137:                 #if( configCHECK_FOR_STACK_OVERFLOW > 2 )
138:                 
139:                 	/* Don't use 0xa5 as the stack fill bytes as that is used by the kernerl for
140:                 	the task stacks, and so will legitimately appear in many positions within
141:                 	the ISR stack. */
142:                 	#define portISR_STACK_FILL_BYTE	0xee
143:                 
144:                 	static const uint8_t ucExpectedStackBytes[] = {
145:                 									portISR_STACK_FILL_BYTE, portISR_STACK_FILL_BYTE, portISR_STACK_FILL_BYTE, portISR_STACK_FILL_BYTE,		\
146:                 									portISR_STACK_FILL_BYTE, portISR_STACK_FILL_BYTE, portISR_STACK_FILL_BYTE, portISR_STACK_FILL_BYTE,		\
147:                 									portISR_STACK_FILL_BYTE, portISR_STACK_FILL_BYTE, portISR_STACK_FILL_BYTE, portISR_STACK_FILL_BYTE,		\
148:                 									portISR_STACK_FILL_BYTE, portISR_STACK_FILL_BYTE, portISR_STACK_FILL_BYTE, portISR_STACK_FILL_BYTE,		\
149:                 									portISR_STACK_FILL_BYTE, portISR_STACK_FILL_BYTE, portISR_STACK_FILL_BYTE, portISR_STACK_FILL_BYTE };	\
150:                 
151:                 	#define portCHECK_ISR_STACK() configASSERT( ( memcmp( ( void * ) xISRStack, ( void * ) ucExpectedStackBytes, sizeof( ucExpectedStackBytes ) ) == 0 ) )
152:                 #else
153:                 	/* Define the function away. */
154:                 	#define portCHECK_ISR_STACK()
155:                 #endif /* configCHECK_FOR_STACK_OVERFLOW > 2 */
156:                 
157:                 /*-----------------------------------------------------------*/
158:                 
159:                 
160:                 /*
161:                  * Place the prototype here to ensure the interrupt vector is correctly installed.
162:                  * Note that because the interrupt is written in assembly, the IPL setting in the
163:                  * following line of code has no effect.  The interrupt priority is set by the
164:                  * call to ConfigIntTimer1() in vApplicationSetupTickTimerInterrupt().
165:                  */
166:                 extern void __attribute__( (interrupt(IPL1AUTO), vector( configTICK_INTERRUPT_VECTOR ))) vPortTickInterruptHandler( void );
167:                 
168:                 /*
169:                  * The software interrupt handler that performs the yield.  Note that, because
170:                  * the interrupt is written in assembly, the IPL setting in the following line of
171:                  * code has no effect.  The interrupt priority is set by the call to
172:                  * mConfigIntCoreSW0() in xPortStartScheduler().
173:                  */
174:                 void __attribute__( (interrupt(IPL1AUTO), vector(_CORE_SOFTWARE_0_VECTOR))) vPortYieldISR( void );
175:                 
176:                 /*
177:                  * Used to catch tasks that attempt to return from their implementing function.
178:                  */
179:                 static void prvTaskExitError( void );
180:                 
181:                 /*-----------------------------------------------------------*/
182:                 
183:                 /* Records the interrupt nesting depth.  This is initialised to one as it is
184:                 decremented to 0 when the first task starts. */
185:                 volatile UBaseType_t uxInterruptNesting = 0x01;
186:                 
187:                 /* Stores the task stack pointer when a switch is made to use the system stack. */
188:                 UBaseType_t uxSavedTaskStackPointer = 0;
189:                 
190:                 /* The stack used by interrupt service routines that cause a context switch. */
191:                 StackType_t xISRStack[ configISR_STACK_SIZE ] = { 0 };
192:                 
193:                 /* The top of stack value ensures there is enough space to store 6 registers on
194:                 the callers stack, as some functions seem to want to do this. */
195:                 const StackType_t * const xISRStackTop = &( xISRStack[ configISR_STACK_SIZE - 7 ] );
196:                 
197:                 /*-----------------------------------------------------------*/
198:                 
199:                 /*
200:                  * See header file for description.
201:                  */
202:                 StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
203:                 {
9D0141B4  27BDFFF8   ADDIU SP, SP, -8
9D0141B8  AFBF0004   SW RA, 4(SP)
204:                 	/* Ensure byte alignment is maintained when leaving this function. */
205:                 	pxTopOfStack--;
206:                 
207:                 	*pxTopOfStack = (StackType_t) 0xDEADBEEF;
9D0141BC  3C02DEAD   LUI V0, -8531
9D0141C0  3442BEEF   ORI V0, V0, -16657
9D0141C4  AC82FFFC   SW V0, -4(A0)
208:                 	pxTopOfStack--;
209:                 
210:                 	*pxTopOfStack = (StackType_t) 0x12345678;	/* Word to which the stack pointer will be left pointing after context restore. */
9D0141C8  3C021234   LUI V0, 4660
9D0141CC  24425678   ADDIU V0, V0, 22136
9D0141D0  AC82FFF8   SW V0, -8(A0)
211:                 	pxTopOfStack--;
212:                 
213:                 	*pxTopOfStack = (StackType_t) _CP0_GET_CAUSE();
9D0141D4  40026800   MFC0 V0, Cause
9D0141D8  AC82FFF4   SW V0, -12(A0)
214:                 	pxTopOfStack--;
215:                 
216:                 	*pxTopOfStack = (StackType_t) portINITIAL_SR;/* CP0_STATUS */
9D0141DC  24020003   ADDIU V0, ZERO, 3
9D0141E0  AC82FFF0   SW V0, -16(A0)
217:                 	pxTopOfStack--;
218:                 
219:                 	*pxTopOfStack = (StackType_t) pxCode; 		/* CP0_EPC */
9D0141E4  AC85FFEC   SW A1, -20(A0)
220:                 	pxTopOfStack--;
221:                 
222:                 	*pxTopOfStack = (StackType_t) portTASK_RETURN_ADDRESS;	/* ra */
9D0141E8  3C029D01   LUI V0, -25343
9D0141EC  24425404   ADDIU V0, V0, 21508
9D0141F0  AC82FFE8   SW V0, -24(A0)
223:                 	pxTopOfStack -= 15;
224:                 
225:                 	*pxTopOfStack = (StackType_t) pvParameters; /* Parameters to pass in. */
9D0141F4  AC86FFAC   SW A2, -84(A0)
226:                 	pxTopOfStack -= 15;
227:                 
228:                 	return pxTopOfStack;
229:                 }
9D0141F8  2482FF70   ADDIU V0, A0, -144
9D0141FC  8FBF0004   LW RA, 4(SP)
9D014200  03E00008   JR RA
9D014204  27BD0008   ADDIU SP, SP, 8
230:                 /*-----------------------------------------------------------*/
231:                 
232:                 static void prvTaskExitError( void )
233:                 {
9D015404  27BDFFF8   ADDIU SP, SP, -8
9D015408  AFBF0004   SW RA, 4(SP)
234:                 	/* A function that implements a task must not exit or attempt to return to
235:                 	its caller as there is nothing to return to.  If a task wants to exit it
236:                 	should instead call vTaskDelete( NULL ).
237:                 
238:                 	Artificially force an assert() to be triggered if configASSERT() is
239:                 	defined, then stop here so application writers can catch the error. */
240:                 	configASSERT( uxSavedTaskStackPointer == 0UL );
241:                 	portDISABLE_INTERRUPTS();
9D01540C  40026000   MFC0 V0, Status
9D015410  7C027A84   INS V0, ZERO, 10, 6
9D015414  34420C00   ORI V0, V0, 3072
9D015418  40826000   MTC0 V0, Status
9D01541C  000000C0   EHB
9D015420  0B405508   J 0x9D015420
9D015424  00000000   NOP
242:                 	for( ;; );
243:                 }
244:                 /*-----------------------------------------------------------*/
245:                 
246:                 /*
247:                  * Setup a timer for a regular tick.  This function uses peripheral timer 1.
248:                  * The function is declared weak so an application writer can use a different
249:                  * timer by redefining this implementation.  If a different timer is used then
250:                  * configTICK_INTERRUPT_VECTOR must also be defined in FreeRTOSConfig.h to
251:                  * ensure the RTOS provided tick interrupt handler is installed on the correct
252:                  * vector number.  When Timer 1 is used the vector number is defined as
253:                  * _TIMER_1_VECTOR.
254:                  */
255:                 __attribute__(( weak )) void vApplicationSetupTickTimerInterrupt( void )
256:                 {
257:                 const uint32_t ulCompareMatch = ( (configPERIPHERAL_CLOCK_HZ / portTIMER_PRESCALE) / configTICK_RATE_HZ ) - 1;
258:                 
259:                 	T1CON = 0x0000;
9D01363C  3C02BF80   LUI V0, -16512
9D013640  AC400600   SW ZERO, 1536(V0)
260:                 	T1CONbits.TCKPS = portPRESCALE_BITS;
9D013644  3C02BF80   LUI V0, -16512
9D013648  94440600   LHU A0, 1536(V0)
9D01364C  24030001   ADDIU V1, ZERO, 1
9D013650  7C642904   INS A0, V1, 4, 2
9D013654  A4440600   SH A0, 1536(V0)
261:                 	PR1 = ulCompareMatch;
9D013658  24051387   ADDIU A1, ZERO, 4999
9D01365C  3C04BF80   LUI A0, -16512
9D013660  AC850620   SW A1, 1568(A0)
262:                 	IPC1bits.T1IP = configKERNEL_INTERRUPT_PRIORITY;
9D013664  3C04BF88   LUI A0, -16504
9D013668  8C8510A0   LW A1, 4256(A0)
9D01366C  7C652084   INS A1, V1, 2, 3
9D013670  AC8510A0   SW A1, 4256(A0)
263:                 
264:                 	/* Clear the interrupt as a starting condition. */
265:                 	IFS0bits.T1IF = 0;
9D013674  3C04BF88   LUI A0, -16504
9D013678  8C851030   LW A1, 4144(A0)
9D01367C  7C052104   INS A1, ZERO, 4, 1
9D013680  AC851030   SW A1, 4144(A0)
266:                 
267:                 	/* Enable the interrupt. */
268:                 	IEC0bits.T1IE = 1;
9D013684  3C04BF88   LUI A0, -16504
9D013688  8C851060   LW A1, 4192(A0)
9D01368C  7C652104   INS A1, V1, 4, 1
9D013690  AC851060   SW A1, 4192(A0)
269:                 
270:                 	/* Start the timer. */
271:                 	T1CONbits.TON = 1;
9D013694  94440600   LHU A0, 1536(V0)
9D013698  7C647BC4   INS A0, V1, 15, 1
9D01369C  A4440600   SH A0, 1536(V0)
9D0136A0  03E00008   JR RA
9D0136A4  00000000   NOP
272:                 }
273:                 /*-----------------------------------------------------------*/
274:                 
275:                 void vPortEndScheduler(void)
276:                 {
277:                 	/* Not implemented in ports where there is nothing to return to.
278:                 	Artificially force an assert. */
279:                 	configASSERT( uxInterruptNesting == 1000UL );
280:                 }
281:                 /*-----------------------------------------------------------*/
282:                 
283:                 BaseType_t xPortStartScheduler( void )
284:                 {
9D013CD4  27BDFFE8   ADDIU SP, SP, -24
9D013CD8  AFBF0014   SW RA, 20(SP)
285:                 extern void vPortStartFirstTask( void );
286:                 extern void *pxCurrentTCB;
287:                 
288:                 	#if ( configCHECK_FOR_STACK_OVERFLOW > 2 )
289:                 	{
290:                 		/* Fill the ISR stack to make it easy to asses how much is being used. */
291:                 		memset( ( void * ) xISRStack, portISR_STACK_FILL_BYTE, sizeof( xISRStack ) );
292:                 	}
293:                 	#endif /* configCHECK_FOR_STACK_OVERFLOW > 2 */
294:                 
295:                 	/* Clear the software interrupt flag. */
296:                 	IFS0CLR = _IFS0_CS0IF_MASK;
9D013CDC  24020002   ADDIU V0, ZERO, 2
9D013CE0  3C03BF88   LUI V1, -16504
9D013CE4  AC621034   SW V0, 4148(V1)
297:                 
298:                 	/* Set software timer priority. */
299:                 	IPC0CLR = _IPC0_CS0IP_MASK;
9D013CE8  24041C00   ADDIU A0, ZERO, 7168
9D013CEC  3C03BF88   LUI V1, -16504
9D013CF0  AC641094   SW A0, 4244(V1)
300:                 	IPC0SET = ( configKERNEL_INTERRUPT_PRIORITY << _IPC0_CS0IP_POSITION );
9D013CF4  24040400   ADDIU A0, ZERO, 1024
9D013CF8  3C03BF88   LUI V1, -16504
9D013CFC  AC641098   SW A0, 4248(V1)
301:                 
302:                 	/* Enable software interrupt. */
303:                 	IEC0CLR = _IEC0_CS0IE_MASK;
9D013D00  3C03BF88   LUI V1, -16504
9D013D04  AC621064   SW V0, 4196(V1)
304:                 	IEC0SET = 1 << _IEC0_CS0IE_POSITION;
9D013D08  3C03BF88   LUI V1, -16504
9D013D0C  AC621068   SW V0, 4200(V1)
305:                 
306:                 	/* Setup the timer to generate the tick.  Interrupts will have been
307:                 	disabled by the time we get here. */
308:                 	vApplicationSetupTickTimerInterrupt();
9D013D10  0F404D8F   JAL vApplicationSetupTickTimerInterrupt
9D013D14  00000000   NOP
309:                 
310:                 	/* Kick off the highest priority task that has been created so far.
311:                 	Its stack location is loaded into uxSavedTaskStackPointer. */
312:                 	uxSavedTaskStackPointer = *( UBaseType_t * ) pxCurrentTCB;
9D013D18  8F8280A4   LW V0, -32604(GP)
9D013D1C  8C420000   LW V0, 0(V0)
313:                 	vPortStartFirstTask();
9D013D20  0F401570   JAL vPortStartFirstTask
9D013D24  AF8280D4   SW V0, -32556(GP)
314:                 
315:                 	/* Should never get here as the tasks will now be executing!  Call the task
316:                 	exit error function to prevent compiler warnings about a static function
317:                 	not being called in the case that the application writer overrides this
318:                 	functionality by defining configTASK_RETURN_ADDRESS. */
319:                 	prvTaskExitError();
9D013D28  0F405501   JAL prvTaskExitError
9D013D2C  00000000   NOP
320:                 
321:                 	return pdFALSE;
322:                 }
323:                 /*-----------------------------------------------------------*/
324:                 
325:                 void vPortIncrementTick( void )
326:                 {
9D014208  27BDFFE8   ADDIU SP, SP, -24
9D01420C  AFBF0014   SW RA, 20(SP)
327:                 UBaseType_t uxSavedStatus;
328:                 
329:                 	uxSavedStatus = uxPortSetInterruptMaskFromISR();
9D014210  0F4052D3   JAL uxPortSetInterruptMaskFromISR
9D014214  AFB00010   SW S0, 16(SP)
330:                 	{
331:                 		if( xTaskIncrementTick() != pdFALSE )
9D014218  0F403087   JAL xTaskIncrementTick
9D01421C  00408021   ADDU S0, V0, ZERO
9D014220  10400005   BEQ V0, ZERO, vPortIncrementTick::vPortClearInterruptMaskFromISR
9D014224  00000000   NOP
332:                 		{
333:                 			/* Pend a context switch. */
334:                 			_CP0_BIS_CAUSE( portCORE_SW_0 );
9D014228  40026800   MFC0 V0, Cause
9D01422C  34420100   ORI V0, V0, 256
9D014230  40826800   MTC0 V0, Cause
9D014234  000000C0   EHB
335:                 		}
336:                 	}
337:                 	vPortClearInterruptMaskFromISR( uxSavedStatus );
338:                 
339:                 	/* Look for the ISR stack getting near or past its limit. */
340:                 	portCHECK_ISR_STACK();
341:                 
342:                 	/* Clear timer interrupt. */
343:                 	configCLEAR_TICK_TIMER_INTERRUPT();
9D014240  24030010   ADDIU V1, ZERO, 16
9D014244  3C02BF88   LUI V0, -16504
9D014248  AC431034   SW V1, 4148(V0)
344:                 }
9D01424C  8FBF0014   LW RA, 20(SP)
345:                 /*-----------------------------------------------------------*/
346:                 
347:                 UBaseType_t uxPortSetInterruptMaskFromISR( void )
348:                 {
9D014B4C  27BDFFF8   ADDIU SP, SP, -8
9D014B50  AFBF0004   SW RA, 4(SP)
349:                 UBaseType_t uxSavedStatusRegister;
350:                 
351:                 	__builtin_disable_interrupts();
9D014B54  41626000   DI V0
9D014B58  000000C0   EHB
352:                 	uxSavedStatusRegister = _CP0_GET_STATUS() | 0x01;
9D014B5C  40026000   MFC0 V0, Status
353:                 	/* This clears the IPL bits, then sets them to
354:                 	configMAX_SYSCALL_INTERRUPT_PRIORITY.  This function should not be called
355:                 	from an interrupt that has a priority above
356:                 	configMAX_SYSCALL_INTERRUPT_PRIORITY so, when used correctly, the action
357:                 	can only result in the IPL being unchanged or raised, and therefore never
358:                 	lowered. */
359:                 	_CP0_SET_STATUS( ( ( uxSavedStatusRegister & ( ~portALL_IPL_BITS ) ) ) | ( configMAX_SYSCALL_INTERRUPT_PRIORITY << portIPL_SHIFT ) );
9D014B60  3C04FFFF   LUI A0, -1
9D014B64  348403FF   ORI A0, A0, 1023
9D014B68  00441824   AND V1, V0, A0
9D014B6C  34630C01   ORI V1, V1, 3073
9D014B70  40836000   MTC0 V1, Status
9D014B74  000000C0   EHB
360:                 
361:                 	return uxSavedStatusRegister;
362:                 }
9D014B78  34420001   ORI V0, V0, 1
9D014B7C  8FBF0004   LW RA, 4(SP)
9D014B80  03E00008   JR RA
9D014B84  27BD0008   ADDIU SP, SP, 8
363:                 /*-----------------------------------------------------------*/
364:                 
365:                 void vPortClearInterruptMaskFromISR( UBaseType_t uxSavedStatusRegister )
366:                 {
9D01569C  27BDFFF8   ADDIU SP, SP, -8
9D0156A0  AFBF0004   SW RA, 4(SP)
367:                 	_CP0_SET_STATUS( uxSavedStatusRegister );
9D014238  40906000   MTC0 S0, Status
9D0156A4  40846000   MTC0 A0, Status
9D0156A8  000000C0   EHB
368:                 }
9D0156AC  8FBF0004   LW RA, 4(SP)
9D0156B0  03E00008   JR RA
9D0156B4  27BD0008   ADDIU SP, SP, 8
369:                 /*-----------------------------------------------------------*/
370:                 
371:                 
372:                 
373:                 
374:                 
---  /home/whatisthis/microchip/harmony/v2_04/third_party/rtos/FreeRTOS/Source/list.c  ------------------
1:                   /*
2:                       FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
3:                       All rights reserved
4:                   
5:                       VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
6:                   
7:                       This file is part of the FreeRTOS distribution.
8:                   
9:                       FreeRTOS is free software; you can redistribute it and/or modify it under
10:                      the terms of the GNU General Public License (version 2) as published by the
11:                      Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
12:                  
13:                      ***************************************************************************
14:                      >>!   NOTE: The modification to the GPL is included to allow you to     !<<
15:                      >>!   distribute a combined work that includes FreeRTOS without being   !<<
16:                      >>!   obliged to provide the source code for proprietary components     !<<
17:                      >>!   outside of the FreeRTOS kernel.                                   !<<
18:                      ***************************************************************************
19:                  
20:                      FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
21:                      WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
22:                      FOR A PARTICULAR PURPOSE.  Full license text is available on the following
23:                      link: http://www.freertos.org/a00114.html
24:                  
25:                      ***************************************************************************
26:                       *                                                                       *
27:                       *    FreeRTOS provides completely free yet professionally developed,    *
28:                       *    robust, strictly quality controlled, supported, and cross          *
29:                       *    platform software that is more than just the market leader, it     *
30:                       *    is the industry's de facto standard.                               *
31:                       *                                                                       *
32:                       *    Help yourself get started quickly while simultaneously helping     *
33:                       *    to support the FreeRTOS project by purchasing a FreeRTOS           *
34:                       *    tutorial book, reference manual, or both:                          *
35:                       *    http://www.FreeRTOS.org/Documentation                              *
36:                       *                                                                       *
37:                      ***************************************************************************
38:                  
39:                      http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
40:                      the FAQ page "My application does not run, what could be wrong?".  Have you
41:                      defined configASSERT()?
42:                  
43:                      http://www.FreeRTOS.org/support - In return for receiving this top quality
44:                      embedded software for free we request you assist our global community by
45:                      participating in the support forum.
46:                  
47:                      http://www.FreeRTOS.org/training - Investing in training allows your team to
48:                      be as productive as possible as early as possible.  Now you can receive
49:                      FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
50:                      Ltd, and the world's leading authority on the world's leading RTOS.
51:                  
52:                      http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
53:                      including FreeRTOS+Trace - an indispensable productivity tool, a DOS
54:                      compatible FAT file system, and our tiny thread aware UDP/IP stack.
55:                  
56:                      http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
57:                      Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
58:                  
59:                      http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
60:                      Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
61:                      licenses offer ticketed support, indemnification and commercial middleware.
62:                  
63:                      http://www.SafeRTOS.com - High Integrity Systems also provide a safety
64:                      engineered and independently SIL3 certified version for use in safety and
65:                      mission critical applications that require provable dependability.
66:                  
67:                      1 tab == 4 spaces!
68:                  */
69:                  
70:                  
71:                  #include <stdlib.h>
72:                  #include "FreeRTOS.h"
73:                  #include "list.h"
74:                  
75:                  /*-----------------------------------------------------------
76:                   * PUBLIC LIST API documented in list.h
77:                   *----------------------------------------------------------*/
78:                  
79:                  void vListInitialise( List_t * const pxList )
80:                  {
81:                  	/* The list structure contains a list item which is used to mark the
82:                  	end of the list.  To initialise the list the list end is inserted
83:                  	as the only list entry. */
84:                  	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
9D015564  24820008   ADDIU V0, A0, 8
9D015568  AC820004   SW V0, 4(A0)
85:                  
86:                  	/* The list end value is the highest possible value in the list to
87:                  	ensure it remains at the end of the list. */
88:                  	pxList->xListEnd.xItemValue = portMAX_DELAY;
9D01556C  2403FFFF   ADDIU V1, ZERO, -1
9D015570  AC830008   SW V1, 8(A0)
89:                  
90:                  	/* The list end next and previous pointers point to itself so we know
91:                  	when the list is empty. */
92:                  	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
9D015574  AC82000C   SW V0, 12(A0)
93:                  	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
9D015578  AC820010   SW V0, 16(A0)
94:                  
95:                  	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
9D01557C  03E00008   JR RA
9D015580  AC800000   SW ZERO, 0(A0)
96:                  
97:                  	/* Write known values into the list if
98:                  	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
99:                  	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
100:                 	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
101:                 }
102:                 /*-----------------------------------------------------------*/
103:                 
104:                 void vListInitialiseItem( ListItem_t * const pxItem )
105:                 {
106:                 	/* Make sure the list item is not recorded as being on a list. */
107:                 	pxItem->pvContainer = NULL;
9D015A18  03E00008   JR RA
9D015A1C  AC800010   SW ZERO, 16(A0)
108:                 
109:                 	/* Write known values into the list item if
110:                 	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
111:                 	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
112:                 	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
113:                 }
114:                 /*-----------------------------------------------------------*/
115:                 
116:                 void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
117:                 {
118:                 ListItem_t * const pxIndex = pxList->pxIndex;
9D015098  8C820004   LW V0, 4(A0)
119:                 
120:                 	/* Only effective when configASSERT() is also defined, these tests may catch
121:                 	the list data structures being overwritten in memory.  They will not catch
122:                 	data errors caused by incorrect configuration or use of FreeRTOS. */
123:                 	listTEST_LIST_INTEGRITY( pxList );
124:                 	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );
125:                 
126:                 	/* Insert a new list item into pxList, but rather than sort the list,
127:                 	makes the new list item the last item to be removed by a call to
128:                 	listGET_OWNER_OF_NEXT_ENTRY(). */
129:                 	pxNewListItem->pxNext = pxIndex;
9D01509C  ACA20004   SW V0, 4(A1)
130:                 	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
9D0150A0  8C430008   LW V1, 8(V0)
9D0150A4  ACA30008   SW V1, 8(A1)
131:                 
132:                 	/* Only used during decision coverage testing. */
133:                 	mtCOVERAGE_TEST_DELAY();
134:                 
135:                 	pxIndex->pxPrevious->pxNext = pxNewListItem;
9D0150A8  8C430008   LW V1, 8(V0)
9D0150AC  AC650004   SW A1, 4(V1)
136:                 	pxIndex->pxPrevious = pxNewListItem;
9D0150B0  AC450008   SW A1, 8(V0)
137:                 
138:                 	/* Remember which list the item is in. */
139:                 	pxNewListItem->pvContainer = ( void * ) pxList;
9D0150B4  ACA40010   SW A0, 16(A1)
140:                 
141:                 	( pxList->uxNumberOfItems )++;
9D0150B8  8C820000   LW V0, 0(A0)
9D0150BC  24420001   ADDIU V0, V0, 1
9D0150C0  03E00008   JR RA
9D0150C4  AC820000   SW V0, 0(A0)
142:                 }
143:                 /*-----------------------------------------------------------*/
144:                 
145:                 void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
146:                 {
147:                 ListItem_t *pxIterator;
148:                 const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
9D013C1C  8CA70000   LW A3, 0(A1)
149:                 
150:                 	/* Only effective when configASSERT() is also defined, these tests may catch
151:                 	the list data structures being overwritten in memory.  They will not catch
152:                 	data errors caused by incorrect configuration or use of FreeRTOS. */
153:                 	listTEST_LIST_INTEGRITY( pxList );
154:                 	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );
155:                 
156:                 	/* Insert the new list item into the list, sorted in xItemValue order.
157:                 
158:                 	If the list already contains a list item with the same item value then the
159:                 	new list item should be placed after it.  This ensures that TCB's which are
160:                 	stored in ready lists (all of which have the same xItemValue value) get a
161:                 	share of the CPU.  However, if the xItemValue is the same as the back marker
162:                 	the iteration loop below will not end.  Therefore the value is checked
163:                 	first, and the algorithm slightly modified if necessary. */
164:                 	if( xValueOfInsertion == portMAX_DELAY )
9D013C20  2402FFFF   ADDIU V0, ZERO, -1
9D013C24  14E20003   BNE A3, V0, 0x9D013C34
9D013C28  24830008   ADDIU V1, A0, 8
9D013C2C  0B404F14   J 0x9D013C50
9D013C30  8C830010   LW V1, 16(A0)
165:                 	{
166:                 		pxIterator = pxList->xListEnd.pxPrevious;
167:                 	}
168:                 	else
169:                 	{
170:                 		/* *** NOTE ***********************************************************
171:                 		If you find your application is crashing here then likely causes are
172:                 		listed below.  In addition see http://www.freertos.org/FAQHelp.html for
173:                 		more tips, and ensure configASSERT() is defined!
174:                 		http://www.freertos.org/a00110.html#configASSERT
175:                 
176:                 			1) Stack overflow -
177:                 			   see http://www.freertos.org/Stacks-and-stack-overflow-checking.html
178:                 			2) Incorrect interrupt priority assignment, especially on Cortex-M
179:                 			   parts where numerically high priority values denote low actual
180:                 			   interrupt priorities, which can seem counter intuitive.  See
181:                 			   http://www.freertos.org/RTOS-Cortex-M3-M4.html and the definition
182:                 			   of configMAX_SYSCALL_INTERRUPT_PRIORITY on
183:                 			   http://www.freertos.org/a00110.html
184:                 			3) Calling an API function from within a critical section or when
185:                 			   the scheduler is suspended, or calling an API function that does
186:                 			   not end in "FromISR" from an interrupt.
187:                 			4) Using a queue or semaphore before it has been initialised or
188:                 			   before the scheduler has been started (are interrupts firing
189:                 			   before vTaskStartScheduler() has been called?).
190:                 		**********************************************************************/
191:                 
192:                 		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
9D013C34  8C620004   LW V0, 4(V1)
9D013C38  8C460000   LW A2, 0(V0)
9D013C3C  00E6302B   SLTU A2, A3, A2
9D013C40  54C00005   BNEL A2, ZERO, 0x9D013C58
9D013C44  ACA20004   SW V0, 4(A1)
9D013C48  0B404F0D   J 0x9D013C34
9D013C4C  00401821   ADDU V1, V0, ZERO
193:                 		{
194:                 			/* There is nothing to do here, just iterating to the wanted
195:                 			insertion position. */
196:                 		}
197:                 	}
198:                 
199:                 	pxNewListItem->pxNext = pxIterator->pxNext;
9D013C50  8C620004   LW V0, 4(V1)
9D013C54  ACA20004   SW V0, 4(A1)
200:                 	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
9D013C58  AC450008   SW A1, 8(V0)
201:                 	pxNewListItem->pxPrevious = pxIterator;
9D013C5C  ACA30008   SW V1, 8(A1)
202:                 	pxIterator->pxNext = pxNewListItem;
9D013C60  AC650004   SW A1, 4(V1)
203:                 
204:                 	/* Remember which list the item is in.  This allows fast removal of the
205:                 	item later. */
206:                 	pxNewListItem->pvContainer = ( void * ) pxList;
9D013C64  ACA40010   SW A0, 16(A1)
207:                 
208:                 	( pxList->uxNumberOfItems )++;
9D013C68  8C820000   LW V0, 0(A0)
9D013C6C  24420001   ADDIU V0, V0, 1
9D013C70  03E00008   JR RA
9D013C74  AC820000   SW V0, 0(A0)
209:                 }
210:                 /*-----------------------------------------------------------*/
211:                 
212:                 UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
213:                 {
214:                 /* The list item knows which list it is in.  Obtain the list from the list
215:                 item. */
216:                 List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
9D01474C  8C830010   LW V1, 16(A0)
217:                 
218:                 	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
9D014750  8C820004   LW V0, 4(A0)
9D014754  8C850008   LW A1, 8(A0)
9D014758  AC450008   SW A1, 8(V0)
219:                 	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
9D01475C  8C820008   LW V0, 8(A0)
9D014760  8C850004   LW A1, 4(A0)
9D014764  AC450004   SW A1, 4(V0)
220:                 
221:                 	/* Only used during decision coverage testing. */
222:                 	mtCOVERAGE_TEST_DELAY();
223:                 
224:                 	/* Make sure the index is left pointing to a valid item. */
225:                 	if( pxList->pxIndex == pxItemToRemove )
9D014768  8C620004   LW V0, 4(V1)
9D01476C  54440004   BNEL V0, A0, 0x9D014780
9D014770  AC800010   SW ZERO, 16(A0)
226:                 	{
227:                 		pxList->pxIndex = pxItemToRemove->pxPrevious;
9D014774  8C420008   LW V0, 8(V0)
9D014778  AC620004   SW V0, 4(V1)
228:                 	}
229:                 	else
230:                 	{
231:                 		mtCOVERAGE_TEST_MARKER();
232:                 	}
233:                 
234:                 	pxItemToRemove->pvContainer = NULL;
9D01477C  AC800010   SW ZERO, 16(A0)
235:                 	( pxList->uxNumberOfItems )--;
9D014780  8C620000   LW V0, 0(V1)
9D014784  2442FFFF   ADDIU V0, V0, -1
236:                 
237:                 	return pxList->uxNumberOfItems;
238:                 }
9D014788  03E00008   JR RA
9D01478C  AC620000   SW V0, 0(V1)
239:                 /*-----------------------------------------------------------*/
240:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/usb/src/dynamic/usb_device_cdc_acm.c  -----------
1:                   /*******************************************************************************
2:                    USB CDC ACM SubClass
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       usb_device_cdc_acm.c
9:                   
10:                    Summary:
11:                      USB CDC ACM SubClass
12:                  
13:                    Description:
14:                      USB CDC ACM SubClass
15:                   *******************************************************************************/
16:                  
17:                  // DOM-IGNORE-BEGIN
18:                  /*******************************************************************************
19:                   Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
20:                  
21:                   Microchip licenses to you the right to use, modify, copy and distribute
22:                   Software only when embedded on a Microchip microcontroller or digital signal
23:                   controller that is integrated into your product or third party product
24:                   (pursuant to the sublicense terms in the accompanying license agreement).
25:                  
26:                   You should refer to the license agreement accompanying this Software for
27:                   additional information regarding your rights and obligations.
28:                  
29:                   SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
30:                   EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
31:                   MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
32:                   IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
33:                   CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
34:                   OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
35:                   INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
36:                   CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
37:                   SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
38:                   (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
39:                   *******************************************************************************/
40:                  // DOM-IGNORE-END
41:                  
42:                  // *****************************************************************************
43:                  // *****************************************************************************
44:                  // Section: Included Files
45:                  // *****************************************************************************
46:                  // *****************************************************************************
47:                  /*  This section lists the other files that are included in this file.
48:                   */
49:                  #include <stdio.h>
50:                  #include <stdint.h>
51:                  #include "usb/usb_cdc.h"
52:                  #include "usb/usb_device_cdc.h"
53:                  #include "usb/src/usb_device_cdc_local.h"
54:                  
55:                  // *****************************************************************************
56:                  // *****************************************************************************
57:                  // Section: File Scope or Global Constants
58:                  // *****************************************************************************
59:                  // *****************************************************************************
60:                  
61:                  
62:                  // *****************************************************************************
63:                  // *****************************************************************************
64:                  // Section: File Scope or Global Data Types
65:                  // *****************************************************************************
66:                  // *****************************************************************************
67:                  
68:                  // *****************************************************************************
69:                  // *****************************************************************************
70:                  // Section: File Scope Functions
71:                  // *****************************************************************************
72:                  // *****************************************************************************
73:                  
74:                  //******************************************************************************
75:                  /* Function:
76:                      void _USB_DEVICE_CDC_ACMSetUpPacketHandler ( USB_DEVICE_CDC_INSTANCE *instance,
77:                                                                      uint16_t value )
78:                  
79:                    Summary:
80:                      Handles ACM sub class specific requests.
81:                  
82:                    Description:
83:                      This function handles ACM sub class specific requests.
84:                  
85:                    Remarks:
86:                      Called by the CDC function driver.
87:                   */
88:                  
89:                  void _USB_DEVICE_CDC_ACMSetUpPacketHandler 
90:                  (
91:                      SYS_MODULE_INDEX iCDC ,
92:                      USB_DEVICE_CDC_INSTANCE * thisCDCDevice,
93:                      USB_SETUP_PACKET * setupRequest
94:                  )
95:                  {
9D00C860  27BDFFE8   ADDIU SP, SP, -24
9D00C864  AFBF0014   SW RA, 20(SP)
96:                      
97:                      /* Check the request */
98:                      switch (setupRequest->bRequest )
9D00C868  90C30001   LBU V1, 1(A2)
9D00C86C  2C630024   SLTIU V1, V1, 36
9D00C870  10600052   BEQ V1, ZERO, 0x9D00C9BC
9D00C874  00A01021   ADDU V0, A1, ZERO
9D00C878  90C50001   LBU A1, 1(A2)
9D00C87C  00052880   SLL A1, A1, 2
9D00C880  3C039D01   LUI V1, -25343
9D00C884  2463C898   ADDIU V1, V1, -14184
9D00C888  00651821   ADDU V1, V1, A1
9D00C88C  8C630000   LW V1, 0(V1)
9D00C890  00600008   JR V1
9D00C894  00000000   NOP
99:                      {
100:                         case USB_CDC_REQUEST_SET_LINE_CODING:
101:                 
102:                             /* Send this event to application. The application
103:                              * should issues a control receive request to receive
104:                              * the data from the host. */
105:                 
106:                             if(thisCDCDevice->appEventCallBack != NULL)
9D00C928  8C430020   LW V1, 32(V0)
9D00C92C  10600026   BEQ V1, ZERO, 0x9D00C9C8
9D00C930  00003021   ADDU A2, ZERO, ZERO
107:                             {
108:                                 thisCDCDevice->appEventCallBack(iCDC, 
9D00C934  00002821   ADDU A1, ZERO, ZERO
9D00C938  0060F809   JALR V1
9D00C93C  8C470024   LW A3, 36(V0)
109:                                         USB_DEVICE_CDC_EVENT_SET_LINE_CODING, 
110:                                         NULL, thisCDCDevice->userData);
111:                             }
112:                 
113:                             break;
114:                 
115:                         case USB_CDC_REQUEST_GET_LINE_CODING:
116:                 
117:                             /* Send this event to application. The application should
118:                              * issue a control send request to send this request to 
119:                              * the host. */
120:                 
121:                             if(thisCDCDevice->appEventCallBack != NULL)
9D00C948  8C430020   LW V1, 32(V0)
9D00C94C  1060001E   BEQ V1, ZERO, 0x9D00C9C8
9D00C950  00003021   ADDU A2, ZERO, ZERO
122:                             {
123:                                 thisCDCDevice->appEventCallBack(iCDC, 
9D00C954  24050001   ADDIU A1, ZERO, 1
9D00C958  0060F809   JALR V1
9D00C95C  8C470024   LW A3, 36(V0)
124:                                         USB_DEVICE_CDC_EVENT_GET_LINE_CODING, 
125:                                         NULL, thisCDCDevice->userData);
126:                             }
127:                 
128:                             break;
129:                 
130:                         case USB_CDC_REQUEST_SET_CONTROL_LINE_STATE:
131:                 
132:                             /* In this event, the data is available in the
133:                              * setup packet. Send it to the application */
134:                 
135:                             if(thisCDCDevice->appEventCallBack != NULL)
9D00C968  8C430020   LW V1, 32(V0)
9D00C96C  10600016   BEQ V1, ZERO, 0x9D00C9C8
9D00C970  24C60002   ADDIU A2, A2, 2
136:                             {
137:                                 thisCDCDevice->appEventCallBack(iCDC,
9D00C974  24050002   ADDIU A1, ZERO, 2
9D00C978  0060F809   JALR V1
9D00C97C  8C470024   LW A3, 36(V0)
138:                                         USB_DEVICE_CDC_EVENT_SET_CONTROL_LINE_STATE,
139:                                         (USB_CDC_CONTROL_LINE_STATE *)(&setupRequest->wValue),
140:                                         thisCDCDevice->userData);
141:                             }
142:                 
143:                             break;
144:                 
145:                             /* AT commands */
146:                         case USB_CDC_REQUEST_SEND_ENCAPSULATED_COMMAND:
147:                         case USB_CDC_REQUEST_GET_ENCAPSULATED_RESPONSE:
148:                 
149:                             /* AT commands are not supported */
150:                             USB_DEVICE_ControlStatus(thisCDCDevice->deviceHandle, 
9D00C988  8C440000   LW A0, 0(V0)
9D00C98C  0F404BC3   JAL USB_DEVICE_ControlStatus
9D00C990  24050001   ADDIU A1, ZERO, 1
151:                                     USB_DEVICE_CONTROL_STATUS_ERROR);
152:                             break;
9D00C994  0B403273   J 0x9D00C9CC
9D00C998  8FBF0014   LW RA, 20(SP)
153:                 
154:                             /* break request */
155:                         case USB_CDC_REQUEST_SEND_BREAK:
156:                 
157:                             /* In this event, the data is available in the
158:                              * setup packet. Send it to the application */
159:                 
160:                             if(thisCDCDevice->appEventCallBack != NULL)
9D00C99C  8C430020   LW V1, 32(V0)
9D00C9A0  10600009   BEQ V1, ZERO, 0x9D00C9C8
9D00C9A4  24C60002   ADDIU A2, A2, 2
161:                             {
162:                                 thisCDCDevice->appEventCallBack(iCDC,
9D00C9A8  24050003   ADDIU A1, ZERO, 3
9D00C9AC  0060F809   JALR V1
9D00C9B0  8C470024   LW A3, 36(V0)
163:                                         USB_DEVICE_CDC_EVENT_SEND_BREAK,
164:                                         (uint16_t *)(&setupRequest->wValue), thisCDCDevice->userData);
165:                             }
166:                 
167:                             break;
168:                 
169:                             /* requests that do not belog to ACM sub class */
170:                         case USB_CDC_REQUEST_SET_COMM_FEATURE:
171:                         case USB_CDC_REQUEST_GET_COMM_FEATURE:
172:                         case USB_CDC_REQUEST_CLEAR_COMM_FEATURE:
173:                         case USB_CDC_REQUEST_SET_AUX_LINE_STATE:
174:                         case USB_CDC_REQUEST_SET_HOOK_STATE:
175:                         case USB_CDC_REQUEST_PULSE_SETUP:
176:                         case USB_CDC_REQUEST_SEND_PULSE:
177:                         case USB_CDC_REQUEST_SET_PULSE_TIME:
178:                         case USB_CDC_REQUEST_RING_AUX_JACK:
179:                         case USB_CDC_REQUEST_SET_RINGER_PARMS:
180:                         case USB_CDC_REQUEST_GET_RINGER_PARMS:
181:                         case USB_CDC_REQUEST_SET_OPERATIONAL_PARMS:
182:                         case USB_CDC_REQUEST_GET_OPERATIONAL_PARMS:
183:                         case USB_CDC_REQUEST_SET_LINE_PARMS:
184:                         case USB_CDC_REQUEST_GET_LINE_PARMS:
185:                         case USB_CDC_REQUEST_DIAL_DIGITS:
186:                         case USB_CDC_REQUEST_SET_UNIT_PARAMETER:
187:                         case USB_CDC_REQUEST_GET_UNIT_PARAMETER:
188:                         case USB_CDC_REQUEST_CLEAR_UNIT_PARAMETER:
189:                         case USB_CDC_REQUEST_GET_PROFILE:
190:                         case USB_CDC_REQUEST_SET_ETHERNET_MULTICAST_FILTERS:
191:                         case USB_CDC_REQUEST_SET_ETHERNET_POWER_MANAGEMENT_FILTER:
192:                         case USB_CDC_REQUEST_GET_ETHERNET_POWER_MANAGEMENT_FILTER:
193:                         case USB_CDC_REQUEST_SET_ETHERNET_PACKET_FILTER:
194:                         case USB_CDC_REQUEST_GET_ETHERNET_STATISTIC:
195:                         case USB_CDC_REQUEST_SET_ATM_DATA_FORMAT:
196:                         case USB_CDC_REQUEST_GET_ATM_DEVICE_STATISTICS:
197:                         case USB_CDC_REQUEST_SET_ATM_DEFAULT_VC:
198:                         case USB_CDC_REQUEST_GET_ATM_VC_STATISTICS:
199:                         default:
200:                 
201:                             /* These request are not supported */
202:                 
203:                             USB_DEVICE_ControlStatus(thisCDCDevice->deviceHandle,
9D00C9BC  8C440000   LW A0, 0(V0)
9D00C9C0  0F404BC3   JAL USB_DEVICE_ControlStatus
9D00C9C4  24050001   ADDIU A1, ZERO, 1
204:                                        USB_DEVICE_CONTROL_STATUS_ERROR);
205:                 
206:                             break;
207:                     }
208:                 }
9D00C940  0B403273   J 0x9D00C9CC
9D00C944  8FBF0014   LW RA, 20(SP)
9D00C960  0B403273   J 0x9D00C9CC
9D00C964  8FBF0014   LW RA, 20(SP)
9D00C980  0B403273   J 0x9D00C9CC
9D00C984  8FBF0014   LW RA, 20(SP)
9D00C9B4  0B403273   J 0x9D00C9CC
9D00C9B8  8FBF0014   LW RA, 20(SP)
9D00C9C8  8FBF0014   LW RA, 20(SP)
9D00C9CC  03E00008   JR RA
9D00C9D0  27BD0018   ADDIU SP, SP, 24
209:                 
210:                 
211:                 
212:                 /*******************************************************************************
213:                  End of File
214:                  */
---  /home/whatisthis/microchip/harmony/v2_04/framework/usb/src/dynamic/usb_device_cdc.c  ---------------
1:                   /*******************************************************************************
2:                    USB CDC Class Function Driver
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       usb_device_cdc.c
9:                   
10:                    Summary:
11:                      USB CDC class function driver.
12:                  
13:                    Description:
14:                      USB CDC class function driver.
15:                   *******************************************************************************/
16:                  
17:                  // DOM-IGNORE-BEGIN
18:                  /*******************************************************************************
19:                   Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
20:                  
21:                   Microchip licenses to you the right to use, modify, copy and distribute
22:                   Software only when embedded on a Microchip microcontroller or digital signal
23:                   controller that is integrated into your product or third party product
24:                   (pursuant to the sublicense terms in the accompanying license agreement).
25:                  
26:                   You should refer to the license agreement accompanying this Software for
27:                   additional information regarding your rights and obligations.
28:                  
29:                   SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
30:                   EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
31:                   MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
32:                   IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
33:                   CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
34:                   OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
35:                   INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
36:                   CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
37:                   SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
38:                   (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
39:                   *******************************************************************************/
40:                  // DOM-IGNORE-END
41:                  
42:                  // *****************************************************************************
43:                  // *****************************************************************************
44:                  // Section: Included Files
45:                  // *****************************************************************************
46:                  // *****************************************************************************
47:                  #include "usb/usb_device_cdc.h"
48:                  #include "usb/src/usb_device_cdc_local.h"
49:                  #include "system/debug/sys_debug.h"
50:                  
51:                  
52:                  // *****************************************************************************
53:                  // *****************************************************************************
54:                  // Section: File Scope or Global Data Types
55:                  // *****************************************************************************
56:                  // *****************************************************************************
57:                  
58:                  // *****************************************************************************
59:                  /* CDC Device function driver structure
60:                  
61:                    Summary:
62:                      Defines the function driver structure required for the device layer.
63:                  
64:                    Description:
65:                      This data type defines the function driver structure required for the
66:                      device layer.
67:                  
68:                    Remarks:
69:                      This structure is private to the USB stack.
70:                  */
71:                  
72:                  const USB_DEVICE_FUNCTION_DRIVER cdcFunctionDriver =
73:                  {
74:                  
75:                      /* CDC init function */
76:                      .initializeByDescriptor         = _USB_DEVICE_CDC_Initialization ,
77:                  
78:                      /* CDC de-init function */
79:                      .deInitialize                   = _USB_DEVICE_CDC_Deinitialization ,
80:                  
81:                      /* EP0 activity callback */
82:                      .controlTransferNotification    = _USB_DEVICE_CDC_ControlTransferHandler,
83:                  
84:                      /* CDC tasks function */
85:                      .tasks                          = NULL,
86:                  
87:                      /* CDC Global Initialize */
88:                      .globalInitialize = _USB_DEVICE_CDC_GlobalInitialize
89:                  };
90:                  
91:                  // *****************************************************************************
92:                  /* CDC Device IRPs
93:                  
94:                    Summary:
95:                      Array of CDC Device IRP. 
96:                  
97:                    Description:
98:                      Array of CDC Device IRP. This array of IRP will be shared by read, write and
99:                      notification data requests.
100:                 
101:                   Remarks:
102:                     This array is private to the USB stack.
103:                 */
104:                 
105:                 USB_DEVICE_IRP gUSBDeviceCDCIRP[USB_DEVICE_CDC_QUEUE_DEPTH_COMBINED];
106:                 
107:                 
108:                 /* Create a variable for holding CDC IRP mutex Handle and status */
109:                 USB_DEVICE_CDC_COMMON_DATA_OBJ gUSBDeviceCdcCommonDataObj;
110:                  
111:                 
112:                 // *****************************************************************************
113:                 /* CDC Instance structure
114:                 
115:                   Summary:
116:                     Defines the CDC instance(s).
117:                 
118:                   Description:
119:                     This data type defines the CDC instance(s). The number of instances is
120:                     defined by the application using USB_DEVICE_CDC_INSTANCES_NUMBER.
121:                 
122:                   Remarks:
123:                     This structure is private to the CDC.
124:                 */
125:                 
126:                 USB_DEVICE_CDC_INSTANCE gUSBDeviceCDCInstance[USB_DEVICE_CDC_INSTANCES_NUMBER];
127:                 
128:                 // *****************************************************************************
129:                 // *****************************************************************************
130:                 // Section: File Scope Functions
131:                 // *****************************************************************************
132:                 // *****************************************************************************
133:                 // ******************************************************************************
134:                 /* Function:
135:                     void _USB_DEVICE_CDC_GlobalInitialize ( void )
136:                 
137:                   Summary:
138:                     This function initializes resourses required common to all instances of CDC
139:                     function driver.
140:                 
141:                   Description:
142:                     This function initializes resourses common to all instances of CDC function
143:                     driver. This function is called by the USB Device layer during Initalization.
144:                 
145:                   Remarks:
146:                     This is local function and should not be called directly by the application.
147:                 */
148:                 void _USB_DEVICE_CDC_GlobalInitialize (void)
149:                 {
9D014B10  27BDFFE8   ADDIU SP, SP, -24
9D014B14  AFBF0014   SW RA, 20(SP)
150:                     OSAL_RESULT osal_err;
151:                     
152:                     /* Create Mutex for CDC IRP objects if not created already */
153:                     if (gUSBDeviceCdcCommonDataObj.isMutexCdcIrpInitialized == false)
9D014B18  9382815C   LBU V0, -32420(GP)
9D014B1C  14400009   BNE V0, ZERO, 0x9D014B44
9D014B20  8FBF0014   LW RA, 20(SP)
154:                     {
155:                         /* This means that mutexes where not created. Create them. */
156:                         osal_err = OSAL_MUTEX_Create(&gUSBDeviceCdcCommonDataObj.mutexCDCIRP);
9D014B24  0F4052B5   JAL OSAL_MUTEX_Create
9D014B28  27848160   ADDIU A0, GP, -32416
157:                 
158:                         if(osal_err != OSAL_RESULT_TRUE)
9D014B2C  24030001   ADDIU V1, ZERO, 1
9D014B30  14430004   BNE V0, V1, 0x9D014B44
9D014B34  8FBF0014   LW RA, 20(SP)
159:                         {
160:                             /*do not proceed lock was not created, let user know about error*/
161:                             return;
162:                         }
163:                 
164:                          /* Set this flag so that global mutexes get allocated only once */
165:                          gUSBDeviceCdcCommonDataObj.isMutexCdcIrpInitialized = true;
9D014B38  24020001   ADDIU V0, ZERO, 1
9D014B3C  A382815C   SB V0, -32420(GP)
166:                     }
167:                 }
9D014B40  8FBF0014   LW RA, 20(SP)
9D014B44  03E00008   JR RA
9D014B48  27BD0018   ADDIU SP, SP, 24
168:                 // ******************************************************************************
169:                 /* Function:
170:                     void _USB_DEVICE_CDC_Initialization 
171:                     ( 
172:                         SYS_MODULE_INDEX iCDC ,
173:                         DRV_HANDLE deviceHandle ,
174:                         void* initData ,
175:                         uint8_t infNum ,
176:                         uint8_t altSetting ,
177:                         uint8_t descType ,
178:                         uint8_t * pDesc 
179:                     )
180:                 
181:                   Summary:
182:                     USB Device CDC function called by the device layer during Set Configuration
183:                     processing.
184:                   
185:                   Description:
186:                     USB Device CDC function called by the device layer during Set Configuration
187:                     processing.
188:                 
189:                   Remarks:
190:                     This is local function and should not be called directly by the application.
191:                 */
192:                 
193:                 void _USB_DEVICE_CDC_Initialization 
194:                 ( 
195:                     SYS_MODULE_INDEX iCDC ,
196:                     USB_DEVICE_HANDLE deviceHandle ,
197:                     void* initData ,
198:                     uint8_t infNum ,
199:                     uint8_t altSetting ,
200:                     uint8_t descType ,
201:                     uint8_t * pDesc 
202:                 )
203:                 {
9D00DA98  27BDFFE8   ADDIU SP, SP, -24
9D00DA9C  AFBF0014   SW RA, 20(SP)
9D00DAA0  AFB00010   SW S0, 16(SP)
9D00DAA4  93A8002C   LBU T0, 44(SP)
204:                     /* Avoid unused warning */
205:                     ( void ) ( altSetting );
206:                     ( void ) ( initData );
207:                     uint8_t epAddress;
208:                     uint8_t epDir;
209:                     uint16_t maxPacketSize;
210:                     USB_DEVICE_CDC_INSTANCE * thisCDCInstance;
211:                     USB_DEVICE_CDC_INIT * cdcInit;
212:                     USB_ENDPOINT_DESCRIPTOR *pEPDesc;
213:                     USB_INTERFACE_DESCRIPTOR *pInfDesc;
214:                     USB_DEVICE_CDC_ENDPOINT * deviceCDCEndpoint;
215:                 
216:                     /* Check the validity of the function driver index */
217:                     if (iCDC >= USB_DEVICE_CDC_INSTANCES_NUMBER)
9D00DAA8  1480004B   BNE A0, ZERO, 0x9D00DBD8
9D00DAAC  8FA30030   LW V1, 48(SP)
218:                     {
219:                         /* Assert on invalid CDC index */
220:                         SYS_DEBUG(0, "USB Device CDC: Invalid index");
221:                         return;
222:                     }
223:                 
224:                     thisCDCInstance = &gUSBDeviceCDCInstance[iCDC];
225:                 
226:                 
227:                     /* Initialize the queue sizes. This code may run several times
228:                      * but then we dont expect the queue sizes to change.*/
229:                 
230:                     cdcInit = ((USB_DEVICE_CDC_INIT *)initData);
231:                     thisCDCInstance->queueSizeWrite = cdcInit->queueSizeWrite;
9D00DAB0  8CC40004   LW A0, 4(A2)
9D00DAB4  3C02A000   LUI V0, -24576
9D00DAB8  24420DB0   ADDIU V0, V0, 3504
9D00DABC  AC440028   SW A0, 40(V0)
232:                     thisCDCInstance->queueSizeRead = cdcInit->queueSizeRead;
9D00DAC0  8CC40000   LW A0, 0(A2)
9D00DAC4  AC44002C   SW A0, 44(V0)
233:                     thisCDCInstance->queueSizeSerialStateNotification = 
9D00DACC  AC440030   SW A0, 48(V0)
234:                     cdcInit->queueSizeSerialStateNotification;
9D00DAC8  8CC40008   LW A0, 8(A2)
235:                     thisCDCInstance->currentQSizeWrite = 0;
9D00DAD0  AC400034   SW ZERO, 52(V0)
236:                     thisCDCInstance->currentQSizeRead = 0;
9D00DAD4  AC400038   SW ZERO, 56(V0)
237:                     thisCDCInstance->currentQSizeSerialStateNotification = 0;
9D00DAD8  AC40003C   SW ZERO, 60(V0)
238:                 
239:                     
240:                     /* check the type of descriptor passed by device layer */
241:                     switch ( descType )
9D00DADC  24020004   ADDIU V0, ZERO, 4
9D00DAE0  11020005   BEQ T0, V0, 0x9D00DAF8
9D00DAE4  24020005   ADDIU V0, ZERO, 5
9D00DAE8  51020015   BEQL T0, V0, 0x9D00DB40
9D00DAEC  90620002   LBU V0, 2(V1)
242:                     {
243:                         /* Interface descriptor passed */
244:                         case USB_DESCRIPTOR_INTERFACE:
245:                             {
246:                                 pInfDesc = ( USB_INTERFACE_DESCRIPTOR * )pDesc;
247:                 
248:                                 /* Preserve the device layer handle */
249:                                 thisCDCInstance->deviceHandle = deviceHandle;
9D00DAF8  3C02A000   LUI V0, -24576
9D00DAFC  AC450DB0   SW A1, 3504(V0)
250:                 
251:                                 /* check if this is notification(communication) interface */
252:                                 if ( ( pInfDesc->bInterfaceClass == USB_CDC_COMMUNICATIONS_INTERFACE_CLASS_CODE ) &&
9D00DB00  90620005   LBU V0, 5(V1)
9D00DB04  24040002   ADDIU A0, ZERO, 2
9D00DB08  54440008   BNEL V0, A0, 0x9D00DB2C
9D00DB0C  2403000A   ADDIU V1, ZERO, 10
9D00DB10  90630006   LBU V1, 6(V1)
9D00DB14  24020002   ADDIU V0, ZERO, 2
9D00DB18  14620030   BNE V1, V0, 0x9D00DBDC
9D00DB1C  8FBF0014   LW RA, 20(SP)
253:                                         ( pInfDesc->bInterfaceSubClass == USB_CDC_SUBCLASS_ABSTRACT_CONTROL_MODEL ) )
254:                                 {
255:                                     /* Save the notification interface number */
256:                                     thisCDCInstance->notificationInterface.interfaceNum = infNum;
9D00DB20  3C02A000   LUI V0, -24576
9D00DB24  0B4036F6   J 0x9D00DBD8
9D00DB28  A0470DC2   SB A3, 3522(V0)
257:                                 }
258:                 
259:                                 /* data interface */
260:                                 else if ( ( pInfDesc->bInterfaceClass == USB_CDC_DATA_INTERFACE_CLASS_CODE ) )
9D00DB2C  1443002B   BNE V0, V1, 0x9D00DBDC
9D00DB30  8FBF0014   LW RA, 20(SP)
261:                                 {
262:                                     /* save the data interface number */
263:                                     thisCDCInstance->dataInterface.interfaceNum = infNum;
9D00DB34  3C02A000   LUI V0, -24576
9D00DB38  0B4036F6   J 0x9D00DBD8
9D00DB3C  A0470DB4   SB A3, 3508(V0)
264:                                 }
265:                 
266:                                 else
267:                                 {
268:                                     /* Ignore anything else */
269:                                     SYS_DEBUG(0, "USB Device CDC: Invalid interface presented to CDC " );
270:                                 }
271:                 
272:                                 break;
273:                             }
274:                 
275:                             /* Endpoint descriptor passed */
276:                         case USB_DESCRIPTOR_ENDPOINT:
277:                             {
278:                                 pEPDesc = ( USB_ENDPOINT_DESCRIPTOR* ) pDesc;
279:                 
280:                                 /* Save the ep address */
281:                                 epAddress = pEPDesc->bEndpointAddress;
282:                 
283:                                 /* Get the direction */
284:                                 epDir = ( epAddress & 0x80 ) ? 
285:                                     ( USB_DEVICE_CDC_ENDPOINT_TX ) : ( USB_DEVICE_CDC_ENDPOINT_RX );
286:                 
287:                                 /* Save max packet size */
288:                                 maxPacketSize = ( ( USB_ENDPOINT_DESCRIPTOR* ) pDesc )->wMaxPacketSize;
9D00DB40  90640004   LBU A0, 4(V1)
9D00DB44  90670005   LBU A3, 5(V1)
9D00DB48  00073A00   SLL A3, A3, 8
9D00DB4C  00E43825   OR A3, A3, A0
289:                 
290:                                 if ( pEPDesc->transferType == USB_TRANSFER_TYPE_BULK )
9D00DB50  90640003   LBU A0, 3(V1)
9D00DB54  30840003   ANDI A0, A0, 3
9D00DB58  24080002   ADDIU T0, ZERO, 2
9D00DB5C  14880009   BNE A0, T0, 0x9D00DB84
9D00DB60  000231C2   SRL A2, V0, 7
291:                                 {
292:                                     /* This is a data interface endpoint */
293:                                     deviceCDCEndpoint = &thisCDCInstance->dataInterface.endpoint[epDir];
9D00DB64  00062040   SLL A0, A2, 1
9D00DB68  000630C0   SLL A2, A2, 3
9D00DB6C  00C43023   SUBU A2, A2, A0
9D00DB70  3C10A000   LUI S0, -24576
9D00DB74  26100DB0   ADDIU S0, S0, 3504
9D00DB78  02068021   ADDU S0, S0, A2
9D00DB7C  0B4036EB   J 0x9D00DBAC
9D00DB80  26100006   ADDIU S0, S0, 6
294:                                 }
295:                                 else if( pEPDesc->transferType == USB_TRANSFER_TYPE_INTERRUPT)
9D00DB84  24080003   ADDIU T0, ZERO, 3
9D00DB88  14880014   BNE A0, T0, 0x9D00DBDC
9D00DB8C  8FBF0014   LW RA, 20(SP)
296:                                 {
297:                                     /* This is notification endpoint */
298:                                     deviceCDCEndpoint = &thisCDCInstance->notificationInterface.endpoint[epDir];
9D00DB90  00062040   SLL A0, A2, 1
9D00DB94  000630C0   SLL A2, A2, 3
9D00DB98  00C43023   SUBU A2, A2, A0
9D00DB9C  3C10A000   LUI S0, -24576
9D00DBA0  26100DB0   ADDIU S0, S0, 3504
9D00DBA4  02068021   ADDU S0, S0, A2
9D00DBA8  26100014   ADDIU S0, S0, 20
299:                                 }
300:                                 else
301:                                 {
302:                                     /* We cannot support ny other type of endpoint for now */
303:                                     SYS_DEBUG(0, "USB Device CDC: Cannot handle this endpoint type" );
304:                                     break;
305:                                 }
306:                 
307:                                 /* Save ep address to the data interface */
308:                                 deviceCDCEndpoint->address = epAddress;
9D00DBAC  A2020000   SB V0, 0(S0)
309:                 
310:                                 /* Save max packet size to the data interface */
311:                                 deviceCDCEndpoint->maxPacketSize = maxPacketSize;
9D00DBB0  A6070002   SH A3, 2(S0)
312:                 
313:                                 /* Enable the endpoint */
314:                                 USB_DEVICE_EndpointEnable ( deviceHandle ,
9D00DBB4  8CA400EC   LW A0, 236(A1)
9D00DBB8  90660003   LBU A2, 3(V1)
9D00DBBC  8C830020   LW V1, 32(A0)
9D00DBC0  8CA40018   LW A0, 24(A1)
9D00DBC4  00402821   ADDU A1, V0, ZERO
9D00DBC8  0060F809   JALR V1
9D00DBCC  30C60003   ANDI A2, A2, 3
315:                                         0,
316:                                         epAddress ,
317:                                         pEPDesc->transferType ,
318:                                         maxPacketSize );
319:                 
320:                                 /* Indicate that the endpoint is configured */
321:                                 deviceCDCEndpoint->isConfigured = true;
9D00DBD0  24020001   ADDIU V0, ZERO, 1
9D00DBD4  A2020004   SB V0, 4(S0)
322:                 
323:                                 break;
324:                             }
325:                 
326:                         case USB_CDC_DESC_CS_INTERFACE:
327:                             {
328:                                 break;
329:                             }
330:                 
331:                         default:
332:                             /* Unsupported descriptor type */
333:                             break;
334:                     }
335:                 }
9D00DAF0  0B4036F7   J 0x9D00DBDC
9D00DAF4  8FBF0014   LW RA, 20(SP)
9D00DBD8  8FBF0014   LW RA, 20(SP)
9D00DBDC  8FB00010   LW S0, 16(SP)
9D00DBE0  03E00008   JR RA
9D00DBE4  27BD0018   ADDIU SP, SP, 24
336:                 
337:                 // ******************************************************************************
338:                 /* Function:
339:                     void _USB_DEVICE_CDC_EndpointDisable
340:                     (
341:                         USB_DEVICE_HANDLE deviceHandle, 
342:                         USB_DEVICE_CDC_ENDPOINT * deviceCDCEndpoint
343:                     )
344:                 
345:                   Summary:
346:                     Disabled USB Device CDC endpoints.
347:                   
348:                   Description:
349:                     Disabled USB Device CDC endpoints.
350:                 
351:                   Remarks:
352:                     This is local function and should not be called directly by the application.
353:                 */
354:                 
355:                 void _USB_DEVICE_CDC_EndpointDisable
356:                 (
357:                     USB_DEVICE_HANDLE deviceHandle, 
358:                     USB_DEVICE_CDC_ENDPOINT * deviceCDCEndpoint
359:                 )
360:                 {
9D0139E0  27BDFFE0   ADDIU SP, SP, -32
9D0139E4  AFBF001C   SW RA, 28(SP)
9D0139E8  AFB10018   SW S1, 24(SP)
9D0139EC  AFB00014   SW S0, 20(SP)
361:                     if(deviceCDCEndpoint->isConfigured)
9D0139F0  90A20004   LBU V0, 4(A1)
9D0139F4  1040000D   BEQ V0, ZERO, 0x9D013A2C
9D0139F8  00A08021   ADDU S0, A1, ZERO
9D0139FC  00808821   ADDU S1, A0, ZERO
362:                     {
363:                         USB_DEVICE_IRPCancelAll(deviceHandle, deviceCDCEndpoint->address);
9D013A00  8C8200EC   LW V0, 236(A0)
9D013A04  8C420040   LW V0, 64(V0)
9D013A08  8C840018   LW A0, 24(A0)
9D013A0C  0040F809   JALR V0
9D013A10  90A50000   LBU A1, 0(A1)
364:                         USB_DEVICE_EndpointDisable(deviceHandle, deviceCDCEndpoint->address);
9D013A14  8E2200EC   LW V0, 236(S1)
9D013A18  8C420024   LW V0, 36(V0)
9D013A1C  8E240018   LW A0, 24(S1)
9D013A20  0040F809   JALR V0
9D013A24  92050000   LBU A1, 0(S0)
365:                         deviceCDCEndpoint->isConfigured = false;
9D013A28  A2000004   SB ZERO, 4(S0)
366:                     }
367:                 }
9D013A2C  8FBF001C   LW RA, 28(SP)
9D013A30  8FB10018   LW S1, 24(SP)
9D013A34  8FB00014   LW S0, 20(SP)
9D013A38  03E00008   JR RA
9D013A3C  27BD0020   ADDIU SP, SP, 32
368:                 
369:                 // ******************************************************************************
370:                 /* Function:
371:                     void _USB_DEVICE_CDC_Deinitialization ( SYS_MODULE_INDEX iCDC )
372:                  
373:                   Summary:
374:                     Deinitializes the function driver instance.
375:                   
376:                   Description:
377:                     Deinitializes the function driver instance.
378:                 
379:                   Remarks:
380:                     This is local function and should not be called directly by the application.
381:                 */
382:                 
383:                 void _USB_DEVICE_CDC_Deinitialization ( SYS_MODULE_INDEX iCDC )
384:                 {
9D01356C  27BDFFE8   ADDIU SP, SP, -24
9D013570  AFBF0014   SW RA, 20(SP)
9D013574  AFB00010   SW S0, 16(SP)
385:                     /* Cancel all IRPs on the owned endpoints and then 
386:                      * disable the endpoint */
387:                 
388:                     USB_DEVICE_HANDLE deviceHandle;
389:                     USB_DEVICE_CDC_ENDPOINT * deviceCDCEndpoint;
390:                 
391:                     if(iCDC >= USB_DEVICE_CDC_INSTANCES_NUMBER)
9D013564  14800018   BNE A0, ZERO, 0x9D0135C8
9D013568  3C02A000   LUI V0, -24576
392:                     {
393:                         SYS_DEBUG(0, "USB Device CDC: Invalid instance");
394:                         return;
395:                     } 
396:                 
397:                     deviceHandle = gUSBDeviceCDCInstance[iCDC].deviceHandle;
9D013578  8C500DB0   LW S0, 3504(V0)
398:                 
399:                     deviceCDCEndpoint = &gUSBDeviceCDCInstance[iCDC].dataInterface.endpoint[0];
400:                     _USB_DEVICE_CDC_EndpointDisable(deviceHandle, deviceCDCEndpoint);
9D01357C  02002021   ADDU A0, S0, ZERO
9D013580  3C05A000   LUI A1, -24576
9D013584  0F404E78   JAL _USB_DEVICE_CDC_EndpointDisable
9D013588  24A50DB6   ADDIU A1, A1, 3510
401:                     
402:                     deviceCDCEndpoint = &gUSBDeviceCDCInstance[iCDC].dataInterface.endpoint[1];
403:                     _USB_DEVICE_CDC_EndpointDisable(deviceHandle, deviceCDCEndpoint);
9D01358C  02002021   ADDU A0, S0, ZERO
9D013590  3C05A000   LUI A1, -24576
9D013594  0F404E78   JAL _USB_DEVICE_CDC_EndpointDisable
9D013598  24A50DBC   ADDIU A1, A1, 3516
404:                     
405:                     deviceCDCEndpoint = &gUSBDeviceCDCInstance[iCDC].notificationInterface.endpoint[0];
406:                     _USB_DEVICE_CDC_EndpointDisable(deviceHandle, deviceCDCEndpoint);
9D01359C  02002021   ADDU A0, S0, ZERO
9D0135A0  3C05A000   LUI A1, -24576
9D0135A4  0F404E78   JAL _USB_DEVICE_CDC_EndpointDisable
9D0135A8  24A50DC4   ADDIU A1, A1, 3524
407:                     
408:                     deviceCDCEndpoint = &gUSBDeviceCDCInstance[iCDC].notificationInterface.endpoint[1];
409:                     _USB_DEVICE_CDC_EndpointDisable(deviceHandle, deviceCDCEndpoint);
9D0135AC  02002021   ADDU A0, S0, ZERO
9D0135B0  3C05A000   LUI A1, -24576
9D0135B4  0F404E78   JAL _USB_DEVICE_CDC_EndpointDisable
9D0135B8  24A50DCA   ADDIU A1, A1, 3530
410:                 
411:                 }
9D0135BC  8FBF0014   LW RA, 20(SP)
9D0135C0  8FB00010   LW S0, 16(SP)
9D0135C4  27BD0018   ADDIU SP, SP, 24
9D0135C8  03E00008   JR RA
9D0135CC  00000000   NOP
412:                 
413:                 // ******************************************************************************
414:                 /* Function:
415:                     void _USB_DEVICE_CDC_ControlTransferHandler 
416:                     (
417:                         USB_DEVICE_CONTROL_TRANSFER_HANDLE controlTransferHandle ,
418:                         SYS_MODULE_INDEX iCDC ,
419:                         USB_DEVICE_EVENT controlTransferEvent,
420:                         void * controlTransferEventData
421:                     )
422:                  
423:                   Summary:
424:                     Control Transfer Handler for class specific control transfer.
425:                   
426:                   Description:
427:                     This is theControl Transfer Handler for class specific control transfer. The
428:                     device layer calls this functions for control transfer that are targetted to
429:                     an interface or endpoint that is owned by this function driver.
430:                 
431:                   Remarks:
432:                     This is local function and should not be called directly by the application.
433:                 */
434:                 
435:                 void _USB_DEVICE_CDC_ControlTransferHandler 
436:                 (
437:                     SYS_MODULE_INDEX iCDC ,
438:                     USB_DEVICE_EVENT controlTransferEvent,
439:                     USB_SETUP_PACKET * setupRequest
440:                 )
441:                 {
9D00FDFC  27BDFFE8   ADDIU SP, SP, -24
442:                     USB_DEVICE_HANDLE deviceHandle;
443:                     USB_DEVICE_CDC_INSTANCE * thisCDCDevice;
444:                     
445:                     /* Check the validity of the function driver index */
446:                     if (iCDC >= USB_DEVICE_CDC_INSTANCES_NUMBER)
9D00FE00  14800039   BNE A0, ZERO, 0x9D00FEE8
9D00FE04  AFBF0014   SW RA, 20(SP)
447:                     {
448:                         /* invalid CDC index */
449:                         SYS_DEBUG(0, "USB Device CDC: Invalid CDC index" );
450:                         return;
451:                     }
452:                 
453:                     /* Get a local reference */
454:                     thisCDCDevice = &gUSBDeviceCDCInstance[iCDC];
455:                 
456:                     /* Get the Device Layer handle */
457:                     deviceHandle = thisCDCDevice->deviceHandle;
9D00FE08  3C02A000   LUI V0, -24576
9D00FE0C  8C440DB0   LW A0, 3504(V0)
458:                 
459:                     switch (controlTransferEvent)
9D00FE10  2402000E   ADDIU V0, ZERO, 14
9D00FE14  10A20007   BEQ A1, V0, 0x9D00FE34
9D00FE18  2402000F   ADDIU V0, ZERO, 15
9D00FE1C  10A20029   BEQ A1, V0, 0x9D00FEC4
9D00FE20  2402000D   ADDIU V0, ZERO, 13
9D00FE24  14A20031   BNE A1, V0, 0x9D00FEEC
9D00FE28  8FBF0014   LW RA, 20(SP)
460:                     {
461:                         /* Setup packet received */
462:                 
463:                         case USB_DEVICE_EVENT_CONTROL_TRANSFER_SETUP_REQUEST:
464:                 
465:                             /* This means we have a setup packet for this interface */
466:                             
467:                             if(!(setupRequest->bmRequestType & USB_CDC_REQUEST_CLASS_SPECIFIC))
9D00FE34  90C20000   LBU V0, 0(A2)
9D00FE38  30420020   ANDI V0, V0, 32
9D00FE3C  304200FF   ANDI V0, V0, 255
9D00FE40  54400005   BNEL V0, ZERO, 0x9D00FE58
9D00FE44  90C20001   LBU V0, 1(A2)
468:                             {
469:                                 /* This means this is not a class specific request.
470:                                  * We stall this request */
471:                 
472:                                 USB_DEVICE_ControlStatus(deviceHandle, USB_DEVICE_CONTROL_STATUS_ERROR);
9D00FE48  0F404BC3   JAL USB_DEVICE_ControlStatus
9D00FE4C  24050001   ADDIU A1, ZERO, 1
9D00FE50  0B403FBB   J 0x9D00FEEC
9D00FE54  8FBF0014   LW RA, 20(SP)
473:                             }
474:                             else
475:                             {
476:                                 /* Check if the requests belong to the ACM sub class */
477:                                 switch(setupRequest->bRequest)
9D00FE58  2C430002   SLTIU V1, V0, 2
9D00FE5C  14600005   BNE V1, ZERO, 0x9D00FE74
9D00FE60  2442FFE0   ADDIU V0, V0, -32
9D00FE64  24030003   ADDIU V1, ZERO, 3
9D00FE68  0062102B   SLTU V0, V1, V0
9D00FE6C  14400007   BNE V0, ZERO, 0x9D00FE8C
9D00FE70  00000000   NOP
478:                                 {
479:                                     case USB_CDC_REQUEST_SET_LINE_CODING:
480:                                     case USB_CDC_REQUEST_GET_LINE_CODING:
481:                                     case USB_CDC_REQUEST_SET_CONTROL_LINE_STATE:
482:                                     case USB_CDC_REQUEST_SEND_BREAK:
483:                                     case USB_CDC_REQUEST_SEND_ENCAPSULATED_COMMAND:
484:                                     case USB_CDC_REQUEST_GET_ENCAPSULATED_RESPONSE:
485:                 
486:                                         /* These are ACM requests */
487:                 
488:                                         _USB_DEVICE_CDC_ACMSetUpPacketHandler(iCDC, thisCDCDevice, 
9D00FE74  00002021   ADDU A0, ZERO, ZERO
9D00FE78  3C05A000   LUI A1, -24576
9D00FE7C  0F403218   JAL _USB_DEVICE_CDC_ACMSetUpPacketHandler
9D00FE80  24A50DB0   ADDIU A1, A1, 3504
489:                                                 setupRequest);
490:                 
491:                                         break;
9D00FE84  0B403FBB   J 0x9D00FEEC
9D00FE88  8FBF0014   LW RA, 20(SP)
492:                                     default:
493:                                         /* This is an un-supported request */
494:                                         USB_DEVICE_ControlStatus(deviceHandle, USB_DEVICE_CONTROL_STATUS_ERROR);
9D00FE8C  0F404BC3   JAL USB_DEVICE_ControlStatus
9D00FE90  24050001   ADDIU A1, ZERO, 1
495:                                         break;
9D00FE94  0B403FBB   J 0x9D00FEEC
9D00FE98  8FBF0014   LW RA, 20(SP)
496:                                 }
497:                             }
498:                 
499:                             break;
500:                 
501:                         case USB_DEVICE_EVENT_CONTROL_TRANSFER_DATA_RECEIVED:
502:                 
503:                             /* A control transfer data stage is complete. Send
504:                              * this event to application */
505:                 
506:                             if(thisCDCDevice->appEventCallBack != NULL)
9D00FE2C  0B403FA7   J 0x9D00FE9C
9D00FE30  3C02A000   LUI V0, -24576
9D00FE9C  8C420DD0   LW V0, 3536(V0)
9D00FEA0  10400011   BEQ V0, ZERO, 0x9D00FEE8
9D00FEA4  00002021   ADDU A0, ZERO, ZERO
507:                             {
508:                                 thisCDCDevice->appEventCallBack(iCDC, 
9D00FEA8  24050008   ADDIU A1, ZERO, 8
9D00FEAC  00003021   ADDU A2, ZERO, ZERO
9D00FEB0  3C03A000   LUI V1, -24576
9D00FEB4  0040F809   JALR V0
9D00FEB8  8C670DD4   LW A3, 3540(V1)
509:                                         USB_DEVICE_CDC_EVENT_CONTROL_TRANSFER_DATA_RECEIVED,
510:                                         NULL, thisCDCDevice->userData );
511:                             }
512:                 
513:                             break;
514:                 
515:                         case USB_DEVICE_EVENT_CONTROL_TRANSFER_DATA_SENT:
516:                 
517:                             /* A control transfer data stage is complete. Send
518:                              * this event to application */
519:                 
520:                             if(thisCDCDevice->appEventCallBack != NULL)
9D00FEC4  3C02A000   LUI V0, -24576
9D00FEC8  8C420DD0   LW V0, 3536(V0)
9D00FECC  10400006   BEQ V0, ZERO, 0x9D00FEE8
9D00FED0  00002021   ADDU A0, ZERO, ZERO
521:                             {
522:                                 thisCDCDevice->appEventCallBack(iCDC, 
9D00FED4  24050007   ADDIU A1, ZERO, 7
9D00FED8  00003021   ADDU A2, ZERO, ZERO
9D00FEDC  3C03A000   LUI V1, -24576
9D00FEE0  0040F809   JALR V0
9D00FEE4  8C670DD4   LW A3, 3540(V1)
523:                                         USB_DEVICE_CDC_EVENT_CONTROL_TRANSFER_DATA_SENT,
524:                                         NULL, thisCDCDevice->userData );
525:                             }
526:                 
527:                         default:
528:                             break;
529:                     }
530:                 }
9D00FEBC  0B403FBB   J 0x9D00FEEC
9D00FEC0  8FBF0014   LW RA, 20(SP)
9D00FEE8  8FBF0014   LW RA, 20(SP)
9D00FEEC  03E00008   JR RA
9D00FEF0  27BD0018   ADDIU SP, SP, 24
531:                 
532:                 // ******************************************************************************
533:                 /* Function:
534:                     void _USB_DEVICE_CDC_SerialStateSendIRPCallback (USB_DEVICE_IRP * irp )
535:                  
536:                   Summary:
537:                     IRP call back for Serial State Send IRPs.
538:                   
539:                   Description:
540:                     This is IRP call back for IRPs submitted through the
541:                     USB_DEVICE_CDC_SerialStateSend() function.
542:                 
543:                   Remarks:
544:                     This is local function and should not be called directly by the application.
545:                 */
546:                 
547:                 void _USB_DEVICE_CDC_SerialStateSendIRPCallback (USB_DEVICE_IRP * irp )
548:                 {
549:                     USB_DEVICE_CDC_INSTANCE * thisCDCDevice;
550:                 
551:                     /* This function is called when a CDC Write IRP has
552:                      * terminated */
553:                     
554:                     USB_DEVICE_CDC_EVENT_DATA_SERIAL_STATE_NOTIFICATION_COMPLETE serialStateEventData;
555:                 
556:                     /* The user data field of the IRP contains the CDC instance
557:                      * that submitted this IRP */
558:                     thisCDCDevice = &gUSBDeviceCDCInstance[irp->userData];
559:                 
560:                     /* populate the event handler for this transfer */
561:                     serialStateEventData.handle = ( USB_DEVICE_CDC_TRANSFER_HANDLE ) irp;
562:                 
563:                     /* update the size written */
564:                     serialStateEventData.length = irp->size;
565:                     
566:                     /* Get transfer status */
567:                     if ((irp->status == USB_DEVICE_IRP_STATUS_COMPLETED) 
568:                         || (irp->status == USB_DEVICE_IRP_STATUS_COMPLETED_SHORT))
569:                     {
570:                         /* Transfer completed successfully */
571:                         serialStateEventData.status = USB_DEVICE_CDC_RESULT_OK; 
572:                     }
573:                     else if (irp->status == USB_DEVICE_IRP_STATUS_ABORTED_ENDPOINT_HALT)
574:                     {
575:                         /* Transfer cancelled due to Endpoint Halt */
576:                         serialStateEventData.status = USB_DEVICE_CDC_RESULT_ERROR_ENDPOINT_HALTED; 
577:                     }
578:                     else if (irp->status == USB_DEVICE_IRP_STATUS_TERMINATED_BY_HOST)
579:                     {
580:                         /* Transfer Cancelled by Host (Host sent a Clear feature )*/
581:                         serialStateEventData.status = USB_DEVICE_CDC_RESULT_ERROR_TERMINATED_BY_HOST; 
582:                     }
583:                     else
584:                     {
585:                         /* Transfer was not completed successfully */
586:                         serialStateEventData.status = USB_DEVICE_CDC_RESULT_ERROR; 
587:                     }
588:                 
589:                     /* Reduce the queue size */
590:                 
591:                     thisCDCDevice->currentQSizeSerialStateNotification --;
592:                 
593:                     /* valid application event handler present? */
594:                     if ( thisCDCDevice->appEventCallBack )
595:                     {
596:                         /* inform the application */
597:                         thisCDCDevice->appEventCallBack ( (USB_DEVICE_CDC_INDEX)(irp->userData) , 
598:                                    USB_DEVICE_CDC_EVENT_SERIAL_STATE_NOTIFICATION_COMPLETE ,
599:                                    &serialStateEventData, thisCDCDevice->userData);
600:                     }
601:                 
602:                 }
603:                 
604:                 // ******************************************************************************
605:                 /* Function:
606:                     void _USB_DEVICE_CDC_ReadIRPCallback (USB_DEVICE_IRP * irp )
607:                  
608:                   Summary:
609:                     IRP call back for Data Read IRPs.
610:                   
611:                   Description:
612:                     This is IRP call back for IRPs submitted through the USB_DEVICE_CDC_Read()
613:                     function.
614:                 
615:                   Remarks:
616:                     This is local function and should not be called directly by the application.
617:                 */
618:                 
619:                 void _USB_DEVICE_CDC_ReadIRPCallback (USB_DEVICE_IRP * irp )
620:                 {
621:                     USB_DEVICE_CDC_INSTANCE * thisCDCDevice;
622:                 
623:                     /* This function is called when a CDC Write IRP has
624:                      * terminated */
625:                     
626:                     USB_DEVICE_CDC_EVENT_DATA_READ_COMPLETE readEventData;
627:                 
628:                     /* The user data field of the IRP contains the CDC instance
629:                      * that submitted this IRP */
630:                     thisCDCDevice = &gUSBDeviceCDCInstance[irp->userData];
631:                 
632:                     /* populate the event handler for this transfer */
633:                     readEventData.handle = ( USB_DEVICE_CDC_TRANSFER_HANDLE ) irp;
634:                 
635:                     /* update the size written */
636:                     readEventData.length = irp->size;
637:                     
638:                     /* Get transfer status */
639:                     if ((irp->status == USB_DEVICE_IRP_STATUS_COMPLETED) 
640:                         || (irp->status == USB_DEVICE_IRP_STATUS_COMPLETED_SHORT))
641:                     {
642:                         /* Transfer completed successfully */
643:                         readEventData.status = USB_DEVICE_CDC_RESULT_OK; 
644:                     }
645:                     else if (irp->status == USB_DEVICE_IRP_STATUS_ABORTED_ENDPOINT_HALT)
646:                     {
647:                         /* Transfer cancelled due to Endpoint Halt */
648:                         readEventData.status = USB_DEVICE_CDC_RESULT_ERROR_ENDPOINT_HALTED; 
649:                     }
650:                     else if (irp->status == USB_DEVICE_IRP_STATUS_TERMINATED_BY_HOST)
651:                     {
652:                         /* Transfer Cancelled by Host (Host sent a Clear feature )*/
653:                         readEventData.status = USB_DEVICE_CDC_RESULT_ERROR_TERMINATED_BY_HOST; 
654:                     }
655:                     else
656:                     {
657:                         /* Transfer was not completed successfully */
658:                         readEventData.status = USB_DEVICE_CDC_RESULT_ERROR; 
659:                     }
660:                 
661:                     /* update the queue size */
662:                     thisCDCDevice->currentQSizeRead --;
663:                 
664:                     /* valid application event handler present? */
665:                     if ( thisCDCDevice->appEventCallBack )
666:                     {
667:                         /* inform the application */
668:                         thisCDCDevice->appEventCallBack ( (USB_DEVICE_CDC_INDEX)(irp->userData) , 
669:                                    USB_DEVICE_CDC_EVENT_READ_COMPLETE , 
670:                                    &readEventData, thisCDCDevice->userData);
671:                     }
672:                 
673:                 }
674:                 
675:                 // ******************************************************************************
676:                 /* Function:
677:                     void _USB_DEVICE_CDC_WriteIRPCallback (USB_DEVICE_IRP * irp )
678:                  
679:                   Summary:
680:                     IRP call back for Data Write IRPs.
681:                   
682:                   Description:
683:                     This is IRP call back for IRPs submitted through the USB_DEVICE_CDC_Write()
684:                     function.
685:                 
686:                   Remarks:
687:                     This is local function and should not be called directly by the application.
688:                 */
689:                 
690:                 void _USB_DEVICE_CDC_WriteIRPCallback (USB_DEVICE_IRP * irp )
691:                 {
692:                     USB_DEVICE_CDC_INSTANCE * thisCDCDevice;
693:                 
694:                     /* This function is called when a CDC Write IRP has
695:                      * terminated */
696:                     
697:                     USB_DEVICE_CDC_EVENT_DATA_WRITE_COMPLETE writeEventData;
698:                 
699:                     /* The user data field of the IRP contains the CDC instance
700:                      * that submitted this IRP */
701:                     thisCDCDevice = &gUSBDeviceCDCInstance[irp->userData];
702:                 
703:                     /* populate the event handler for this transfer */
704:                     writeEventData.handle = ( USB_DEVICE_CDC_TRANSFER_HANDLE ) irp;
705:                 
706:                     /* update the size written */
707:                     writeEventData.length = irp->size;
708:                     
709:                     /* Get transfer status */
710:                     if ((irp->status == USB_DEVICE_IRP_STATUS_COMPLETED) 
711:                         || (irp->status == USB_DEVICE_IRP_STATUS_COMPLETED_SHORT))
712:                     {
713:                         /* Transfer completed successfully */
714:                         writeEventData.status = USB_DEVICE_CDC_RESULT_OK; 
715:                     }
716:                     else if (irp->status == USB_DEVICE_IRP_STATUS_ABORTED_ENDPOINT_HALT)
717:                     {
718:                         /* Transfer cancelled due to Endpoint Halt */
719:                         writeEventData.status = USB_DEVICE_CDC_RESULT_ERROR_ENDPOINT_HALTED; 
720:                     }
721:                     else if (irp->status == USB_DEVICE_IRP_STATUS_TERMINATED_BY_HOST)
722:                     {
723:                         /* Transfer Cancelled by Host (Host sent a Clear feature )*/
724:                         writeEventData.status = USB_DEVICE_CDC_RESULT_ERROR_TERMINATED_BY_HOST; 
725:                     }
726:                     else
727:                     {
728:                         /* Transfer was not completed successfully */
729:                         writeEventData.status = USB_DEVICE_CDC_RESULT_ERROR; 
730:                     }
731:                 
732:                     /* Update the queue size*/
733:                     thisCDCDevice->currentQSizeWrite --;
734:                 
735:                     /* valid application event handler present? */
736:                     if ( thisCDCDevice->appEventCallBack )
737:                     {
738:                         /* inform the application */
739:                         thisCDCDevice->appEventCallBack ( (USB_DEVICE_CDC_INDEX)(irp->userData) , 
740:                                    USB_DEVICE_CDC_EVENT_WRITE_COMPLETE , 
741:                                    &writeEventData, thisCDCDevice->userData);
742:                     }
743:                 
744:                 }
745:                 
746:                 // *****************************************************************************
747:                 // *****************************************************************************
748:                 // Section: CDC Interface Function Definitions
749:                 // *****************************************************************************
750:                 // *****************************************************************************
751:                 
752:                 
753:                 // *****************************************************************************
754:                 /* Function:
755:                     USB_DEVICE_CDC_RESULT USB_DEVICE_CDC_Read 
756:                     (
757:                         USB_DEVICE_CDC_INDEX instance, 
758:                         USB_CDC_DEVICE_TRANSFER_HANDLE * transferHandle,
759:                         void * data, 
760:                         size_t size
761:                     );
762:                 
763:                   Summary:
764:                     This function requests a data read from the USB Device CDC Function Driver 
765:                     Layer.
766:                 
767:                   Description:
768:                     This function requests a data read from the USB Device CDC Function Driver
769:                     Layer. The function places a requests with driver, the request will get
770:                     serviced as data is made available by the USB Host. A handle to the request
771:                     is returned in the transferHandle parameter. The termination of the request
772:                     is indicated by the USB_DEVICE_CDC_EVENT_READ_COMPLETE event. The amount of
773:                     data read and the transfer handle associated with the request is returned
774:                     along with the event in the pData parameter of the event handler. The
775:                     transfer handle expires when event handler for the
776:                     USB_DEVICE_CDC_EVENT_READ_COMPLETE exits. If the read request could not be
777:                     accepted, the function returns an error code and transferHandle will contain
778:                     the value USB_DEVICE_CDC_TRANSFER_HANDLE_INVALID.
779:                 
780:                     If the size parameter is not a multiple of maxPacketSize or is 0, the
781:                     function returns USB_DEVICE_CDC_TRANSFER_HANDLE_INVALID in transferHandle
782:                     and returns an error code as a return value. If the size parameter is a
783:                     multiple of maxPacketSize and the host send less than maxPacketSize data in
784:                     any transaction, the transfer completes and the function driver will issue a
785:                     USB_DEVICE_CDC_EVENT_READ_COMPLETE event along with the
786:                     USB_DEVICE_CDC_EVENT_READ_COMPLETE_DATA data structure. If the size
787:                     parameter is a multiple of maxPacketSize and the host sends maxPacketSize
788:                     amount of data, and total data received does not exceed size, then the
789:                     function driver will wait for the next packet. 
790:                   
791:                   Remarks:
792:                     Refer to usb_device_cdc.h for usage information.
793:                 */   
794:                 
795:                 USB_DEVICE_CDC_RESULT USB_DEVICE_CDC_Read 
796:                 (
797:                     USB_DEVICE_CDC_INDEX iCDC ,
798:                     USB_DEVICE_CDC_TRANSFER_HANDLE * transferHandle ,
799:                     void * data , size_t size
800:                 )
801:                 {
802:                     unsigned int cnt;
803:                     unsigned int remainder;
804:                     USB_DEVICE_IRP * irp;
805:                     USB_DEVICE_CDC_ENDPOINT * endpoint;
806:                     USB_DEVICE_CDC_INSTANCE * thisCDCDevice;
807:                     OSAL_RESULT osalError;
808:                     USB_ERROR irpError;
809:                     OSAL_CRITSECT_DATA_TYPE IntState;
810:                 
811:                     /* Check the validity of the function driver index */
812:                     
813:                     if (  iCDC >= USB_DEVICE_CDC_INSTANCES_NUMBER  )
814:                     {
815:                         /* Invalid CDC index */
816:                         SYS_ASSERT(false, "Invalid CDC Device Index");
817:                         return USB_DEVICE_CDC_RESULT_ERROR_INSTANCE_INVALID;
818:                     }
819:                 
820:                     thisCDCDevice = &gUSBDeviceCDCInstance[iCDC];
821:                     endpoint = &thisCDCDevice->dataInterface.endpoint[USB_DEVICE_CDC_ENDPOINT_RX];
822:                     *transferHandle = USB_DEVICE_CDC_TRANSFER_HANDLE_INVALID;
823:                 
824:                     /* Check if the endpoint is configured */
825:                     if(!(endpoint->isConfigured))
826:                     {
827:                         /* This means that the endpoint is not configured yet */
828:                         SYS_ASSERT(false, "Endpoint not configured");
829:                         return (USB_DEVICE_CDC_RESULT_ERROR_INSTANCE_NOT_CONFIGURED);
830:                     }
831:                 
832:                     /* For read the size should be a multiple of endpoint size*/
833:                     remainder = size % endpoint->maxPacketSize;
834:                 
835:                     if((size == 0) || (remainder != 0))
836:                     {
837:                         /* Size is not valid */
838:                         SYS_ASSERT(false, "Invalid size in IRP read");
839:                         return(USB_DEVICE_CDC_RESULT_ERROR_TRANSFER_SIZE_INVALID);
840:                     }
841:                 
842:                     /* Make sure that we are with in the queue size for this instance */
843:                     if(thisCDCDevice->currentQSizeRead >= thisCDCDevice->queueSizeRead)
844:                     {
845:                         SYS_ASSERT(false, "Read Queue is full");
846:                         return(USB_DEVICE_CDC_RESULT_ERROR_TRANSFER_QUEUE_FULL);
847:                     }
848:                 
849:                     /*Obtain mutex to get access to a shared resource, check return value*/
850:                     osalError = OSAL_MUTEX_Lock(&gUSBDeviceCdcCommonDataObj.mutexCDCIRP, OSAL_WAIT_FOREVER);
851:                     if(osalError != OSAL_RESULT_TRUE)
852:                     {
853:                       /*Do not proceed lock was not obtained, or error occurred, let user know about error*/
854:                       return (USB_DEVICE_CDC_RESULT_ERROR);
855:                     }
856:                 
857:                     /* Loop and find a free IRP in the Q */
858:                     for ( cnt = 0; cnt < USB_DEVICE_CDC_QUEUE_DEPTH_COMBINED; cnt ++ )
859:                     {
860:                         if(gUSBDeviceCDCIRP[cnt].status <
861:                                 (USB_DEVICE_IRP_STATUS)USB_DEVICE_IRP_FLAG_DATA_PENDING)
862:                         {
863:                             /* This means the IRP is free. Configure the IRP
864:                              * update the current queue size and then submit */
865:                 
866:                             irp = &gUSBDeviceCDCIRP[cnt];
867:                             irp->data = data;
868:                             irp->size = size;
869:                             irp->userData = (uintptr_t) iCDC;
870:                             irp->callback = _USB_DEVICE_CDC_ReadIRPCallback;
871:                             
872:                             /* Prevent other tasks pre-empting this sequence of code */ 
873:                             IntState = OSAL_CRIT_Enter(OSAL_CRIT_TYPE_HIGH);
874:                             /* Update the read queue size */ 
875:                             thisCDCDevice->currentQSizeRead++;
876:                             OSAL_CRIT_Leave(OSAL_CRIT_TYPE_HIGH, IntState);
877:                             
878:                             *transferHandle = (USB_DEVICE_CDC_TRANSFER_HANDLE)irp;
879:                             irpError = USB_DEVICE_IRPSubmit(thisCDCDevice->deviceHandle,
880:                                     endpoint->address, irp);
881:                 
882:                             /* If IRP Submit function returned any error, then invalidate the
883:                                Transfer handle.  */
884:                             if (irpError != USB_ERROR_NONE )
885:                             {
886:                                 /* Prevent other tasks pre-empting this sequence of code */ 
887:                                 IntState = OSAL_CRIT_Enter(OSAL_CRIT_TYPE_HIGH);
888:                                 /* Update the read queue size */ 
889:                                 thisCDCDevice->currentQSizeRead--;
890:                                 OSAL_CRIT_Leave(OSAL_CRIT_TYPE_HIGH, IntState);
891:                                 *transferHandle = USB_DEVICE_CDC_TRANSFER_HANDLE_INVALID;
892:                             }
893:                             
894:                             /*Release mutex, done with shared resource*/
895:                             osalError = OSAL_MUTEX_Unlock(&gUSBDeviceCdcCommonDataObj.mutexCDCIRP);
896:                             if(osalError != OSAL_RESULT_TRUE)
897:                             {
898:                                 /*Do not proceed unlock was not complete, or error occurred, let user know about error*/
899:                                 return (USB_DEVICE_CDC_RESULT_ERROR);
900:                             }
901:                             
902:                             return(irpError);
903:                         }
904:                     }
905:                     
906:                     /*Release mutex, done with shared resource*/
907:                     osalError = OSAL_MUTEX_Unlock(&gUSBDeviceCdcCommonDataObj.mutexCDCIRP);
908:                     if(osalError != OSAL_RESULT_TRUE)
909:                     {
910:                         /*Do not proceed unlock was not complete, or error occurred, let user know about error*/
911:                         return (USB_DEVICE_CDC_RESULT_ERROR);
912:                     }
913:                     /* If here means we could not find a spare IRP */
914:                     return(USB_DEVICE_CDC_RESULT_ERROR_TRANSFER_QUEUE_FULL);
915:                 }
916:                 
917:                 // *****************************************************************************
918:                 /* Function:
919:                     USB_DEVICE_CDC_RESULT USB_DEVICE_CDC_Write 
920:                     (   
921:                         USB_DEVICE_CDC_INDEX instance, 
922:                         USB_CDC_DEVICE_TRANSFER_HANDLE * transferHandle, 
923:                         const void * data, 
924:                         size_t size, 
925:                         USB_DEVICE_CDC_TRANSFER_FLAGS flags 
926:                     );
927:                 
928:                   Summary:
929:                     This function requests a data write to the USB Device CDC Function Driver 
930:                     Layer.
931:                 
932:                   Description:
933:                     This function requests a data write to the USB Device CDC Function Driver
934:                     Layer. The function places a requests with driver, the request will get
935:                     serviced as data is requested by the USB Host. A handle to the request is
936:                     returned in the transferHandle parameter. The termination of the request is
937:                     indicated by the USB_DEVICE_CDC_EVENT_WRITE_COMPLETE event. The amount of
938:                     data written and the transfer handle associated with the request is returned
939:                     along with the event in writeCompleteData member of the pData parameter in
940:                     the event handler. The transfer handle expires when event handler for the
941:                     USB_DEVICE_CDC_EVENT_WRITE_COMPLETE exits.  If the read request could not be
942:                     accepted, the function returns an error code and transferHandle will contain
943:                     the value USB_DEVICE_CDC_TRANSFER_HANDLE_INVALID.
944:                 
945:                   Remarks:
946:                     Refer to usb_device_cdc.h for usage information.
947:                 */
948:                 
949:                 USB_DEVICE_CDC_RESULT USB_DEVICE_CDC_Write 
950:                 (
951:                     USB_DEVICE_CDC_INDEX iCDC ,
952:                     USB_DEVICE_CDC_TRANSFER_HANDLE * transferHandle ,
953:                     const void * data , size_t size ,
954:                     USB_DEVICE_CDC_TRANSFER_FLAGS flags 
955:                 )
956:                 {
957:                     unsigned int cnt;
958:                     unsigned int remainder;
959:                     USB_DEVICE_IRP * irp;
960:                     USB_DEVICE_IRP_FLAG irpFlag = 0;
961:                     USB_DEVICE_CDC_INSTANCE * thisCDCDevice;
962:                     USB_DEVICE_CDC_ENDPOINT * endpoint;
963:                     OSAL_RESULT osalError;
964:                     USB_ERROR irpError; 
965:                     OSAL_CRITSECT_DATA_TYPE IntState;
966:                 
967:                     /* Check the validity of the function driver index */
968:                     
969:                     if (  iCDC >= USB_DEVICE_CDC_INSTANCES_NUMBER  )
970:                     {
971:                         /* Invalid CDC index */
972:                         SYS_ASSERT(false, "Invalid CDC Device Index");
973:                         return USB_DEVICE_CDC_RESULT_ERROR_INSTANCE_INVALID;
974:                     }
975:                 
976:                     /* Initialize the transfer handle, get the instance object
977:                      * and the transmit endpoint */
978:                 
979:                     * transferHandle = USB_DEVICE_CDC_TRANSFER_HANDLE_INVALID;
980:                     thisCDCDevice = &gUSBDeviceCDCInstance[iCDC];
981:                     endpoint = &thisCDCDevice->dataInterface.endpoint[USB_DEVICE_CDC_ENDPOINT_TX];
982:                 
983:                     if(!(endpoint->isConfigured))
984:                     {
985:                         /* This means that the endpoint is not configured yet */
986:                         SYS_ASSERT(false, "Endpoint not configured");
987:                         return (USB_DEVICE_CDC_RESULT_ERROR_INSTANCE_NOT_CONFIGURED);
988:                     }
989:                 
990:                     if(size == 0) 
991:                     {
992:                         /* Size cannot be zero */
993:                         return (USB_DEVICE_CDC_RESULT_ERROR_TRANSFER_SIZE_INVALID);
994:                     }
995:                 
996:                     /* Check the flag */
997:                 
998:                     if(flags & USB_DEVICE_CDC_TRANSFER_FLAGS_MORE_DATA_PENDING)
999:                     {
1000:                        if(size < endpoint->maxPacketSize)
1001:                        {
1002:                            /* For a data pending flag, we must atleast get max packet
1003:                             * size worth data */
1004:                
1005:                            return(USB_DEVICE_CDC_RESULT_ERROR_TRANSFER_SIZE_INVALID);
1006:                        }
1007:                
1008:                        remainder = size % endpoint->maxPacketSize;
1009:                        
1010:                        if(remainder != 0)
1011:                        {
1012:                            size -= remainder;
1013:                        }
1014:                
1015:                        irpFlag = USB_DEVICE_IRP_FLAG_DATA_PENDING;
1016:                    }
1017:                    else if(flags & USB_DEVICE_CDC_TRANSFER_FLAGS_DATA_COMPLETE)
1018:                    {
1019:                        irpFlag = USB_DEVICE_IRP_FLAG_DATA_COMPLETE;
1020:                    }
1021:                
1022:                    if(thisCDCDevice->currentQSizeWrite >= thisCDCDevice->queueSizeWrite)
1023:                    {
1024:                        SYS_ASSERT(false, "Write Queue is full");
1025:                        return(USB_DEVICE_CDC_RESULT_ERROR_TRANSFER_QUEUE_FULL);
1026:                    }
1027:                
1028:                    /*Obtain mutex to get access to a shared resource, check return value*/
1029:                    osalError = OSAL_MUTEX_Lock(&gUSBDeviceCdcCommonDataObj.mutexCDCIRP, OSAL_WAIT_FOREVER);
1030:                    if(osalError != OSAL_RESULT_TRUE)
1031:                    {
1032:                      /*Do not proceed lock was not obtained, or error occurred, let user know about error*/
1033:                      return (USB_DEVICE_CDC_RESULT_ERROR);
1034:                    }
1035:                
1036:                    /* loop and find a free IRP in the Q */
1037:                    for ( cnt = 0; cnt < USB_DEVICE_CDC_QUEUE_DEPTH_COMBINED; cnt ++ )
1038:                    {
1039:                        if(gUSBDeviceCDCIRP[cnt].status <
1040:                                (USB_DEVICE_IRP_STATUS)USB_DEVICE_IRP_FLAG_DATA_PENDING)
1041:                        {
1042:                            /* This means the IRP is free */
1043:                
1044:                            irp         = &gUSBDeviceCDCIRP[cnt];
1045:                            irp->data   = (void *)data;
1046:                            irp->size   = size;
1047:                
1048:                            irp->userData   = (uintptr_t) iCDC;
1049:                            irp->callback   = _USB_DEVICE_CDC_WriteIRPCallback;
1050:                            irp->flags      = irpFlag;
1051:                
1052:                            /* Prevent other tasks pre-empting this sequence of code */ 
1053:                            IntState = OSAL_CRIT_Enter(OSAL_CRIT_TYPE_HIGH);
1054:                            /* Update the Write queue size */ 
1055:                            thisCDCDevice->currentQSizeWrite++;
1056:                            OSAL_CRIT_Leave(OSAL_CRIT_TYPE_HIGH, IntState);
1057:                            
1058:                            *transferHandle = (USB_DEVICE_CDC_TRANSFER_HANDLE)irp;
1059:                
1060:                            irpError = USB_DEVICE_IRPSubmit(thisCDCDevice->deviceHandle,
1061:                                    endpoint->address, irp);
1062:                
1063:                            /* If IRP Submit function returned any error, then invalidate the
1064:                               Transfer handle.  */
1065:                            if (irpError != USB_ERROR_NONE )
1066:                            {
1067:                                /* Prevent other tasks pre-empting this sequence of code */ 
1068:                                IntState = OSAL_CRIT_Enter(OSAL_CRIT_TYPE_HIGH);
1069:                                /* Update the Write queue size */ 
1070:                                thisCDCDevice->currentQSizeWrite--;
1071:                                OSAL_CRIT_Leave(OSAL_CRIT_TYPE_HIGH, IntState);
1072:                                *transferHandle = USB_DEVICE_CDC_TRANSFER_HANDLE_INVALID;
1073:                            }
1074:                            /*Release mutex, done with shared resource*/
1075:                            osalError = OSAL_MUTEX_Unlock(&gUSBDeviceCdcCommonDataObj.mutexCDCIRP);
1076:                            if(osalError != OSAL_RESULT_TRUE)
1077:                            {
1078:                                /*Do not proceed unlock was not complete, or error occurred, let user know about error*/
1079:                                return (USB_DEVICE_CDC_RESULT_ERROR);
1080:                            }
1081:                
1082:                            return(irpError);
1083:                        }
1084:                    }
1085:                    
1086:                    /*Release mutex, done with shared resource*/
1087:                    osalError = OSAL_MUTEX_Unlock(&gUSBDeviceCdcCommonDataObj.mutexCDCIRP);
1088:                    if(osalError != OSAL_RESULT_TRUE)
1089:                    {
1090:                        /*Do not proceed unlock was not complete, or error occurred, let user know about error*/
1091:                        return (USB_DEVICE_CDC_RESULT_ERROR);
1092:                    }
1093:                    /* If here means we could not find a spare IRP */
1094:                    return(USB_DEVICE_CDC_RESULT_ERROR_TRANSFER_QUEUE_FULL);
1095:                }
1096:                
1097:                USB_DEVICE_CDC_RESULT USB_DEVICE_CDC_EventHandlerSet 
1098:                (
1099:                    USB_DEVICE_CDC_INDEX iCDC ,
1100:                    USB_DEVICE_CDC_EVENT_HANDLER eventHandler,
1101:                    uintptr_t userData
1102:                
1103:                )
1104:                {
1105:                    /* Check the validity of the function driver index */
1106:                    if (( iCDC >= USB_DEVICE_CDC_INSTANCES_NUMBER ) )
1107:                    {
1108:                        /* invalid CDC index */
1109:                        return USB_DEVICE_CDC_RESULT_ERROR_INSTANCE_INVALID;
1110:                    }
1111:                
1112:                    /* Check if the given event handler is valid */
1113:                    if ( eventHandler )
1114:                    {
1115:                        /* update the event handler for this instance */
1116:                        gUSBDeviceCDCInstance[iCDC].appEventCallBack = eventHandler;
1117:                        gUSBDeviceCDCInstance[iCDC].userData = userData;
1118:                
1119:                        /* return success */
1120:                        return USB_DEVICE_CDC_RESULT_OK;
1121:                    }
1122:                
1123:                    else
1124:                    {
1125:                        /* invalid event handler passed */
1126:                        return USB_DEVICE_CDC_RESULT_ERROR_PARAMETER_INVALID;
1127:                    }
1128:                }
1129:                
1130:                uint16_t USB_DEVICE_CDC_ReadPacketSizeGet ( USB_DEVICE_CDC_INDEX iCDC )
1131:                {
1132:                    /* check the validity of the function driver index */
1133:                    if ( ( iCDC >= USB_DEVICE_CDC_INSTANCES_NUMBER ) )
1134:                    {
1135:                        /* Invalid CDC index */
1136:                        SYS_ASSERT ( false , "Invalid CDC index" );
1137:                        return (0);
1138:                    }
1139:                
1140:                    /* max read packet size for this instance */
1141:                    return (gUSBDeviceCDCInstance[iCDC].dataInterface
1142:                            .endpoint[USB_DEVICE_CDC_ENDPOINT_RX].maxPacketSize );
1143:                
1144:                }
1145:                
1146:                // *****************************************************************************
1147:                /* Function:
1148:                    USB_DEVICE_CDC_RESULT USB_DEVICE_CDC_EventHandlerSet 
1149:                    (
1150:                        USB_DEVICE_CDC_INDEX instance 
1151:                        USB_DEVICE_CDC_EVENT_HANDLER eventHandler 
1152:                        uintptr_t context
1153:                    );
1154:                
1155:                  Summary:
1156:                    This function registers a event handler for the specified CDC function
1157:                    driver instance. 
1158:                
1159:                  Description:
1160:                    This function registers a event handler for the specified CDC function
1161:                    driver instance. This function should be called by the client when it
1162:                    receives a SET CONFIGURATION event from the device layer. A event handler
1163:                    must be registered for function driver to respond to function driver
1164:                    specific commands. If the event handler is not registered, the device layer
1165:                    will stall function driver specific commands and the USB device may not
1166:                    function. 
1167:                
1168:                  Remarks:
1169:                    Refer to usb_device_cdc.h for usage information.
1170:                */
1171:                
1172:                
1173:                uint16_t USB_DEVICE_CDC_WritePacketSizeGet ( USB_DEVICE_CDC_INDEX iCDC )
1174:                {
1175:                    /* check the validity of the function driver index */
1176:                    if ( ( iCDC >= USB_DEVICE_CDC_INSTANCES_NUMBER ) )
1177:                    {
1178:                        /* Invalid CDC index */
1179:                        SYS_ASSERT ( false , "Invalid CDC index" );
1180:                        return (0);
1181:                    }
1182:                
1183:                    /* max read packet size for this instance */
1184:                    return (gUSBDeviceCDCInstance[iCDC].dataInterface.
1185:                            endpoint[USB_DEVICE_CDC_ENDPOINT_TX].maxPacketSize );
1186:                }
1187:                // *****************************************************************************
1188:                /* Function:
1189:                    USB_DEVICE_CDC_RESULT USB_DEVICE_CDC_SerialStateNotificationSend
1190:                    (
1191:                        USB_DEVICE_CDC_INDEX instanceIndex,
1192:                        USB_DEVICE_CDC_TRANSFER_HANDLE * transferHandle,
1193:                        USB_DEVICE_CDC_SERIAL_STATE_NOTIFICATION * notificationData
1194:                    );
1195:                    
1196:                  Summary:
1197:                    This function schedules a request to send serial state notification to the host.
1198:                
1199:                  Description:
1200:                    This function places a request to send serial state notificatin data to the
1201:                    host. The function will place the request with the driver, the request will
1202:                    get serviced when the data is requested by the USB host.  A handle to the
1203:                    request is returned in the transferHandle parameter. The termination of the
1204:                    request is indicated by the
1205:                    USB_DEVICE_CDC_EVENT_SERIAL_STATE_NOTIFICATION_COMPLETE event. The amount of
1206:                    data transmitted and the transfer handle associated with the request is
1207:                    returned along with the event in the serialStateNotificationCompleteData
1208:                    member of pData paramter of the event handler. The transfer handle expires
1209:                    when the event handler for the
1210:                    USB_DEVICE_CDC_EVENT_SERIAL_STATE_NOTIFICATION_COMPLETE event exits. If the
1211:                    send request could not be accepted, the function returns an error code and
1212:                    transferHandle will contain the value
1213:                    USB_DEVICE_CDC_TRANSFER_HANDLE_INVALID.
1214:                
1215:                  Remarks:
1216:                    Refer to usb_device_cdc.h for usage information.
1217:                */
1218:                
1219:                USB_DEVICE_CDC_RESULT USB_DEVICE_CDC_SerialStateNotificationSend 
1220:                (
1221:                    USB_DEVICE_CDC_INDEX iCDC ,
1222:                    USB_DEVICE_CDC_TRANSFER_HANDLE * transferHandle ,
1223:                    USB_CDC_SERIAL_STATE * notificationData 
1224:                )
1225:                {
1226:                    unsigned int cnt;
1227:                    USB_DEVICE_IRP * irp;
1228:                    USB_DEVICE_CDC_ENDPOINT * endpoint;
1229:                    USB_DEVICE_CDC_INSTANCE * thisCDCDevice;
1230:                    OSAL_RESULT osalError;
1231:                    USB_ERROR irpError;
1232:                    OSAL_CRITSECT_DATA_TYPE IntState;
1233:                
1234:                    *transferHandle = USB_DEVICE_CDC_TRANSFER_HANDLE_INVALID;
1235:                
1236:                    /* Check the validity of the function driver index */
1237:                    
1238:                    if (  iCDC >= USB_DEVICE_CDC_INSTANCES_NUMBER  )
1239:                    {
1240:                        /* Invalid CDC index */
1241:                        SYS_ASSERT(false, "Invalid CDC Device Index");
1242:                        return USB_DEVICE_CDC_RESULT_ERROR_INSTANCE_INVALID;
1243:                    }
1244:                
1245:                    thisCDCDevice = &gUSBDeviceCDCInstance[iCDC];
1246:                    endpoint = &thisCDCDevice->notificationInterface.endpoint[USB_DEVICE_CDC_ENDPOINT_TX];
1247:                
1248:                    if(!(endpoint->isConfigured))
1249:                    {
1250:                        /* This means that the endpoint is not configured yet */
1251:                        SYS_ASSERT(false, "Endpoint not configured");
1252:                        return (USB_DEVICE_CDC_RESULT_ERROR_INSTANCE_NOT_CONFIGURED);
1253:                    }
1254:                
1255:                    if(thisCDCDevice->currentQSizeSerialStateNotification >=
1256:                            thisCDCDevice->queueSizeSerialStateNotification)
1257:                    {
1258:                        SYS_ASSERT(false, "Serial State Notification Send Queue is full");
1259:                        return(USB_DEVICE_CDC_RESULT_ERROR_TRANSFER_QUEUE_FULL);
1260:                    }
1261:                
1262:                    /*Obtain mutex to get access to a shared resource, check return value*/
1263:                    osalError = OSAL_MUTEX_Lock(&gUSBDeviceCdcCommonDataObj.mutexCDCIRP, OSAL_WAIT_FOREVER);
1264:                    if(osalError != OSAL_RESULT_TRUE)
1265:                    {
1266:                      /*Do not proceed lock was not obtained, or error occurred, let user know about error*/
1267:                      return (USB_DEVICE_CDC_RESULT_ERROR);
1268:                    }
1269:                
1270:                    /* Loop and find a free IRP in the Q */
1271:                    for ( cnt = 0; cnt < USB_DEVICE_CDC_QUEUE_DEPTH_COMBINED; cnt ++ )
1272:                    {
1273:                        if(gUSBDeviceCDCIRP[cnt].status < (USB_DEVICE_IRP_STATUS)USB_DEVICE_IRP_FLAG_DATA_PENDING)
1274:                        {
1275:                            /* This means the IRP is free */
1276:                
1277:                            irp = &gUSBDeviceCDCIRP[cnt];
1278:                            irp->data = notificationData;
1279:                            irp->size = sizeof(USB_CDC_SERIAL_STATE);
1280:                            irp->userData = (uintptr_t) iCDC;
1281:                            irp->callback = _USB_DEVICE_CDC_SerialStateSendIRPCallback;
1282:                            irp->flags = USB_DEVICE_IRP_FLAG_DATA_COMPLETE;
1283:                            /* Prevent other tasks pre-empting this sequence of code */ 
1284:                            IntState = OSAL_CRIT_Enter(OSAL_CRIT_TYPE_HIGH);
1285:                            /* Update Serial State Notification Queue Size */ 
1286:                            thisCDCDevice->currentQSizeSerialStateNotification ++;
1287:                            OSAL_CRIT_Leave(OSAL_CRIT_TYPE_HIGH, IntState);
1288:                            
1289:                            *transferHandle = (USB_DEVICE_CDC_TRANSFER_HANDLE) irp;
1290:                            irpError = USB_DEVICE_IRPSubmit(thisCDCDevice->deviceHandle, endpoint->address, irp);
1291:                            
1292:                            /* If IRP Submit function returned any error, then invalidate the
1293:                               Transfer handle.  */
1294:                            if (irpError != USB_ERROR_NONE )
1295:                            {
1296:                                /* Prevent other tasks pre-empting this sequence of code */ 
1297:                                IntState = OSAL_CRIT_Enter(OSAL_CRIT_TYPE_HIGH);
1298:                                /* Update Serial State Notification Queue Size */ 
1299:                                thisCDCDevice->currentQSizeSerialStateNotification --;
1300:                                OSAL_CRIT_Leave(OSAL_CRIT_TYPE_HIGH, IntState);
1301:                                
1302:                                *transferHandle = USB_DEVICE_CDC_TRANSFER_HANDLE_INVALID;
1303:                            }
1304:                
1305:                            /*Release mutex, done with shared resource*/
1306:                            osalError = OSAL_MUTEX_Unlock(&gUSBDeviceCdcCommonDataObj.mutexCDCIRP);
1307:                            if(osalError != OSAL_RESULT_TRUE)
1308:                            {
1309:                                /*Do not proceed unlock was not complete, or error occurred, let user know about error*/
1310:                                return (USB_DEVICE_CDC_RESULT_ERROR);
1311:                            }
1312:                            
1313:                            return(irpError);
1314:                        }
1315:                    }
1316:                    
1317:                    /*Release mutex, done with shared resource*/
1318:                    osalError = OSAL_MUTEX_Unlock(&gUSBDeviceCdcCommonDataObj.mutexCDCIRP);
1319:                    if(osalError != OSAL_RESULT_TRUE)
1320:                    {
1321:                        /*Do not proceed unlock was not complete, or error occurred, let user know about error*/
1322:                        return (USB_DEVICE_CDC_RESULT_ERROR);
1323:                    }
1324:                    /* If here means we could not find a spare IRP */
1325:                    return(USB_DEVICE_CDC_RESULT_ERROR_TRANSFER_QUEUE_FULL);
1326:                }
1327:                
1328:                /*******************************************************************************
1329:                 End of File
1330:                 */
---  /home/whatisthis/microchip/harmony/v2_04/framework/usb/src/dynamic/usb_device.c  -------------------
1:                   /**************************************************************************
2:                    USB Device Layer Implementation
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                       
7:                     File Name:
8:                       usb_device.c
9:                       
10:                    Summary:
11:                      This file contains implementations of both private and public functions
12:                      of the USB Device Layer.
13:                      
14:                    Description:
15:                      This file contains the USB device layer implementation.
16:                  **************************************************************************/
17:                  
18:                  // DOM-IGNORE-BEGIN
19:                  /*******************************************************************************
20:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
21:                  
22:                  Microchip licenses to you the right to use, modify, copy and distribute
23:                  Software only when embedded on a Microchip microcontroller or digital signal
24:                  controller that is integrated into your product or third party product
25:                  (pursuant to the sublicense terms in the accompanying license agreement).
26:                  
27:                  You should refer to the license agreement accompanying this Software for
28:                  additional information regarding your rights and obligations.
29:                  
30:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
31:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
32:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
33:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
34:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
35:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
36:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
37:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
38:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
39:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
40:                  *******************************************************************************/
41:                  // DOM-IGNORE-END
42:                  
43:                  #include <stdlib.h>
44:                  #include <stdint.h>
45:                  #include <stdbool.h>
46:                  
47:                  #include "system_config.h"
48:                  #include "system/common/sys_module.h"
49:                  #include "usb/usb_common.h"
50:                  #include "usb/usb_chapter_9.h"
51:                  #include "usb/usb_device.h"
52:                  #include "system/debug/sys_debug.h"
53:                  #include "usb/src/usb_device_local.h"
54:                  #include "driver/usb/drv_usb.h"
55:                  
56:                  /**********************************
57:                   * Device layer instance objects.
58:                   *********************************/
59:                  static USB_DEVICE_OBJ usbDeviceInstance[USB_DEVICE_INSTANCES_NUMBER];
60:                  
61:                  /*************************************
62:                   * Device layer endpoint constants. 
63:                   *************************************/
64:                  static const USB_ENDPOINT controlEndpointTx = 0x80;
65:                  static const USB_ENDPOINT controlEndpointRx  = 0x00;
66:                  
67:                  // *****************************************************************************
68:                  // *****************************************************************************
69:                  // Section: USB Device Layer System Interface functions.
70:                  // *****************************************************************************
71:                  // *****************************************************************************
72:                  
73:                  // ******************************************************************************
74:                  /* Function:
75:                      SYS_MODULE_OBJ USB_DEVICE_Initialize
76:                      (
77:                          const SYS_MODULE_INDEX index, 
78:                          const SYS_MODULE_INIT * const initData
79:                      )
80:                  
81:                    Summary:
82:                      Initializes the required USB device layer state machines.
83:                  
84:                    Description:
85:                      This function initializes the required state machines of the USB device
86:                      layer.
87:                  
88:                    Remarks:
89:                      Refer to usb_device.h for usage information.
90:                  */
91:                  
92:                  SYS_MODULE_OBJ USB_DEVICE_Initialize
93:                  (
94:                      const SYS_MODULE_INDEX index, 
95:                      const SYS_MODULE_INIT * const initData
96:                  )
97:                  {
9D00D960  27BDFFE0   ADDIU SP, SP, -32
9D00D964  AFBF001C   SW RA, 28(SP)
9D00D968  AFB20018   SW S2, 24(SP)
9D00D96C  AFB10014   SW S1, 20(SP)
9D00D970  AFB00010   SW S0, 16(SP)
98:                      USB_DEVICE_INIT *deviceInit;
99:                      USB_DEVICE_OBJ* usbDeviceThisInstance;
100:                     USB_DEVICE_DRIVER_SELF_INITIALIZE
101:                     USB_DEVICE_IRP * irpEp0Rx;
102:                     USB_DEVICE_IRP * irpEp0Tx;
103:                     uint8_t count;
104:                     USB_DEVICE_FUNCTION_DRIVER * driver;
105:                     USB_DEVICE_FUNCTION_REGISTRATION_TABLE * funcRegTable;
106:                          
107:                     /* Copy init data to local variable. */
108:                     deviceInit = (USB_DEVICE_INIT *)initData;
109:                     
110:                     /* Make sure the index is with in range. */
111:                     if(( index < 0 ) || ( index >= USB_DEVICE_INSTANCES_NUMBER ))
9D00D944  14800052   BNE A0, ZERO, 0x9D00DA90
9D00D948  2402FFFF   ADDIU V0, ZERO, -1
112:                     {
113:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Invalid index value");
114:                         return (SYS_MODULE_OBJ_INVALID);
115:                     }
116:                     
117:                     /* Make sure that initData is not NULL. */
118:                     if(deviceInit == NULL)
9D00D94C  10A00047   BEQ A1, ZERO, 0x9D00DA6C
9D00D950  00000000   NOP
119:                     {
120:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Initialization data is NULL");
121:                         return (SYS_MODULE_OBJ_INVALID);
9D00DA6C  03E00008   JR RA
9D00DA70  2402FFFF   ADDIU V0, ZERO, -1
122:                     }
123:                     
124:                     /* Make sure that the USB Device Master Descriptor is valid */
125:                     if(deviceInit->usbMasterDescriptor == NULL)
9D00D954  8CA20020   LW V0, 32(A1)
9D00D958  10400046   BEQ V0, ZERO, 0x9D00DA74
9D00D95C  3C03A000   LUI V1, -24576
126:                     {
127:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: USB Master Descriptor table is NULL");
128:                         return (SYS_MODULE_OBJ_INVALID);
9D00DA74  03E00008   JR RA
9D00DA78  2402FFFF   ADDIU V0, ZERO, -1
129:                     }
130:                     
131:                     /* Get this instance of USB device layer. */
132:                     usbDeviceThisInstance = &usbDeviceInstance[index];
133:                 
134:                     /* Initialize this instance */        
135:                     usbDeviceThisInstance->usbDeviceInstanceState = SYS_STATUS_BUSY;
9D00D974  24627264   ADDIU V0, V1, 29284
9D00D978  24040001   ADDIU A0, ZERO, 1
9D00D97C  AC440004   SW A0, 4(V0)
136:                 
137:                     /* Save the "self" index for future use */    
138:                     usbDeviceThisInstance->usbDevLayerIndex = index;
9D00D980  A4400014   SH ZERO, 20(V0)
139:                     
140:                     /* Set the device state to dettached.*/
141:                     usbDeviceThisInstance->usbDeviceStatusStruct.usbDeviceState = USB_DEVICE_STATE_DETACHED;
9D00D984  94460002   LHU A2, 2(V0)
9D00D988  7C061004   INS A2, ZERO, 0, 3
9D00D98C  A4460002   SH A2, 2(V0)
142:                     
143:                     /* Initialize the instance structure. */
144:                     usbDeviceThisInstance->ptrMasterDescTable           = deviceInit->usbMasterDescriptor;
9D00D990  8CA60020   LW A2, 32(A1)
9D00D994  AC460008   SW A2, 8(V0)
145:                     usbDeviceThisInstance->registeredFuncDriverCount    = deviceInit->registeredFuncCount;
9D00D998  94A60018   LHU A2, 24(A1)
9D00D99C  A446000C   SH A2, 12(V0)
146:                     usbDeviceThisInstance->registeredFuncDrivers        = deviceInit->registeredFunctions;
9D00D9A0  8CB0001C   LW S0, 28(A1)
9D00D9A4  AC500010   SW S0, 16(V0)
147:                 
148:                     /* Initialize remote wakeup to disabled */
149:                     usbDeviceThisInstance->remoteWakeupStatus = USB_DEVICE_REMOTE_WAKEUP_DISABLED;
9D00D9A8  AC4000BC   SW ZERO, 188(V0)
150:                 
151:                     /* Initialize power source to bus power */
152:                     usbDeviceThisInstance->usbDeviceStatusStruct.powerState = USB_DEVICE_POWER_STATE_BUS_POWERED;
9D00D9AC  90677264   LBU A3, 29284(V1)
9D00D9B0  7C070004   INS A3, ZERO, 0, 1
153:                 
154:                     /* USBCD initialization */
155:                     USB_DEVICE_DRIVER_INIT()
156:                     
157:                     /* Reset set address flag.*/
158:                     usbDeviceThisInstance->usbDeviceStatusStruct.setAddressPending = false;
9D00D9B4  7C072104   INS A3, ZERO, 4, 1
159:                     
160:                     /* Reset Test mode flag.*/
161:                     usbDeviceThisInstance->usbDeviceStatusStruct.testModePending = false;
9D00D9B8  7C072944   INS A3, ZERO, 5, 1
162:                     
163:                     /* Initialize the RX IRP */
164:                     irpEp0Rx            = &usbDeviceThisInstance->irpEp0Rx;
165:                     irpEp0Rx->data      = usbDeviceThisInstance->ep0RxBuffer;
9D00D9BC  3C08A000   LUI T0, -24576
9D00D9C0  25087284   ADDIU T0, T0, 29316
9D00D9C4  AC480084   SW T0, 132(V0)
166:                     irpEp0Rx->size      = USB_DEVICE_EP0_BUFFER_SIZE;
9D00D9C8  24080040   ADDIU T0, ZERO, 64
9D00D9CC  AC480088   SW T0, 136(V0)
167:                     irpEp0Rx->flags     = USB_DEVICE_IRP_FLAG_DATA_COMPLETE;
9D00D9D0  AC440094   SW A0, 148(V0)
168:                     irpEp0Rx->status    = USB_DEVICE_IRP_STATUS_COMPLETED;
9D00D9D4  AC40008C   SW ZERO, 140(V0)
169:                     irpEp0Rx->callback  = &_USB_DEVICE_Ep0ReceiveCompleteCallback;
9D00D9D8  3C089D01   LUI T0, -25343
9D00D9DC  2508C6DC   ADDIU T0, T0, -14628
9D00D9E0  AC480090   SW T0, 144(V0)
170:                     irpEp0Rx->userData  = (uintptr_t)usbDeviceThisInstance;
9D00D9E4  AC420098   SW V0, 152(V0)
171:                 
172:                     /* Initialize the TX IRP */
173:                     irpEp0Tx            = &usbDeviceThisInstance->irpEp0Tx;
174:                     irpEp0Tx->callback  = &_USB_DEVICE_Ep0TransmitCompleteCallback;
9D00D9E8  3C089D01   LUI T0, -25343
9D00D9EC  250815E8   ADDIU T0, T0, 5608
9D00D9F0  AC48006C   SW T0, 108(V0)
175:                     irpEp0Tx->userData  = (uintptr_t)usbDeviceThisInstance;
9D00D9F4  AC420074   SW V0, 116(V0)
176:                     irpEp0Tx->flags     = USB_DEVICE_IRP_FLAG_DATA_COMPLETE;
9D00D9F8  AC440070   SW A0, 112(V0)
177:                 
178:                     /* Device is not suspended */
179:                     usbDeviceThisInstance->usbDeviceStatusStruct.isSuspended = false;
9D00D9FC  00E02021   ADDU A0, A3, ZERO
9D00DA00  7C0439C4   INS A0, ZERO, 7, 1
9D00DA04  A0647264   SB A0, 29284(V1)
180:                 
181:                     /* Set the task state to opening the USB driver */
182:                     usbDeviceThisInstance->taskState = USB_DEVICE_TASK_STATE_OPENING_USBCD;
9D00DA08  AC4000D0   SW ZERO, 208(V0)
183:                 
184:                     /* Get a pointer to the driver interface */
185:                     usbDeviceThisInstance->driverInterface = (DRV_USB_DEVICE_INTERFACE *)(deviceInit->usbDriverInterface);
9D00DA0C  8CA30030   LW V1, 48(A1)
9D00DA10  AC4300EC   SW V1, 236(V0)
186:                     usbDeviceThisInstance->driverIndex = deviceInit->driverIndex;
9D00DA14  94A3002C   LHU V1, 44(A1)
187:                 
188:                     /* Initialize Endpoint Q size */ 
189:                     _USB_DEVICE_Initialize_Endpoint_Q(index, deviceInit->queueSizeEndpointRead, deviceInit->queueSizeEndpointWrite);
190:                 
191:                     /* Create Mutex for Endpoint Read Write */
192:                     _USB_DEVICE_EndpointMutexCreate (usbDeviceThisInstance);
193:                 
194:                     funcRegTable    = usbDeviceThisInstance->registeredFuncDrivers;
195:                 
196:                     for(count = 0; count < usbDeviceThisInstance->registeredFuncDriverCount; count++ )
9D00DA18  30C6FFFF   ANDI A2, A2, -1
9D00DA1C  10C00011   BEQ A2, ZERO, 0x9D00DA64
9D00DA20  A44300F0   SH V1, 240(V0)
9D00DA24  00008821   ADDU S1, ZERO, ZERO
9D00DA28  3C12A000   LUI S2, -24576
9D00DA4C  323100FF   ANDI S1, S1, 255
9D00DA50  26427264   ADDIU V0, S2, 29284
9D00DA54  9442000C   LHU V0, 12(V0)
9D00DA58  0222102B   SLTU V0, S1, V0
9D00DA5C  1440FFF3   BNE V0, ZERO, 0x9D00DA2C
9D00DA60  26100014   ADDIU S0, S0, 20
197:                     {
198:                         /* The global intialize function of each registered function driver is
199:                          * called once when the device layer is initialized. This allows the
200:                          * function driver to create any mutexes once when the device stack is
201:                          * initialized. This happens only once. */
202:                 
203:                         driver = (USB_DEVICE_FUNCTION_DRIVER *)funcRegTable->driver;
9D00DA2C  8E020010   LW V0, 16(S0)
204:                 
205:                         if (driver != NULL)
9D00DA30  10400006   BEQ V0, ZERO, 0x9D00DA4C
9D00DA34  26310001   ADDIU S1, S1, 1
206:                         {
207:                             if(driver->globalInitialize != NULL)
9D00DA38  8C420010   LW V0, 16(V0)
9D00DA3C  10400003   BEQ V0, ZERO, 0x9D00DA4C
9D00DA40  00000000   NOP
208:                             {
209:                                 driver->globalInitialize();
9D00DA44  0040F809   JALR V0
9D00DA48  00000000   NOP
210:                             }
211:                         }
212:                         funcRegTable++;
213:                     }
214:                 
215:                     /* Return the index as the system module object */
216:                     return index;  
9D00DA64  0B40369F   J 0x9D00DA7C
9D00DA68  00001021   ADDU V0, ZERO, ZERO
217:                 }    
9D00DA7C  8FBF001C   LW RA, 28(SP)
9D00DA80  8FB20018   LW S2, 24(SP)
9D00DA84  8FB10014   LW S1, 20(SP)
9D00DA88  8FB00010   LW S0, 16(SP)
9D00DA8C  27BD0020   ADDIU SP, SP, 32
9D00DA90  03E00008   JR RA
9D00DA94  00000000   NOP
218:                 
219:                 // *****************************************************************************
220:                 /* Function:
221:                     SYS_STATUS USB_DEVICE_Status ( SYS_MODULE_OBJ object )
222:                 
223:                   Summary:
224:                     Provides the current status of the USB device layer.
225:                 
226:                   Description:
227:                     This function provides the current status of the USB device layer.
228:                 
229:                   Remarks
230:                     Refer to usb_device.h for usage information.
231:                 */
232:                 
233:                 SYS_STATUS USB_DEVICE_Status( SYS_MODULE_OBJ object )
234:                 {
235:                     SYS_MODULE_INDEX index = (SYS_MODULE_INDEX)object;
236:                 
237:                     if(object == SYS_MODULE_OBJ_INVALID)
238:                     {
239:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Invalid System Module Object");
240:                         return(SYS_STATUS_UNINITIALIZED);
241:                     }
242:                 
243:                     return( usbDeviceInstance[index].usbDeviceInstanceState );
244:                 }
245:                 
246:                 // *****************************************************************************
247:                 /* Function:
248:                     bool USB_DEVICE_IsSuspended( USB_DEVICE_HANDLE usbDeviceHandle )
249:                 
250:                   Summary:
251:                     Returns true if the device is in a suspended state.
252:                 
253:                   Description:
254:                     This function returns true if the device is presently in suspended state.
255:                 
256:                   Remarks:
257:                     Refer to usb_device.h for usage information.
258:                 */
259:                 
260:                 bool USB_DEVICE_IsSuspended( USB_DEVICE_HANDLE usbDeviceHandle )
261:                 {
262:                     USB_DEVICE_OBJ* usbClientHandle;
263:                 
264:                     /* Validate the handle */
265:                     usbClientHandle = _USB_DEVICE_ClientHandleValidate(usbDeviceHandle );
266:                 
267:                     if(usbClientHandle == NULL)
268:                     {
269:                        /* Handle is not valid */
270:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Invalid handle");
271:                     }
272:                 
273:                     return (usbClientHandle->usbDeviceStatusStruct.isSuspended); 
274:                 }
275:                 
276:                 // *****************************************************************************
277:                 /* Function:
278:                     USB_DEVICE_STATE USB_DEVICE_StateGet( USB_DEVICE_HANDLE usbDeviceHandle )
279:                 
280:                   Summary:
281:                     Returns the current state of the USB device.
282:                 
283:                   Description:
284:                     This function returns the current state of the USB device, as described in
285:                     Chapter 9 of the USB 2.0 Specification.
286:                 
287:                   Remarks:
288:                     Refer to usb_device.h for usage information.
289:                 */
290:                 
291:                 USB_DEVICE_STATE USB_DEVICE_StateGet( USB_DEVICE_HANDLE usbDeviceHandle )
292:                 {
293:                     USB_DEVICE_OBJ* usbClientHandle;
294:                 
295:                     /* Validate the handle */
296:                     usbClientHandle = _USB_DEVICE_ClientHandleValidate(usbDeviceHandle );
297:                 
298:                     if(usbClientHandle == NULL)
299:                     {
300:                        /* Handle is not valid */
301:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Invalid handle");
302:                     }
303:                     
304:                     return (usbClientHandle->usbDeviceStatusStruct.usbDeviceState); 
305:                 }
306:                 
307:                 // *****************************************************************************
308:                 /* Function:
309:                     void USB_DEVICE_Deinitialize ( SYS_MODULE_OBJ usbDeviceobj)
310:                 
311:                   Summary:
312:                     De initializes the specified instance of the USB device layer.
313:                 
314:                   Description:
315:                     This function de initializes the specified instance of the USB device layer,
316:                     disabling its operation (and any hardware) and invalidates all of the
317:                     internal data.
318:                 
319:                   Remarks:
320:                     Refer to usb_device.h for usage information.
321:                 */
322:                 
323:                 void USB_DEVICE_Deinitialize ( SYS_MODULE_OBJ usbDeviceObj )
324:                 {
325:                     USB_DEVICE_OBJ * usbDeviceThisInstance;
326:                     SYS_MODULE_INDEX index = (SYS_MODULE_INDEX)usbDeviceObj;
327:                 
328:                     /* Check if we have a valid system module object */
329:                     if(usbDeviceObj == SYS_MODULE_OBJ_INVALID)
330:                     {
331:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Invalid System Module Object");
332:                         return;
333:                     }
334:                 
335:                     /* In this release of the device stack, we really dont do much in the
336:                      * deinitialize function, as we dont expect the USB Device Layer to be
337:                      * deinitialized in a typical application. */
338:                 
339:                     usbDeviceThisInstance = ( USB_DEVICE_OBJ *)&usbDeviceInstance[index];
340:                 
341:                     /* Invalidate the object */
342:                     usbDeviceThisInstance->usbDeviceInstanceState =  SYS_STATUS_UNINITIALIZED;
343:                 }
344:                  
345:                 // *****************************************************************************
346:                 /* Function:
347:                     void USB_DEVICE_Tasks( SYS_MODULE_OBJ devLayerObj )
348:                 
349:                   Summary:
350:                     Calls all USB device layer tasks.
351:                 
352:                   Description:
353:                     This function internally calls all USB Device layer tasks.
354:                 
355:                   Remarks:
356:                     Refer to usb_device.h for usage information.
357:                 */
358:                 
359:                 void USB_DEVICE_Tasks( SYS_MODULE_OBJ devLayerObj )
360:                 {
9D00CCC0  27BDFFC8   ADDIU SP, SP, -56
9D00CCC4  AFBF0034   SW RA, 52(SP)
9D00CCC8  AFB70030   SW S7, 48(SP)
9D00CCCC  AFB6002C   SW S6, 44(SP)
9D00CCD0  AFB50028   SW S5, 40(SP)
9D00CCD4  AFB40024   SW S4, 36(SP)
9D00CCD8  AFB30020   SW S3, 32(SP)
9D00CCDC  AFB2001C   SW S2, 28(SP)
9D00CCE0  AFB10018   SW S1, 24(SP)
9D00CCE4  AFB00014   SW S0, 20(SP)
361:                     uint8_t count;
362:                     USB_SPEED speed;
363:                     uint16_t configValue;
364:                     uint16_t maxFunctionCounts;
365:                     USB_DEVICE_OBJ * usbDeviceThisInstance;
366:                     USB_DEVICE_FUNCTION_REGISTRATION_TABLE * funcRegTable;
367:                     USB_DEVICE_FUNCTION_DRIVER * driver;
368:                 
369:                     /* Assert object is valid. */
370:                     if(devLayerObj == SYS_MODULE_OBJ_INVALID)
9D00CCB4  2402FFFF   ADDIU V0, ZERO, -1
9D00CCB8  10820058   BEQ A0, V0, 0x9D00CE1C
9D00CCBC  00041080   SLL V0, A0, 2
371:                     {
372:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: System Module Object is invalid");
373:                         return;
374:                     }
375:                 
376:                     /* Get this instance of USB device layer.*/
377:                     usbDeviceThisInstance = &usbDeviceInstance[devLayerObj];    
9D00CCE8  00049180   SLL S2, A0, 6
9D00CCEC  02429023   SUBU S2, S2, V0
9D00CCF0  02442021   ADDU A0, S2, A0
9D00CCF4  00042080   SLL A0, A0, 2
9D00CCF8  3C12A000   LUI S2, -24576
9D00CCFC  26527264   ADDIU S2, S2, 29284
9D00CD00  02449021   ADDU S2, S2, A0
378:                 
379:                     /* Proceed only if this instance is in initialized state. */
380:                     if( usbDeviceThisInstance->usbDeviceInstanceState <= SYS_STATUS_UNINITIALIZED )
9D00CD04  8E420004   LW V0, 4(S2)
9D00CD08  5840003B   BLEZL V0, 0x9D00CDF8
9D00CD0C  8FBF0034   LW RA, 52(SP)
381:                     {
382:                         /* Instance is not yet initialized. Just do a return. */
383:                         return;
384:                     }
385:                 
386:                     /* Update the USBCD Tasks routine. This will call the driver tasks only if
387:                      * the device layer has initialized the driver. Else the following function
388:                      * call will map to NULL. */
389:                     DRV_USB_Tasks(usbDeviceThisInstance->usbCDSystemModuleObject);
390:                 
391:                     /* Get device layer data. */
392:                     speed           = usbDeviceThisInstance->usbDeviceStatusStruct.usbSpeed ;
9D00CD10  8E540000   LW S4, 0(S2)
9D00CD14  7E941040   EXT S4, S4, 1, 3
393:                     configValue     = usbDeviceThisInstance->activeConfiguration ;
9D00CD18  925500A9   LBU S5, 169(S2)
394:                     funcRegTable    = usbDeviceThisInstance->registeredFuncDrivers;
9D00CD1C  8E500010   LW S0, 16(S2)
395:                     maxFunctionCounts = usbDeviceThisInstance->registeredFuncDriverCount;
396:                 
397:                     /* Run the device layer task routine */
398:                     switch(usbDeviceThisInstance->taskState)
9D00CD20  8E4200D0   LW V0, 208(S2)
9D00CD24  1040000A   BEQ V0, ZERO, 0x9D00CD50
9D00CD28  9653000C   LHU S3, 12(S2)
9D00CD2C  24030001   ADDIU V1, ZERO, 1
9D00CD30  14430031   BNE V0, V1, 0x9D00CDF8
9D00CD34  8FBF0034   LW RA, 52(SP)
399:                     {
400:                         case USB_DEVICE_TASK_STATE_OPENING_USBCD:
401:                 
402:                             /* Try to open the driver handle. This could fail if the driver is
403:                              * not ready to be opened. */
404:                             usbDeviceThisInstance->usbCDHandle = USB_DEVICE_DRIVER_OPEN();
9D00CD50  8E4200EC   LW V0, 236(S2)
9D00CD54  8C420000   LW V0, 0(V0)
9D00CD58  964400F0   LHU A0, 240(S2)
9D00CD5C  0040F809   JALR V0
9D00CD60  2405000F   ADDIU A1, ZERO, 15
405:                 
406:                             /* Check if the driver was opened */
407:                             if(usbDeviceThisInstance->usbCDHandle != DRV_HANDLE_INVALID)
9D00CD64  2403FFFF   ADDIU V1, ZERO, -1
9D00CD68  10430022   BEQ V0, V1, 0x9D00CDF4
9D00CD6C  AE420018   SW V0, 24(S2)
408:                             {
409:                                 /* Yes the driver could be opened. Advance the state to the next
410:                                  * state */
411:                                 usbDeviceThisInstance->taskState = USB_DEVICE_TASK_STATE_RUNNING;
9D00CD70  24020001   ADDIU V0, ZERO, 1
9D00CD74  AE4200D0   SW V0, 208(S2)
412:                 
413:                                 /* Update the USB Device Layer state to indicate that it can be
414:                                  * opened */
415:                                 usbDeviceThisInstance->usbDeviceInstanceState = SYS_STATUS_READY;
9D00CD78  24020002   ADDIU V0, ZERO, 2
9D00CD7C  0B40337D   J 0x9D00CDF4
9D00CD80  AE420004   SW V0, 4(S2)
416:                             }
417:                 
418:                             break;
419:                 
420:                         case USB_DEVICE_TASK_STATE_RUNNING:
421:                 
422:                             /* In this state, the device layer performs it's actual task, that
423:                              * is calling the tasks routines of the functions drivers. The task
424:                              * routine of a function driver is called in the context of the
425:                              * USB_DEVICE_Tasks() function. The task routine is called only if
426:                              * the current device speed matches the function driver speed
427:                              * mentioned in the function driver registration table, the current
428:                              * configuration matches the configuration value mentioned in the
429:                              * function driver registration table, if the device is not
430:                              * suspended and if the device state is in a configured state. */
431:                 
432:                             for(count = 0; count < maxFunctionCounts; count++ )
9D00CD38  00008821   ADDU S1, ZERO, ZERO
9D00CD40  16600010   BNE S3, ZERO, 0x9D00CD84
9D00CD44  3C160005   LUI S6, 5
9D00CDE0  26310001   ADDIU S1, S1, 1
9D00CDE4  323100FF   ANDI S1, S1, 255
9D00CDE8  0233102B   SLTU V0, S1, S3
9D00CDEC  1440FFE5   BNE V0, ZERO, 0x9D00CD84
9D00CDF0  26100014   ADDIU S0, S0, 20
433:                             {
434:                                 if( (funcRegTable->speed & speed) && (funcRegTable->configurationValue == configValue))
9D00CD84  8E020000   LW V0, 0(S0)
9D00CD88  02821024   AND V0, S4, V0
9D00CD8C  50400015   BEQL V0, ZERO, 0x9D00CDE4
9D00CD90  26310001   ADDIU S1, S1, 1
9D00CD94  92020004   LBU V0, 4(S0)
9D00CD98  54550012   BNEL V0, S5, 0x9D00CDE4
9D00CD9C  26310001   ADDIU S1, S1, 1
435:                                 {
436:                                     if((usbDeviceThisInstance->usbDeviceStatusStruct.usbDeviceState == USB_DEVICE_STATE_CONFIGURED) &&
9D00CD3C  3C170007   LUI S7, 7
9D00CDA0  8E420000   LW V0, 0(S2)
9D00CDA4  00571024   AND V0, V0, S7
9D00CDA8  5456000E   BNEL V0, S6, 0x9D00CDE4
9D00CDAC  26310001   ADDIU S1, S1, 1
9D00CDB4  7C4201C0   EXT V0, V0, 7, 1
9D00CDB8  5440000A   BNEL V0, ZERO, 0x9D00CDE4
9D00CDBC  26310001   ADDIU S1, S1, 1
437:                                             (usbDeviceThisInstance->usbDeviceStatusStruct.isSuspended == false))
9D00CDB0  8E420000   LW V0, 0(S2)
438:                                     {
439:                                         /* Get a pointer to the driver function pointer table and
440:                                            call the task routine of the driver. */
441:                                         driver = (USB_DEVICE_FUNCTION_DRIVER *)funcRegTable->driver;
9D00CDC0  8E020010   LW V0, 16(S0)
442:                 
443:                                         if (driver != NULL)
9D00CDC4  50400007   BEQL V0, ZERO, 0x9D00CDE4
9D00CDC8  26310001   ADDIU S1, S1, 1
444:                                         {
445:                                             if(driver->tasks != NULL)
9D00CDCC  8C42000C   LW V0, 12(V0)
9D00CDD0  50400004   BEQL V0, ZERO, 0x9D00CDE4
9D00CDD4  26310001   ADDIU S1, S1, 1
446:                                             {
447:                                                 driver->tasks( funcRegTable->funcDriverIndex );
9D00CDD8  0040F809   JALR V0
9D00CDDC  96040008   LHU A0, 8(S0)
448:                                             }
449:                                         }
450:                                     }
451:                                 }
452:                 
453:                                 /* Run the task routine for the next driver in the function
454:                                  * driver registration table */
455:                                 funcRegTable++;
456:                             }
457:                             break;
458:                 
459:                         default:
460:                             break;
461:                     }
462:                 }
9D00CD48  0B40337F   J 0x9D00CDFC
9D00CD4C  8FB70030   LW S7, 48(SP)
9D00CDF4  8FBF0034   LW RA, 52(SP)
9D00CDF8  8FB70030   LW S7, 48(SP)
9D00CDFC  8FB6002C   LW S6, 44(SP)
9D00CE00  8FB50028   LW S5, 40(SP)
9D00CE04  8FB40024   LW S4, 36(SP)
9D00CE08  8FB30020   LW S3, 32(SP)
9D00CE0C  8FB2001C   LW S2, 28(SP)
9D00CE10  8FB10018   LW S1, 24(SP)
9D00CE14  8FB00014   LW S0, 20(SP)
9D00CE18  27BD0038   ADDIU SP, SP, 56
9D00CE1C  03E00008   JR RA
9D00CE20  00000000   NOP
463:                 
464:                 // *****************************************************************************
465:                 // *****************************************************************************
466:                 // Section: USB Device Layer Client Interface Functions
467:                 // *****************************************************************************
468:                 // *****************************************************************************
469:                 
470:                 // *****************************************************************************
471:                 /* Function:
472:                     USB_DEVICE_HANDLE USB_DEVICE_Open
473:                     (
474:                         const SYS_MODULE_INDEX index,
475:                         const DRV_IO_INTENT intent
476:                     )
477:                 
478:                   Summary:
479:                     Opens the specific module instance and returns a handle.
480:                 
481:                   Description:
482:                     This function opens the USB device layer for use by any client module and
483:                     provides a handle that must be provided to any of the other device layer
484:                     operations to identify the caller and the instance of the driver/hardware
485:                     module.
486:                 
487:                   Remarks
488:                     Refer to usb_device.h for usage information.
489:                 */
490:                 
491:                 USB_DEVICE_HANDLE USB_DEVICE_Open
492:                 (
493:                     const SYS_MODULE_INDEX index, 
494:                     const DRV_IO_INTENT intent
495:                 )
496:                 {
497:                     USB_DEVICE_OBJ * usbDeviceThisClient;
498:                 
499:                     /* Make sure the index is with in range. */
500:                     if((index < 0) || (index >= USB_DEVICE_INSTANCES_NUMBER))
501:                     {
502:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Index is invalid");
503:                         return(USB_DEVICE_HANDLE_INVALID);
504:                     }
505:                 
506:                     /* Check if the instance is initialized. */   
507:                     if(usbDeviceInstance[index].usbDeviceInstanceState != SYS_STATUS_READY)
508:                     {
509:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Device Layer is not ready to be opened");
510:                         return(USB_DEVICE_HANDLE_INVALID);
511:                     }
512:                 
513:                     /* Copy this local client. This implementation of the device layer only
514:                      * allows one client. Hence there is not seperate client object. The client
515:                      * object is really the device layer object. */
516:                     usbDeviceThisClient = &usbDeviceInstance[index];
517:                 
518:                     if(!usbDeviceThisClient->inUse)
519:                     {
520:                         /* We found a free client object */
521:                         usbDeviceThisClient->inUse = true;
522:                 
523:                         /* Update client status */
524:                         usbDeviceThisClient->clientState = USB_DEVICE_CLIENT_STATUS_READY;
525:                 
526:                         /* Get the Client Handle */
527:                         return((USB_DEVICE_HANDLE)usbDeviceThisClient);
528:                     }
529:                       
530:                     /* If we have reached here, then we did not find a free client object */
531:                     SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: No free client objects");
532:                 
533:                     return(USB_DEVICE_HANDLE_INVALID);   
534:                 }    
535:                 
536:                 // *****************************************************************************
537:                 /* Function:
538:                     void USB_DEVICE_Close( DRV_HANDLE usbDevHandle )
539:                 
540:                   Summary:
541:                     Closes an opened instance of the USB device layer.
542:                 
543:                   Description:
544:                     This function closes an opened instance of the USB device layer,
545:                     invalidating the handle.
546:                 
547:                   Remarks:
548:                     Refer to usb_device.h for usage information.
549:                 */
550:                 
551:                 void USB_DEVICE_Close(USB_DEVICE_HANDLE hClient )
552:                 {
553:                     USB_DEVICE_OBJ* usbClientHandle;
554:                     
555:                     /* Validate the handle */
556:                     
557:                     usbClientHandle = _USB_DEVICE_ClientHandleValidate(hClient);
558:                     if(usbClientHandle == NULL)
559:                     {
560:                        /* Handle is not valid */
561:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Invalid handle");
562:                        return; 
563:                     }
564:                     
565:                     /* Close this client */
566:                     usbClientHandle->clientState = DRV_CLIENT_STATUS_CLOSED;
567:                     usbClientHandle->inUse = false;
568:                 }    
569:                 
570:                 // *****************************************************************************
571:                 /* Function:
572:                     USB_DEVICE_CLIENT_STATUS USB_DEVICE_ClientStatusGet
573:                     (
574:                         USB_DEVICE_HANDLE usbDevHandle
575:                     );
576:                 
577:                   Summary:
578:                     Gets the current client-specific status of the USB device layer.
579:                 
580:                   Description:
581:                     This function gets the client-specific status of the USB device layer
582:                     associated with the specified handle.
583:                 
584:                   Returns:
585:                     Refer to usb_device.h for usage information.
586:                 */
587:                 
588:                 USB_DEVICE_CLIENT_STATUS USB_DEVICE_ClientStatusGet( USB_DEVICE_HANDLE hHandle )
589:                 {
590:                     USB_DEVICE_OBJ * devClientHandle;
591:                 
592:                     devClientHandle = _USB_DEVICE_ClientHandleValidate(hHandle);
593:                 
594:                     if(devClientHandle == NULL)
595:                     {
596:                         return (USB_DEVICE_CLIENT_STATUS_CLOSED);
597:                     }
598:                     
599:                     /* Return the state of the client. */  
600:                     return( devClientHandle->clientState ); 
601:                 }
602:                 
603:                 // *****************************************************************************
604:                 /* Function:
605:                     void USB_DEVICE_Tasks_ISR (SYS_MODULE_OBJ devLayerObj);
606:                 
607:                   Summary:
608:                     USB Device Layer Tasks routine to be called in the USB Interrupt Service
609:                     Routine.
610:                 
611:                   Description:
612:                     This function must be called in the USB Interrupt Service Routine if the
613:                     Device Stack is configured for interrupt mode. In case the Device Stack is
614:                     configured for polling mode, this function is automatically called from the
615:                     USB_DEVICE_Tasks() function. devLayerObj must be the system module object
616:                     associated with the USB module generating the interrupt.
617:                 
618:                   Remarks:
619:                     Refer to usb_device.h for usage information.
620:                 */
621:                 
622:                 void USB_DEVICE_Tasks_ISR(SYS_MODULE_OBJ devLayerObj)
623:                 {
624:                     USB_DEVICE_OBJ * usbDeviceThisInstance;
625:                 
626:                     /* Assert object is valid. */
627:                     if(devLayerObj == SYS_MODULE_OBJ_INVALID)
628:                     {
629:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: System Module Object is invalid");
630:                         return;
631:                     }
632:                 
633:                     /* Get this instance of USB device layer.*/
634:                     usbDeviceThisInstance = &usbDeviceInstance[devLayerObj];
635:                 
636:                     /* Proceed only if this instance is in initialized state. */
637:                     if( usbDeviceThisInstance->usbDeviceInstanceState <= SYS_STATUS_UNINITIALIZED )
638:                     {
639:                         /* Instance is not yet initialized. Just do a return. */
640:                         return;
641:                     }
642:                 
643:                     DRV_USB_Tasks_ISR(usbDeviceThisInstance->usbCDSystemModuleObject);
644:                 }
645:                 
646:                 void USB_DEVICE_Tasks_ISR_USBDMA(SYS_MODULE_OBJ devLayerObj)
647:                 {
648:                     USB_DEVICE_OBJ * usbDeviceThisInstance;
649:                 
650:                     /* Assert object is valid. */
651:                     if(devLayerObj == SYS_MODULE_OBJ_INVALID)
652:                     {
653:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: System Module Object is invalid");
654:                         return;
655:                     }
656:                 
657:                     /* Get this instance of USB device layer.*/
658:                     usbDeviceThisInstance = &usbDeviceInstance[devLayerObj];
659:                 
660:                     /* Proceed only if this instance is in initialized state. */
661:                     if( usbDeviceThisInstance->usbDeviceInstanceState <= SYS_STATUS_UNINITIALIZED )
662:                     {
663:                         /* Instance is not yet initialized. Just do a return. */
664:                         return;
665:                     }
666:                 
667:                     DRV_USB_Tasks_ISR_DMA(usbDeviceThisInstance->usbCDSystemModuleObject);
668:                 }
669:                 
670:                 // ******************************************************************************
671:                 /* Function:
672:                     void USB_DEVICE_EventCallBackSet
673:                     (
674:                         USB_DEVICE_HANDLE hHandle,
675:                         const USB_DEVICE_EVENT_HANDLER callBackFunc
676:                         uintptr_t context
677:                     );
678:                 
679:                   Summary:
680:                     Sets up the callback function that will be called in case of an
681:                     event from the USB device layer.
682:                 
683:                   Description:
684:                     This function sets up the callback function. This callback function 
685:                     will be called when an event occurs in the USB device layer.
686:                 
687:                   Remarks:
688:                     Refer to usb_device.h for usage information.
689:                 */
690:                 
691:                 void USB_DEVICE_EventHandlerSet
692:                 (
693:                     USB_DEVICE_HANDLE hHandle, 
694:                     const USB_DEVICE_EVENT_HANDLER callBackFunc,
695:                     uintptr_t context
696:                 )
697:                 {
698:                     USB_DEVICE_OBJ* devClientHandle;
699:                 
700:                     /* Validate the handle */
701:                 
702:                     devClientHandle = _USB_DEVICE_ClientHandleValidate(hHandle);
703:                     if(devClientHandle == NULL)
704:                     {
705:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Invalid client handle");
706:                         return;
707:                     }
708:                 
709:                     /* Register the callback function. Note that the call back function is
710:                      * invoked for control transfer events.  */
711:                     devClientHandle->callBackFunc = callBackFunc;
712:                     devClientHandle->context = context;
713:                 
714:                     /* Register a callback with the driver. */
715:                     DRV_USB_ClientEventCallBackSet(devClientHandle->usbCDHandle, (uintptr_t)devClientHandle, &_USB_DEVICE_EventHandler);
716:                 }   
717:                 
718:                 // ******************************************************************************
719:                 /* Function:
720:                    uint8_t USB_DEVICE_ActiveConfigurationGet( USB_DEVICE_HANDLE usbDeviceHandle )
721:                 
722:                   Summary:
723:                     Informs the client of the current USB device configuration set by the USB
724:                     host.
725:                 
726:                   Description:
727:                     This function returns the current active USB device configuration.
728:                 
729:                   Precondition:
730:                     The USB Device Layer must have been initialized and opened before calling this
731:                     function.
732:                 
733:                   Remarks:  
734:                     See usb_device.h for usage information.
735:                 */
736:                 
737:                 uint8_t USB_DEVICE_ActiveConfigurationGet(USB_DEVICE_HANDLE hHandle)
738:                 {
739:                     USB_DEVICE_OBJ * devClientHandle;
740:                 
741:                     /* Validate the client handle */
742:                 
743:                     devClientHandle = _USB_DEVICE_ClientHandleValidate(hHandle);
744:                     if(devClientHandle == NULL)
745:                     {
746:                         /* Client handle is invalid */
747:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Invalid client handle");
748:                         return(0);
749:                     }
750:                     
751:                     return(devClientHandle->activeConfiguration);
752:                 }
753:                 
754:                 // *****************************************************************************
755:                 /* Function:
756:                     USB_SPEED USB_DEVICE_ActiveSpeedGet(USB_DEVICE_HANDLE usbDeviceHandle)
757:                 
758:                   Summary:
759:                     Informs the client of the current operation speed of the USB bus.
760:                 
761:                   Description:
762:                     The USB device stack supports both high speed and full speed operations.
763:                     This function returns the current operation speed of the USB bus. This
764:                     function should be called after the USB_DEVICE_EVENT_RESET event has
765:                     occurred.
766:                 
767:                   Precondition:
768:                     The USB device layer must have been initialized and a valid handle
769:                     to USB device layer must have been opened.
770:                   
771:                   Remarks:  
772:                     See usb_device.h for usage information.
773:                 */
774:                 
775:                 USB_SPEED USB_DEVICE_ActiveSpeedGet(USB_DEVICE_HANDLE hHandle)
776:                 {
777:                     USB_DEVICE_OBJ* devClientHandle;
778:                     
779:                     /* Validate the handle */
780:                     devClientHandle = _USB_DEVICE_ClientHandleValidate(hHandle);
781:                 
782:                     if(devClientHandle == NULL)
783:                     {
784:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Invalid Handle");
785:                         return(USB_SPEED_LOW);
786:                     }
787:                 
788:                     /* Return the current speed */
789:                     return(devClientHandle->usbDeviceStatusStruct.usbSpeed);
790:                 }
791:                 
792:                 // *****************************************************************************
793:                 /* Function:
794:                     USB_DEVICE_CONTROL_TRANSFER_RESULT USB_DEVICE_ControlSend
795:                     (
796:                         USB_DEVICE_HANDLE usbDeviceHandle,
797:                         uint8_t * data, 
798:                         size_t length 
799:                     )
800:                 
801:                   Summary:
802:                     Sends data stage of the control transfer from device to host.
803:                 
804:                   Description:
805:                     Sends data stage of the control transfer from device to host.
806:                 
807:                   Remarks:
808:                     Refer to usb_device.h for usage information.
809:                 */
810:                 
811:                 USB_DEVICE_CONTROL_TRANSFER_RESULT USB_DEVICE_ControlSend
812:                 (
813:                     USB_DEVICE_HANDLE hClient,
814:                     void * data, 
815:                     size_t length 
816:                 )
817:                 {
9D012D08  27BDFFE0   ADDIU SP, SP, -32
9D012D0C  AFBF001C   SW RA, 28(SP)
9D012D10  AFB10018   SW S1, 24(SP)
9D012D14  AFB00014   SW S0, 20(SP)
9D012D18  00A08821   ADDU S1, A1, ZERO
818:                     USB_DEVICE_OBJ * usbDeviceThisInstance;
819:                     USB_DEVICE_IRP * irpHandle;   
820:                 
821:                     usbDeviceThisInstance = _USB_DEVICE_ClientHandleValidate(hClient);
9D012D1C  0F4054AB   JAL _USB_DEVICE_ClientHandleValidate
9D012D20  00C08021   ADDU S0, A2, ZERO
822:                 
823:                     /* Validate the client handle */
824:                     if(usbDeviceThisInstance == NULL)
9D012D24  50400014   BEQL V0, ZERO, 0x9D012D78
9D012D28  2402FF8B   ADDIU V0, ZERO, -117
825:                     {
826:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Invalid Client Handle");
827:                         return(USB_DEVICE_CONTROL_TRANSFER_RESULT_FAILED);
828:                     }
829:                 
830:                     /* Get a handle to the TX IRP */
831:                     irpHandle = &usbDeviceThisInstance->irpEp0Tx;     
832:                     irpHandle->data = data;
9D012D2C  AC510060   SW S1, 96(V0)
833:                     irpHandle->size = (unsigned int )length;
9D012D30  AC500064   SW S0, 100(V0)
834:                 
835:                     /* The function assumes the control transfer was initiated by the host and
836:                      * the setup command has been received. controlTransferDataStageSize in such
837:                      * a case will have the size of the control transfer data stage size. If the
838:                      * length submitted by application is what the host is expecting, then we
839:                      * dont have to send a ZLP. If the length is less than the what the host is
840:                      * expecting then we should send a ZLP. */
841:                 
842:                     if(length == usbDeviceThisInstance->controlTransferDataStageSize)
9D012D34  944300E4   LHU V1, 228(V0)
9D012D38  14700004   BNE V1, S0, 0x9D012D4C
9D012D3C  24460060   ADDIU A2, V0, 96
843:                     {
844:                         /* This means we are sending the amount of data that is required.
845:                          * So no need to send send ZLP */
846:                         irpHandle->flags = USB_DEVICE_IRP_FLAG_DATA_PENDING;
9D012D40  24030002   ADDIU V1, ZERO, 2
9D012D44  0B404B58   J 0x9D012D60
9D012D48  AC430070   SW V1, 112(V0)
847:                     }
848:                     else if (length < usbDeviceThisInstance->controlTransferDataStageSize )
9D012D4C  0203802B   SLTU S0, S0, V1
9D012D50  52000004   BEQL S0, ZERO, 0x9D012D64
9D012D54  8C4300EC   LW V1, 236(V0)
849:                     {
850:                         /* The length is less than requested. We let the driver manage the
851:                          * ZLP. */
852:                         irpHandle->flags = USB_DEVICE_IRP_FLAG_DATA_COMPLETE;
9D012D58  24030001   ADDIU V1, ZERO, 1
9D012D5C  AC430070   SW V1, 112(V0)
853:                     }
854:                 
855:                     /* Submit the IRP to the USBCD */
856:                     (void)DRV_USB_DEVICE_IRPSubmit( usbDeviceThisInstance->usbCDHandle, controlEndpointTx, irpHandle);
9D012D60  8C4300EC   LW V1, 236(V0)
9D012D64  8C630038   LW V1, 56(V1)
9D012D68  8C440018   LW A0, 24(V0)
9D012D6C  0060F809   JALR V1
9D012D70  24050080   ADDIU A1, ZERO, 128
9D012D74  00001021   ADDU V0, ZERO, ZERO
857:                 
858:                     return USB_DEVICE_CONTROL_TRANSFER_RESULT_SUCCESS;
859:                 }
9D012D78  8FBF001C   LW RA, 28(SP)
860:                 
861:                 // *****************************************************************************
862:                 /* Function:
863:                     USB_DEVICE_CONTROL_TRANSFER_RESULT USB_DEVICE_ControlReceive
864:                     (
865:                         USB_DEVICE_HANDLE usbDeviceHandle,
866:                         void * data, 
867:                         size_t length
868:                     )
869:                 
870:                   Summary:
871:                     Receives data stage of the control transfer from host to device.
872:                 
873:                   Description:
874:                     Receives data stage of the control transfer from host to device.
875:                 
876:                   Remarks:
877:                     Refer to usb_device.h for usage information.
878:                 */
879:                 
880:                 USB_DEVICE_CONTROL_TRANSFER_RESULT USB_DEVICE_ControlReceive
881:                 (
882:                     USB_DEVICE_HANDLE handle,
883:                     void * data, 
884:                     size_t length
885:                 )
886:                 {
887:                     USB_DEVICE_CONTROL_TRANSFER_STRUCT * pControlTransfer;
888:                     USB_DEVICE_OBJ * client;
889:                 
890:                     /* Validate the client handle */
891:                     client = _USB_DEVICE_ClientHandleValidate(handle);
892:                     if(client == NULL)
893:                     {
894:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Invalid Client Handle");
895:                         return(USB_DEVICE_CONTROL_TRANSFER_RESULT_FAILED);
896:                     }
897:                 
898:                     /* Get the control transfer object. The device layer is always ready to
899:                      * receive data from the device. It needs to know however where the received
900:                      * data should be placed. This is determined by the rxBuffer member of the
901:                      * control transfer object. */
902:                     pControlTransfer = &client->controlTransfer;
903:                     pControlTransfer->rxBuffer = data ;
904:                     pControlTransfer->rxDataCount = 0;
905:                     pControlTransfer->expectedRxDataCount = length ;
906:                 
907:                     /* We are always ready to receive data on endpoint 0. So no need to submit a
908:                      * IRP */
909:                     return USB_DEVICE_CONTROL_TRANSFER_RESULT_SUCCESS;
910:                 }
911:                 
912:                 // *****************************************************************************
913:                 /* Function:
914:                     USB_DEVICE_CONTROL_TRANSFER_RESULT USB_DEVICE_ControlStatus
915:                     (
916:                         USB_DEVICE_HANDLE hClient,
917:                         USB_DEVICE_CONTROL_STATUS status 
918:                     )
919:                 
920:                   Summary:
921:                     Initiates status stage of the control transfer.
922:                 
923:                   Description:
924:                     Initiates status stage of the control transfer.
925:                 
926:                   Remarks:
927:                     Refer to usb_device.h for usage information.
928:                 */
929:                 
930:                 USB_DEVICE_CONTROL_TRANSFER_RESULT USB_DEVICE_ControlStatus
931:                 (
932:                     USB_DEVICE_HANDLE handle,
933:                     USB_DEVICE_CONTROL_STATUS status
934:                 )
935:                 {
9D012F0C  27BDFFE8   ADDIU SP, SP, -24
9D012F10  AFBF0014   SW RA, 20(SP)
9D012F14  AFB00010   SW S0, 16(SP)
936:                     USB_DEVICE_OBJ * usbDeviceThisInstance;
937:                     USB_DEVICE_IRP * irpHandle;
938:                 
939:                     usbDeviceThisInstance = _USB_DEVICE_ClientHandleValidate(handle);
9D012F18  0F4054AB   JAL _USB_DEVICE_ClientHandleValidate
9D012F1C  00A08021   ADDU S0, A1, ZERO
940:                     if(usbDeviceThisInstance == NULL)
9D012F20  10400014   BEQ V0, ZERO, 0x9D012F74
9D012F24  24030001   ADDIU V1, ZERO, 1
941:                     {
942:                         /* Client handle is not valid */
943:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Invalid Client Handle");
944:                         return(USB_DEVICE_CONTROL_TRANSFER_RESULT_FAILED);
9D012F74  2402FF8B   ADDIU V0, ZERO, -117
945:                     }
946:                 
947:                     usbDeviceThisInstance->controlTransfer.inProgress = false;
948:                 
949:                     if(USB_DEVICE_CONTROL_STATUS_ERROR == status)
9D012F28  16030008   BNE S0, V1, 0x9D012F4C
9D012F2C  A04000C0   SB ZERO, 192(V0)
950:                     {
951:                         /* This means the control transfer should be stalled. We stall endpoint
952:                          * 0 */
953:                         DRV_USB_DEVICE_EndpointStall(usbDeviceThisInstance->usbCDHandle , controlEndpointTx);        
9D012F30  8C4300EC   LW V1, 236(V0)
9D012F34  8C630028   LW V1, 40(V1)
9D012F38  8C440018   LW A0, 24(V0)
9D012F3C  0060F809   JALR V1
9D012F40  24050080   ADDIU A1, ZERO, 128
9D012F44  0B404BDE   J 0x9D012F78
9D012F48  00001021   ADDU V0, ZERO, ZERO
954:                     }
955:                     else
956:                     {
957:                         /* We must acknowledge the control transfer. This is done by sending a
958:                          * ZLP */
959:                         irpHandle = &usbDeviceThisInstance->irpEp0Tx;
960:                         irpHandle->data = NULL;
9D012F4C  AC400060   SW ZERO, 96(V0)
961:                         irpHandle->size = 0;
9D012F50  AC400064   SW ZERO, 100(V0)
962:                 
963:                         (void)DRV_USB_DEVICE_IRPSubmit( usbDeviceThisInstance->usbCDHandle, controlEndpointTx, irpHandle);
9D012F54  8C4300EC   LW V1, 236(V0)
9D012F58  8C630038   LW V1, 56(V1)
9D012F5C  8C440018   LW A0, 24(V0)
9D012F60  24050080   ADDIU A1, ZERO, 128
9D012F64  0060F809   JALR V1
9D012F68  24460060   ADDIU A2, V0, 96
964:                     }
965:                 
966:                     return USB_DEVICE_CONTROL_TRANSFER_RESULT_SUCCESS;
9D012F6C  0B404BDE   J 0x9D012F78
9D012F70  00001021   ADDU V0, ZERO, ZERO
967:                 }
9D012F78  8FBF0014   LW RA, 20(SP)
9D012F7C  8FB00010   LW S0, 16(SP)
9D012F80  03E00008   JR RA
9D012F84  27BD0018   ADDIU SP, SP, 24
968:                 // *****************************************************************************
969:                 /* Function:
970:                     void USB_DEVICE_PowerStateSet
971:                     (
972:                         USB_DEVICE_HANDLE handle,
973:                         USB_DEVICE_POWER_STATE state
974:                     )
975:                 
976:                   Summary:
977:                     Sets the power state of the device.
978:                 
979:                   Description:
980:                     Sets the power state of the device.
981:                     
982:                   Remarks:
983:                     Refer to usb_device.h for usage information.
984:                 */
985:                 
986:                 void USB_DEVICE_PowerStateSet
987:                 (
988:                     USB_DEVICE_HANDLE handle,
989:                     USB_DEVICE_POWER_STATE state
990:                 )
991:                 {
992:                     USB_DEVICE_OBJ* client;
993:                 
994:                     /* Validate the client handle */
995:                 
996:                     client = _USB_DEVICE_ClientHandleValidate(handle);
997:                     if(client == NULL)
998:                     {
999:                         /* Client handle is invalid */
1000:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Invalid Handle");
1001:                        return;
1002:                    }
1003:                
1004:                    /* Store the power state */
1005:                    client->usbDeviceStatusStruct.powerState = state;
1006:                }
1007:                
1008:                // ******************************************************************************
1009:                /* Function:
1010:                    USB_DEVICE_REMOTE_WAKEUP_STATUS USB_DEVICE_RemoteWakeupStatusGet
1011:                    (
1012:                        USB_DEVICE_HANDLE handle
1013:                    )
1014:                
1015:                  Summary:
1016:                    This function returns the status of remote wakeup capability of the device.
1017:                
1018:                  Description:
1019:                    This function returns the status of remote wakeup capability of the device.
1020:                
1021:                  Remarks:
1022:                    Refer to usb_device.h for usage information.
1023:                */
1024:                
1025:                USB_DEVICE_REMOTE_WAKEUP_STATUS USB_DEVICE_RemoteWakeupStatusGet
1026:                (
1027:                    USB_DEVICE_HANDLE handle
1028:                )
1029:                {
1030:                    USB_DEVICE_OBJ* client;
1031:                
1032:                    /* Validate the client handle */
1033:                
1034:                    client = _USB_DEVICE_ClientHandleValidate(handle);
1035:                    if(client == NULL)
1036:                    {
1037:                        /* Client handle is invalid */
1038:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Invalid Handle");
1039:                        return USB_DEVICE_REMOTE_WAKEUP_DISABLED;
1040:                    }
1041:                
1042:                    return (client->remoteWakeupStatus);
1043:                }
1044:                
1045:                // *****************************************************************************
1046:                /* Function:
1047:                    void USB_DEVICE_RemoteWakeupStop ( USB_DEVICE_HANDLE usbDeviceHandle )
1048:                
1049:                  Summary:
1050:                    This function will stop the resume signalling.
1051:                
1052:                  Description:
1053:                    This function will stop the resume signalling. This function should be
1054:                    called after the client has called the USB_DEVICE_RemoteWakeupStart()
1055:                    function.
1056:                
1057:                  Remarks:
1058:                    Refer to usb_device.h for usage information.
1059:                */
1060:                
1061:                void USB_DEVICE_RemoteWakeupStop( USB_DEVICE_HANDLE handle )
1062:                {
1063:                    USB_DEVICE_OBJ* usbDeviceThisInstance;
1064:                
1065:                    /* Validate the device handle */
1066:                    usbDeviceThisInstance = _USB_DEVICE_ClientHandleValidate(handle);
1067:                    if(NULL == usbDeviceThisInstance)
1068:                    {
1069:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer Client Handle is invalid");
1070:                        return;
1071:                    }
1072:                
1073:                    /* Call the driver remote wake up function here */
1074:                    DRV_USB_DEVICE_RemoteWakeupStop(usbDeviceThisInstance->usbCDHandle);
1075:                }
1076:                
1077:                // *****************************************************************************
1078:                /* Function:
1079:                    void USB_DEVICE_RemoteWakeupStart( USB_DEVICE_HANDLE usbDeviceHandle )
1080:                
1081:                  Summary:
1082:                    This function will start the resume signalling.
1083:                
1084:                  Description:
1085:                    This function will start the resume signalling on the bus. The client calls
1086:                    this function after it has detected a idle bus (through the
1087:                    USB_DEVICE_EVENT_SUSPENDED event). The remote wakeup feature should have
1088:                    been enabled by the host, before the client can call this function. The
1089:                    client can use the USB_DEVICE_RemoteWakeupStatusGet() function to check if
1090:                    the host has enabled the remote wakeup feature.
1091:                
1092:                  Remarks:
1093:                    Refer to usb_device.h for usage information.
1094:                */
1095:                
1096:                void USB_DEVICE_RemoteWakeupStart( USB_DEVICE_HANDLE usbDeviceHandle )
1097:                {
1098:                    USB_DEVICE_OBJ * usbDeviceThisInstance;
1099:                
1100:                    /* Validate the device handle */
1101:                    usbDeviceThisInstance = _USB_DEVICE_ClientHandleValidate(usbDeviceHandle);
1102:                    if(NULL == usbDeviceThisInstance)
1103:                    {
1104:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer Client Handle is invalid");
1105:                        return;
1106:                    }
1107:                
1108:                    /* Call the driver remote wake up function here */
1109:                    DRV_USB_DEVICE_RemoteWakeupStart(usbDeviceThisInstance->usbCDHandle);
1110:                }
1111:                
1112:                // *****************************************************************************
1113:                // *****************************************************************************
1114:                // Section: USB Device Layer Local Functions
1115:                // *****************************************************************************
1116:                // *****************************************************************************
1117:                
1118:                // ******************************************************************************
1119:                /* Function:
1120:                    void _USB_DEVICE_Ep0ReceiveCompleteCallback( USB_DEVICE_IRP * handle )
1121:                
1122:                  Summary:
1123:                    Control receive complete callback.
1124:                
1125:                  Description:
1126:                    This callback is called when either data/SETUP packet is received
1127:                    on the control endpoint.
1128:                
1129:                  Remarks:
1130:                    This is local function. It should not be used directly by the client.
1131:                */
1132:                
1133:                void _USB_DEVICE_Ep0ReceiveCompleteCallback( USB_DEVICE_IRP * handle )
1134:                {
9D00C6DC  27BDFFE0   ADDIU SP, SP, -32
9D00C6E0  AFBF001C   SW RA, 28(SP)
9D00C6E4  AFB10018   SW S1, 24(SP)
9D00C6E8  AFB00014   SW S0, 20(SP)
1135:                    USB_DEVICE_IRP * irpHandle = (USB_DEVICE_IRP *)handle;
1136:                    USB_DEVICE_OBJ * usbDeviceThisInstance;  
1137:                    USB_DEVICE_EVENT controlEvent = 0;
1138:                    USB_DEVICE_CONTROL_TRANSFER_STRUCT * controlTransfer;
1139:                    void * eventData;
1140:                
1141:                    /* If the IRP was aborted, there is nothing for us to do */
1142:                    if(irpHandle->status == USB_DEVICE_IRP_STATUS_ABORTED)
9D00C6EC  8C820008   LW V0, 8(A0)
9D00C6F0  2403FFFE   ADDIU V1, ZERO, -2
9D00C6F4  10430055   BEQ V0, V1, 0x9D00C84C
9D00C6F8  00808821   ADDU S1, A0, ZERO
1143:                    {
1144:                        return;
1145:                    }
1146:                
1147:                    usbDeviceThisInstance = (USB_DEVICE_OBJ *)irpHandle->userData;
1148:                    controlTransfer = &usbDeviceThisInstance->controlTransfer;
1149:                
1150:                    /* Something is received on EP0. */
1151:                
1152:                    if(irpHandle->status == USB_DEVICE_IRP_STATUS_SETUP)
9D00C6FC  24030002   ADDIU V1, ZERO, 2
9D00C700  1443001D   BNE V0, V1, 0x9D00C778
9D00C704  8C900014   LW S0, 20(A0)
1153:                    {
1154:                        /* If we have received a SETUP packet, then abort any on-going control
1155:                         * transfer. Reset the control transfer handler back to the device layer
1156:                         * */
1157:                
1158:                        if(controlTransfer->inProgress )
9D00C708  920200C0   LBU V0, 192(S0)
9D00C70C  10400011   BEQ V0, ZERO, 0x9D00C754
9D00C710  24020001   ADDIU V0, ZERO, 1
1159:                        {
1160:                            /* Abort any previous transfer */
1161:                            if ( controlTransfer->handler != NULL)
9D00C714  8E0200CC   LW V0, 204(S0)
9D00C718  5040000E   BEQL V0, ZERO, 0x9D00C754
9D00C71C  24020001   ADDIU V0, ZERO, 1
1162:                            {
1163:                                if (controlTransfer->handler == (void*)usbDeviceThisInstance->callBackFunc)
9D00C720  8E0300DC   LW V1, 220(S0)
9D00C724  54430007   BNEL V0, V1, 0x9D00C744
9D00C728  960400C4   LHU A0, 196(S0)
1164:                                {
1165:                                    /* If the Control transfer handler is Application callback
1166:                                     * for USB Device layer, then invoke the application
1167:                                     * callback function.  */
1168:                
1169:                                    usbDeviceThisInstance->callBackFunc(USB_DEVICE_EVENT_CONTROL_TRANSFER_ABORTED, NULL, usbDeviceThisInstance->context ); 
9D00C72C  2404000C   ADDIU A0, ZERO, 12
9D00C730  00002821   ADDU A1, ZERO, ZERO
9D00C734  0040F809   JALR V0
9D00C738  8E0600E0   LW A2, 224(S0)
9D00C73C  0B4031D5   J 0x9D00C754
9D00C740  24020001   ADDIU V0, ZERO, 1
1170:                                }
1171:                                else
1172:                                {
1173:                                    /* This means the in progress control transfer was initiated
1174:                                     * by a function driver or the device layer it self. */
1175:                                    controlTransfer->handler(controlTransfer->handlerIndex, USB_DEVICE_EVENT_CONTROL_TRANSFER_ABORTED , NULL );
9D00C744  2405000C   ADDIU A1, ZERO, 12
9D00C748  0040F809   JALR V0
9D00C74C  00003021   ADDU A2, ZERO, ZERO
1176:                                }
1177:                            }
1178:                            else
1179:                            {
1180:                                SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Control transfer Handler is NULL" );
1181:                            }
1182:                        }
1183:                
1184:                        /* Mark the control transfer as "in progress". */
1185:                        controlTransfer->inProgress = true;
9D00C750  24020001   ADDIU V0, ZERO, 1
9D00C754  A20200C0   SB V0, 192(S0)
1186:                
1187:                        /* Now change the transfer handler back to USB device layer handler. We
1188:                         * need to send the SETUP packet event and the SETUP packet to the
1189:                         * device layer */
1190:                        controlTransfer->handler = &_USB_DEVICE_ControlTransferHandler;
9D00C758  3C029D01   LUI V0, -25343
9D00C75C  24429400   ADDIU V0, V0, -27648
9D00C760  AE0200CC   SW V0, 204(S0)
1191:                        controlTransfer->handlerIndex = usbDeviceThisInstance->usbDevLayerIndex;
9D00C764  96020014   LHU V0, 20(S0)
9D00C768  A60200C4   SH V0, 196(S0)
1192:                        controlEvent = USB_DEVICE_EVENT_CONTROL_TRANSFER_SETUP_REQUEST; 
1193:                        eventData = usbDeviceThisInstance->ep0RxBuffer;
9D00C76C  26060020   ADDIU A2, S0, 32
9D00C770  0B40320D   J 0x9D00C834
9D00C774  2405000E   ADDIU A1, ZERO, 14
1194:                
1195:                    }
1196:                    else if( irpHandle->size == 0)
9D00C778  8C860004   LW A2, 4(A0)
9D00C77C  54C00004   BNEL A2, ZERO, 0x9D00C790
9D00C780  920200C0   LBU V0, 192(S0)
1197:                    {
1198:                        /* ZLP received. This marks the completion of control transfer. Inform
1199:                         * the handler. */
1200:                        controlTransfer->inProgress = false;
9D00C784  A20000C0   SB ZERO, 192(S0)
9D00C788  0B40320D   J 0x9D00C834
9D00C78C  2405000F   ADDIU A1, ZERO, 15
1201:                        controlEvent = USB_DEVICE_EVENT_CONTROL_TRANSFER_DATA_SENT;
1202:                        eventData = NULL;
1203:                    }
1204:                    else if( irpHandle->size &&  controlTransfer->inProgress )
9D00C790  1040001C   BEQ V0, ZERO, 0x9D00C804
9D00C794  24020040   ADDIU V0, ZERO, 64
1205:                    {
1206:                        /* We are in the data stage of the control transfer.  See if the control
1207:                         * transfer handler was expecting the data. */
1208:                
1209:                        if(controlTransfer->rxDataCount <  controlTransfer->expectedRxDataCount)
9D00C798  920200C1   LBU V0, 193(S0)
9D00C79C  920300C2   LBU V1, 194(S0)
9D00C7A0  0043182B   SLTU V1, V0, V1
9D00C7A4  50600020   BEQL V1, ZERO, 0x9D00C828
9D00C7A8  00003021   ADDU A2, ZERO, ZERO
1210:                        {
1211:                            /* Copy the RX buffer to control transfer handler given driver
1212:                             * buffer and advance the buffer. Continue the transfer  */
1213:                            memcpy(&usbDeviceThisInstance->controlTransfer.rxBuffer[controlTransfer->rxDataCount], usbDeviceThisInstance->ep0RxBuffer, irpHandle->size );
9D00C7AC  8E0400C8   LW A0, 200(S0)
9D00C7B0  00822021   ADDU A0, A0, V0
9D00C7B4  0F40343F   JAL memcpy
9D00C7B8  26050020   ADDIU A1, S0, 32
1214:                            controlTransfer->rxDataCount += irpHandle->size;
9D00C7BC  8E230004   LW V1, 4(S1)
9D00C7C0  920200C1   LBU V0, 193(S0)
9D00C7C4  00621021   ADDU V0, V1, V0
9D00C7C8  304200FF   ANDI V0, V0, 255
9D00C7CC  A20200C1   SB V0, 193(S0)
1215:                        }
1216:                        
1217:                        /* Now that we have received the data, check if the IRP is completed */
1218:                        if(controlTransfer->rxDataCount >=  controlTransfer->expectedRxDataCount)
9D00C7D0  920300C2   LBU V1, 194(S0)
9D00C7D4  0043102B   SLTU V0, V0, V1
9D00C7D8  1440000A   BNE V0, ZERO, 0x9D00C804
9D00C7DC  24020040   ADDIU V0, ZERO, 64
9D00C7E0  0B40320C   J 0x9D00C830
9D00C7E4  00003021   ADDU A2, ZERO, ZERO
1219:                        {
1220:                            /* We have received all the the data that we need. Send an event to
1221:                             * the upper layer */
1222:                            controlEvent = USB_DEVICE_EVENT_CONTROL_TRANSFER_DATA_RECEIVED;
9D00C828  0B40320D   J 0x9D00C834
9D00C82C  2405000D   ADDIU A1, ZERO, 13
9D00C830  2405000D   ADDIU A1, ZERO, 13
1223:                            eventData = NULL;
1224:                        }
1225:                    }
1226:                
1227:                    if(controlEvent)
1228:                    {
1229:                        /* This means that some type of control transfer event needs to be sent
1230:                         * either to the the device layer or to the function driver or client
1231:                         * driver function driver layer. If a Setup packet was recieved, then
1232:                         * this will always go the device layer first. If this was a data stage
1233:                         * or handshake stage, then entity that was responsible for completing
1234:                         * the control transfer handles the events. */
1235:                
1236:                        if (controlTransfer->handler == (void*)usbDeviceThisInstance->callBackFunc)
9D00C834  8E0200CC   LW V0, 204(S0)
9D00C838  8E0300DC   LW V1, 220(S0)
9D00C83C  1443FFEE   BNE V0, V1, 0x9D00C7F8
9D00C840  00A02021   ADDU A0, A1, ZERO
9D00C844  0B4031FA   J 0x9D00C7E8
9D00C848  00C02821   ADDU A1, A2, ZERO
1237:                        {
1238:                            /* If the Control transfer handler is Application callback for USB Device layer,
1239:                             * then invoke the application callback function.  */
1240:                            usbDeviceThisInstance->callBackFunc(controlEvent, eventData, usbDeviceThisInstance->context ); 
9D00C7E8  0040F809   JALR V0
9D00C7EC  8E0600E0   LW A2, 224(S0)
9D00C7F0  0B403201   J 0x9D00C804
9D00C7F4  24020040   ADDIU V0, ZERO, 64
1241:                        }
1242:                        else
1243:                        {
1244:                            /* Propagate the event to the control transfer handler */
1245:                            controlTransfer->handler(controlTransfer->handlerIndex, controlEvent , eventData);
9D00C7F8  0040F809   JALR V0
9D00C7FC  960400C4   LHU A0, 196(S0)
1246:                        }
1247:                    }
1248:                
1249:                    usbDeviceThisInstance->irpEp0Rx.size = USB_DEVICE_EP0_BUFFER_SIZE;
9D00C800  24020040   ADDIU V0, ZERO, 64
9D00C804  AE020088   SW V0, 136(S0)
1250:                
1251:                    /* Submit IRP to endpoint 0 to receive the next data packet. */
1252:                    (void)DRV_USB_DEVICE_IRPSubmit( usbDeviceThisInstance->usbCDHandle, controlEndpointRx , &usbDeviceThisInstance->irpEp0Rx);
9D00C808  8E0200EC   LW V0, 236(S0)
9D00C80C  8C420038   LW V0, 56(V0)
9D00C810  8E040018   LW A0, 24(S0)
9D00C814  00002821   ADDU A1, ZERO, ZERO
9D00C818  0040F809   JALR V0
9D00C81C  26060084   ADDIU A2, S0, 132
1253:                }
9D00C820  0B403214   J 0x9D00C850
9D00C824  8FBF001C   LW RA, 28(SP)
9D00C84C  8FBF001C   LW RA, 28(SP)
9D00C850  8FB10018   LW S1, 24(SP)
9D00C854  8FB00014   LW S0, 20(SP)
9D00C858  03E00008   JR RA
9D00C85C  27BD0020   ADDIU SP, SP, 32
1254:                
1255:                // ******************************************************************************
1256:                /* Function:
1257:                    void _USB_DEVICE_Ep0TransmitCompleteCallback( void * handle)
1258:                
1259:                  Summary:
1260:                    EP0 transmit complete callback.
1261:                
1262:                  Description:
1263:                    This function is called by the controller driver after the completing the
1264:                    EP0 transmit.
1265:                
1266:                  Returns:
1267:                    This is local function. It should not be used directly by the client.
1268:                */
1269:                
1270:                void _USB_DEVICE_Ep0TransmitCompleteCallback(USB_DEVICE_IRP * handle)
1271:                {
9D0115E8  27BDFFE0   ADDIU SP, SP, -32
9D0115EC  AFBF001C   SW RA, 28(SP)
9D0115F0  AFB10018   SW S1, 24(SP)
9D0115F4  AFB00014   SW S0, 20(SP)
9D0115F8  00808821   ADDU S1, A0, ZERO
1272:                    USB_DEVICE_IRP * irpHandle = (USB_DEVICE_IRP *)handle;
1273:                    USB_DEVICE_OBJ * usbDeviceThisInstance;
1274:                    USB_DEVICE_CONTROL_TRANSFER_STRUCT * controlTransfer;
1275:                
1276:                    usbDeviceThisInstance = (USB_DEVICE_OBJ *)irpHandle->userData;
1277:                    controlTransfer = &(usbDeviceThisInstance->controlTransfer);
1278:                    
1279:                    if(irpHandle->status == USB_DEVICE_IRP_STATUS_ABORTED)
9D0115FC  8C830008   LW V1, 8(A0)
9D011600  2402FFFE   ADDIU V0, ZERO, -2
9D011604  1062001F   BEQ V1, V0, 0x9D011684
9D011608  8C900014   LW S0, 20(A0)
1280:                    {
1281:                        return;
1282:                    }
1283:                
1284:                    /* If the device layer had recieved the set address request from the host
1285:                     * and we have now recieved a transmit complete callback, then this means we
1286:                     * have completed the handshake stage of the callback function and now need
1287:                     * to set the device address. */ 
1288:                    if(usbDeviceThisInstance->usbDeviceStatusStruct.setAddressPending)
9D01160C  8E020000   LW V0, 0(S0)
9D011610  7C420100   EXT V0, V0, 4, 1
9D011614  5040000A   BEQL V0, ZERO, 0x9D011640
9D011618  8E020000   LW V0, 0(S0)
1289:                    {
1290:                        DRV_USB_DEVICE_AddressSet(usbDeviceThisInstance->usbCDHandle, usbDeviceThisInstance->deviceAddress);
9D01161C  8E0200EC   LW V0, 236(S0)
9D011620  8C42000C   LW V0, 12(V0)
9D011624  8E040018   LW A0, 24(S0)
9D011628  0040F809   JALR V0
9D01162C  920500A8   LBU A1, 168(S0)
1291:                        usbDeviceThisInstance->usbDeviceStatusStruct.setAddressPending = false;
9D011630  92020000   LBU V0, 0(S0)
9D011634  7C022104   INS V0, ZERO, 4, 1
9D011638  0B40459B   J 0x9D01166C
9D01163C  A2020000   SB V0, 0(S0)
1292:                    }
1293:                
1294:                    /* Or else, if the host had sent a request to enter test mode, we have
1295:                     * acknowledged that request and now should enter test mode. */
1296:                
1297:                    else if(usbDeviceThisInstance->usbDeviceStatusStruct.testModePending)
9D011640  7C420140   EXT V0, V0, 5, 1
9D011644  5040000A   BEQL V0, ZERO, 0x9D011670
9D011648  8E220008   LW V0, 8(S1)
1298:                    {
1299:                        /* Set the flag to false and enter test mode */
1300:                        usbDeviceThisInstance->usbDeviceStatusStruct.testModePending = false;
9D01164C  92020000   LBU V0, 0(S0)
9D011650  7C022944   INS V0, ZERO, 5, 1
9D011654  A2020000   SB V0, 0(S0)
1301:                        DRV_USB_DEVICE_TestModeEnter(usbDeviceThisInstance->usbCDHandle, usbDeviceThisInstance->usbDeviceStatusStruct.testSelector );
9D011658  8E0200EC   LW V0, 236(S0)
9D01165C  8C42004C   LW V0, 76(V0)
9D011660  8E040018   LW A0, 24(S0)
9D011664  0040F809   JALR V0
9D011668  92050001   LBU A1, 1(S0)
1302:                    }
1303:                
1304:                    if(irpHandle->status == USB_DEVICE_IRP_STATUS_COMPLETED)
9D01166C  8E220008   LW V0, 8(S1)
9D011670  14400005   BNE V0, ZERO, 0x9D011688
9D011674  8FBF001C   LW RA, 28(SP)
1305:                    {
1306:                        if( irpHandle->size == 0 )
9D011678  8E220004   LW V0, 4(S1)
9D01167C  50400001   BEQL V0, ZERO, 0x9D011684
9D011680  A20000C0   SB ZERO, 192(S0)
1307:                        {
1308:                            controlTransfer->inProgress = false;
1309:                        }
1310:                    }
1311:                }
9D011684  8FBF001C   LW RA, 28(SP)
9D011688  8FB10018   LW S1, 24(SP)
9D01168C  8FB00014   LW S0, 20(SP)
9D011690  03E00008   JR RA
9D011694  27BD0020   ADDIU SP, SP, 32
1312:                
1313:                // *****************************************************************************
1314:                /* Function:
1315:                    void _USB_DEVICE_DeInitializeAllFunctionDrivers
1316:                    (
1317:                        USB_DEVICE_OBJ * usbDeviceThisInstance
1318:                    )
1319:                
1320:                  Summary:
1321:                    De-initializes all function drivers that are presently loaded for the
1322:                    selected configuration.
1323:                
1324:                  Description:
1325:                    De initializes all function drivers that are presently loaded for the
1326:                    selected configuration.
1327:                
1328:                  Remarks
1329:                    This function is a local function and should not be called directly by the
1330:                    client.
1331:                */
1332:                
1333:                void _USB_DEVICE_DeInitializeAllFunctionDrivers
1334:                (
1335:                    USB_DEVICE_OBJ * usbDeviceThisInstance
1336:                )
1337:                {
9D0117EC  27BDFFD8   ADDIU SP, SP, -40
9D0117F0  AFBF0024   SW RA, 36(SP)
9D0117F4  AFB40020   SW S4, 32(SP)
9D0117F8  AFB3001C   SW S3, 28(SP)
9D0117FC  AFB20018   SW S2, 24(SP)
9D011800  AFB10014   SW S1, 20(SP)
9D011804  AFB00010   SW S0, 16(SP)
1338:                    /* This function is called when device layer has detected a USB reset
1339:                     * signalling or when the host has set device configuration 0. */
1340:                
1341:                    uint8_t count = 0;
1342:                    USB_SPEED speed = usbDeviceThisInstance->usbDeviceStatusStruct.usbSpeed ;
9D011808  8C930000   LW S3, 0(A0)
9D01180C  7E731040   EXT S3, S3, 1, 3
1343:                    uint16_t configValue = usbDeviceThisInstance->activeConfiguration ;
9D011810  909400A9   LBU S4, 169(A0)
1344:                    uint16_t maxFunctionCounts = usbDeviceThisInstance->registeredFuncDriverCount;
9D011814  9492000C   LHU S2, 12(A0)
1345:                    USB_DEVICE_FUNCTION_REGISTRATION_TABLE * funcRegTable = usbDeviceThisInstance->registeredFuncDrivers;
1346:                    USB_DEVICE_FUNCTION_DRIVER * driver;
1347:                
1348:                    for(count = 0; count < maxFunctionCounts; count++ )
9D011818  12400016   BEQ S2, ZERO, 0x9D011874
9D01181C  8C900010   LW S0, 16(A0)
9D011820  00008821   ADDU S1, ZERO, ZERO
9D011860  26310001   ADDIU S1, S1, 1
9D011864  323100FF   ANDI S1, S1, 255
9D011868  0232102B   SLTU V0, S1, S2
9D01186C  1440FFED   BNE V0, ZERO, 0x9D011824
9D011870  26100014   ADDIU S0, S0, 20
1349:                    {
1350:                        if( (funcRegTable->speed & speed) && (funcRegTable->configurationValue == configValue))
9D011824  8E020000   LW V0, 0(S0)
9D011828  02621024   AND V0, S3, V0
9D01182C  5040000D   BEQL V0, ZERO, 0x9D011864
9D011830  26310001   ADDIU S1, S1, 1
9D011834  92020004   LBU V0, 4(S0)
9D011838  5454000A   BNEL V0, S4, 0x9D011864
9D01183C  26310001   ADDIU S1, S1, 1
1351:                        {
1352:                            /* De initialize the function driver */
1353:                            driver = (USB_DEVICE_FUNCTION_DRIVER *)funcRegTable->driver;
9D011840  8E020010   LW V0, 16(S0)
1354:                            if (driver != NULL)
9D011844  50400007   BEQL V0, ZERO, 0x9D011864
9D011848  26310001   ADDIU S1, S1, 1
1355:                            {
1356:                                if(driver->deInitialize != NULL)
9D01184C  8C420004   LW V0, 4(V0)
9D011850  50400004   BEQL V0, ZERO, 0x9D011864
9D011854  26310001   ADDIU S1, S1, 1
1357:                                {
1358:                                    /* Call the function driver deInitialize routine */
1359:                                    driver->deInitialize( funcRegTable->funcDriverIndex );
9D011858  0040F809   JALR V0
9D01185C  96040008   LHU A0, 8(S0)
1360:                                }
1361:                            }           
1362:                        }
1363:                
1364:                        funcRegTable++;
1365:                    }
1366:                }
9D011874  8FBF0024   LW RA, 36(SP)
9D011878  8FB40020   LW S4, 32(SP)
9D01187C  8FB3001C   LW S3, 28(SP)
9D011880  8FB20018   LW S2, 24(SP)
9D011884  8FB10014   LW S1, 20(SP)
9D011888  8FB00010   LW S0, 16(SP)
9D01188C  03E00008   JR RA
9D011890  27BD0028   ADDIU SP, SP, 40
1367:                
1368:                // ******************************************************************************
1369:                /* Function:
1370:                    void _USB_DEVICE_EventHandler
1371:                    (
1372:                        uintptr_t referenceHandle,
1373:                        DRV_USB_EVENT eventType, 
1374:                        void * eventData
1375:                    )
1376:                
1377:                  Summary:
1378:                    Handles the events originating from the USB Controller driver.
1379:                
1380:                  Description:
1381:                    This function is registered into the USB Controller driver as a callback
1382:                    function. The USB Controller driver calls this function in case of events
1383:                    from the USB Controller driver.
1384:                    
1385:                  Remarks:
1386:                    This is a local function and should not be called directly by a client.
1387:                */
1388:                
1389:                void _USB_DEVICE_EventHandler
1390:                (
1391:                    uintptr_t referenceHandle,
1392:                    DRV_USB_EVENT eventType, 
1393:                    void * eventData
1394:                )
1395:                {
1396:                    USB_DEVICE_OBJ* usbDeviceThisInstance;
1397:                    USB_DEVICE_MASTER_DESCRIPTOR * ptrMasterDescTable;
1398:                    USB_DEVICE_EVENT_DATA_SOF SOFFrameNumber;
1399:                
1400:                    usbDeviceThisInstance = (USB_DEVICE_OBJ *)referenceHandle;
1401:                
1402:                    /* Handle events, only if this instance is in initialized state */
1403:                    if( usbDeviceThisInstance->usbDeviceInstanceState <= SYS_STATUS_UNINITIALIZED )
1404:                    {
1405:                        /* The device should anyway not be attached when the device layer is
1406:                         * not initialized. If we receive driver event when the device layer is
1407:                         * not initialized, there is nothing we can do but ignore them. */
1408:                        return;                
1409:                    }
1410:                
1411:                    switch(eventType)
1412:                    {
1413:                        case DRV_USB_EVENT_RESET_DETECT:
1414:                
1415:                            /* Clear the suspended state */
1416:                            usbDeviceThisInstance->usbDeviceStatusStruct.isSuspended = false;
1417:                
1418:                            /* Cancel any IRP already submitted in the RX direction. */
1419:                            DRV_USB_DEVICE_IRPCancelAll( usbDeviceThisInstance->usbCDHandle, controlEndpointRx );
1420:                
1421:                            /* Cancel any IRP already submitted in the TX direction. */
1422:                            DRV_USB_DEVICE_IRPCancelAll( usbDeviceThisInstance->usbCDHandle, controlEndpointTx );
1423:                
1424:                            /* Deinitialize all function drivers.*/
1425:                            _USB_DEVICE_DeInitializeAllFunctionDrivers ( usbDeviceThisInstance );
1426:                
1427:                            /* Disable all endpoints except for EP0.*/
1428:                            DRV_USB_DEVICE_EndpointDisableAll(usbDeviceThisInstance->usbCDHandle);
1429:                
1430:                            /* Enable EP0 endpoint. Note that the driver will ignore the
1431:                             * direction because this is endpoint 0. */
1432:                            (void)DRV_USB_DEVICE_EndpointEnable( usbDeviceThisInstance->usbCDHandle, controlEndpointTx, USB_TRANSFER_TYPE_CONTROL, USB_DEVICE_EP0_BUFFER_SIZE);
1433:                
1434:                            if(usbDeviceThisInstance->irpEp0Rx.status <= USB_DEVICE_IRP_STATUS_SETUP)
1435:                            {
1436:                                /* Submit IRP to endpoint 0 to receive the setup packet */
1437:                                (void)DRV_USB_DEVICE_IRPSubmit( usbDeviceThisInstance->usbCDHandle, controlEndpointRx , &usbDeviceThisInstance->irpEp0Rx);
1438:                            }
1439:                
1440:                            /* Change device state to Default */
1441:                            usbDeviceThisInstance->usbDeviceStatusStruct.usbDeviceState = USB_DEVICE_STATE_DEFAULT;
1442:                
1443:                            /* Reset means chirping has already happened. So, we must be knowing
1444:                               the speed. Get the speed and save it for future. */
1445:                            usbDeviceThisInstance->usbDeviceStatusStruct.usbSpeed = DRV_USB_DEVICE_CurrentSpeedGet(usbDeviceThisInstance->usbCDHandle);
1446:                
1447:                            /* Get the master descriptor table entry.*/
1448:                            ptrMasterDescTable = usbDeviceThisInstance->ptrMasterDescTable;
1449:                
1450:                            /* Now we know the speed. So for this speed get the pointer that
1451:                               points to correct group of configurations. */
1452:                            if( usbDeviceThisInstance->usbDeviceStatusStruct.usbSpeed == USB_SPEED_HIGH )
1453:                            {
1454:                                usbDeviceThisInstance->configDescriptorsPtr = ptrMasterDescTable->highSpeedConfigDescriptorTable;
1455:                
1456:                                /* Also get the max configurations available in this group.*/
1457:                                usbDeviceThisInstance->maxConfigs = ptrMasterDescTable->highSpeedConfigDescriptorCount;
1458:                            }
1459:                            else
1460:                            {
1461:                                /* Classic speeds (full/low speed) */
1462:                                usbDeviceThisInstance->configDescriptorsPtr = ptrMasterDescTable->configDescriptorTable;
1463:                
1464:                                /* Get the maximum configurations available in this group.*/
1465:                                usbDeviceThisInstance->maxConfigs = ptrMasterDescTable->configDescriptorCount;
1466:                            }
1467:                
1468:                            /* Invalidate the current active configuration */
1469:                            usbDeviceThisInstance->activeConfiguration = 0;
1470:                            break;
1471:                
1472:                        case DRV_USB_EVENT_RESUME_DETECT:
1473:                
1474:                            /* USB device resumed. Update the flag.*/
1475:                            usbDeviceThisInstance->usbDeviceStatusStruct.isSuspended = false;
1476:                            break;
1477:                
1478:                        case DRV_USB_EVENT_IDLE_DETECT:
1479:                
1480:                            /* USB Device is suspended */
1481:                            usbDeviceThisInstance->usbDeviceStatusStruct.isSuspended = true;
1482:                            break;        
1483:                
1484:                        case DRV_USB_EVENT_SOF_DETECT:
1485:                
1486:                            /* The _USB_DEVICE_SOFEventEnable() macro resolves to eventType 
1487:                             * events are enabled in system_config.h. If enabled the event
1488:                             * will sent to the application. Else the event will not be
1489:                             * processed. */
1490:                            eventType = _USB_DEVICE_SOFEventEnable(); 
1491:                            if (eventType)
1492:                            {
1493:                                eventType = USB_DEVICE_EVENT_SOF;
1494:                                /* Get the frame number */
1495:                                SOFFrameNumber.frameNumber = DRV_USB_DEVICE_SOFNumberGet(usbDeviceThisInstance->usbCDHandle);
1496:                                eventData = &SOFFrameNumber;
1497:                            }
1498:                
1499:                            break;
1500:                
1501:                        case DRV_USB_EVENT_DEVICE_SESSION_VALID:
1502:                
1503:                            /* VBUS is valid.*/
1504:                            usbDeviceThisInstance->usbDeviceStatusStruct.usbDeviceState = USB_DEVICE_STATE_ATTACHED;
1505:                            break;
1506:                
1507:                        case DRV_USB_EVENT_DEVICE_SESSION_INVALID:
1508:                
1509:                            /* VBUS is not valid. */ 
1510:                            usbDeviceThisInstance->usbDeviceStatusStruct.usbDeviceState = USB_DEVICE_STATE_DETACHED;  
1511:                            break;
1512:                
1513:                        default:
1514:                            // Nothing to do for all other cases.
1515:                            eventType = 0;
1516:                            break;
1517:                    }
1518:                
1519:                    if(eventType)
1520:                    {
1521:                        /* Inform the client about the event */
1522:                        if((usbDeviceThisInstance->clientState == USB_DEVICE_CLIENT_STATUS_READY) && (usbDeviceThisInstance->callBackFunc != NULL))
1523:                        {
1524:                            /* This means this client is valid and is a client of this device
1525:                             * layer instance. Pass event to application */
1526:                            usbDeviceThisInstance->callBackFunc(eventType, eventData, usbDeviceThisInstance->context);
1527:                        }
1528:                    }
1529:                }    
1530:                
1531:                // ******************************************************************************
1532:                /* Function:
1533:                    void _USB_DEVICE_ControlTransferHandler
1534:                    (
1535:                        SYS_MODULE_INDEX handlerIndex,
1536:                        USB_DEVICE_CONTROL_TRANSFER_EVENT transferEvent,
1537:                        USB_DEVICE_CONTROL_TRANSFER_EVENT_DATA * eventData 
1538:                    )
1539:                
1540:                  Summary:
1541:                    Processes the SETUP packet received from the USB Controller driver.
1542:                
1543:                  Description:
1544:                    This function processes the SETUP packet received from the USB Controller 
1545:                    driver.
1546:                   
1547:                  Remarks:
1548:                    This is a local function and should not be called directly by the client.
1549:                */
1550:                
1551:                void  _USB_DEVICE_ControlTransferHandler
1552:                (    
1553:                    SYS_MODULE_INDEX handlerIndex,
1554:                    USB_DEVICE_EVENT transferEvent,
1555:                    void * eventData
1556:                )
1557:                {
9D009400  27BDFFD8   ADDIU SP, SP, -40
9D009404  AFBF0024   SW RA, 36(SP)
9D009408  AFB10020   SW S1, 32(SP)
9D00940C  AFB0001C   SW S0, 28(SP)
1558:                    /* This function is called from _USB_DEVICE_Ep0ReceiveCompleteCallback
1559:                     * function when a Setup packet has been received. */
1560:                
1561:                    USB_DEVICE_OBJ * usbDeviceThisInstance = (USB_DEVICE_OBJ *)&usbDeviceInstance[handlerIndex];
9D009420  00041080   SLL V0, A0, 2
9D009424  00048980   SLL S1, A0, 6
9D009428  02228823   SUBU S1, S1, V0
9D00942C  02242021   ADDU A0, S1, A0
9D009430  00042080   SLL A0, A0, 2
9D009434  3C11A000   LUI S1, -24576
9D009438  26317264   ADDIU S1, S1, 29284
9D00943C  02248821   ADDU S1, S1, A0
1562:                    USB_SETUP_PACKET * setupPkt;
1563:                    uint8_t interfaceNumber = 0;
1564:                    USB_ENDPOINT endpointNumber;
1565:                    bool enpointFoundInDescriptors = false;
1566:                  
1567:                    if( transferEvent == USB_DEVICE_EVENT_CONTROL_TRANSFER_SETUP_REQUEST )
9D009410  2402000E   ADDIU V0, ZERO, 14
9D009414  14A20074   BNE A1, V0, 0x9D0095E8
9D009418  A3A00010   SB ZERO, 16(SP)
9D00941C  00C08021   ADDU S0, A2, ZERO
1568:                    {
1569:                        /* Get pointer to Setup Packet */ 
1570:                        setupPkt = (USB_SETUP_PACKET *)(eventData);
1571:                
1572:                        /* Get of Length of the Data Stage */
1573:                        usbDeviceThisInstance->controlTransferDataStageSize = setupPkt->wLength;
9D009440  90C30006   LBU V1, 6(A2)
9D009444  90C20007   LBU V0, 7(A2)
9D009448  00021200   SLL V0, V0, 8
9D00944C  00431025   OR V0, V0, V1
9D009450  A62200E4   SH V0, 228(S1)
1574:                
1575:                        /* Cancel any IRP that is in the pipe. */
1576:                        DRV_USB_DEVICE_IRPCancelAll( usbDeviceThisInstance->usbCDHandle, controlEndpointTx );
9D009454  8E2200EC   LW V0, 236(S1)
9D009458  8C420040   LW V0, 64(V0)
9D00945C  8E240018   LW A0, 24(S1)
9D009460  0040F809   JALR V0
9D009464  24050080   ADDIU A1, ZERO, 128
1577:                        
1578:                        switch (setupPkt->Recipient)
9D009468  92020000   LBU V0, 0(S0)
9D00946C  3042001F   ANDI V0, V0, 31
9D009470  24030001   ADDIU V1, ZERO, 1
9D009474  1043002A   BEQ V0, V1, 0x9D009520
9D009478  28430002   SLTI V1, V0, 2
9D00947C  50600005   BEQL V1, ZERO, 0x9D009494
9D009480  24030002   ADDIU V1, ZERO, 2
9D009484  50400009   BEQL V0, ZERO, 0x9D0094AC
9D009488  92030000   LBU V1, 0(S0)
9D009494  10430031   BEQ V0, V1, 0x9D00955C
9D009498  24030003   ADDIU V1, ZERO, 3
9D00949C  1043004F   BEQ V0, V1, 0x9D0095DC
9D0094A0  02202021   ADDU A0, S1, ZERO
1579:                        {
1580:                            case USB_SETUP_RECIPIENT_DEVICE:
1581:                                if (setupPkt->RequestType == USB_SETUP_REQUEST_TYPE_STANDARD)
9D0094AC  30620060   ANDI V0, V1, 96
9D0094B0  5440000C   BNEL V0, ZERO, 0x9D0094E4
9D0094B4  24030040   ADDIU V1, ZERO, 64
1582:                                {
1583:                                    /* This is a standard Device Request */ 
1584:                                    if (setupPkt->DataDir == USB_SETUP_REQUEST_DIRECTION_HOST_TO_DEVICE)
9D0094B8  30630080   ANDI V1, V1, 128
9D0094BC  14600005   BNE V1, ZERO, 0x9D0094D4
9D0094C0  02202021   ADDU A0, S1, ZERO
1585:                                    {
1586:                                        /* Serve standard Device SET requests */
1587:                                        _USB_DEVICE_ProcessStandardDeviceSetRequests ( usbDeviceThisInstance, setupPkt );
9D0094C4  0F4021EF   JAL _USB_DEVICE_ProcessStandardDeviceSetRequests
9D0094C8  02002821   ADDU A1, S0, ZERO
9D0094CC  0B40257B   J 0x9D0095EC
9D0094D0  8FBF0024   LW RA, 36(SP)
1588:                                    }
1589:                                    else
1590:                                    {
1591:                                        /* Serve standard Device GET requests */
1592:                                        _USB_DEVICE_ProcessStandardDeviceGetRequests ( usbDeviceThisInstance, setupPkt );
9D0094D4  0F401DE7   JAL _USB_DEVICE_ProcessStandardDeviceGetRequests
9D0094D8  02002821   ADDU A1, S0, ZERO
1593:                                    }
1594:                                }
1595:                                else if (setupPkt->RequestType == USB_SETUP_REQUEST_TYPE_VENDOR)
9D0094E4  14430007   BNE V0, V1, 0x9D009504
9D0094E8  24030020   ADDIU V1, ZERO, 32
1596:                                {
1597:                                    /* This is a SETUP request of Vendor type  to recipient
1598:                                     * Device. The device layer does not know how to Handle
1599:                                     * these requests. Forward this request to application. */
1600:                
1601:                                    _USB_DEVICE_RedirectControlXfrToClient (usbDeviceThisInstance, USB_DEVICE_EVENT_CONTROL_TRANSFER_SETUP_REQUEST, setupPkt);
9D0094EC  02202021   ADDU A0, S1, ZERO
9D0094F0  2405000E   ADDIU A1, ZERO, 14
9D0094F4  0F4050FA   JAL _USB_DEVICE_RedirectControlXfrToClient
9D0094F8  02003021   ADDU A2, S0, ZERO
9D0094FC  0B40257B   J 0x9D0095EC
9D009500  8FBF0024   LW RA, 36(SP)
1602:                                }
1603:                                else if (setupPkt->RequestType == USB_SETUP_REQUEST_TYPE_CLASS )
9D009504  54430039   BNEL V0, V1, 0x9D0095EC
9D009508  8FBF0024   LW RA, 36(SP)
1604:                                {
1605:                                    /* This is a SETUP request of Type Class to recipient
1606:                                     * Device. */
1607:                
1608:                                    USB_DEVICE_ControlStatus ((USB_DEVICE_HANDLE)usbDeviceThisInstance, USB_DEVICE_CONTROL_STATUS_ERROR);
9D00950C  02202021   ADDU A0, S1, ZERO
9D009510  0F404BC3   JAL USB_DEVICE_ControlStatus
9D009514  24050001   ADDIU A1, ZERO, 1
1609:                                }
1610:                                break;
1611:                
1612:                            case USB_SETUP_RECIPIENT_INTERFACE:
1613:                
1614:                                 /* Serve any requests that is not "standard" type and whose
1615:                                  * recipient is not "device". (Any request whose recipient is
1616:                                  * interface/endpoint must be handled by the function driver.
1617:                                  * This is because function driver has all the information
1618:                                  * about endpoint and interface) */				
1619:                				if (setupPkt->RequestType == USB_SETUP_REQUEST_TYPE_VENDOR)
9D009520  92030000   LBU V1, 0(S0)
9D009524  30630060   ANDI V1, V1, 96
9D009528  24020040   ADDIU V0, ZERO, 64
9D00952C  14620006   BNE V1, V0, 0x9D009548
9D009530  02202021   ADDU A0, S1, ZERO
1620:                				{
1621:                					_USB_DEVICE_VendorInterfaceRequestProcess(usbDeviceThisInstance, setupPkt->bIntfID,setupPkt); 
9D009534  92050004   LBU A1, 4(S0)
9D009538  0F40480E   JAL _USB_DEVICE_ForwardControlXfrToFunction
9D00953C  02003021   ADDU A2, S0, ZERO
9D009540  0B40257B   J 0x9D0095EC
9D009544  8FBF0024   LW RA, 36(SP)
1622:                				}
1623:                				else
1624:                				{
1625:                					_USB_DEVICE_ForwardControlXfrToFunction(usbDeviceThisInstance, setupPkt->bIntfID,setupPkt ); 
9D009548  92050004   LBU A1, 4(S0)
9D00954C  0F40480E   JAL _USB_DEVICE_ForwardControlXfrToFunction
9D009550  02003021   ADDU A2, S0, ZERO
1626:                				}
1627:                                break;
1628:                
1629:                            case USB_SETUP_RECIPIENT_ENDPOINT:
1630:                
1631:                                /* Retrieve Endpoint number from Setup Packet */
1632:                                endpointNumber = setupPkt->bEPID;
9D00955C  92050004   LBU A1, 4(S0)
1633:                
1634:                                /* Any Control request to a Non Zero Endpoint should be Stalled
1635:                                 * if the Device is not in Configured State. The request will
1636:                                 * also be stalled if there is no descriptor available for this
1637:                                 * Endpoint */ 
1638:                
1639:                                if (endpointNumber != 0)
9D009560  50A00011   BEQL A1, ZERO, 0x9D0095A8
9D009564  92020000   LBU V0, 0(S0)
1640:                                {
1641:                                    /* Check if the Endpoint is present in the Descriptors. If
1642:                                     * yes find the interface number */
1643:                
1644:                                    enpointFoundInDescriptors = _USB_DEVICE_FindEndpoint( usbDeviceThisInstance, endpointNumber, &interfaceNumber);
9D009568  02202021   ADDU A0, S1, ZERO
9D00956C  0F404B21   JAL _USB_DEVICE_FindEndpoint
9D009570  27A60010   ADDIU A2, SP, 16
1645:                                    if ((usbDeviceThisInstance->usbDeviceStatusStruct.usbDeviceState != USB_DEVICE_STATE_CONFIGURED) ||(enpointFoundInDescriptors != true))
9D009574  8E240000   LW A0, 0(S1)
9D009578  3C030007   LUI V1, 7
9D00957C  00832024   AND A0, A0, V1
9D009580  3C030005   LUI V1, 5
9D009584  14830004   BNE A0, V1, 0x9D009598
9D009588  02202021   ADDU A0, S1, ZERO
9D00958C  54400006   BNEL V0, ZERO, 0x9D0095A8
9D009590  92020000   LBU V0, 0(S0)
1646:                                    {
1647:                                        /* The Device should not service the Non Zero Endpoint
1648:                                         * request if the Device is not configured or the
1649:                                         * Endpoint is not present in descriptors. So stall this
1650:                                         * request.  */
1651:                
1652:                                        USB_DEVICE_ControlStatus ((USB_DEVICE_HANDLE)usbDeviceThisInstance, USB_DEVICE_CONTROL_STATUS_ERROR);
9D009594  02202021   ADDU A0, S1, ZERO
9D009598  0F404BC3   JAL USB_DEVICE_ControlStatus
9D00959C  24050001   ADDIU A1, ZERO, 1
1653:                                        return;
1654:                                    }
1655:                                }
1656:                
1657:                                /* Program control reached here means that we have received an
1658:                                 * Endpoint request on a valid Endpoint Number. */
1659:                
1660:                                if (setupPkt->RequestType == USB_SETUP_REQUEST_TYPE_STANDARD)
9D0095A8  30420060   ANDI V0, V0, 96
9D0095AC  14400006   BNE V0, ZERO, 0x9D0095C8
9D0095B0  02202021   ADDU A0, S1, ZERO
1661:                                {
1662:                                    /* Standard Endpoint requests are handled by Device Layer */
1663:                                    _USB_DEVICE_ProcessStandardEndpointRequest( usbDeviceThisInstance, interfaceNumber, setupPkt);
9D0095B4  93A50010   LBU A1, 16(SP)
9D0095B8  0F403EC2   JAL _USB_DEVICE_ProcessStandardEndpointRequest
9D0095BC  02003021   ADDU A2, S0, ZERO
9D0095C0  0B40257B   J 0x9D0095EC
9D0095C4  8FBF0024   LW RA, 36(SP)
1664:                                }
1665:                                else 
1666:                                {
1667:                                    /* This is Class or Vendor request. Forward the request to
1668:                                     * right Function driver or Client */ 
1669:                
1670:                                    _USB_DEVICE_ForwardControlXfrToFunction (usbDeviceThisInstance, interfaceNumber,setupPkt );
9D0095C8  93A50010   LBU A1, 16(SP)
9D0095CC  0F40480E   JAL _USB_DEVICE_ForwardControlXfrToFunction
9D0095D0  02003021   ADDU A2, S0, ZERO
1671:                                   
1672:                                }
1673:                                break;
1674:                            
1675:                            case USB_SETUP_RECIPIENT_OTHER:
1676:                                
1677:                                /* This is a SETUP request of Type Vendor to recipient Device.
1678:                                 * The device layer does not know how to Handle these requests.
1679:                                 * Forward this request to application. */
1680:                
1681:                                _USB_DEVICE_RedirectControlXfrToClient( usbDeviceThisInstance, USB_DEVICE_EVENT_CONTROL_TRANSFER_SETUP_REQUEST, setupPkt);
9D0095DC  2405000E   ADDIU A1, ZERO, 14
9D0095E0  0F4050FA   JAL _USB_DEVICE_RedirectControlXfrToClient
9D0095E4  02003021   ADDU A2, S0, ZERO
1682:                                break;
1683:                               
1684:                            default: 
1685:                                SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Unknown Control Transfer received from Host" );
1686:                                break;
1687:                        }
1688:                    }   
1689:                }
9D00948C  0B40257B   J 0x9D0095EC
9D009490  8FBF0024   LW RA, 36(SP)
9D0094A4  0B40257B   J 0x9D0095EC
9D0094A8  8FBF0024   LW RA, 36(SP)
9D0094DC  0B40257B   J 0x9D0095EC
9D0094E0  8FBF0024   LW RA, 36(SP)
9D009518  0B40257B   J 0x9D0095EC
9D00951C  8FBF0024   LW RA, 36(SP)
9D009554  0B40257B   J 0x9D0095EC
9D009558  8FBF0024   LW RA, 36(SP)
9D0095A0  0B40257B   J 0x9D0095EC
9D0095A4  8FBF0024   LW RA, 36(SP)
9D0095D4  0B40257B   J 0x9D0095EC
9D0095D8  8FBF0024   LW RA, 36(SP)
9D0095E8  8FBF0024   LW RA, 36(SP)
9D0095EC  8FB10020   LW S1, 32(SP)
9D0095F0  8FB0001C   LW S0, 28(SP)
9D0095F4  03E00008   JR RA
9D0095F8  27BD0028   ADDIU SP, SP, 40
1690:                
1691:                // *****************************************************************************
1692:                /* Function:
1693:                    void _USB_DEVICE_ForwardControlXfrToFunction 
1694:                    (
1695:                        USB_DEVICE_OBJ * usbDeviceThisInstance,
1696:                        uint8_t interfaceNumber,
1697:                        USB_SETUP_PACKET * setupPkt
1698:                    )
1699:                
1700:                  Summary:
1701:                    This function forwards control transfers to registred function drivers.
1702:                
1703:                  Description:
1704:                    This function Forwards control transfers to registred function drivers. If
1705:                    control handler fucntion callback is null, then the control transfer is
1706:                    forwarded to client.
1707:                
1708:                  Remarks:
1709:                    This is local function. It should not be used directly by the client.
1710:                */
1711:                
1712:                void _USB_DEVICE_ForwardControlXfrToFunction 
1713:                (
1714:                    USB_DEVICE_OBJ * usbDeviceThisInstance,
1715:                    uint8_t interfaceNumber,
1716:                    USB_SETUP_PACKET * setupPkt
1717:                )
1718:                {
9D012038  27BDFFE0   ADDIU SP, SP, -32
9D01203C  AFBF001C   SW RA, 28(SP)
9D012040  AFB10018   SW S1, 24(SP)
9D012044  AFB00014   SW S0, 20(SP)
9D012048  00808021   ADDU S0, A0, ZERO
9D01204C  00C08821   ADDU S1, A2, ZERO
1719:                    USB_DEVICE_FUNCTION_REGISTRATION_TABLE * lFuncDriverRegTable;
1720:                    USB_DEVICE_CONTROL_TRANSFER_STRUCT * controlTransfer = &usbDeviceThisInstance->controlTransfer;
1721:                    USB_DEVICE_FUNCTION_DRIVER * driver;
1722:                    
1723:                    /* This is a function driver /vendor specific setup packet. The recipient
1724:                     * field is either interface or other. Check which function driver has to
1725:                     * handle this setup packet. This function is called from Setup packet
1726:                     * handling function. We first find out which function driver owns this
1727:                     * interface.  */
1728:                    
1729:                    lFuncDriverRegTable = _USB_DEVICE_GetFunctionDriverEntryByInterface( interfaceNumber, usbDeviceThisInstance);
9D012050  00A02021   ADDU A0, A1, ZERO
9D012054  0F404B00   JAL _USB_DEVICE_GetFunctionDriverEntryByInterface
9D012058  02002821   ADDU A1, S0, ZERO
1730:                    if (lFuncDriverRegTable != NULL)
9D01205C  10400016   BEQ V0, ZERO, 0x9D0120B8
9D012060  02002021   ADDU A0, S0, ZERO
1731:                    {
1732:                        if (lFuncDriverRegTable->driver != NULL)
9D012064  8C430010   LW V1, 16(V0)
9D012068  1060000F   BEQ V1, ZERO, 0x9D0120A8
9D01206C  2405000E   ADDIU A1, ZERO, 14
1733:                        {
1734:                            driver = (USB_DEVICE_FUNCTION_DRIVER *)(lFuncDriverRegTable->driver);
1735:                            if (driver->controlTransferNotification != NULL)
9D012070  8C630008   LW V1, 8(V1)
9D012074  10600008   BEQ V1, ZERO, 0x9D012098
9D012078  00000000   NOP
1736:                            {
1737:                                /* The interface number is owned by one of the registered
1738:                                 * function driver. Pass the SETUP packet to the function
1739:                                 * driver. */
1740:                
1741:                                /* Save the callback and index for future use.  Here we change
1742:                                 * the handler to function driver specific handler.  All further
1743:                                 * control transfer stage must be handled by the function driver
1744:                                 * control transfer handler.*/
1745:                
1746:                                controlTransfer->handler = (void *)driver->controlTransferNotification;
9D01207C  AE0300CC   SW V1, 204(S0)
1747:                                controlTransfer->handlerIndex = lFuncDriverRegTable->funcDriverIndex;
9D012080  94440008   LHU A0, 8(V0)
9D012084  A60400C4   SH A0, 196(S0)
1748:                
1749:                                /* Forward the SETUP packet to the function driver */
1750:                                controlTransfer->handler( controlTransfer->handlerIndex, USB_DEVICE_EVENT_CONTROL_TRANSFER_SETUP_REQUEST, setupPkt);
9D012088  0060F809   JALR V1
9D01208C  02203021   ADDU A2, S1, ZERO
9D012090  0B404831   J 0x9D0120C4
9D012094  8FBF001C   LW RA, 28(SP)
1751:                            }
1752:                            else
1753:                            {
1754:                                /* There is no valid control Transfer Notification Handler found
1755:                                 * in the Function registration Table. This control transfer
1756:                                 * will be handled by the client */
1757:                
1758:                                _USB_DEVICE_RedirectControlXfrToClient (usbDeviceThisInstance, USB_DEVICE_EVENT_CONTROL_TRANSFER_SETUP_REQUEST, setupPkt );
9D012098  0F4050FA   JAL _USB_DEVICE_RedirectControlXfrToClient
9D01209C  02203021   ADDU A2, S1, ZERO
1759:                            }
1760:                        }
1761:                        else
1762:                        {
1763:                            /* If the driver member of the function driver registration table
1764:                             * entry is NULL, this means that the device layer client will
1765:                             * handle the control transfer. Forward the request to the device
1766:                             * layer client. */
1767:                
1768:                            _USB_DEVICE_RedirectControlXfrToClient (usbDeviceThisInstance, USB_DEVICE_EVENT_CONTROL_TRANSFER_SETUP_REQUEST, setupPkt );
9D0120A8  0F4050FA   JAL _USB_DEVICE_RedirectControlXfrToClient
9D0120AC  02203021   ADDU A2, S1, ZERO
1769:                        }
1770:                    }
1771:                    else
1772:                    {
1773:                        /* The interface number specified in the SETUP Packet does not belong to
1774:                         * any of the registered function driver. Host should not have sent this
1775:                         * request. STALL this request */
1776:                
1777:                        USB_DEVICE_ControlStatus((USB_DEVICE_HANDLE)usbDeviceThisInstance, USB_DEVICE_CONTROL_STATUS_ERROR);
9D0120B8  0F404BC3   JAL USB_DEVICE_ControlStatus
9D0120BC  24050001   ADDIU A1, ZERO, 1
1778:                    }
1779:                }
9D0120A0  0B404831   J 0x9D0120C4
9D0120A4  8FBF001C   LW RA, 28(SP)
9D0120B0  0B404831   J 0x9D0120C4
9D0120B4  8FBF001C   LW RA, 28(SP)
9D0120C0  8FBF001C   LW RA, 28(SP)
9D0120C4  8FB10018   LW S1, 24(SP)
9D0120C8  8FB00014   LW S0, 20(SP)
9D0120CC  03E00008   JR RA
9D0120D0  27BD0020   ADDIU SP, SP, 32
1780:                
1781:                // *****************************************************************************
1782:                /* Function:
1783:                    void _USB_DEVICE_ProcessStandardEndpointRequest
1784:                    (
1785:                        USB_DEVICE_OBJ * usbDeviceThisInstance,
1786:                        uint8_t interfaceNumber,
1787:                        USB_SETUP_PACKET * setupPkt
1788:                    )
1789:                
1790:                  Summary:
1791:                    This function handles standard Endpoint requests.
1792:                
1793:                  Description:
1794:                    This function handles standard Endpoint requests. 
1795:                
1796:                  Remarks:
1797:                    This is local function. It should not be used directly by the client.
1798:                */
1799:                
1800:                void _USB_DEVICE_ProcessStandardEndpointRequest
1801:                (
1802:                    USB_DEVICE_OBJ * usbDeviceThisInstance,
1803:                    uint8_t interfaceNumber,
1804:                    USB_SETUP_PACKET * setupPkt
1805:                )
1806:                {
9D00FB08  27BDFFE8   ADDIU SP, SP, -24
9D00FB0C  AFBF0014   SW RA, 20(SP)
9D00FB10  AFB00010   SW S0, 16(SP)
9D00FB14  00808021   ADDU S0, A0, ZERO
1807:                    USB_ENDPOINT usbEndpoint;
1808:                    usbEndpoint = setupPkt->bEPID;
1809:                
1810:                    if( setupPkt->bRequest == USB_REQUEST_GET_STATUS )
9D00FB18  90C20001   LBU V0, 1(A2)
9D00FB1C  1440000F   BNE V0, ZERO, 0x9D00FB5C
9D00FB20  90C50004   LBU A1, 4(A2)
1811:                    {
1812:                        /* This is an Endpoint Get Status request. Send the status to the host.
1813:                         * */
1814:                        usbDeviceThisInstance->getStatusResponse.status = 0x00;
9D00FB24  A48000B8   SH ZERO, 184(A0)
1815:                        usbDeviceThisInstance->getStatusResponse.endPointHalt =  DRV_USB_DEVICE_EndpointIsStalled(usbDeviceThisInstance->usbCDHandle, usbEndpoint );
9D00FB28  8C8200EC   LW V0, 236(A0)
9D00FB2C  8C420034   LW V0, 52(V0)
9D00FB30  0040F809   JALR V0
9D00FB34  8C840018   LW A0, 24(A0)
9D00FB38  960300B8   LHU V1, 184(S0)
9D00FB3C  7C430004   INS V1, V0, 0, 1
9D00FB40  A60300B8   SH V1, 184(S0)
1816:                
1817:                        USB_DEVICE_ControlSend( (USB_DEVICE_HANDLE)usbDeviceThisInstance, (uint8_t *)&usbDeviceThisInstance->getStatusResponse, 2 );
9D00FB44  02002021   ADDU A0, S0, ZERO
9D00FB48  260500B8   ADDIU A1, S0, 184
9D00FB4C  0F404B42   JAL USB_DEVICE_ControlSend
9D00FB50  24060002   ADDIU A2, ZERO, 2
9D00FB54  0B403EFF   J 0x9D00FBFC
9D00FB58  8FBF0014   LW RA, 20(SP)
1818:                    }
1819:                    else if( setupPkt->bRequest == USB_REQUEST_CLEAR_FEATURE )
9D00FB5C  24030001   ADDIU V1, ZERO, 1
9D00FB60  14430010   BNE V0, V1, 0x9D00FBA4
9D00FB64  24030003   ADDIU V1, ZERO, 3
1820:                    {
1821:                        if( setupPkt->wValue == USB_FEATURE_SELECTOR_ENDPOINT_HALT )
9D00FB68  90C30002   LBU V1, 2(A2)
9D00FB6C  90C20003   LBU V0, 3(A2)
9D00FB70  00021200   SLL V0, V0, 8
9D00FB74  00431025   OR V0, V0, V1
9D00FB78  54400020   BNEL V0, ZERO, 0x9D00FBFC
9D00FB7C  8FBF0014   LW RA, 20(SP)
1822:                        {
1823:                            /* This means the host has requested for the stall condition on an
1824:                             * endpoint to be cleared. */
1825:                            DRV_USB_DEVICE_EndpointStallClear(usbDeviceThisInstance->usbCDHandle, usbEndpoint );
9D00FB80  8C8200EC   LW V0, 236(A0)
9D00FB84  8C42002C   LW V0, 44(V0)
9D00FB88  0040F809   JALR V0
9D00FB8C  8C840018   LW A0, 24(A0)
1826:                            USB_DEVICE_ControlStatus((USB_DEVICE_HANDLE)usbDeviceThisInstance, USB_DEVICE_CONTROL_STATUS_OK );
9D00FB90  02002021   ADDU A0, S0, ZERO
9D00FB94  0F404BC3   JAL USB_DEVICE_ControlStatus
9D00FB98  00002821   ADDU A1, ZERO, ZERO
1827:                        }
1828:                    }
1829:                    else if (setupPkt->bRequest == USB_REQUEST_SET_FEATURE )
9D00FBA4  14430010   BNE V0, V1, 0x9D00FBE8
9D00FBA8  2403000C   ADDIU V1, ZERO, 12
1830:                    {
1831:                        if( setupPkt->wValue == USB_FEATURE_SELECTOR_ENDPOINT_HALT )
9D00FBAC  90C30002   LBU V1, 2(A2)
9D00FBB0  90C20003   LBU V0, 3(A2)
9D00FBB4  00021200   SLL V0, V0, 8
9D00FBB8  00431025   OR V0, V0, V1
9D00FBBC  5440000F   BNEL V0, ZERO, 0x9D00FBFC
9D00FBC0  8FBF0014   LW RA, 20(SP)
1832:                        {
1833:                            /* This means the host has requested for an endpoint to be stalled
1834:                             * */
1835:                            usbEndpoint = setupPkt->bEPID;
1836:                            DRV_USB_DEVICE_EndpointStall(usbDeviceThisInstance->usbCDHandle, usbEndpoint );
9D00FBC4  8C8200EC   LW V0, 236(A0)
9D00FBC8  8C420028   LW V0, 40(V0)
9D00FBCC  0040F809   JALR V0
9D00FBD0  8C840018   LW A0, 24(A0)
1837:                            USB_DEVICE_ControlStatus((USB_DEVICE_HANDLE)usbDeviceThisInstance, USB_DEVICE_CONTROL_STATUS_OK );
9D00FBD4  02002021   ADDU A0, S0, ZERO
9D00FBD8  0F404BC3   JAL USB_DEVICE_ControlStatus
9D00FBDC  00002821   ADDU A1, ZERO, ZERO
1838:                        }
1839:                    }
1840:                    else if (setupPkt->bRequest == USB_REQUEST_SYNCH_FRAME)
9D00FBE8  14430004   BNE V0, V1, 0x9D00FBFC
9D00FBEC  8FBF0014   LW RA, 20(SP)
1841:                    {
1842:                        /* Forward this request to Function driver. */
1843:                        _USB_DEVICE_Handle_Synch_Frame_Request(usbDeviceThisInstance, interfaceNumber, setupPkt);
9D00FBF0  0F404BC3   JAL USB_DEVICE_ControlStatus
9D00FBF4  24050001   ADDIU A1, ZERO, 1
1844:                    }
1845:                }
9D00FB9C  0B403EFF   J 0x9D00FBFC
9D00FBA0  8FBF0014   LW RA, 20(SP)
9D00FBE0  0B403EFF   J 0x9D00FBFC
9D00FBE4  8FBF0014   LW RA, 20(SP)
9D00FBF8  8FBF0014   LW RA, 20(SP)
1846:                
1847:                // ******************************************************************************
1848:                /* Function:
1849:                    void _USB_DEVICE_ProcessStandardGetRequests
1850:                    (
1851:                        USB_DEVICE_OBJ * usbDeviceThisInstance,
1852:                        USB_SETUP_PACKET * setupPkt 
1853:                    )
1854:                
1855:                  Summary:
1856:                    Processes the standard "get" requests received from the USB Controller driver.
1857:                
1858:                  Description:
1859:                    This function processes the standard "get" requests received from the USB 
1860:                    Controller driver.
1861:                   
1862:                  Remarks:
1863:                    This is local function and should not be called directly by the client.
1864:                */
1865:                void _USB_DEVICE_ProcessStandardDeviceGetRequests
1866:                (
1867:                    USB_DEVICE_OBJ * usbDeviceThisInstance,
1868:                    USB_SETUP_PACKET * setupPkt 
1869:                )
1870:                {
9D00779C  27BDFFD8   ADDIU SP, SP, -40
9D0077A0  AFBF0024   SW RA, 36(SP)
9D0077A4  AFB10020   SW S1, 32(SP)
9D0077A8  AFB0001C   SW S0, 28(SP)
9D0077AC  00808821   ADDU S1, A0, ZERO
9D0077B0  00A08021   ADDU S0, A1, ZERO
1871:                    USB_CONFIGURATION_DESCRIPTOR * lConfigDescriptor = NULL;
1872:                    uint16_t size = 0;
9D007994  00001021   ADDU V0, ZERO, ZERO
1873:                    void*  pData = NULL;
9D0077B4  AFA00010   SW ZERO, 16(SP)
1874:                    USB_DEVICE_MASTER_DESCRIPTOR * ptrMasterDescTable ;
1875:                
1876:                    /* Copy the Master descriptor table to a local pointer. */
1877:                    ptrMasterDescTable = usbDeviceThisInstance->ptrMasterDescTable ;
1878:                    
1879:                    if(setupPkt->bRequest == USB_REQUEST_GET_DESCRIPTOR)
9D0077B8  90A20001   LBU V0, 1(A1)
9D0077BC  24030006   ADDIU V1, ZERO, 6
9D0077C0  14430062   BNE V0, V1, 0x9D00794C
9D0077C4  8C840008   LW A0, 8(A0)
1880:                    {
1881:                        switch(setupPkt->bDescriptorType)
9D0077C8  90A20003   LBU V0, 3(A1)
9D0077CC  2C420008   SLTIU V0, V0, 8
9D0077D0  10400070   BEQ V0, ZERO, 0x9D007994
9D0077D4  3C029D00   LUI V0, -25344
9D0077D8  90A30003   LBU V1, 3(A1)
9D0077DC  00031880   SLL V1, V1, 2
9D0077E0  244277F4   ADDIU V0, V0, 30708
9D0077E4  00431021   ADDU V0, V0, V1
9D0077E8  8C420000   LW V0, 0(V0)
9D0077EC  00400008   JR V0
9D0077F0  00000000   NOP
1882:                        {
1883:                            case USB_DESCRIPTOR_DEVICE:
1884:                                if(usbDeviceThisInstance->usbDeviceStatusStruct.usbSpeed == USB_SPEED_HIGH)
9D007814  8E230000   LW V1, 0(S1)
9D007818  3063000E   ANDI V1, V1, 14
9D00781C  24020002   ADDIU V0, ZERO, 2
9D007820  54620005   BNEL V1, V0, 0x9D007838
9D007824  8C820000   LW V0, 0(A0)
1885:                                {
1886:                                    /* High speed descriptor. */
1887:                                    if( ptrMasterDescTable->highSpeedDeviceDescriptor == NULL )
1888:                                    {
1889:                                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: High speed device descriptor is NULL" );
1890:                                    }
1891:                
1892:                                    /* Pointer to high speed device descriptor.*/
1893:                                    pData = ( (uint8_t*) ptrMasterDescTable->highSpeedDeviceDescriptor );
9D007828  8C82000C   LW V0, 12(A0)
9D00782C  AFA20010   SW V0, 16(SP)
9D007830  0B401E66   J 0x9D007998
9D007834  24020012   ADDIU V0, ZERO, 18
1894:                                }
1895:                                else
1896:                                {
1897:                                    /* Full/low speed descriptor.*/
1898:                                    if( ptrMasterDescTable->deviceDescriptor == NULL )
1899:                                    {   
1900:                                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Full/Low speed device descriptor is NULL");
1901:                                    }
1902:                
1903:                                    /* Full/low speed device descriptor points usbDeviceThisInstance->ptrMasterDescTabler */
1904:                                    pData = ( (uint8_t*) ptrMasterDescTable->deviceDescriptor );
9D007838  AFA20010   SW V0, 16(SP)
1905:                                }
1906:                
1907:                                /* Total size of the device descriptor (Its always 18). */
1908:                                size = 18;
9D00783C  0B401E66   J 0x9D007998
9D007840  24020012   ADDIU V0, ZERO, 18
1909:                                break;
1910:                
1911:                            case USB_DESCRIPTOR_CONFIGURATION:                
1912:                
1913:                                /* Get correct pointer to the descriptor based on config value.
1914:                                 * setupPkt->bDscIndex indicates the host requested
1915:                                 * configuration index.  Make sure that the requested
1916:                                 * configuration index is with in the limits.*/
1917:                
1918:                                if( (setupPkt->bDscIndex) < usbDeviceThisInstance->maxConfigs )
9D007844  90A20002   LBU V0, 2(A1)
9D007848  922300AA   LBU V1, 170(S1)
9D00784C  0043182B   SLTU V1, V0, V1
9D007850  10600055   BEQ V1, ZERO, 0x9D0079A8
9D007854  02202021   ADDU A0, S1, ZERO
1919:                                {
1920:                                    lConfigDescriptor = (USB_CONFIGURATION_DESCRIPTOR *)usbDeviceThisInstance->configDescriptorsPtr[setupPkt->bDscIndex];
9D007858  8E2300AC   LW V1, 172(S1)
9D00785C  00021080   SLL V0, V0, 2
9D007860  00621021   ADDU V0, V1, V0
9D007864  8C430000   LW V1, 0(V0)
1921:                                    if(lConfigDescriptor != NULL )
9D007868  1060004F   BEQ V1, ZERO, 0x9D0079A8
9D00786C  00000000   NOP
1922:                                    {
1923:                                        /* We have a valid specified configuration. Prepare the
1924:                                         * output variables */
1925:                                        pData  = (uint8_t *)lConfigDescriptor;
9D007870  AFA30010   SW V1, 16(SP)
1926:                                        size = lConfigDescriptor->wTotalLength;
9D007874  90640002   LBU A0, 2(V1)
9D007878  90620003   LBU V0, 3(V1)
9D00787C  00021200   SLL V0, V0, 8
9D007880  0B401E7B   J 0x9D0079EC
9D007884  00441025   OR V0, V0, A0
1927:                                    }
1928:                                    else
1929:                                    {
1930:                                        /* Configuration not found */
1931:                                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Invalid pointer to configuration descriptor");
1932:                                        pData = NULL;
1933:                                    }
1934:                                }
1935:                                break;
1936:                
1937:                            case USB_DESCRIPTOR_OTHER_SPEED:
1938:                
1939:                                /* Host has requested for the other speed descriptor */
1940:                
1941:                                if( usbDeviceThisInstance->usbDeviceStatusStruct.usbSpeed == USB_SPEED_HIGH )
9D007888  8E230000   LW V1, 0(S1)
9D00788C  3063000E   ANDI V1, V1, 14
9D007890  24020002   ADDIU V0, ZERO, 2
9D007894  1462000B   BNE V1, V0, 0x9D0078C4
9D007898  90A20002   LBU V0, 2(A1)
1942:                                {
1943:                                    if (((setupPkt->bDscIndex) < ptrMasterDescTable->configDescriptorCount) && (ptrMasterDescTable->configDescriptorTable != NULL))
9D00789C  90830004   LBU V1, 4(A0)
9D0078A0  0043182B   SLTU V1, V0, V1
9D0078A4  50600040   BEQL V1, ZERO, 0x9D0079A8
9D0078A8  02202021   ADDU A0, S1, ZERO
9D0078AC  8C830008   LW V1, 8(A0)
9D0078B0  1060003C   BEQ V1, ZERO, 0x9D0079A4
9D0078B4  00021080   SLL V0, V0, 2
1944:                                    {
1945:                                        /* In case of High Speed, we send the full speed
1946:                                         * configuraion descriptor */
1947:                                        lConfigDescriptor = (USB_CONFIGURATION_DESCRIPTOR *)ptrMasterDescTable->configDescriptorTable[setupPkt->bDscIndex];
9D0078B8  00621821   ADDU V1, V1, V0
9D0078BC  0B401E3A   J 0x9D0078E8
9D0078C0  8C630000   LW V1, 0(V1)
1948:                                    }
1949:                                }
1950:                                else
1951:                                {
1952:                                    if (((setupPkt->bDscIndex) < ptrMasterDescTable->highSpeedConfigDescriptorCount)
9D0078C4  90830010   LBU V1, 16(A0)
9D0078C8  0043182B   SLTU V1, V0, V1
9D0078CC  50600036   BEQL V1, ZERO, 0x9D0079A8
9D0078D0  02202021   ADDU A0, S1, ZERO
1953:                                            && (ptrMasterDescTable->highSpeedConfigDescriptorTable != NULL))
9D0078D4  8C830014   LW V1, 20(A0)
9D0078D8  10600032   BEQ V1, ZERO, 0x9D0079A4
9D0078DC  00021080   SLL V0, V0, 2
1954:                                    {
1955:                                        /* If the device is operating at full speed, then send
1956:                                         * the high speed configuration descriptor */
1957:                                        lConfigDescriptor = (USB_CONFIGURATION_DESCRIPTOR *)ptrMasterDescTable->highSpeedConfigDescriptorTable[setupPkt->bDscIndex];
9D0078E0  00621821   ADDU V1, V1, V0
9D0078E4  8C630000   LW V1, 0(V1)
1958:                                    }
1959:                                }
1960:                
1961:                                if(lConfigDescriptor != NULL )
9D0078E8  1060002E   BEQ V1, ZERO, 0x9D0079A4
9D0078EC  24020007   ADDIU V0, ZERO, 7
1962:                                {
1963:                                    /* We have a valid specified configuration. Prepare the
1964:                                     * output variables */
1965:                                    lConfigDescriptor->bDescriptorType = USB_DESCRIPTOR_OTHER_SPEED; 
9D0078F0  A0620001   SB V0, 1(V1)
1966:                                    pData  = (uint8_t *)lConfigDescriptor;
9D0078F4  AFA30010   SW V1, 16(SP)
1967:                                    size = lConfigDescriptor->wTotalLength;
9D0078F8  90640002   LBU A0, 2(V1)
9D0078FC  90620003   LBU V0, 3(V1)
9D007900  00021200   SLL V0, V0, 8
9D007904  0B401E7B   J 0x9D0079EC
9D007908  00441025   OR V0, V0, A0
1968:                                }
1969:                                else
1970:                                {
1971:                                    /* Configuration not found */
1972:                                    SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Invalid pointer to configuration descriptor");
1973:                                    pData = NULL;
1974:                                }
1975:                                break;
1976:                
1977:                            case USB_DESCRIPTOR_DEVICE_QUALIFIER:
1978:                
1979:                                if( usbDeviceThisInstance->usbDeviceStatusStruct.usbSpeed == USB_SPEED_HIGH )
9D00790C  8E230000   LW V1, 0(S1)
9D007910  3063000E   ANDI V1, V1, 14
9D007914  24020002   ADDIU V0, ZERO, 2
9D007918  54620005   BNEL V1, V0, 0x9D007930
9D00791C  8C820024   LW V0, 36(A0)
1980:                                {
1981:                                    /* For high speed, respond with the other speed (full speed) device_qualifier. */
1982:                                    pData = (uint8_t*) ptrMasterDescTable->fullSpeedDeviceQualifier;
9D007920  8C820020   LW V0, 32(A0)
9D007924  AFA20010   SW V0, 16(SP)
9D007928  0B401E66   J 0x9D007998
9D00792C  2402000A   ADDIU V0, ZERO, 10
1983:                                }
1984:                                else
1985:                                {
1986:                                    /* For full speed, respond with the other speed (high speed) device_qualifier. */
1987:                                    pData = ((uint8_t*) ptrMasterDescTable->highSpeedDeviceQualifier );
9D007930  AFA20010   SW V0, 16(SP)
1988:                                } 
1989:                
1990:                                /* Size of device_qualifier descriptor is always 10. */
1991:                                size = 10;
9D007934  0B401E66   J 0x9D007998
9D007938  2402000A   ADDIU V0, ZERO, 10
1992:                                break;
1993:                
1994:                            case USB_DESCRIPTOR_STRING:
1995:                
1996:                                /* A string descriptor was requested */
1997:                                size = _USB_DEVICE_GetStringDescriptorRequest(ptrMasterDescTable, setupPkt, &pData );
9D00793C  0F40432B   JAL _USB_DEVICE_GetStringDescriptorRequestProcess
9D007940  27A60010   ADDIU A2, SP, 16
1998:                                break;
9D007944  0B401E67   J 0x9D00799C
9D007948  8FA50010   LW A1, 16(SP)
1999:                
2000:                            case USB_DESCRIPTOR_BOS:
2001:                
2002:                                /* A BOS descriptor was requested */
2003:                                _USB_DEVICE_GetBosDescriptorRequest(ptrMasterDescTable->bosDescriptor, pData, size );
2004:                                break; 
2005:                
2006:                            default:
2007:                                break;
2008:                        } 
2009:                    }
2010:                    else if (setupPkt->bRequest == USB_REQUEST_GET_CONFIGURATION)
9D00794C  24030008   ADDIU V1, ZERO, 8
9D007950  14430005   BNE V0, V1, 0x9D007968
9D007954  00000000   NOP
2011:                    {
2012:                        /* Host wants to know what is current configuration */
2013:                        pData = &(usbDeviceThisInstance->activeConfiguration);
9D007958  262200A9   ADDIU V0, S1, 169
9D00795C  AFA20010   SW V0, 16(SP)
9D007960  0B401E66   J 0x9D007998
9D007964  24020001   ADDIU V0, ZERO, 1
2014:                        size = 1;
2015:                    }
2016:                    else if (setupPkt->bRequest == USB_REQUEST_GET_STATUS)
9D007968  1440000F   BNE V0, ZERO, 0x9D0079A8
9D00796C  02202021   ADDU A0, S1, ZERO
2017:                    {
2018:                        /* The host want to know the power status and remote wakeup status of
2019:                         * the device. */
2020:                        usbDeviceThisInstance->getStatusResponse.status = 0;
2021:                        usbDeviceThisInstance->getStatusResponse.selfPowered = usbDeviceThisInstance->usbDeviceStatusStruct.powerState;
9D007970  8E230000   LW V1, 0(S1)
9D007974  7C620004   INS V0, V1, 0, 1
2022:                        usbDeviceThisInstance->getStatusResponse.remoteWakeup = usbDeviceThisInstance->remoteWakeupStatus;
9D007978  8E2300BC   LW V1, 188(S1)
9D00797C  7C620844   INS V0, V1, 1, 1
9D007980  A62200B8   SH V0, 184(S1)
2023:                        pData = (uint8_t *)&usbDeviceThisInstance->getStatusResponse;
9D007984  262200B8   ADDIU V0, S1, 184
9D007988  AFA20010   SW V0, 16(SP)
2024:                        size = 2;
9D00798C  0B401E66   J 0x9D007998
9D007990  24020002   ADDIU V0, ZERO, 2
2025:                    }
2026:                
2027:                    if(pData == NULL)
9D007998  8FA50010   LW A1, 16(SP)
9D00799C  54A00007   BNEL A1, ZERO, 0x9D0079BC
9D0079A0  92040006   LBU A0, 6(S0)
9D0079EC  0B401E6E   J 0x9D0079B8
9D0079F0  8FA50010   LW A1, 16(SP)
2028:                    {
2029:                        /* We don't have valid data to send. STALL the transfer */
2030:                        USB_DEVICE_ControlStatus((USB_DEVICE_HANDLE)usbDeviceThisInstance, USB_DEVICE_CONTROL_STATUS_ERROR );
9D0079A4  02202021   ADDU A0, S1, ZERO
9D0079A8  0F404BC3   JAL USB_DEVICE_ControlStatus
9D0079AC  24050001   ADDIU A1, ZERO, 1
9D0079B0  0B401E7D   J 0x9D0079F4
9D0079B4  8FBF0024   LW RA, 36(SP)
2031:                    }
2032:                    else
2033:                    {
2034:                        /* Limit the size. */
2035:                        if( size > setupPkt->wLength )
9D0079B8  92040006   LBU A0, 6(S0)
9D0079BC  92030007   LBU V1, 7(S0)
9D0079C0  00031A00   SLL V1, V1, 8
9D0079C4  00641825   OR V1, V1, A0
9D0079C8  00403021   ADDU A2, V0, ZERO
9D0079CC  0062102B   SLTU V0, V1, V0
9D0079D0  54400001   BNEL V0, ZERO, 0x9D0079D8
9D0079D4  00603021   ADDU A2, V1, ZERO
2036:                        {
2037:                            size = setupPkt->wLength;
2038:                        }
2039:                
2040:                        /* Send the data stage */
2041:                        USB_DEVICE_ControlSend( (USB_DEVICE_HANDLE)usbDeviceThisInstance, pData, size );
9D0079D8  02202021   ADDU A0, S1, ZERO
9D0079DC  0F404B42   JAL USB_DEVICE_ControlSend
9D0079E0  30C6FFFF   ANDI A2, A2, -1
2042:                    }
2043:                }
9D0079E4  0B401E7D   J 0x9D0079F4
9D0079E8  8FBF0024   LW RA, 36(SP)
9D0079F4  8FB10020   LW S1, 32(SP)
9D0079F8  8FB0001C   LW S0, 28(SP)
9D0079FC  03E00008   JR RA
9D007A00  27BD0028   ADDIU SP, SP, 40
2044:                
2045:                // ******************************************************************************
2046:                /* Function:
2047:                    USB_DEVICE_FUNCTION_REGISTRATION_TABLE * _USB_DEVICE_GetFunctionDriverEntryByInterface
2048:                    (
2049:                        uint8_t interfaceNumber,
2050:                        USB_DEVICE_OBJ * usbDeviceThisInstance
2051:                    )
2052:                
2053:                  Summary:
2054:                    This function gets the correct entry in the function driver registration
2055:                    table for a given interface.
2056:                
2057:                  Description:
2058:                    This function gets the correct entry in the function driver registration
2059:                    table for a given interface.
2060:                
2061:                  Remarks:
2062:                    This is an internal function and should not be called directly by the client.
2063:                */
2064:                
2065:                USB_DEVICE_FUNCTION_REGISTRATION_TABLE * _USB_DEVICE_GetFunctionDriverEntryByInterface
2066:                (
2067:                    uint8_t interfaceNumber,
2068:                    USB_DEVICE_OBJ * usbDeviceThisInstance
2069:                )
2070:                {
2071:                    uint8_t count;
2072:                    uint16_t maxFunctionCounts = usbDeviceThisInstance->registeredFuncDriverCount;
9D012C00  94A6000C   LHU A2, 12(A1)
2073:                    USB_DEVICE_FUNCTION_REGISTRATION_TABLE * funcRegTable = usbDeviceThisInstance->registeredFuncDrivers;
9D012C04  8CA20010   LW V0, 16(A1)
2074:                    uint8_t speed = usbDeviceThisInstance->usbDeviceStatusStruct.usbSpeed ;
9D012C08  8CA70000   LW A3, 0(A1)
9D012C0C  7CE71040   EXT A3, A3, 1, 3
2075:                    uint8_t configValue = usbDeviceThisInstance->activeConfiguration ;
2076:                
2077:                    /* This loop finds the function driver that owns this interface */
2078:                    for(count = 0; count < maxFunctionCounts; count++ )
9D012C10  10C00018   BEQ A2, ZERO, 0x9D012C74
9D012C14  90A800A9   LBU T0, 169(A1)
9D012C18  00001821   ADDU V1, ZERO, ZERO
9D012C5C  306300FF   ANDI V1, V1, 255
9D012C60  0066282B   SLTU A1, V1, A2
9D012C64  14A0FFED   BNE A1, ZERO, 0x9D012C1C
9D012C68  24420014   ADDIU V0, V0, 20
9D012C6C  03E00008   JR RA
9D012C70  00001021   ADDU V0, ZERO, ZERO
2079:                    {
2080:                        if( (funcRegTable->speed & speed) && (funcRegTable->configurationValue == configValue)
9D012C1C  8C450000   LW A1, 0(V0)
9D012C20  00E52824   AND A1, A3, A1
9D012C24  50A0000D   BEQL A1, ZERO, 0x9D012C5C
9D012C28  24630001   ADDIU V1, V1, 1
9D012C2C  90450004   LBU A1, 4(V0)
9D012C30  14A8000A   BNE A1, T0, 0x9D012C5C
9D012C34  24630001   ADDIU V1, V1, 1
2081:                                && ( interfaceNumber >= funcRegTable->interfaceNumber ) &&
9D012C38  90450005   LBU A1, 5(V0)
9D012C3C  0085482B   SLTU T1, A0, A1
9D012C40  15200006   BNE T1, ZERO, 0x9D012C5C
9D012C44  00000000   NOP
9D012C50  0085282A   SLT A1, A0, A1
9D012C54  14A00009   BNE A1, ZERO, 0x9D012C7C
9D012C58  00000000   NOP
2082:                                (interfaceNumber < ( funcRegTable->interfaceNumber + funcRegTable->numberOfInterfaces )))
9D012C48  90490006   LBU T1, 6(V0)
9D012C4C  00A92821   ADDU A1, A1, T1
2083:                        {
2084:                            return(funcRegTable);
2085:                        }
2086:                        funcRegTable++;
2087:                    }
2088:                
2089:                    return NULL;
9D012C74  03E00008   JR RA
9D012C78  00001021   ADDU V0, ZERO, ZERO
2090:                }
9D012C7C  03E00008   JR RA
9D012C80  00000000   NOP
2091:                
2092:                // ******************************************************************************
2093:                /* Function:
2094:                    void _USB_DEVICE_ConfigureDevice( USB_DEVICE_OBJ* usbDeviceThisInstance )
2095:                
2096:                  Summary:
2097:                    This function configures the device. 
2098:                
2099:                  Description:
2100:                    The initialization of all the function drivers and opening of all endpoints
2101:                    are done here.
2102:                
2103:                  Returns:
2104:                    This is a local function and should not be called directly by the
2105:                    application.
2106:                */
2107:                
2108:                void _USB_DEVICE_ConfigureDevice( USB_DEVICE_OBJ* usbDeviceThisInstance )
2109:                {
9D00FA08  27BDFFB8   ADDIU SP, SP, -72
9D00FA0C  AFBF0044   SW RA, 68(SP)
9D00FA10  AFBE0040   SW S8, 64(SP)
9D00FA14  AFB7003C   SW S7, 60(SP)
9D00FA18  AFB60038   SW S6, 56(SP)
9D00FA1C  AFB50034   SW S5, 52(SP)
9D00FA20  AFB40030   SW S4, 48(SP)
9D00FA24  AFB3002C   SW S3, 44(SP)
9D00FA28  AFB20028   SW S2, 40(SP)
9D00FA2C  AFB10024   SW S1, 36(SP)
9D00FA30  AFB00020   SW S0, 32(SP)
2110:                    uint16_t parsedLength= 0;
9D00FA5C  00009021   ADDU S2, ZERO, ZERO
2111:                    uint16_t confTotalLength;
2112:                    uint8_t * pDescriptor = usbDeviceThisInstance->pActiveConfigDesc;
9D00FA34  8C9000B0   LW S0, 176(A0)
2113:                    uint8_t descriptorType;
2114:                    uint8_t interfaceNumber = 0;
9D00FA58  0000A821   ADDU S5, ZERO, ZERO
2115:                    uint8_t alternateSetting = 0;
9D00FA54  0000B821   ADDU S7, ZERO, ZERO
2116:                    USB_DEVICE_FUNCTION_REGISTRATION_TABLE * pFunctionRegTable = NULL;
9D00FA50  00008821   ADDU S1, ZERO, ZERO
2117:                    USB_DEVICE_FUNCTION_DRIVER * driver;
2118:                   
2119:                    confTotalLength = ((USB_CONFIGURATION_DESCRIPTOR *)pDescriptor)->wTotalLength;
9D00FA38  92020002   LBU V0, 2(S0)
9D00FA3C  92130003   LBU S3, 3(S0)
9D00FA40  00139A00   SLL S3, S3, 8
9D00FA44  02629825   OR S3, S3, V0
2120:                
2121:                    /* Start parsing the configuration desciptor. For each interface descriptor
2122:                     * that was found, find out the owning function driver and then initialize
2123:                     * the function driver. */
2124:                
2125:                    while(parsedLength < confTotalLength)
9D00FA48  12600023   BEQ S3, ZERO, 0x9D00FAD8
9D00FA4C  0080B021   ADDU S6, A0, ZERO
9D00FACC  0253102B   SLTU V0, S2, S3
9D00FAD0  5440FFE5   BNEL V0, ZERO, 0x9D00FA68
9D00FAD4  921E0001   LBU S8, 1(S0)
2126:                    {
2127:                        descriptorType = ((USB_DEVICE_SERVICE_DESCRIPTOR_HEAD *)pDescriptor)->bDescriptorType;
9D00FA64  921E0001   LBU S8, 1(S0)
2128:                        if(descriptorType == USB_DESCRIPTOR_INTERFACE)
9D00FA60  24140004   ADDIU S4, ZERO, 4
9D00FA68  17D40007   BNE S8, S4, 0x9D00FA88
9D00FA6C  00000000   NOP
2129:                        {
2130:                            /* If this descriptor was an interface, find out which function
2131:                             * driver owns this interface */ 
2132:                            pFunctionRegTable = NULL;
2133:                            interfaceNumber = ((USB_INTERFACE_DESCRIPTOR * )pDescriptor)->bInterfaceNumber;
9D00FA70  92150002   LBU S5, 2(S0)
2134:                            alternateSetting = ((USB_INTERFACE_DESCRIPTOR * )pDescriptor)->bAlternateSetting;
9D00FA74  92170003   LBU S7, 3(S0)
2135:                            pFunctionRegTable = _USB_DEVICE_GetFunctionDriverEntryByInterface(interfaceNumber , usbDeviceThisInstance);
9D00FA78  02A02021   ADDU A0, S5, ZERO
9D00FA7C  0F404B00   JAL _USB_DEVICE_GetFunctionDriverEntryByInterface
9D00FA80  02C02821   ADDU A1, S6, ZERO
9D00FA84  00408821   ADDU S1, V0, ZERO
2136:                        } 
2137:                
2138:                        if( pFunctionRegTable != NULL )
9D00FA88  5220000D   BEQL S1, ZERO, 0x9D00FAC0
9D00FA8C  92020000   LBU V0, 0(S0)
2139:                        {
2140:                            driver = (USB_DEVICE_FUNCTION_DRIVER *)(pFunctionRegTable->driver);
9D00FA90  8E220010   LW V0, 16(S1)
2141:                            
2142:                            if (driver != NULL)
9D00FA94  10400009   BEQ V0, ZERO, 0x9D00FABC
9D00FA98  02C02821   ADDU A1, S6, ZERO
2143:                            {
2144:                                /* Call the driver intialize by descriptor function. This will
2145:                                 * let the function driver know that it should start running and
2146:                                 * be initialized. */
2147:                                driver->initializeByDescriptor(pFunctionRegTable->funcDriverIndex, (USB_DEVICE_HANDLE)usbDeviceThisInstance,
9D00FA9C  96240008   LHU A0, 8(S1)
9D00FAA0  8E26000C   LW A2, 12(S1)
9D00FAA4  AFB70010   SW S7, 16(SP)
9D00FAA8  AFBE0014   SW S8, 20(SP)
9D00FAAC  AFB00018   SW S0, 24(SP)
9D00FAB0  8C420000   LW V0, 0(V0)
9D00FAB4  0040F809   JALR V0
9D00FAB8  02A03821   ADDU A3, S5, ZERO
2148:                                              pFunctionRegTable->funcDriverInit, interfaceNumber, alternateSetting, descriptorType, pDescriptor);
2149:                            }
2150:                        }
2151:                
2152:                        parsedLength += ((USB_DEVICE_SERVICE_DESCRIPTOR_HEAD *)pDescriptor)->bLength;
9D00FABC  92020000   LBU V0, 0(S0)
9D00FAC0  02429021   ADDU S2, S2, V0
9D00FAC4  3252FFFF   ANDI S2, S2, -1
2153:                        pDescriptor += ((USB_DEVICE_SERVICE_DESCRIPTOR_HEAD *)pDescriptor)->bLength;
9D00FAC8  02028021   ADDU S0, S0, V0
2154:                    }
2155:                }
9D00FAD8  8FBF0044   LW RA, 68(SP)
9D00FADC  8FBE0040   LW S8, 64(SP)
9D00FAE0  8FB7003C   LW S7, 60(SP)
9D00FAE4  8FB60038   LW S6, 56(SP)
9D00FAE8  8FB50034   LW S5, 52(SP)
9D00FAEC  8FB40030   LW S4, 48(SP)
9D00FAF0  8FB3002C   LW S3, 44(SP)
9D00FAF4  8FB20028   LW S2, 40(SP)
9D00FAF8  8FB10024   LW S1, 36(SP)
9D00FAFC  8FB00020   LW S0, 32(SP)
9D00FB00  03E00008   JR RA
9D00FB04  27BD0048   ADDIU SP, SP, 72
2156:                
2157:                // ******************************************************************************
2158:                /* Function:
2159:                    bool _USB_DEVICE_FindEndpoint
2160:                    ( 
2161:                        USB_DEVICE_OBJ* usbDeviceThisInstance,
2162:                        USB_ENDPOINT endpointNumber, 
2163:                        uint8_t* interfaceNumber
2164:                    )
2165:                
2166:                  Summary:
2167:                    This function takes an Endpoint Number as a parameter and finds the Endpoint
2168:                    belongs to which Interface.
2169:                
2170:                  Description:
2171:                    This function takes an Endpoint Number as a parameter and finds the Endpoint
2172:                    belongs to which Interface. This function finds the interface by parsing the
2173:                    USB descriptors. This is a local function and should not be called by
2174:                    applications directly.
2175:                
2176:                  Parameters:
2177:                    usbDeviceThisInstance   - This instance of the USB device layer.
2178:                    endpointNumber          - Endpoint Number .
2179:                    interfaceNumber         - pointer to Interface Number. This is an out parameter.
2180:                    
2181:                
2182:                  Returns:
2183:                    true - Returns true if the Endpoint number belongs to any of the registered
2184:                           interfaces. True indicates that a valid interface is found and user
2185:                           can read the interface number from the interfaceNumber parameter.
2186:                    false -Endpoint does not belong to any registered interface.
2187:                */
2188:                
2189:                bool _USB_DEVICE_FindEndpoint
2190:                (
2191:                    USB_DEVICE_OBJ* usbDeviceThisInstance, 
2192:                    USB_ENDPOINT endpointNumber,
2193:                    uint8_t* interfaceNum
2194:                )
2195:                {
2196:                    uint16_t parsedLength= 0;
2197:                    uint16_t confTotalLength;
2198:                    uint8_t * pDescriptor = usbDeviceThisInstance->pActiveConfigDesc;
9D012C84  8C8200B0   LW V0, 176(A0)
2199:                    uint8_t descriptorType;
2200:                
2201:                    confTotalLength = ((USB_CONFIGURATION_DESCRIPTOR *)pDescriptor)->wTotalLength;
9D012C88  90430002   LBU V1, 2(V0)
9D012C8C  90470003   LBU A3, 3(V0)
9D012C90  00073A00   SLL A3, A3, 8
9D012C94  00E33825   OR A3, A3, V1
2202:                
2203:                    /* Parse the configuration descriptor. When an endpoint descriptor is found,
2204:                     * check if the endpoint number matches the input endpoint number. */
2205:                    while(parsedLength < confTotalLength)
9D012C98  10E00017   BEQ A3, ZERO, 0x9D012CF8
9D012C9C  00001821   ADDU V1, ZERO, ZERO
9D012CE4  0067202B   SLTU A0, V1, A3
9D012CE8  5480FFF0   BNEL A0, ZERO, 0x9D012CAC
9D012CEC  90440001   LBU A0, 1(V0)
9D012CF0  03E00008   JR RA
9D012CF4  00001021   ADDU V0, ZERO, ZERO
2206:                    {
2207:                        descriptorType = ((USB_DEVICE_SERVICE_DESCRIPTOR_HEAD *)pDescriptor)->bDescriptorType;
9D012CA8  90440001   LBU A0, 1(V0)
2208:                        if(descriptorType == USB_DESCRIPTOR_INTERFACE)
9D012CA0  24080004   ADDIU T0, ZERO, 4
9D012CAC  14880004   BNE A0, T0, 0x9D012CC0
9D012CB0  00000000   NOP
2209:                        {
2210:                            *(interfaceNum) = ((USB_INTERFACE_DESCRIPTOR *)pDescriptor)->bInterfaceNumber;
9D012CB4  90440002   LBU A0, 2(V0)
9D012CB8  0B404B35   J 0x9D012CD4
9D012CBC  A0C40000   SB A0, 0(A2)
2211:                        }
2212:                        else if (descriptorType == USB_DESCRIPTOR_ENDPOINT)
9D012CA4  24090005   ADDIU T1, ZERO, 5
9D012CC0  54890005   BNEL A0, T1, 0x9D012CD8
9D012CC4  90440000   LBU A0, 0(V0)
2213:                        {
2214:                            if(endpointNumber == ((USB_ENDPOINT_DESCRIPTOR * )pDescriptor)->bEndpointAddress)
9D012CC8  90440002   LBU A0, 2(V0)
9D012CCC  1085000C   BEQ A0, A1, 0x9D012D00
9D012CD0  00000000   NOP
2215:                            {
2216:                                return true;
9D012D00  03E00008   JR RA
2217:                            }
2218:                        }
2219:                
2220:                        parsedLength += ((USB_DEVICE_SERVICE_DESCRIPTOR_HEAD *)pDescriptor)->bLength;
9D012CD4  90440000   LBU A0, 0(V0)
9D012CD8  00641821   ADDU V1, V1, A0
9D012CDC  3063FFFF   ANDI V1, V1, -1
2221:                        pDescriptor += ((USB_DEVICE_SERVICE_DESCRIPTOR_HEAD *)pDescriptor)->bLength;
9D012CE0  00441021   ADDU V0, V0, A0
2222:                    }
2223:                
2224:                    return false;
9D012CF8  03E00008   JR RA
9D012CFC  00001021   ADDU V0, ZERO, ZERO
9D012D00  03E00008   JR RA
9D012D04  24020001   ADDIU V0, ZERO, 1
2225:                }
2226:                
2227:                // ******************************************************************************
2228:                /* Function:
2229:                    void _USB_DEVICE_ProcessStandardSetRequests
2230:                    (
2231:                        USB_DEVICE_OBJ * usbDeviceThisInstance,
2232:                        USB_SETUP_PACKET * setupPkt
2233:                    )
2234:                
2235:                  Summary:
2236:                    Processes the standard "set" requests received from the USB Controller driver.
2237:                
2238:                  Description:
2239:                    This function processes the standard "set" requests received from the USB 
2240:                    Controller driver.
2241:                   
2242:                  Remarks:
2243:                    This is a local function and should not be called directly by the client.
2244:                */
2245:                
2246:                void _USB_DEVICE_ProcessStandardDeviceSetRequests
2247:                (
2248:                    USB_DEVICE_OBJ * usbDeviceThisInstance,
2249:                    USB_SETUP_PACKET * setupPkt
2250:                )
2251:                {   
9D0087BC  27BDFFD8   ADDIU SP, SP, -40
9D0087C0  AFBF0024   SW RA, 36(SP)
9D0087C4  AFB10020   SW S1, 32(SP)
9D0087C8  AFB0001C   SW S0, 28(SP)
9D0087CC  00808821   ADDU S1, A0, ZERO
2252:                    uint8_t count;
2253:                    USB_DEVICE_EVENT_DATA_CONFIGURED configuredEventData;
2254:                    USB_DEVICE_CONTROL_STATUS controlStatus = USB_DEVICE_CONTROL_STATUS_ERROR;
2255:                    bool sendStatus = true;
2256:                    
2257:                    switch(setupPkt->bRequest)
9D0087D0  90A20001   LBU V0, 1(A1)
9D0087D4  24030003   ADDIU V1, ZERO, 3
9D0087D8  1043005D   BEQ V0, V1, 0x9D008950
9D0087DC  00A08021   ADDU S0, A1, ZERO
9D0087E0  2C430004   SLTIU V1, V0, 4
9D0087E4  10600006   BEQ V1, ZERO, 0x9D008800
9D0087E8  24030005   ADDIU V1, ZERO, 5
9D0087EC  24030001   ADDIU V1, ZERO, 1
9D0087F0  5043004E   BEQL V0, V1, 0x9D00892C
9D0087F4  90A20002   LBU V0, 2(A1)
9D008800  10430005   BEQ V0, V1, 0x9D008818
9D008804  24030009   ADDIU V1, ZERO, 9
9D008808  5043000B   BEQL V0, V1, 0x9D008838
9D00880C  90A30002   LBU V1, 2(A1)
2258:                    {
2259:                        case USB_REQUEST_SET_ADDRESS:
2260:                
2261:                            /* Got set address command. Change the address only after responding
2262:                               to the current request.*/
2263:                            
2264:                            usbDeviceThisInstance->usbDeviceStatusStruct.setAddressPending = true;
9D008818  90820000   LBU V0, 0(A0)
9D00881C  24030001   ADDIU V1, ZERO, 1
9D008820  7C622104   INS V0, V1, 4, 1
9D008824  A0820000   SB V0, 0(A0)
2265:                            usbDeviceThisInstance->deviceAddress = setupPkt->bDevADR;
9D008828  90A20002   LBU V0, 2(A1)
9D00882C  A08200A8   SB V0, 168(A0)
2266:                            controlStatus = USB_DEVICE_CONTROL_STATUS_OK;
2267:                            
2268:                            break;
9D008830  0B40226D   J 0x9D0089B4
9D008834  00002821   ADDU A1, ZERO, ZERO
2269:                
2270:                        case USB_REQUEST_SET_CONFIGURATION: 
2271:                
2272:                            /* Device falls back to addressed state if configuration value is 0,
2273:                             * and if the device is already in configured state. */
2274:                            
2275:                            if((setupPkt->wValue == 0) && (usbDeviceThisInstance->usbDeviceStatusStruct.usbDeviceState == USB_DEVICE_STATE_CONFIGURED))
9D008838  90A20003   LBU V0, 3(A1)
9D00883C  00021200   SLL V0, V0, 8
9D008840  00431025   OR V0, V0, V1
9D008844  54400012   BNEL V0, ZERO, 0x9D008890
9D008848  922300A9   LBU V1, 169(S1)
9D00884C  8C840000   LW A0, 0(A0)
9D008850  3C030007   LUI V1, 7
9D008854  00832024   AND A0, A0, V1
9D008858  3C030005   LUI V1, 5
9D00885C  5483000C   BNEL A0, V1, 0x9D008890
9D008860  922300A9   LBU V1, 169(S1)
2276:                            {
2277:                                /* Configuration value 0 means, host is trying to de configure
2278:                                 * the device.  Set a event here. USB device layer task will
2279:                                 * de initialize the function drivers later.*/
2280:                                usbDeviceThisInstance->event = USB_DEVICE_EVENT_DECONFIGURED;
9D008864  2402000B   ADDIU V0, ZERO, 11
9D008868  AE2200B4   SW V0, 180(S1)
2281:                
2282:                                /* Deinit all function drivers. */
2283:                                _USB_DEVICE_DeInitializeAllFunctionDrivers ( usbDeviceThisInstance );
9D00886C  0F4045FB   JAL _USB_DEVICE_DeInitializeAllFunctionDrivers
9D008870  02202021   ADDU A0, S1, ZERO
2284:                
2285:                                /* Change the current active configuration to Zero */
2286:                                usbDeviceThisInstance->activeConfiguration = 0;
9D008874  A22000A9   SB ZERO, 169(S1)
2287:                
2288:                                /* Change the state to Addressed   */
2289:                                usbDeviceThisInstance->usbDeviceStatusStruct.usbDeviceState = USB_DEVICE_STATE_ADDRESSED;
9D008878  96220002   LHU V0, 2(S1)
9D00887C  24030004   ADDIU V1, ZERO, 4
9D008880  7C621004   INS V0, V1, 0, 3
9D008884  A6220002   SH V0, 2(S1)
9D008888  0B40226D   J 0x9D0089B4
9D00888C  00002821   ADDU A1, ZERO, ZERO
2290:                            }  
2291:                            else
2292:                            {
2293:                                /* Proceed only if new configuration value is different from
2294:                                 * current configuration value. */
2295:                                if( usbDeviceThisInstance->activeConfiguration != (uint8_t)setupPkt->wValue)
9D008890  304200FF   ANDI V0, V0, 255
9D008894  10620047   BEQ V1, V0, 0x9D0089B4
9D008898  00002821   ADDU A1, ZERO, ZERO
2296:                                {
2297:                                    for(count = 0; count < usbDeviceThisInstance->maxConfigs; count++)
9D00889C  922700AA   LBU A3, 170(S1)
9D0088A0  10E0000C   BEQ A3, ZERO, 0x9D0088D4
9D0088A4  00001021   ADDU V0, ZERO, ZERO
9D0088A8  8E2300AC   LW V1, 172(S1)
9D0088C0  24420001   ADDIU V0, V0, 1
9D0088C4  304200FF   ANDI V0, V0, 255
9D0088C8  0047202B   SLTU A0, V0, A3
9D0088CC  1480FFF7   BNE A0, ZERO, 0x9D0088AC
9D0088D0  24630004   ADDIU V1, V1, 4
2298:                                    {
2299:                                        /* 5th byte in the configuration descriptor table
2300:                                         * specifies the configuration value. */
2301:                
2302:                                        if( usbDeviceThisInstance->configDescriptorsPtr[count][5] == setupPkt->bConfigurationValue )
9D0088AC  8C640000   LW A0, 0(V1)
9D0088B0  90860005   LBU A2, 5(A0)
9D0088B4  92050002   LBU A1, 2(S0)
9D0088B8  50C50001   BEQL A2, A1, 0x9D0088C0
9D0088BC  AE2400B0   SW A0, 176(S1)
2303:                                        {
2304:                                            /* Got a configuration match. Get the pointer to
2305:                                             * configuration descriptor. We have to pass this to
2306:                                             * function driver, so that function driver can
2307:                                             * parse configuration descriptor and get the
2308:                                             * required info. */
2309:                
2310:                                            usbDeviceThisInstance->pActiveConfigDesc = (uint8_t *)usbDeviceThisInstance->configDescriptorsPtr[count];
2311:                                        }
2312:                                    }
2313:                
2314:                                    /* Save the current active configuration.  This may be
2315:                                     * required for clients to know which configuration is
2316:                                     * presently active. */
2317:                
2318:                                    usbDeviceThisInstance->activeConfiguration = (uint8_t)setupPkt->wValue;
9D0088D4  92020002   LBU V0, 2(S0)
9D0088D8  A22200A9   SB V0, 169(S1)
2319:                
2320:                                    /* In case the endpoint functions are enabled for Vendor operation,
2321:                                     * the endpoint queue sizes need to reset. */
2322:                                    _USB_DEVICE_EndpointCurrentQueueSizeReset(usbDeviceThisInstance->usbDevLayerIndex);
2323:                
2324:                                    /* Initialize all function drivers and change to configured
2325:                                     * state only if all function drivers are initialized
2326:                                     * successfully. */
2327:                                    _USB_DEVICE_ConfigureDevice(usbDeviceThisInstance);
9D0088DC  0F403E82   JAL _USB_DEVICE_ConfigureDevice
9D0088E0  02202021   ADDU A0, S1, ZERO
2328:                
2329:                                    /* Change the state to configured. */
2330:                                    usbDeviceThisInstance->usbDeviceStatusStruct.usbDeviceState = USB_DEVICE_STATE_CONFIGURED;
9D0088E4  96220002   LHU V0, 2(S1)
9D0088E8  24030005   ADDIU V1, ZERO, 5
9D0088EC  7C621004   INS V0, V1, 0, 3
9D0088F0  A6220002   SH V0, 2(S1)
2331:                
2332:                                    /* Set an event, so that application and function drivers
2333:                                     * are informed  about the same. */
2334:                                    configuredEventData.configurationValue = (uint8_t)setupPkt->wValue;
9D0088F4  92020002   LBU V0, 2(S0)
9D0088F8  A3A20010   SB V0, 16(SP)
2335:                
2336:                                    /* Inform the client about the event */
2337:                                    if((usbDeviceThisInstance->clientState == USB_DEVICE_CLIENT_STATUS_READY) &&
9D0088FC  8E2300D4   LW V1, 212(S1)
9D008900  24020001   ADDIU V0, ZERO, 1
9D008904  1462002B   BNE V1, V0, 0x9D0089B4
9D008908  00002821   ADDU A1, ZERO, ZERO
9D008910  10400028   BEQ V0, ZERO, 0x9D0089B4
9D008914  2404000A   ADDIU A0, ZERO, 10
2338:                                            (usbDeviceThisInstance->callBackFunc != NULL))
9D00890C  8E2200DC   LW V0, 220(S1)
2339:                                    {
2340:                                        /* This means this client is valid and is a client of this device
2341:                                           layer instance. Pass event to application */
2342:                                        usbDeviceThisInstance->callBackFunc (USB_DEVICE_EVENT_CONFIGURED, &configuredEventData, usbDeviceThisInstance->context);
9D008918  27A50010   ADDIU A1, SP, 16
9D00891C  0040F809   JALR V0
9D008920  8E2600E0   LW A2, 224(S1)
2343:                                    }
2344:                                }
2345:                            }
2346:                            
2347:                            controlStatus = USB_DEVICE_CONTROL_STATUS_OK;
9D008924  0B40226D   J 0x9D0089B4
9D008928  00002821   ADDU A1, ZERO, ZERO
2348:                            break;
2349:                
2350:                         case  USB_REQUEST_CLEAR_FEATURE:
2351:                
2352:                            if( setupPkt->wValue == USB_FEATURE_SELECTOR_DEVICE_REMOTE_WAKEUP )
9D00892C  90A30003   LBU V1, 3(A1)
9D008930  00031A00   SLL V1, V1, 8
9D008934  00621825   OR V1, V1, V0
9D008938  24020001   ADDIU V0, ZERO, 1
9D00893C  1462001D   BNE V1, V0, 0x9D0089B4
9D008940  24050001   ADDIU A1, ZERO, 1
2353:                            {
2354:                                /* The host is disabling the remote wakeup capability */
2355:                                usbDeviceThisInstance->remoteWakeupStatus = USB_DEVICE_REMOTE_WAKEUP_DISABLED ;
9D008944  AC8000BC   SW ZERO, 188(A0)
2356:                                controlStatus = USB_DEVICE_CONTROL_STATUS_OK;
9D008948  0B40226D   J 0x9D0089B4
9D00894C  00002821   ADDU A1, ZERO, ZERO
2357:                            }
2358:                            break;
2359:                
2360:                        case USB_REQUEST_SET_FEATURE:
2361:                
2362:                            if (setupPkt->wValue == USB_FEATURE_SELECTOR_DEVICE_REMOTE_WAKEUP)
9D008950  90A30002   LBU V1, 2(A1)
9D008954  90A20003   LBU V0, 3(A1)
9D008958  00021200   SLL V0, V0, 8
9D00895C  00431025   OR V0, V0, V1
9D008960  24030001   ADDIU V1, ZERO, 1
9D008964  14430005   BNE V0, V1, 0x9D00897C
9D008968  24030002   ADDIU V1, ZERO, 2
2363:                            {
2364:                                usbDeviceThisInstance->remoteWakeupStatus = USB_DEVICE_REMOTE_WAKEUP_ENABLED;
9D00896C  24020001   ADDIU V0, ZERO, 1
9D008970  AC8200BC   SW V0, 188(A0)
9D008974  0B40226D   J 0x9D0089B4
9D008978  00002821   ADDU A1, ZERO, ZERO
2365:                                controlStatus = USB_DEVICE_CONTROL_STATUS_OK;
2366:                            }
2367:                            else if (setupPkt->wValue == USB_FEATURE_SELECTOR_DEVICE_TEST_MODE)
9D00897C  1443000D   BNE V0, V1, 0x9D0089B4
9D008980  24050001   ADDIU A1, ZERO, 1
2368:                            {
2369:                                /* Enable test mode only if the Device Speed is High Speed */
2370:                                if (usbDeviceThisInstance->usbDeviceStatusStruct.usbSpeed == USB_SPEED_HIGH)
9D008984  8C830000   LW V1, 0(A0)
9D008988  3063000E   ANDI V1, V1, 14
9D00898C  24020002   ADDIU V0, ZERO, 2
9D008990  14620008   BNE V1, V0, 0x9D0089B4
9D008994  24030001   ADDIU V1, ZERO, 1
2371:                                {
2372:                                    /* Send ACK to the Test Mode request. */
2373:                                    controlStatus = USB_DEVICE_CONTROL_STATUS_OK;
2374:                
2375:                                    /* Save the Test Selector from SETUP Packet */
2376:                                    usbDeviceThisInstance->usbDeviceStatusStruct.testSelector = setupPkt->W_Index.byte.HB;
9D008998  92020005   LBU V0, 5(S0)
9D00899C  A0820001   SB V0, 1(A0)
2377:                
2378:                                    /* Switching to Test mode is done in the
2379:                                     * _USB_DEVICE_EP0_TransmitComplete function. */
2380:                                    usbDeviceThisInstance->usbDeviceStatusStruct.testModePending = true;
9D0089A0  90820000   LBU V0, 0(A0)
9D0089A4  7C622944   INS V0, V1, 5, 1
9D0089A8  A0820000   SB V0, 0(A0)
9D0089AC  0B40226D   J 0x9D0089B4
9D0089B0  00002821   ADDU A1, ZERO, ZERO
2381:                                }
2382:                                else
2383:                                {
2384:                                    /* Device is not High Speed. STALL the request. */
2385:                                    controlStatus = USB_DEVICE_CONTROL_STATUS_ERROR;
2386:                                }
2387:                            }
2388:                            break;
2389:                
2390:                        case USB_REQUEST_SET_DESCRIPTOR:      
2391:                
2392:                            /* All SET_DESCRIPTOR requests are directly forwarded to application */
2393:                            _USB_DEVICE_Handle_Set_Descriptor_Request ( usbDeviceThisInstance, USB_DEVICE_EVENT_SET_DESCRIPTOR, setupPkt);
2394:                            controlStatus = USB_DEVICE_CONTROL_STATUS_ERROR;
9D0087F8  0B40226D   J 0x9D0089B4
9D0087FC  24050001   ADDIU A1, ZERO, 1
9D008810  0B40226D   J 0x9D0089B4
9D008814  24050001   ADDIU A1, ZERO, 1
2395:                            break;
2396:                
2397:                        default:
2398:                            /* Respond with a request error. Stall the endpoint. Stall the EP0
2399:                             * TX. */
2400:                            controlStatus = USB_DEVICE_CONTROL_STATUS_ERROR;
2401:                            break;
2402:                    }
2403:                
2404:                    /* Send ZLP */
2405:                    if (sendStatus)
2406:                    {
2407:                        USB_DEVICE_ControlStatus( (USB_DEVICE_HANDLE)usbDeviceThisInstance, controlStatus);
9D0089B4  0F404BC3   JAL USB_DEVICE_ControlStatus
9D0089B8  02202021   ADDU A0, S1, ZERO
2408:                    }
2409:                }
9D0089BC  8FBF0024   LW RA, 36(SP)
9D0089C0  8FB10020   LW S1, 32(SP)
9D0089C4  8FB0001C   LW S0, 28(SP)
9D0089C8  03E00008   JR RA
9D0089CC  27BD0028   ADDIU SP, SP, 40
2410:                
2411:                // ******************************************************************************
2412:                /* Function:
2413:                    void _USB_DEVICE_RedirectControlXfrToClient
2414:                    (
2415:                        USB_DEVICE_OBJ* usbDeviceThisInstance ,
2416:                        USB_DEVICE_EVENT event,
2417:                        USB_SETUP_PACKET * setupPkt
2418:                    )
2419:                
2420:                  Summary:
2421:                    This function forwards control transfers to client.
2422:                
2423:                  Description:
2424:                    This function forwards control transfers to client.
2425:                
2426:                  Remarks:
2427:                    This is local function. It should not be used directly by the client.
2428:                */
2429:                
2430:                void _USB_DEVICE_RedirectControlXfrToClient
2431:                (
2432:                    USB_DEVICE_OBJ* usbDeviceThisInstance ,
2433:                    USB_DEVICE_EVENT event,
2434:                    USB_SETUP_PACKET * setupPkt
2435:                )
2436:                {
9D014410  27BDFFE8   ADDIU SP, SP, -24
9D014414  AFBF0014   SW RA, 20(SP)
2437:                    USB_DEVICE_CONTROL_TRANSFER_STRUCT * controlTransfer = &usbDeviceThisInstance->controlTransfer;
2438:                    
2439:                    /* This control transfer will be handled by the client */
2440:                    controlTransfer->handler = (void *)usbDeviceThisInstance->callBackFunc;
9D0143E8  8C8300DC   LW V1, 220(A0)
9D0143EC  AC8300CC   SW V1, 204(A0)
2441:                    controlTransfer->handlerIndex = usbDeviceThisInstance->usbDevLayerIndex ;
9D0143F0  94870014   LHU A3, 20(A0)
9D0143F4  A48700C4   SH A3, 196(A0)
2442:                
2443:                    /* Let app clients handle the SETUP packet. */
2444:                    if((usbDeviceThisInstance->clientState == USB_DEVICE_CLIENT_STATUS_READY) && (usbDeviceThisInstance->callBackFunc != NULL))
9D0143F8  8C8800D4   LW T0, 212(A0)
9D0143FC  24070001   ADDIU A3, ZERO, 1
9D014400  1507000A   BNE T0, A3, 0x9D01442C
9D014404  00801021   ADDU V0, A0, ZERO
9D014408  10600008   BEQ V1, ZERO, 0x9D01442C
9D01440C  00A02021   ADDU A0, A1, ZERO
2445:                    {
2446:                        /* This means this is a valid client. Pass the control transfer
2447:                         * event to the client. */
2448:                        usbDeviceThisInstance->callBackFunc( event, setupPkt, usbDeviceThisInstance->context );
9D014418  00C02821   ADDU A1, A2, ZERO
9D01441C  0060F809   JALR V1
9D014420  8C4600E0   LW A2, 224(V0)
2449:                    }
2450:                
2451:                }
9D014424  8FBF0014   LW RA, 20(SP)
9D014428  27BD0018   ADDIU SP, SP, 24
9D01442C  03E00008   JR RA
9D014430  00000000   NOP
2452:                
2453:                // ******************************************************************************
2454:                /* Function:
2455:                    USB_DEVICE_CLIENT_HANDLE _USB_DEVICE_ClientHandleValidate
2456:                    (
2457:                        USB_DEVICE_HANDLE deviceHandle
2458:                    )
2459:                
2460:                  Summary:
2461:                    Validates the client device handle.
2462:                
2463:                  Description:
2464:                    This function validates a device handle. It returns NULL if the device
2465:                    handle is not valid. It returns the pointer to the client object associated
2466:                    with the handle otherwise.
2467:                
2468:                  Remarks:
2469:                    This is a local function and should not be called directly by the client.
2470:                */
2471:                
2472:                USB_DEVICE_OBJ* _USB_DEVICE_ClientHandleValidate(USB_DEVICE_HANDLE deviceHandle)
2473:                {
2474:                    /* This function validates the client handle and return NULL if the client
2475:                       handle is invalid or if the client has closed the device layer. */
2476:                
2477:                    USB_DEVICE_OBJ* client;
2478:                
2479:                    if((USB_DEVICE_HANDLE_INVALID == deviceHandle) || (0 == deviceHandle))
9D0152AC  2482FFFF   ADDIU V0, A0, -1
9D0152B0  2C42FFFE   SLTIU V0, V0, -2
9D0152B4  10400005   BEQ V0, ZERO, 0x9D0152CC
9D0152B8  00000000   NOP
2480:                    {
2481:                        return (NULL);
2482:                    }
2483:                
2484:                    /* Check if the client object is in use */
2485:                    client = (USB_DEVICE_OBJ *) deviceHandle;
2486:                
2487:                    if(!client->inUse)
9D0152BC  908200D8   LBU V0, 216(A0)
2488:                    {
2489:                        return(NULL);
9D0152C0  0002200A   MOVZ A0, ZERO, V0
9D0152C4  03E00008   JR RA
9D0152C8  00801021   ADDU V0, A0, ZERO
2490:                    }
2491:                
2492:                    /* Return the client handle */
2493:                    return(client);
2494:                }
9D0152CC  03E00008   JR RA
9D0152D0  00001021   ADDU V0, ZERO, ZERO
2495:                
2496:                // ******************************************************************************
2497:                /* Function:
2498:                    void _USB_DEVICE_EndpointMutexCreateFunction
2499:                    (
2500:                        USB_DEVICE_OBJ* usbDeviceThisInstance
2501:                    )
2502:                
2503:                  Summary:
2504:                    Creats mutex which is required for Endpoint read write functions.
2505:                
2506:                  Description:
2507:                    Creats mutex which is required for Endpoint read write functions.
2508:                
2509:                  Remarks:
2510:                    This is a local function and should not be called directly by the client.
2511:                */
2512:                
2513:                void _USB_DEVICE_EndpointMutexCreateFunction(USB_DEVICE_OBJ* usbDeviceThisInstance)
2514:                {
2515:                    
2516:                    OSAL_RESULT osalResult;
2517:                    
2518:                    if (usbDeviceThisInstance->isMutexEndpointIrpInitialized == false)
2519:                    {
2520:                        /* Use the OSAL to create Mutex */
2521:                        osalResult = OSAL_MUTEX_Create(&(usbDeviceThisInstance->mutexEndpointIRP));
2522:                    
2523:                    
2524:                        if(osalResult != OSAL_RESULT_TRUE)
2525:                        {
2526:                            /* Mutex creation failed*/
2527:                            usbDeviceThisInstance->isMutexEndpointIrpInitialized = false;
2528:                            SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Mutex Create Failed");
2529:                        }
2530:                        else
2531:                        {
2532:                            /* Update the flag indicating that the Mutex has been created */
2533:                            usbDeviceThisInstance->isMutexEndpointIrpInitialized = true;
2534:                        }
2535:                    }
2536:                }
2537:                
2538:                // ******************************************************************************
2539:                /* Function:
2540:                    void _USB_DEVICE_EndpointMutexDeleteFunction
2541:                    (
2542:                        USB_DEVICE_OBJ* usbDeviceThisInstance
2543:                    )
2544:                
2545:                  Summary:
2546:                    Deletes mutex which is required for Endpoint read write functions.
2547:                
2548:                  Description:
2549:                    Deletes mutex which is required for Endpoint read write functions.
2550:                
2551:                  Remarks:
2552:                    This is a local function and should not be called directly by the client.
2553:                */
2554:                
2555:                void _USB_DEVICE_EndpointMutexDeleteFunction(USB_DEVICE_OBJ* usbDeviceThisInstance)
2556:                {
2557:                    OSAL_RESULT osalResult;
2558:                
2559:                    /* Use the OSAL to delete the Mutex */
2560:                    osalResult = OSAL_MUTEX_Delete(&(usbDeviceThisInstance->mutexEndpointIRP));
2561:                
2562:                    if(osalResult != OSAL_RESULT_TRUE)
2563:                    {
2564:                        /* Mutex delete failed */
2565:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Mutex Delete Failed");
2566:                    }
2567:                    else
2568:                    {
2569:                        /* Update the flag indicating that the mutex needs to be created again
2570:                         * */
2571:                        usbDeviceThisInstance->isMutexEndpointIrpInitialized = false;
2572:                    }
2573:                }
2574:                
2575:                // ******************************************************************************
2576:                /* Function:
2577:                    uint16_t _USB_DEVICE_GetStringDescriptorRequestProcess
2578:                    (
2579:                        USB_DEVICE_MASTER_DESCRIPTOR * ptrMasterDescTable,
2580:                        USB_SETUP_PACKET * setupPkt,
2581:                        void**  pDescriptorString
2582:                    )
2583:                  Summary:
2584:                    This function processes the Get Descriptor request received from Host.
2585:                
2586:                  Description:
2587:                    This function processes the Get Descriptor request received from Host.
2588:                    The USB Device Layer chooses this function when the macro
2589:                    USB_DEVICE_STRING_DESCRIPTOR_TABLE_ADVANCED_ENABLE is not defined.
2590:                
2591:                    This function is implemented based on the following String Descriptor 
2592:                    Table structure. 
2593:                    
2594:                    Following example assumes the Device supports 3 String Descriptors in 3 
2595:                    different Languages. 
2596:                    
2597:                        String Descriptor Index 0 -- Specifies Codes for all the Language 
2598:                                                     supported. 
2599:                        String -- Index 1 -- Language 1
2600:                        String -- Index 2 -- Language 1
2601:                        String -- Index 3 -- Language 1
2602:                        String -- Index 1 -- Language 2
2603:                        String -- Index 2 -- Language 2
2604:                        String -- Index 3 -- Language 2
2605:                        String -- Index 1 -- Language 3
2606:                        String -- Index 2 -- Language 3
2607:                        String -- Index 3 -- Language 3 
2608:                
2609:                  Remarks:
2610:                    This is a local function and should not be called directly by the client.
2611:                */
2612:                
2613:                uint16_t _USB_DEVICE_GetStringDescriptorRequestProcess
2614:                (
2615:                    USB_DEVICE_MASTER_DESCRIPTOR * ptrMasterDescTable,
2616:                    USB_SETUP_PACKET * setupPkt,
2617:                    void**  pDescriptorString
2618:                )
2619:                {
2620:                    uint8_t* stringDesc;
2621:                    uint8_t NumberLangSupported =0;
2622:                    uint16_t langID;
2623:                    uint16_t langIndex;
2624:                    uint16_t CurrentLangId;
2625:                    uint8_t stringIndex;
2626:                    uint16_t DescriptorStringSize = 0;
9D010D74  00001021   ADDU V0, ZERO, ZERO
2627:                
2628:                    /* Get the string descriptor index from setup packet*/
2629:                    stringIndex = setupPkt->bDscIndex;
9D010CAC  90A80002   LBU T0, 2(A1)
2630:                    uint8_t stringDescPerLang =0; 
2631:                    
2632:                    /* Find Number Languages supported from String Descriptor array index 0 */
2633:                    NumberLangSupported = (uint8_t)((ptrMasterDescTable->stringDescriptorTable[0][0]) - 2)/2;   
9D010CB0  8C89001C   LW T1, 28(A0)
9D010CB4  8D270000   LW A3, 0(T1)
9D010CB8  90E30000   LBU V1, 0(A3)
9D010CBC  2463FFFE   ADDIU V1, V1, -2
9D010CC0  7C633040   EXT V1, V1, 1, 7
2634:                    
2635:                    if (NumberLangSupported)
9D010CC4  10600007   BEQ V1, ZERO, 0x9D010CE4
9D010CC8  00001021   ADDU V0, ZERO, ZERO
2636:                    {
2637:                        /* Get Number of Strings per Language */
2638:                        stringDescPerLang = (ptrMasterDescTable->stringDescCount - 1)/NumberLangSupported; 
9D010CCC  90820018   LBU V0, 24(A0)
9D010CD0  2442FFFF   ADDIU V0, V0, -1
9D010CD4  0043001A   DIV V0, V1
9D010CD8  006001F4   TEQ V1, ZERO
9D010CDC  00001012   MFLO V0
9D010CE0  304200FF   ANDI V0, V0, 255
2639:                    }
2640:                    
2641:                    /* Check if the String Index requested by Host is with in the String
2642:                     * descriptor count specified in the Master descriptor Table */ 
2643:                
2644:                    if(setupPkt->bDscIndex <= stringDescPerLang)
9D010CE4  0048202B   SLTU A0, V0, T0
9D010CE8  14800023   BNE A0, ZERO, 0x9D010D78
9D010CEC  00001021   ADDU V0, ZERO, ZERO
2645:                    {
2646:                        /* This means the index is valid. Get correct string
2647:                         * descriptor and update the response variable */
2648:                
2649:                        if (stringIndex == 0)
9D010CF0  55000004   BNEL T0, ZERO, 0x9D010D04
9D010CF4  90A20004   LBU V0, 4(A1)
2650:                        {
2651:                            /* Get pointer to String Descriptor */ 
2652:                            stringDesc = (uint8_t*)(ptrMasterDescTable->stringDescriptorTable[0] );
2653:                            *pDescriptorString = (uint8_t *)stringDesc;
9D010CF8  ACC70000   SW A3, 0(A2)
9D010CFC  03E00008   JR RA
9D010D00  90E20000   LBU V0, 0(A3)
2654:                
2655:                            /* Get Size of the String descriptor. Size is always the First
2656:                             * element in the String descriptor structure  */  
2657:                            DescriptorStringSize = stringDesc[0];
2658:                        }
2659:                        else
2660:                        {
2661:                            /* Retrieve Language ID from SETUP packet */
2662:                            langID = setupPkt->wLangID;
9D010D04  90A50005   LBU A1, 5(A1)
9D010D08  00052A00   SLL A1, A1, 8
9D010D0C  00A22825   OR A1, A1, V0
2663:                
2664:                            /* Search through the String Descriptor Array (Index Zero) to find
2665:                             * out Language ID Index*/
2666:                            for (langIndex = 1; langIndex <= NumberLangSupported; langIndex++)
9D010D10  10600018   BEQ V1, ZERO, 0x9D010D74
9D010D14  00602021   ADDU A0, V1, ZERO
9D010D58  24420001   ADDIU V0, V0, 1
9D010D5C  3042FFFF   ANDI V0, V0, -1
9D010D60  0082182B   SLTU V1, A0, V0
9D010D64  1060FFF1   BEQ V1, ZERO, 0x9D010D2C
9D010D68  00021840   SLL V1, V0, 1
9D010D6C  03E00008   JR RA
9D010D70  00001021   ADDU V0, ZERO, ZERO
2667:                            {
2668:                                /* Get the Language ID from String Descriptor Index 0 */ 
2669:                                CurrentLangId = *((uint16_t*)ptrMasterDescTable->stringDescriptorTable[0] + langIndex);
9D010D2C  00E31821   ADDU V1, A3, V1
2670:                
2671:                                /* Check if the requested Language ID same as Current Language ID */ 
2672:                                if (CurrentLangId == langID)
9D010D18  94E20002   LHU V0, 2(A3)
9D010D1C  1445000E   BNE V0, A1, 0x9D010D58
9D010D20  24020001   ADDIU V0, ZERO, 1
9D010D30  94630000   LHU V1, 0(V1)
9D010D34  54650009   BNEL V1, A1, 0x9D010D5C
9D010D38  24420001   ADDIU V0, V0, 1
9D010D3C  70481002   MUL V0, V0, T0
2673:                                {
2674:                                    /* The Requested String Descriptor and Language was found.
2675:                                     * Get pointer to String Descriptor */ 
2676:                                    stringDesc = (uint8_t*)( ptrMasterDescTable->stringDescriptorTable[langIndex*stringIndex] );
9D010D24  0B404350   J 0x9D010D40
9D010D28  70481002   MUL V0, V0, T0
9D010D40  00021080   SLL V0, V0, 2
9D010D44  01224821   ADDU T1, T1, V0
9D010D48  8D220000   LW V0, 0(T1)
2677:                                    *pDescriptorString = (uint8_t *)stringDesc;
9D010D4C  ACC20000   SW V0, 0(A2)
2678:                                    
2679:                                    /* Get Size of the String descriptor. Size is always the
2680:                                     * First element in the String descriptor structure  */
2681:                                    DescriptorStringSize = stringDesc[0];
2682:                                    break;
9D010D50  03E00008   JR RA
9D010D54  90420000   LBU V0, 0(V0)
2683:                                }
2684:                            }
2685:                        }
2686:                
2687:                        return DescriptorStringSize;
2688:                    }
2689:                
2690:                    /* We could not find the requested String Descriptor in the String 
2691:                       Descriptor Table. The request will be stalled. */  
2692:                    
2693:                    return 0; 
2694:                }
9D010D78  03E00008   JR RA
9D010D7C  00000000   NOP
2695:                
2696:                // ******************************************************************************
2697:                /* Function:
2698:                    uint16_t _USB_DEVICE_GetStringDescriptorRequestProcessAdvanced
2699:                    (
2700:                        USB_DEVICE_MASTER_DESCRIPTOR * ptrMasterDescTable,
2701:                        USB_SETUP_PACKET * setupPkt,
2702:                        void**  pDescriptorString
2703:                    )
2704:                
2705:                  Summary:
2706:                    This function processes the Get Descriptor request received from Host.
2707:                
2708:                  Description:
2709:                    This function processes the Get Descriptor request received from Host.
2710:                    The USB Device Layer chooses this function when the macro
2711:                    USB_DEVICE_STRING_DESCRIPTOR_TABLE_ADVANCED_ENABLE is defined.
2712:                
2713:                    This function is implemented based on the following String Descriptor 
2714:                    Table structure. 
2715:                    
2716:                            |Size(Byte)|Type(Byte)|String Index 0(Byte)|0(Word)|Language ID 1(Word)|Language ID 2(Word)|...|Language ID n(Word)|
2717:                            |Size(Byte)|Type(Byte)|String Index x(Byte)|Language ID 1(Word)|String |
2718:                            |Size(Byte)|Type(Byte)|String Index x(Byte)|Language ID 1(Word)|String |
2719:                            .
2720:                            .
2721:                            .
2722:                            |Size(Byte)|Type(Byte)|String Index x(Byte)|Language ID n(Word)|String |
2723:                
2724:                  Remarks:
2725:                    This is a local function and should not be called directly by the client.
2726:                */
2727:                
2728:                uint16_t _USB_DEVICE_GetStringDescriptorRequestProcessAdvanced
2729:                (
2730:                    USB_DEVICE_MASTER_DESCRIPTOR * ptrMasterDescTable,
2731:                    USB_SETUP_PACKET * setupPkt,
2732:                    void**  pDescriptorString
2733:                )
2734:                {
2735:                    uint8_t* stringDesc;
2736:                    uint16_t langID;
2737:                    uint8_t stringIndexRequested;
2738:                    uint16_t DescriptorStringSize = 0;
2739:                    uint8_t count;
2740:                    uint8_t stringIndex;
2741:                     
2742:                     /* Get the string descriptor index from setup packet*/
2743:                    stringIndexRequested = setupPkt->bDscIndex;
2744:                
2745:                    if (stringIndexRequested == 0)
2746:                    {
2747:                        /* Get pointer to String Descriptor */ 
2748:                        stringDesc = (uint8_t*)&(ptrMasterDescTable->stringDescriptorTable[0][3] );
2749:                        *pDescriptorString = (uint8_t *)stringDesc;
2750:                
2751:                        /* Get Size of the String descriptor. Size is always the First element
2752:                         * in the String descriptor structure  */ 
2753:                
2754:                        DescriptorStringSize = stringDesc[0];
2755:                    }
2756:                    else
2757:                    {
2758:                        for (count = 1; count < ptrMasterDescTable->stringDescCount; count++ )
2759:                        {
2760:                            /* Get the string index from the String Descriptor.  String Index is
2761:                             * always the third element in the String Descriptor */  
2762:                            
2763:                            stringIndex = ptrMasterDescTable->stringDescriptorTable[count][0];
2764:                            
2765:                            /* Get Language ID from the string descriptor. Language ID is always
2766:                             * the Fourth element in the String Descriptor */ 
2767:                            
2768:                            langID = ((uint16_t)ptrMasterDescTable->stringDescriptorTable[count][2]<<8)
2769:                                               |ptrMasterDescTable->stringDescriptorTable[count][1];
2770:                
2771:                            /* Check if the Requested String Index and Language ID matches with
2772:                             * the values retrieved from String Descriptor */  
2773:                
2774:                            if ((stringIndex == stringIndexRequested) && (langID == setupPkt->wLangID))
2775:                            {
2776:                                    /* The Requested String Descriptor and Language was found.
2777:                                     * Get pointer to String Descriptor */ 
2778:                
2779:                                    stringDesc = (uint8_t*)&( ptrMasterDescTable->stringDescriptorTable[count][3] );
2780:                                    *pDescriptorString = (uint8_t *)stringDesc;
2781:                                    
2782:                                    /* Get Size of the String descriptor. Size is always the
2783:                                     * First element in the String descriptor structure  */
2784:                
2785:                                    DescriptorStringSize = stringDesc[0];
2786:                                    break;
2787:                            }
2788:                        }
2789:                    }
2790:                
2791:                    /* Return String descriptor size. USB device layer would stall the request
2792:                     * if the requested string descriptor was not found. If requested string was
2793:                     * not found the DescriptorStringSize would be zero and pDescriptorString
2794:                     * would be NULL.  */  
2795:                
2796:                    return DescriptorStringSize;
2797:                }
2798:                
2799:                /********************End of file********************************/
---  /home/whatisthis/microchip/harmony/v2_04/framework/system/random/src/sys_random.c  -----------------
1:                   /*******************************************************************************
2:                     Random System Service Implementation
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       sys_random.c
9:                   
10:                    Summary:
11:                      Random Generator System Service implementation.
12:                  
13:                    Description:
14:                      This file contains the implementation for the Random Generator
15:                      System Service.
16:                  *******************************************************************************/
17:                  
18:                  //DOM-IGNORE-BEGIN
19:                  /*******************************************************************************
20:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
21:                  
22:                  Microchip licenses to you the right to use, modify, copy and distribute
23:                  Software only when embedded on a Microchip microcontroller or digital signal
24:                  controller that is integrated into your product or third party product
25:                  (pursuant to the sublicense terms in the accompanying license agreement).
26:                  
27:                  You should refer to the license agreement accompanying this Software for
28:                  additional information regarding your rights and obligations.
29:                  
30:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
31:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
32:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
33:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
34:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
35:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
36:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
37:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
38:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
39:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
40:                  *******************************************************************************/
41:                  //DOM-IGNORE-END
42:                  // *****************************************************************************
43:                  // *****************************************************************************
44:                  // Section: Macro Definitions
45:                  // *****************************************************************************
46:                  // *****************************************************************************
47:                  
48:                  // *****************************************************************************
49:                  // *****************************************************************************
50:                  // Section: Included Files
51:                  // *****************************************************************************
52:                  // *****************************************************************************
53:                  
54:                  #include "system/random/src/sys_random_local.h"
55:                  
56:                  #ifndef SYS_RANDOM_CRYPTO_SEED_SIZE
57:                      #error "SYS_RANDOM_CRYPTO_SEED_SIZE is a required build configuration parameter"
58:                  #endif
59:                  
60:                  // *****************************************************************************
61:                  // *****************************************************************************
62:                  // Section: Local Data
63:                  // *****************************************************************************
64:                  // *****************************************************************************
65:                  
66:                  
67:                  static SYS_RANDOM_INIT      randInitDefault = { 0 };
68:                  
69:                  static SYS_RANDOM_OBJECT    sysRandObject = { 0 };
70:                  
71:                  CRYPT_RNG_CTX               sysRandCtx;
72:                  
73:                  
74:                  SYS_MODULE_OBJ SYS_RANDOM_Initialize( const SYS_MODULE_INDEX index, const SYS_MODULE_INIT * const init )
75:                  {
9D013714  27BDFFE8   ADDIU SP, SP, -24
9D013718  AFBF0014   SW RA, 20(SP)
9D01371C  AFB00010   SW S0, 16(SP)
76:                      sysRandObject.index = index;
9D013720  3C02A000   LUI V0, -24576
9D013724  A44403E4   SH A0, 996(V0)
77:                      sysRandObject.status = SYS_STATUS_BUSY;
9D013728  244203E4   ADDIU V0, V0, 996
9D01372C  24030001   ADDIU V1, ZERO, 1
78:                  
79:                      const SYS_RANDOM_INIT* pInitData = (const SYS_RANDOM_INIT*)init;
9D013738  0B404DD2   J 0x9D013748
9D01373C  00A08021   ADDU S0, A1, ZERO
80:                  
81:                      if(pInitData == NULL)
9D013730  10A00003   BEQ A1, ZERO, 0x9D013740
9D013734  AC430004   SW V1, 4(V0)
82:                      {
83:                          pInitData = &randInitDefault;
9D013740  3C10A000   LUI S0, -24576
9D013744  261003F0   ADDIU S0, S0, 1008
84:                      }
85:                  
86:                      srand(pInitData->seedPseudo);
9D013748  0F4055B5   JAL srand
9D01374C  8E040000   LW A0, 0(S0)
87:                  
88:                  #ifdef SYS_RANDOM_USE_CRYPTO_STRENGTH
89:                      if(CRYPT_RNG_Initialize(&sysRandCtx) < 0)
90:                      {   // failed
91:                          sysRandObject.status = SYS_STATUS_UNINITIALIZED;
92:                          return SYS_MODULE_OBJ_INVALID;
93:                      }
94:                  #endif
95:                  
96:                      sysRandObject.seedCryptoSize = pInitData->seedCryptoSize;
9D013750  3C02A000   LUI V0, -24576
9D013754  244203E4   ADDIU V0, V0, 996
9D013758  8E030008   LW V1, 8(S0)
9D01375C  AC430008   SW V1, 8(V0)
97:                      sysRandObject.status = SYS_STATUS_READY;
9D013760  24030002   ADDIU V1, ZERO, 2
9D013764  AC430004   SW V1, 4(V0)
98:                      /* Return dummy object */
99:                      return 0;    
100:                 }
9D013768  00001021   ADDU V0, ZERO, ZERO
9D01376C  8FBF0014   LW RA, 20(SP)
9D013770  8FB00010   LW S0, 16(SP)
9D013774  03E00008   JR RA
9D013778  27BD0018   ADDIU SP, SP, 24
101:                 
102:                 
103:                 
104:                 void SYS_RANDOM_Deinitialize( SYS_MODULE_OBJ object )
105:                 {
106:                     sysRandObject.status = SYS_STATUS_UNINITIALIZED;
107:                     
108:                 }
109:                 
110:                 
111:                 
112:                 
113:                 // *****************************************************************************
114:                 // *****************************************************************************
115:                 // Section: SYS RANDOM Pseudo Random Number Generator Routines
116:                 // Use the std C library calls
117:                 // *****************************************************************************
118:                 // *****************************************************************************
119:                 
120:                 
121:                 void SYS_RANDOM_PseudoSeedSet( uint32_t seed )
122:                 {
123:                     srand(seed);
124:                 }
125:                 
126:                 
127:                 
128:                 uint32_t SYS_RANDOM_PseudoGet( void )
129:                 {
9D015680  27BDFFE8   ADDIU SP, SP, -24
9D015684  AFBF0014   SW RA, 20(SP)
130:                     return (uint32_t)rand();
9D015688  0F404A34   JAL rand
9D01568C  00000000   NOP
131:                 }
9D015690  8FBF0014   LW RA, 20(SP)
9D015694  03E00008   JR RA
9D015698  27BD0018   ADDIU SP, SP, 24
132:                 
133:                 // *****************************************************************************
134:                 // *****************************************************************************
135:                 // Section: SYS RANDOM Cryptographic Random Number Generator Routines
136:                 // *****************************************************************************
137:                 // *****************************************************************************
138:                 
139:                 #ifdef SYS_RANDOM_USE_CRYPTO_STRENGTH
140:                 
141:                 void SYS_RANDOM_CryptoSeedSet( void *seed, size_t size)
142:                 {
143:                     unsigned int *seed_ptr = (unsigned int *)seed;
144:                 #if defined(__PIC32MZ__)    // All PIC32MZ devices have a PRNG, so it can be set
145:                 #if ((__PIC32_FEATURE_SET0 == 'E') && (__PIC32_FEATURE_SET1 == 'C'))
146:                     RNGPOLY1 = _CP0_GET_COUNT();
147:                     RNGPOLY2 = _CP0_GET_COUNT();
148:                 #else
149:                     if (!RNGCONbits.TRNGMODE)
150:                     {
151:                         RNGCONbits.TRNGMODE = 1;
152:                         RNGCONbits.TRNGEN = 1;
153:                     }
154:                     while (RNGCNT < 64);
155:                     RNGPOLY2 = RNGSEED2;
156:                     RNGPOLY1 = RNGSEED1;
157:                 #endif
158:                     RNGSEED1 = *seed_ptr;
159:                     seed_ptr++;
160:                     RNGSEED2 = *seed_ptr;
161:                 #else
162:                     // For all other devices, use srand
163:                     srand(*seed_ptr);
164:                 #endif
165:                 }
166:                 
167:                 size_t SYS_RANDOM_CryptoSeedSizeGet( void )
168:                 {
169:                     return (sysRandObject.status == SYS_STATUS_READY) ? sysRandObject.seedCryptoSize : 0;
170:                 }
171:                 
172:                 
173:                 
174:                 uint32_t SYS_RANDOM_CryptoGet( void )
175:                 {
176:                     union
177:                     {
178:                         uint8_t     u8[4];
179:                         uint32_t    u32;
180:                     }sUint = {};
181:                 
182:                 
183:                     CRYPT_RNG_BlockGenerate(&sysRandCtx, (unsigned char*)sUint.u8, sizeof(sUint.u8));
184:                 
185:                     return sUint.u32;
186:                 }
187:                 
188:                 
189:                 void SYS_RANDOM_CryptoBlockGet( void *buffer, size_t size )
190:                 {
191:                     if(buffer != 0 && size != 0)
192:                     {
193:                         CRYPT_RNG_BlockGenerate(&sysRandCtx, (unsigned char*)buffer, size);
194:                     }
195:                 }
196:                 
197:                 
198:                 uint8_t SYS_RANDOM_CryptoByteGet( void )
199:                 {
200:                     uint8_t rNo = 0;
201:                     CRYPT_RNG_Get(&sysRandCtx, (unsigned char*)&rNo);
202:                 
203:                     return rNo;
204:                 }
205:                 
206:                 
207:                 
208:                 
209:                 void SYS_RANDOM_CryptoEntropyAdd( uint8_t data )
210:                 {
211:                     // Entropy cannot be added to the system at this time, so this just returns.
212:                 }
213:                 
214:                 #endif
215:                 
216:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/system/msg/src/sys_msg.c  -----------------------
1:                   /*******************************************************************************
2:                     System Messaging Implementation
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       sys_msg.c
9:                   
10:                    Summary:
11:                      System Messaging Implementation
12:                  
13:                    Description:   
14:                  
15:                      While building the driver from source, ALWAYS use this file in the build.
16:                  *******************************************************************************/
17:                  
18:                  //DOM-IGNORE-BEGIN
19:                  /*******************************************************************************
20:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
21:                  
22:                  Microchip licenses to you the right to use, modify, copy and distribute
23:                  Software only when embedded on a Microchip microcontroller or digital signal
24:                  controller that is integrated into your product or third party product
25:                  (pursuant to the sublicense terms in the accompanying license agreement).
26:                  
27:                  You should refer to the license agreement accompanying this Software for
28:                  additional information regarding your rights and obligations.
29:                  
30:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
31:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
32:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
33:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
34:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
35:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
36:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
37:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
38:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
39:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
40:                  *******************************************************************************/
41:                  //DOM-IGNORE-END
42:                  
43:                  
44:                  // *****************************************************************************
45:                  // *****************************************************************************
46:                  // Section: Include Files
47:                  // *****************************************************************************
48:                  // *****************************************************************************
49:                  
50:                  #include <stdlib.h>
51:                  #include <string.h>
52:                  #include <sys/appio.h>
53:                  
54:                  #include "system/common/sys_common.h"
55:                  #include "system/msg/sys_msg.h"
56:                  #include "system/msg/src/sys_msg_local.h"
57:                  
58:                  // *****************************************************************************
59:                  // *****************************************************************************
60:                  // Section: File Scope Variables
61:                  // *****************************************************************************
62:                  // *****************************************************************************
63:                  static SYS_MSG_MESSAGING_OBJECT *handleSysMsg[SYS_MSG_NUM_INSTANCES];
64:                  
65:                  // *****************************************************************************
66:                  // *****************************************************************************
67:                  // Section: File Scope Functions
68:                  // *****************************************************************************
69:                  // *****************************************************************************
70:                  
71:                  void AssertToIDE(char *test, char *message, uint16_t line, char *file)
72:                  {
73:                      /*LDRA_INSPECTED 496 S */ /*Deviation Reference: MH-4498*/
74:                      DBPRINTF("%s :: SYS_ASSERT failed: %s, at line %d in %s\n",message,test,line,file);
75:                      asm("break");
76:                  }
77:                  
78:                  
79:                  static SYS_MSG_MESSAGE_DEFN * _ID2hMsgType( SYS_MSG_MESSAGING_OBJECT *hSysMsg,
80:                                                              uint8_t         nMessageTypeID   )
81:                  {
82:                      uint16_t iMessageType;
83:                      SYS_MSG_MESSAGE_DEFN * hMsgType = NULL;
9D0086B4  00621026   XOR V0, V1, V0
84:                  
85:                      // Find hMsgType corresponding to nMessageTypeID
86:                      for ( iMessageType = 0; iMessageType < SYS_MSG_MAX_TYPES; iMessageType++ )
87:                      {
88:                          if ( NULL != hSysMsg->pMessageType[iMessageType] )
9D008690  12E00004   BEQ S7, ZERO, 0x9D0086A4
9D0086A4  8E570020   LW S7, 32(S2)
89:                          {// If slot is in use
90:                              if ( hSysMsg->nMessageTypeIDs[iMessageType] == nMessageTypeID )
9D008698  92430001   LBU V1, 1(S2)
9D0086B0  92430002   LBU V1, 2(S2)
9D0086B4  00621026   XOR V0, V1, V0
9D0086B8  0002B80B   MOVN S7, ZERO, V0
91:                              {// Found matching message type, return handle to message definition
92:                                  hMsgType = hSysMsg->pMessageType[iMessageType];
93:                                  break;
94:                              }
95:                          }
96:                      }
97:                  
98:                      return hMsgType;
99:                  }
100:                 
101:                 
102:                 static bool _GotMessages( SYS_MSG_MESSAGING_OBJECT *hSysMsg )
103:                 {
104:                     int16_t iPriority;
105:                     uint16_t nMessagePriorities;
106:                     SYS_MSG_QUEUE *pQ;
107:                     bool bGotMessages = false;
108:                 
109:                     SYS_ASSERT( NULL != hSysMsg, "Bad argument!" );     // Check argument
110:                 
111:                     // Find queue that is not empty
112:                     nMessagePriorities = hSysMsg->nMessagePriorities;
9D0085B4  90820000   LBU V0, 0(A0)
113:                     for (iPriority=nMessagePriorities-1;iPriority>=0;iPriority--)
9D0085B8  2442FFFF   ADDIU V0, V0, -1
9D0085BC  7C021620   SEH V0, V0
9D0085C0  04400072   BLTZ V0, 0x9D00878C
9D0085C4  AFA20014   SW V0, 20(SP)
9D0085E8  0B402182   J 0x9D008608
9D0085EC  8FA20014   LW V0, 20(SP)
9D008608  2442FFFF   ADDIU V0, V0, -1
9D00860C  7C021620   SEH V0, V0
9D008610  0441FFF7   BGEZ V0, SYS_MSG_Tasks::_GotMessages
9D008614  00021880   SLL V1, V0, 2
114:                     {
115:                         pQ = &(hSysMsg->msgQueues[iPriority]);
9D0085C8  0002F080   SLL S8, V0, 2
9D0085CC  00021100   SLL V0, V0, 4
9D0085D0  03C2F021   ADDU S8, S8, V0
9D0085D4  27DE0008   ADDIU S8, S8, 8
9D0085D8  009EF021   ADDU S8, A0, S8
9D0085F0  00022100   SLL A0, V0, 4
9D0085F4  00641821   ADDU V1, V1, A0
116:                         if (!SYS_MSGQ_IsEmpty(pQ) )
9D0085DC  8FC20004   LW V0, 4(S8)
9D0085E0  1440005A   BNE V0, ZERO, 0x9D00874C
9D0085E4  00809021   ADDU S2, A0, ZERO
9D0085FC  8C63000C   LW V1, 12(V1)
9D008600  14600053   BNE V1, ZERO, 0x9D008750
9D008604  8FA40048   LW A0, 72(SP)
117:                         {
118:                             bGotMessages = true;
119:                             break;
120:                         }
121:                     }
122:                 
123:                     return bGotMessages;
124:                 }
125:                 
126:                 
127:                 // *****************************************************************************
128:                 // *****************************************************************************
129:                 // Section: System Messaging Initialization
130:                 // *****************************************************************************
131:                 // *****************************************************************************
132:                 
133:                 //******************************************************************************
134:                 /* Function:
135:                     SYS_OBJ_HANDLE SYS_MSG_Initialize ( const SYS_MSG_INSTANCE iSysMsg,
136:                                                         const SYS_MODULE_INIT * const pInitSysMsg )
137:                   Summary:
138:                     Configures and initializes the messaging subsystem.
139:                 */
140:                 
141:                     SYS_OBJ_HANDLE SYS_MSG_Initialize ( const SYS_MSG_INSTANCE iSysMsg,
142:                                                         SYS_OBJ_HANDLE pInitializeSysMsg )
143:                 {
9D00D3CC  27BDFFD8   ADDIU SP, SP, -40
9D00D3D0  AFBF0024   SW RA, 36(SP)
9D00D3D4  AFB40020   SW S4, 32(SP)
9D00D3D8  AFB3001C   SW S3, 28(SP)
9D00D3DC  AFB20018   SW S2, 24(SP)
9D00D3E0  AFB10014   SW S1, 20(SP)
9D00D3E4  AFB00010   SW S0, 16(SP)
9D00D3E8  00808021   ADDU S0, A0, ZERO
144:                     uint16_t iPriority;
145:                     SYS_MSGQ_RESULT initResult;
146:                     SYS_MSG_MESSAGING_OBJECT *hSysMsg;
147:                     SYS_MSG_INIT * pInitSysMsg = (SYS_MSG_INIT *)pInitializeSysMsg;
9D00D42C  02209821   ADDU S3, S1, ZERO
148:                 
149:                     // Check arguments
150:                     if ( iSysMsg >= SYS_MSG_NUM_INSTANCES )
9D00D3EC  2C830005   SLTIU V1, A0, 5
9D00D3F0  10600046   BEQ V1, ZERO, 0x9D00D50C
9D00D3F4  2402FFFF   ADDIU V0, ZERO, -1
151:                     {// Bad instance index
152:                         return SYS_OBJ_HANDLE_INVALID;
153:                     }
154:                     if ( NULL != handleSysMsg[iSysMsg] )
9D00D3F8  00041880   SLL V1, A0, 2
9D00D3FC  3C02A000   LUI V0, -24576
9D00D400  244275E8   ADDIU V0, V0, 30184
9D00D404  00621021   ADDU V0, V1, V0
9D00D408  8C430000   LW V1, 0(V0)
9D00D40C  1460003F   BNE V1, ZERO, 0x9D00D50C
9D00D410  2402FFFF   ADDIU V0, ZERO, -1
9D00D414  00A08821   ADDU S1, A1, ZERO
155:                     {// Instance index already in use.
156:                         return SYS_OBJ_HANDLE_INVALID;
157:                     }
158:                 
159:                     hSysMsg = (SYS_MSG_MESSAGING_OBJECT*)malloc(sizeof(SYS_MSG_MESSAGING_OBJECT));
9D00D418  0F401C09   JAL malloc
9D00D41C  2404002C   ADDIU A0, ZERO, 44
9D00D420  00409021   ADDU S2, V0, ZERO
160:                     if ( NULL == hSysMsg )
9D00D424  12400039   BEQ S2, ZERO, 0x9D00D50C
9D00D428  2402FFFF   ADDIU V0, ZERO, -1
161:                     {
162:                         return SYS_OBJ_HANDLE_INVALID;
163:                     }
164:                     memset(hSysMsg,0x00,sizeof(SYS_MSG_MESSAGING_OBJECT));
9D00D430  AE400000   SW ZERO, 0(S2)
9D00D434  AE400004   SW ZERO, 4(S2)
9D00D438  AE400008   SW ZERO, 8(S2)
9D00D43C  AE40000C   SW ZERO, 12(S2)
9D00D440  AE400010   SW ZERO, 16(S2)
9D00D444  AE400014   SW ZERO, 20(S2)
9D00D448  AE400018   SW ZERO, 24(S2)
9D00D44C  AE40001C   SW ZERO, 28(S2)
9D00D450  AE400020   SW ZERO, 32(S2)
9D00D454  AE400024   SW ZERO, 36(S2)
165:                 
166:                     if ( NULL != pInitSysMsg )
9D00D458  1220001B   BEQ S1, ZERO, 0x9D00D4C8
9D00D45C  AE400028   SW ZERO, 40(S2)
167:                     {// Pointer to init structure provided, use init structure values.
168:                         // Initialize Sytem Message Object
169:                         hSysMsg->nMaxMsgsDelivered  = pInitSysMsg->nMaxMsgsDelivered;
9D00D460  92220000   LBU V0, 0(S1)
9D00D464  A6420006   SH V0, 6(S2)
170:                         hSysMsg->nMessagePriorities = pInitSysMsg->nMessagePriorities;
9D00D468  92220001   LBU V0, 1(S1)
171:                 
172:                         // Initialize individual message queues, one for each priority
173:                         for (iPriority=0;iPriority<pInitSysMsg->nMessagePriorities;iPriority++)
9D00D46C  1040001F   BEQ V0, ZERO, 0x9D00D4EC
9D00D470  A2420000   SB V0, 0(S2)
9D00D474  00008821   ADDU S1, ZERO, ZERO
9D00D4AC  3231FFFF   ANDI S1, S1, -1
9D00D4B0  92620001   LBU V0, 1(S3)
9D00D4B4  0222102B   SLTU V0, S1, V0
9D00D4B8  1440FFF1   BNE V0, ZERO, 0x9D00D480
9D00D4BC  00112080   SLL A0, S1, 2
9D00D4C0  0B40353C   J 0x9D00D4F0
9D00D4C4  00108080   SLL S0, S0, 2
174:                         {
175:                             initResult = SYS_MSGQ_Init(hSysMsg->msgQueues + iPriority,pInitSysMsg->nQSizes[iPriority]);
9D00D47C  00112080   SLL A0, S1, 2
9D00D480  00111100   SLL V0, S1, 4
9D00D484  00822021   ADDU A0, A0, V0
9D00D488  24840008   ADDIU A0, A0, 8
9D00D48C  8E630004   LW V1, 4(S3)
9D00D490  00111040   SLL V0, S1, 1
9D00D494  00621021   ADDU V0, V1, V0
9D00D498  02442021   ADDU A0, S2, A0
9D00D49C  0F404CD0   JAL SYS_MSGQ_Init
9D00D4A0  94450000   LHU A1, 0(V0)
176:                             if (SYS_MSGQ_Success !=initResult )
9D00D478  2414000A   ADDIU S4, ZERO, 10
9D00D4A4  14540018   BNE V0, S4, 0x9D00D508
9D00D4A8  26310001   ADDIU S1, S1, 1
177:                             {
178:                                 return SYS_OBJ_HANDLE_INVALID;
179:                             }
180:                         }
181:                     }
182:                     else
183:                     {// No pointer to init structure provided, use default values from config file.
184:                         // Initialize Sytem Message Object
185:                         hSysMsg->nMaxMsgsDelivered  = SYS_MSG_MAX_MSGS_DELIVERED;
9D00D4C8  24020001   ADDIU V0, ZERO, 1
9D00D4CC  A6420006   SH V0, 6(S2)
186:                         hSysMsg->nMessagePriorities = SYS_MSG_MAX_PRIORITY+1;
9D00D4D0  A2420000   SB V0, 0(S2)
187:                 
188:                         // Initialize individual message queues, one for each priority
189:                         uint16_t nQSizes[] = SYS_MSG_BUFFER_SIZES;
190:                         for (iPriority=0;iPriority<(SYS_MSG_MAX_PRIORITY+1);iPriority++)
191:                         {
192:                             initResult = SYS_MSGQ_Init(hSysMsg->msgQueues + iPriority,nQSizes[iPriority]);
9D00D4D4  26440008   ADDIU A0, S2, 8
9D00D4D8  0F404CD0   JAL SYS_MSGQ_Init
9D00D4DC  24050010   ADDIU A1, ZERO, 16
193:                             if (SYS_MSGQ_Success !=initResult )
9D00D4E0  2403000A   ADDIU V1, ZERO, 10
9D00D4E4  54430009   BNEL V0, V1, 0x9D00D50C
9D00D4E8  2402FFFF   ADDIU V0, ZERO, -1
194:                             {
195:                                 return SYS_OBJ_HANDLE_INVALID;
196:                             }
197:                         }
198:                      }
199:                 
200:                   //NOTE: Using memset above means these initializations aren't necessary
201:                   //hSysMsg->nMessageTypes = 0;
202:                   //hSysMsg->nMailboxes    = 0;
203:                   //Also: nMessageTypeIDs[], pMessageType[], and pMailbox[] arrays don't need initialization to zero
204:                 
205:                     handleSysMsg[iSysMsg] = hSysMsg;
9D00D4EC  00108080   SLL S0, S0, 2
9D00D4F0  3C02A000   LUI V0, -24576
9D00D4F4  244275E8   ADDIU V0, V0, 30184
9D00D4F8  02021021   ADDU V0, S0, V0
9D00D4FC  AC520000   SW S2, 0(V0)
206:                 
207:                     return (SYS_OBJ_HANDLE)hSysMsg;
9D00D500  0B403543   J 0x9D00D50C
9D00D504  02401021   ADDU V0, S2, ZERO
9D00D508  2402FFFF   ADDIU V0, ZERO, -1
208:                 }
9D00D50C  8FBF0024   LW RA, 36(SP)
9D00D510  8FB40020   LW S4, 32(SP)
9D00D514  8FB3001C   LW S3, 28(SP)
9D00D518  8FB20018   LW S2, 24(SP)
9D00D51C  8FB10014   LW S1, 20(SP)
9D00D520  8FB00010   LW S0, 16(SP)
9D00D524  03E00008   JR RA
9D00D528  27BD0028   ADDIU SP, SP, 40
209:                 
210:                 
211:                 //******************************************************************************
212:                 /* Function:
213:                     void  SYS_MSG_Deinitialize ( SYS_OBJ_HANDLE hSysMsg )
214:                 
215:                   Summary:
216:                     Deinitializes System Messaging Instance
217:                 */
218:                 void  SYS_MSG_Deinitialize ( SYS_OBJ_HANDLE hSysMsgForDeinit )
219:                 {
220:                     SYS_MSG_MESSAGING_OBJECT *hSysMsg = (SYS_MSG_MESSAGING_OBJECT *)hSysMsgForDeinit;
221:                     uint16_t iSysMsg;
222:                 
223:                     for ( iSysMsg=0; iSysMsg < SYS_MSG_NUM_INSTANCES; iSysMsg++ )
224:                     {
225:                         if ( hSysMsg == handleSysMsg[iSysMsg] )
226:                         {// Zero out pointer
227:                             handleSysMsg[iSysMsg] = NULL;
228:                             break;
229:                         }
230:                     }
231:                     /*LDRA_INSPECTED 125 D */ /*Deviation Reference: MH-4494*/
232:                     free( hSysMsg );
233:                 }
234:                 
235:                 
236:                 //******************************************************************************
237:                 /* Function:
238:                     void  SYS_MSG_Tasks ( SYS_OBJ_HANDLE hSysMsg )
239:                 
240:                 */
241:                 void  SYS_MSG_Tasks ( SYS_OBJ_HANDLE handleSysMsg )
242:                 {
9D008584  27BDFFB8   ADDIU SP, SP, -72
9D008588  AFBF0044   SW RA, 68(SP)
9D00858C  AFBE0040   SW S8, 64(SP)
9D008590  AFB7003C   SW S7, 60(SP)
9D008594  AFB60038   SW S6, 56(SP)
9D008598  AFB50034   SW S5, 52(SP)
9D00859C  AFB40030   SW S4, 48(SP)
9D0085A0  AFB3002C   SW S3, 44(SP)
9D0085A4  AFB20028   SW S2, 40(SP)
9D0085A8  AFB10024   SW S1, 36(SP)
9D0085AC  AFB00020   SW S0, 32(SP)
9D0085B0  AFA40048   SW A0, 72(SP)
243:                     SYS_MSG_MESSAGING_OBJECT *hSysMsg = (SYS_MSG_MESSAGING_OBJECT *)handleSysMsg;
244:                 
245:                     SYS_ASSERT( NULL != hSysMsg, "Bad handle argument!"); // Check argument
246:                 
247:                     if ( _GotMessages(hSysMsg) )
248:                     {
249:                         int16_t iPriority;
250:                         int16_t nMsgsDelivered      = 0;
9D008758  AFA00010   SW ZERO, 16(SP)
251:                         uint16_t nMaxMsgsDelivered  = hSysMsg->nMaxMsgsDelivered;
9D00874C  8FA40048   LW A0, 72(SP)
9D008750  94840006   LHU A0, 6(A0)
9D008754  AFA40018   SW A0, 24(SP)
252:                         uint16_t nMessagePriorities = hSysMsg->nMessagePriorities;
253:                 
254:                         SYS_MSG_QUEUE *pQ;
255:                         SYS_MSGQ_ELEMENT *pQElement;
256:                         SYS_MSG_MESSAGE_DEFN * hMsgType;
257:                         SYS_MSG_MAILBOX_OBJECT * pMailbox;
258:                 
259:                         uint16_t iBit, iBitMap, bitMap, iMailbox;
260:                         do
261:                         {
262:                             // Find the first queue that is not empty
263:                             pQElement = NULL;
264:                             for (iPriority=nMessagePriorities-1;iPriority>=0;iPriority--)
9D008678  2442FFFF   ADDIU V0, V0, -1
9D00867C  7C021620   SEH V0, V0
9D008680  0441FFEC   BGEZ V0, 0x9D008634
9D008684  00021880   SLL V1, V0, 2
9D008688  0B4021E4   J 0x9D008790
9D00868C  8FBF0044   LW RA, 68(SP)
265:                             {
266:                                 pQ = &(hSysMsg->msgQueues[iPriority]);
9D00862C  0B402194   J SYS_MSGQ_GetNextQRef
9D008630  03C01821   ADDU V1, S8, ZERO
9D008634  00022100   SLL A0, V0, 4
9D008638  00641821   ADDU V1, V1, A0
9D00863C  24630008   ADDIU V1, V1, 8
9D008640  02431821   ADDU V1, S2, V1
267:                                 if (!SYS_MSGQ_IsEmpty(pQ) )
9D008620  8FC30004   LW V1, 4(S8)
9D008624  10600014   BEQ V1, ZERO, 0x9D008678
9D008628  8FA20014   LW V0, 20(SP)
9D008644  8C640004   LW A0, 4(V1)
9D008648  1080000C   BEQ A0, ZERO, 0x9D00867C
9D00864C  2442FFFF   ADDIU V0, V0, -1
268:                                 {
269:                                     pQElement = SYS_MSGQ_GetNextQRef(pQ);
270:                                     break;
271:                                 }
272:                             }
273:                 
274:                             if ( NULL != pQElement )
9D008668  56C00009   BNEL S6, ZERO, _ID2hMsgType
9D00866C  8E57001C   LW S7, 28(S2)
9D008670  0B4021E4   J 0x9D008790
9D008674  8FBF0044   LW RA, 68(SP)
275:                             {// Found message to deliver
276:                                 hMsgType = _ID2hMsgType(hSysMsg,pQElement->sMessage.nMessageTypeID);
277:                                 SYS_ASSERT( NULL != hMsgType, "Null message type handle!" );
278:                 
279:                                 // Notify all interested mailboxes of this message
280:                                 for ( iBitMap = 0; iBitMap < (SYS_MSG_NUM_MAILBOX_BITMAPS); iBitMap++ )
281:                                 {
282:                                     bitMap = pQElement->mailboxInterestBitMap[iBitMap];
9D0086BC  8FB10048   LW S1, 72(SP)
9D0086C0  00008021   ADDU S0, ZERO, ZERO
283:                                     for ( iBit = 0; iBit < 16; iBit++ )
9D0086F0  1614FFF4   BNE S0, S4, 0x9D0086C4
9D0086F4  26310004   ADDIU S1, S1, 4
9D008760  0B402188   J 0x9D008620
9D008764  24140010   ADDIU S4, ZERO, 16
284:                                     {
285:                                         if ( (bitMap & 1<<iBit) > 0 )
9D0086C4  02151004   SLLV V0, S5, S0
9D0086C8  00531024   AND V0, V0, S3
9D0086CC  58400008   BLEZL V0, 0x9D0086F0
9D0086D0  26100001   ADDIU S0, S0, 1
9D00875C  24150001   ADDIU S5, ZERO, 1
286:                                         {
287:                                             iMailbox = iBit + 16*iBitMap;
288:                                             pMailbox = hSysMsg->pMailbox[iMailbox];
289:                                             if ( NULL != pMailbox->msgCallBackFunction )
9D0086D4  8E220024   LW V0, 36(S1)
9D0086D8  8C420008   LW V0, 8(V0)
9D0086DC  50400004   BEQL V0, ZERO, 0x9D0086F0
9D0086E0  26100001   ADDIU S0, S0, 1
290:                                             {
291:                                                 (*(pMailbox->msgCallBackFunction))( &(pQElement->sMessage) ); // Launch callback
9D0086E4  0040F809   JALR V0
9D0086E8  02C02021   ADDU A0, S6, ZERO
9D0086EC  26100001   ADDIU S0, S0, 1
292:                                             }
293:                                         }
294:                                     }
295:                                 }
296:                                 nMsgsDelivered = (nMaxMsgsDelivered > 0) ? nMsgsDelivered+1 : -1;
9D0086F8  8FA20018   LW V0, 24(SP)
9D0086FC  5040001A   BEQL V0, ZERO, 0x9D008768
9D008700  92E20006   LBU V0, 6(S7)
9D008704  8FA30010   LW V1, 16(SP)
9D008708  24620001   ADDIU V0, V1, 1
9D00870C  7C021620   SEH V0, V0
9D008710  AFA20010   SW V0, 16(SP)
9D008780  2402FFFF   ADDIU V0, ZERO, -1
9D008784  0B402188   J 0x9D008620
9D008788  AFA20010   SW V0, 16(SP)
297:                 
298:                                 // Dequeue message now that all mailboxes have been notified
299:                                 iPriority = hMsgType->nMessagePriority;
300:                                 pQ = &(hSysMsg->msgQueues[iPriority]);
9D008714  92E20006   LBU V0, 6(S7)
9D008718  00022080   SLL A0, V0, 2
9D00871C  00021100   SLL V0, V0, 4
9D008720  00822021   ADDU A0, A0, V0
9D008724  24840008   ADDIU A0, A0, 8
9D008768  00022080   SLL A0, V0, 2
9D00876C  00021100   SLL V0, V0, 4
9D008770  00822021   ADDU A0, A0, V0
9D008774  24840008   ADDIU A0, A0, 8
301:                                 SYS_MSGQ_Dequeue(pQ);
9D008728  0F4053C1   JAL SYS_MSGQ_Dequeue
9D00872C  02442021   ADDU A0, S2, A0
9D008778  0F4053C1   JAL SYS_MSGQ_Dequeue
9D00877C  02442021   ADDU A0, S2, A0
302:                             }
303:                 
304:                         } while ( nMsgsDelivered < nMaxMsgsDelivered && NULL != pQElement );
9D008730  8FA40018   LW A0, 24(SP)
9D008734  8FA30010   LW V1, 16(SP)
9D008738  0064102A   SLT V0, V1, A0
9D00873C  5440FFB9   BNEL V0, ZERO, 0x9D008624
9D008740  8FC30004   LW V1, 4(S8)
305:                 
306:                     }//end if ( _GotMessages(hSysMsg) )
307:                 }
9D008618  0B4021E4   J 0x9D008790
9D00861C  8FBF0044   LW RA, 68(SP)
9D008744  0B4021E4   J 0x9D008790
9D008748  8FBF0044   LW RA, 68(SP)
9D00878C  8FBF0044   LW RA, 68(SP)
308:                 
309:                 
310:                 // *****************************************************************************
311:                 // *****************************************************************************
312:                 // Section: Messages
313:                 // *****************************************************************************
314:                 // *****************************************************************************
315:                 
316:                 // *****************************************************************************
317:                 /* Function:
318:                     SYS_OBJ_HANDLE SYS_MSG_TypeCreate( const SYS_MSG_INSTANCE iSysMsg,
319:                                                        uint8_t  nMessageTypeID,
320:                                                        uint8_t  nMessagePriority )
321:                   Summary:
322:                     Creates a new message type.
323:                 */
324:                 
325:                 SYS_OBJ_HANDLE SYS_MSG_TypeCreate( const SYS_MSG_INSTANCE iSysMsg,
326:                                                    uint8_t  nMessageTypeID,
327:                                                    uint8_t  nMessagePriority )
328:                 {
329:                     SYS_MSG_MESSAGING_OBJECT *hSysMsg;
330:                     SYS_MSG_MESSAGE_DEFN * hMsgType;  // Return this value
331:                     uint16_t iMessageType;
332:                     uint8_t  nMessageTypes;
333:                 
334:                     // Check arguments
335:                     if ( iSysMsg >= SYS_MSG_NUM_INSTANCES ||
336:                          NULL == handleSysMsg[iSysMsg]      )
337:                     {// Bad instance index
338:                         return SYS_OBJ_HANDLE_INVALID;
339:                     }
340:                     hSysMsg = handleSysMsg[iSysMsg];
341:                     if ( nMessagePriority >= hSysMsg->nMessagePriorities )
342:                     {// Bad message priority
343:                         return SYS_OBJ_HANDLE_INVALID;
344:                     }
345:                 
346:                 
347:                     // Don't duplicate message type IDs
348:                     for ( iMessageType = 0; iMessageType < SYS_MSG_MAX_TYPES; iMessageType++ )
349:                     {
350:                         if ( hSysMsg->pMessageType[iMessageType] != NULL &&
351:                              hSysMsg->nMessageTypeIDs[iMessageType] == nMessageTypeID )
352:                         {// Trying to reuse message type ID
353:                             return SYS_OBJ_HANDLE_INVALID;
354:                         }
355:                     }
356:                 
357:                     // Allocate memory for this new message type
358:                     hMsgType = (SYS_MSG_MESSAGE_DEFN *)calloc(1, sizeof(SYS_MSG_MESSAGE_DEFN) );
359:                     if ( NULL == hMsgType )
360:                     {// Can't allocate memory for message type definition
361:                         return SYS_OBJ_HANDLE_INVALID;
362:                     }
363:                 
364:                     //Set iMessageType to first open slot in pMessageType array
365:                     //TODO: MUTEX on pMessageType[] array
366:                     for ( iMessageType = 0; iMessageType < SYS_MSG_MAX_TYPES; iMessageType++ )
367:                     {
368:                         if ( NULL == hSysMsg->pMessageType[iMessageType] )
369:                         {
370:                             // Use this slot in the array
371:                             hSysMsg->pMessageType[iMessageType] = hMsgType;
372:                             break;
373:                         }
374:                     }
375:                     //TODO: Release MUTEX on pMessageType[] array
376:                 
377:                     if ( iMessageType >= SYS_MSG_MAX_TYPES )
378:                     {// Couldn't find open slot in pMessageType[] array
379:                         free( hMsgType );
380:                         return SYS_OBJ_HANDLE_INVALID;
381:                     }
382:                 
383:                     //TODO: MUTEX on hSysMsg->nMessageTypes
384:                     nMessageTypes = hSysMsg->nMessageTypes + 1;
385:                     if ( nMessageTypes > SYS_MSG_MAX_TYPES )
386:                     {// Have exceeded maximum allowable message types
387:                         free( hMsgType );
388:                         return SYS_OBJ_HANDLE_INVALID;
389:                     }
390:                     hSysMsg->nMessageTypes = nMessageTypes;
391:                     //TODO: Release MUTEX on hSysMsg->nMessageTypes
392:                 
393:                     // Remember this message type in the System Messaging object
394:                     hSysMsg->nMessageTypeIDs[iMessageType] = nMessageTypeID;
395:                 
396:                     // Record message information
397:                     hMsgType->hSysMsg          = hSysMsg;
398:                     hMsgType->iMessageType     = iMessageType;
399:                     hMsgType->nMessageTypeID   = nMessageTypeID;
400:                     hMsgType->nMessagePriority = nMessagePriority;
401:                 
402:                     return (SYS_OBJ_HANDLE)hMsgType;
403:                 }
404:                 
405:                 // *****************************************************************************
406:                 /* Function:
407:                     void SYS_MSG_TypeRemove( SYS_OBJ_HANDLE hMsgType )
408:                 
409:                   Summary:
410:                     Removes an existing message type.
411:                 */
412:                 
413:                 void SYS_MSG_TypeRemove( SYS_OBJ_HANDLE handleMsgType )
414:                 {
415:                     SYS_MSG_MESSAGE_DEFN * hMsgType = (SYS_MSG_MESSAGE_DEFN *)handleMsgType;
416:                     SYS_MSG_MESSAGING_OBJECT *hSysMsg;
417:                     uint16_t iMessageType;
418:                 
419:                     // Check paramaters
420:                     SYS_ASSERT( NULL != hMsgType, "Null hMsgType!" );
421:                 
422:                     hSysMsg = (SYS_MSG_MESSAGING_OBJECT *)hMsgType->hSysMsg;
423:                     SYS_ASSERT( NULL != hSysMsg, "Null hSysMsg!" );
424:                 
425:                     //TODO: MUTEX on hSysMsg->nMessageTypes
426:                     hSysMsg->nMessageTypes -= 1;
427:                     //TODO: Disable MUTEX on hSysMsg->nMessageTypes
428:                 
429:                     iMessageType = hMsgType->iMessageType;
430:                     hSysMsg->pMessageType[iMessageType]    = NULL;
431:                     hSysMsg->nMessageTypeIDs[iMessageType] = 0;
432:                 
433:                     /*LDRA_INSPECTED 125 D */ /*Deviation Reference: MH-4495*/
434:                     free(hMsgType);
435:                 }
436:                 
437:                 
438:                 // *****************************************************************************
439:                 /* Function:
440:                     SYS_OBJ_HANDLE SYS_MSG_ID2hMsgType( const SYS_MSG_INSTANCE iSysMsg,
441:                                                         uint8_t        nMessageTypeID )
442:                   Summary:
443:                     Translates message type identifier into handle of corresponding message type object.
444:                 */
445:                 
446:                 SYS_OBJ_HANDLE SYS_MSG_ID2hMsgType( const SYS_MSG_INSTANCE iSysMsg,
447:                                                     uint8_t         nMessageTypeID)
448:                 {
449:                     SYS_MSG_MESSAGING_OBJECT *hSysMsg;
450:                 
451:                     // Check arguments
452:                     if ( iSysMsg >= SYS_MSG_NUM_INSTANCES ||
453:                          NULL == handleSysMsg[iSysMsg]      )
454:                     {// Bad instance index
455:                         return (SYS_OBJ_HANDLE)NULL;
456:                     }
457:                     else
458:                     {
459:                         uint16_t iMessageType;
460:                         SYS_MSG_MESSAGE_DEFN * hMsgType = NULL;
461:                 
462:                         hSysMsg = handleSysMsg[iSysMsg];
463:                 
464:                         // Find hMsgType corresponding to nMessageTypeID
465:                         for ( iMessageType = 0; iMessageType < SYS_MSG_MAX_TYPES; iMessageType++ )
466:                         {
467:                             if ( NULL != hSysMsg->pMessageType[iMessageType] )
468:                             {// If slot is in use
469:                                 if ( hSysMsg->nMessageTypeIDs[iMessageType] == nMessageTypeID )
470:                                 {// Found matching message type, return handle to message definition
471:                                     hMsgType = hSysMsg->pMessageType[iMessageType];
472:                                     break;
473:                                 }
474:                             }
475:                         }
476:                 
477:                         return (SYS_OBJ_HANDLE)hMsgType;
478:                     }
479:                 }
480:                 
481:                 
482:                 // *****************************************************************************
483:                 /* Function:
484:                     bool SYS_MSG_GotMessages( const SYS_MSG_INSTANCE iSysMsg )
485:                 
486:                   Summary:
487:                     Returns true if system messaging has undelivered messages, false otherwise.
488:                 */
489:                 bool SYS_MSG_GotMessages( const SYS_MSG_INSTANCE iSysMsg )
490:                 {
491:                     SYS_MSG_MESSAGING_OBJECT *hSysMsg;
492:                     int16_t iPriority;
493:                     uint16_t nMessagePriorities;
494:                     SYS_MSG_QUEUE *pQ;
495:                     bool bGotMessages = false;
496:                 
497:                     // Check argument
498:                     SYS_ASSERT( iSysMsg < SYS_MSG_NUM_INSTANCES && NULL != handleSysMsg[iSysMsg], "Bad arguments!" );
499:                 
500:                     // Find queue that is not empty
501:                     hSysMsg = handleSysMsg[iSysMsg];
502:                     nMessagePriorities = hSysMsg->nMessagePriorities;
503:                     for (iPriority=nMessagePriorities-1;iPriority>=0;iPriority--)
504:                     {
505:                         pQ = &(hSysMsg->msgQueues[iPriority]);
506:                         if (!SYS_MSGQ_IsEmpty(pQ) )
507:                         {
508:                             bGotMessages = true;
509:                             break;
510:                         }
511:                     }
512:                     return bGotMessages;
513:                 }
514:                 
515:                 
516:                 // *****************************************************************************
517:                 /* Function:
518:                     SYS_MSG_RESULTS SYS_MSG_MessageSend( const SYS_MSG_INSTANCE iSysMsg,
519:                                                          SYS_MSG_OBJECT *pMessage      )
520:                   Summary:
521:                     Sends a message, as defined by a message structure.
522:                 */
523:                 
524:                 SYS_MSG_RESULTS SYS_MSG_MessageSend( const SYS_MSG_INSTANCE iSysMsg,
525:                                                      SYS_MSG_OBJECT *pMessage      )
526:                 {
527:                     SYS_MSG_MESSAGING_OBJECT *hSysMsg;
528:                     SYS_MSG_MESSAGE_DEFN *hMsgType;
529:                     uint8_t  nMessagePriority;
530:                     SYS_MSGQ_ELEMENT qElement;
531:                 
532:                     // Check arguments
533:                     SYS_ASSERT( iSysMsg < SYS_MSG_NUM_INSTANCES && NULL != handleSysMsg[iSysMsg], "Bad arguments!");
534:                     SYS_ASSERT( NULL != pMessage, "Null message pointer!" );
535:                 
536:                     hMsgType = (SYS_MSG_MESSAGE_DEFN *)SYS_MSG_ID2hMsgType(iSysMsg,pMessage->nMessageTypeID);
537:                     if ( NULL == hMsgType )
538:                     {
539:                         return SYS_MSG_BAD_MSGTYPE;
540:                     }
541:                 
542:                     hSysMsg = handleSysMsg[iSysMsg];
543:                     nMessagePriority = hMsgType->nMessagePriority;
544:                     if ( nMessagePriority >= hSysMsg->nMessagePriorities )
545:                     {
546:                         return SYS_MSG_BAD_PRIORITY;
547:                     }
548:                 
549:                     // Load message into queue element
550:                     qElement.sMessage = *pMessage;
551:                     memcpy(qElement.mailboxInterestBitMap,
552:                            hMsgType->mailboxInterestBitMap,
553:                            SYS_MSG_NUM_MAILBOX_BITMAPS*sizeof(uint16_t));
554:                 
555:                     // Enqueue the message
556:                     //TODO: MUTEX on message queues
557:                     return (SYS_MSGQ_Failure == SYS_MSGQ_Enqueue( &(hSysMsg->msgQueues[nMessagePriority]), &qElement)) ? SYS_MSG_NOT_SENT_QFULL : SYS_MSG_SENT;    
558:                     //TODO: Disable MUTEX on message queues
559:                 }
560:                 
561:                 
562:                 // *****************************************************************************
563:                 /* Function:
564:                     SYS_MSGQ_ELEMENT *SYS_MSG_MessageReceive( const SYS_MSG_INSTANCE iSysMsg )
565:                 
566:                   Summary:
567:                     Receive next message in message queues.
568:                 */
569:                 
570:                 SYS_MSGQ_ELEMENT *SYS_MSG_MessageReceive( const SYS_MSG_INSTANCE iSysMsg )
571:                 {
572:                     SYS_MSG_MESSAGING_OBJECT *hSysMsg;
573:                     int16_t iPriority;
574:                     uint16_t nMessagePriorities;
575:                     SYS_MSG_QUEUE *pQ;
576:                     SYS_MSGQ_ELEMENT *pElem = NULL;
577:                 
578:                     // Check argument
579:                     SYS_ASSERT( iSysMsg < SYS_MSG_NUM_INSTANCES && NULL != handleSysMsg[iSysMsg], "Bad arguments!");
580:                 
581:                     // Find queue that is not empty
582:                     hSysMsg = handleSysMsg[iSysMsg];
583:                     nMessagePriorities = hSysMsg->nMessagePriorities;
584:                     for (iPriority=nMessagePriorities-1;iPriority>=0;iPriority--)
585:                     {
586:                         pQ = &(hSysMsg->msgQueues[iPriority]);
587:                         if (!SYS_MSGQ_IsEmpty(pQ) )
588:                         {
589:                             pElem = SYS_MSGQ_GetNextQRef(pQ);
590:                             break;
591:                         }
592:                     }
593:                 
594:                     return pElem;
595:                 }
596:                 
597:                 
598:                 // *****************************************************************************
599:                 /* Function:
600:                     void SYS_MSG_MessageDeliver( const SYS_MSG_INSTANCE iSysMsg, SYS_MSGQ_ELEMENT *pQElement );
601:                 
602:                   Summary:
603:                     Deliver message to mailboxes.
604:                 */
605:                 
606:                 void SYS_MSG_MessageDeliver( const SYS_MSG_INSTANCE iSysMsg, SYS_MSGQ_ELEMENT *pQElement )
607:                 {
608:                     SYS_MSG_MESSAGING_OBJECT * hSysMsg;
609:                     SYS_MSG_MESSAGE_DEFN     * hMsgType;
610:                     SYS_MSG_MAILBOX_OBJECT   * pMailbox;
611:                     SYS_MSG_QUEUE            * pQ;
612:                 
613:                     uint16_t iPriority;
614:                     uint16_t iMailbox, iBitMap, iBit, bitMap;
615:                 
616:                     // Check arguments
617:                     SYS_ASSERT( iSysMsg < SYS_MSG_NUM_INSTANCES && NULL != handleSysMsg[iSysMsg], "Bad arguments!");
618:                     SYS_ASSERT( NULL != pQElement, "Null pQElement!" );
619:                 
620:                     hSysMsg = handleSysMsg[iSysMsg];
621:                 
622:                     hMsgType = (SYS_MSG_MESSAGE_DEFN *)SYS_MSG_ID2hMsgType(iSysMsg,pQElement->sMessage.nMessageTypeID);
623:                     SYS_ASSERT( NULL != hMsgType, "Null message type handle!" );
624:                 
625:                     // Notify all interested mailboxes of this message
626:                     for ( iBitMap = 0; iBitMap < (SYS_MSG_NUM_MAILBOX_BITMAPS); iBitMap++ )
627:                     {
628:                         bitMap = pQElement->mailboxInterestBitMap[iBitMap];
629:                         for ( iBit = 0; iBit < 16; iBit++ )
630:                         {
631:                             if ( (bitMap & 1<<iBit) > 0 )
632:                             {
633:                                 iMailbox = iBit + 16*iBitMap;
634:                                 pMailbox = hSysMsg->pMailbox[iMailbox];
635:                                 if ( NULL != pMailbox->msgCallBackFunction )
636:                                 {
637:                                     (*(pMailbox->msgCallBackFunction))( &(pQElement->sMessage) ); // Launch callback
638:                                 }
639:                             }
640:                         }
641:                     }
642:                 
643:                     // Dequeue message now that all mailboxes have been notified
644:                     iPriority = hMsgType->nMessagePriority;
645:                     pQ = &(hSysMsg->msgQueues[iPriority]);
646:                     SYS_MSGQ_Dequeue(pQ);
647:                 }
648:                 
649:                 
650:                 // *****************************************************************************
651:                 // *****************************************************************************
652:                 // Section: Mailboxes
653:                 // *****************************************************************************
654:                 // *****************************************************************************
655:                 
656:                 // *****************************************************************************
657:                 /* Function:
658:                     SYS_OBJ_HANDLE SYS_MSG_MailboxOpen( const SYS_MSG_INSTANCE iSysMsg,
659:                                                         SYS_MSG_RECEIVE_CALLBACK msgCallBackFunction );
660:                 
661:                   Summary:
662:                     Opens a system messaging mailbox.
663:                 */
664:                 
665:                 SYS_OBJ_HANDLE SYS_MSG_MailboxOpen( const SYS_MSG_INSTANCE iSysMsg,
666:                                                     SYS_MSG_RECEIVE_CALLBACK msgCallBackFunction )
667:                 {
668:                     SYS_MSG_MESSAGING_OBJECT *hSysMsg;
669:                     SYS_MSG_MAILBOX_OBJECT *hMailbox;
670:                     uint16_t  iMailbox, nMailboxes;
671:                 
672:                     // Check arguments
673:                     SYS_ASSERT( iSysMsg < SYS_MSG_NUM_INSTANCES && NULL != handleSysMsg[iSysMsg], "Bad arguments!");
674:                     hSysMsg = handleSysMsg[iSysMsg];
675:                 
676:                     // Allocate memory for this new message type
677:                     hMailbox = (SYS_MSG_MAILBOX_OBJECT *)calloc(1, sizeof(SYS_MSG_MAILBOX_OBJECT) );
678:                     if ( NULL == hMailbox )
679:                     {// Can't allocate memory for message type definition
680:                         return SYS_OBJ_HANDLE_INVALID;
681:                     }
682:                 
683:                     // Set iMailbox to first unused slot in pMailbox[] array
684:                     //TODO: MUTEX on pMailbox[] array
685:                     for ( iMailbox = 0; iMailbox < SYS_MSG_MAX_MAILBOXES; iMailbox++ )
686:                     {
687:                         if ( NULL == hSysMsg->pMailbox[iMailbox] )
688:                         {
689:                             hSysMsg->pMailbox[iMailbox] = hMailbox;
690:                             break;
691:                         }
692:                     }
693:                     //TODO: Release MUTEX on pMailbox[] array
694:                 
695:                     if ( iMailbox >= SYS_MSG_MAX_MAILBOXES )
696:                     {// Couldn't find open slot in pMailbox[] array
697:                         free( hMailbox );
698:                         return SYS_OBJ_HANDLE_INVALID;
699:                     }
700:                 
701:                     // Have one more mailbox
702:                     //TODO: MUTEX on hSysMsg->nMailboxes
703:                     nMailboxes = hSysMsg->nMailboxes + 1;
704:                     if ( nMailboxes > SYS_MSG_MAX_MAILBOXES )
705:                     {// Have exceeded maximum allowable number of mailboxes
706:                         free( hMailbox );
707:                         //TODO: Release MUTEX on hSysMsg->nMailboxes
708:                         return SYS_OBJ_HANDLE_INVALID;
709:                     }
710:                     else
711:                     {
712:                         hSysMsg->nMailboxes = nMailboxes;
713:                         //TODO: Release MUTEX on hSysMsg->nMailboxes
714:                     }
715:                 
716:                     // Initialize mailbox.
717:                     hMailbox->hSysMsg  = handleSysMsg[iSysMsg];
718:                     hMailbox->iMailbox = iMailbox;
719:                     hMailbox->msgCallBackFunction = msgCallBackFunction;
720:                 
721:                     return (SYS_OBJ_HANDLE)hMailbox;
722:                 }
723:                 
724:                 
725:                 // *****************************************************************************
726:                 /* Function:
727:                     void SYS_MSG_MailboxClose( SYS_OBJ_HANDLE hMailbox )
728:                 
729:                   Summary:
730:                     Closes (destroys) a mailbox previously opened with SYS_MSG_MailboxOpen.
731:                 */
732:                 
733:                 void SYS_MSG_MailboxClose( SYS_OBJ_HANDLE handleMailbox )
734:                 {
735:                     SYS_MSG_MAILBOX_OBJECT *hMailbox = (SYS_MSG_MAILBOX_OBJECT *)handleMailbox;
736:                     SYS_MSG_MESSAGING_OBJECT *hSysMsg;
737:                     SYS_MSG_INSTANCE iSysMsg;
738:                     uint8_t  nMsgTypeID;
739:                     uint16_t index, iMailbox, iBitMap, iBit, bitMap;
740:                 
741:                     // Check argument.
742:                     SYS_ASSERT( NULL != hMailbox, "NULL mailbox handle!" );
743:                 
744:                     hSysMsg = hMailbox->hSysMsg;
745:                     SYS_ASSERT( NULL != hSysMsg, "Null hSysMsg!" );
746:                     for ( iSysMsg=0; iSysMsg < SYS_MSG_NUM_INSTANCES; iSysMsg++ )
747:                     {
748:                         if ( hSysMsg == handleSysMsg[iSysMsg] )
749:                         {// Zero out pointer
750:                             break;
751:                         }
752:                     }
753:                     SYS_ASSERT( iSysMsg < SYS_MSG_NUM_INSTANCES, "iSysMsg undefined!" );
754:                 
755:                     // remove messages to avoid orphaned message deliveries
756:                     for ( iBitMap = 0; iBitMap < (SYS_MSG_NUM_TYPES_BITMAPS); iBitMap++ )
757:                     {
758:                         bitMap = hMailbox->msgInterestBitMap[iBitMap];
759:                         for ( iBit = 0; iBit < 16; iBit++ )
760:                         {
761:                             if ( (bitMap & 1<<iBit) > 0 )
762:                             {
763:                                 index = iBit + 16*iBitMap;
764:                                 nMsgTypeID = hSysMsg->nMessageTypeIDs[index];
765:                                 SYS_MSG_MailboxMsgRemove(handleMailbox,
766:                                                          SYS_MSG_ID2hMsgType(iSysMsg,nMsgTypeID) );
767:                             }
768:                         }
769:                     }
770:                 
771:                     // remove mailbox from data structures
772:                     hSysMsg->nMailboxes -= 1;
773:                     iMailbox = hMailbox->iMailbox;
774:                     hSysMsg->pMailbox[iMailbox] = NULL;
775:                 
776:                     /*LDRA_INSPECTED 125 D */ /*Deviation Reference: MH-4496*/
777:                     free(hMailbox);
778:                 }
779:                 
780:                 
781:                 // *****************************************************************************
782:                 /* Function:
783:                     void SYS_MSG_MailboxReinit( SYS_OBJ_HANDLE hMailbox,
784:                                                 SYS_MSG_RECEIVE_CALLBACK msgCallBackFunction );
785:                 
786:                   Summary:
787:                     Reinitialize previously opened mailbox.
788:                 */
789:                 
790:                 void SYS_MSG_MailboxReinit( SYS_OBJ_HANDLE handleMailbox,
791:                                             SYS_MSG_RECEIVE_CALLBACK msgCallBackFunction )
792:                 {
793:                     SYS_MSG_MAILBOX_OBJECT *hMailbox = (SYS_MSG_MAILBOX_OBJECT *)handleMailbox;
794:                     uint16_t iMsgInterest;
795:                 
796:                     // Check argument.
797:                     SYS_ASSERT( NULL != hMailbox, "NULL mailbox handle!" );
798:                 
799:                     // Remember new call back function.
800:                     hMailbox->msgCallBackFunction = msgCallBackFunction;
801:                 
802:                     // Clear message interest bit map
803:                     for ( iMsgInterest = 0; iMsgInterest < (SYS_MSG_MAX_TYPES/16); iMsgInterest++ )
804:                     {
805:                         hMailbox->msgInterestBitMap[iMsgInterest] = 0;
806:                     }
807:                 }
808:                 
809:                 
810:                 // *****************************************************************************
811:                 /* Function:
812:                     void SYS_MSG_MailboxMsgAdd( SYS_OBJ_HANDLE hMailbox, SYS_OBJ_HANDLE hMsgType )
813:                 
814:                   Summary:
815:                     Adds a message type to the list of messages received by a mailbox.
816:                 */
817:                 
818:                 void SYS_MSG_MailboxMsgAdd( SYS_OBJ_HANDLE handleMailbox, SYS_OBJ_HANDLE handleMsgType )
819:                 {
820:                     SYS_MSG_MAILBOX_OBJECT *hMailbox = (SYS_MSG_MAILBOX_OBJECT *)handleMailbox;
821:                     SYS_MSG_MESSAGE_DEFN   *hMsgType = (SYS_MSG_MESSAGE_DEFN   *)handleMsgType;
822:                     uint16_t iMailbox, iMessageType;
823:                 
824:                     // Check arguments
825:                     SYS_ASSERT( NULL != hMailbox, "Null mailbox handle!" );
826:                     SYS_ASSERT( NULL != hMsgType, "Null message type handle!" );
827:                 
828:                     // Get object indexes
829:                     iMailbox     = hMailbox->iMailbox;
830:                     iMessageType = hMsgType->iMessageType;
831:                 
832:                     // Set bit maps.
833:                     hMsgType->mailboxInterestBitMap[iMailbox>>4] |= 1 << (iMailbox % (1<<4));
834:                     hMailbox->msgInterestBitMap[iMessageType>>4] |= 1 << (iMessageType % (1<<4));
835:                 }
836:                 
837:                 
838:                 // *****************************************************************************
839:                 /* Function:
840:                     void SYS_MSG_MailboxMsgRemove( SYS_OBJ_HANDLE hMailbox, SYS_OBJ_HANDLE hMsgType )
841:                 
842:                   Summary:
843:                     Removes a message type from the list of messages received by a mailbox.
844:                 */
845:                 
846:                 void SYS_MSG_MailboxMsgRemove( SYS_OBJ_HANDLE handleMailbox, SYS_OBJ_HANDLE handleMsgType )
847:                 {
848:                     SYS_MSG_MAILBOX_OBJECT *hMailbox = (SYS_MSG_MAILBOX_OBJECT *)handleMailbox;
849:                     SYS_MSG_MESSAGE_DEFN   *hMsgType = (SYS_MSG_MESSAGE_DEFN   *)handleMsgType;
850:                     uint16_t iMailbox, iMessageType;
851:                 
852:                     // Check arguments
853:                     SYS_ASSERT( NULL != hMailbox, "Null mailbox handle!" );
854:                     SYS_ASSERT( NULL != hMsgType, "Null message type handle!" );
855:                 
856:                     // Get object indexes
857:                     iMailbox     = hMailbox->iMailbox;
858:                     iMessageType = hMsgType->iMessageType;
859:                 
860:                     // Clear bit maps.
861:                     hMsgType->mailboxInterestBitMap[iMailbox>>4] &= ~( 1 << (iMailbox % (1<<4))     );
862:                     hMailbox->msgInterestBitMap[iMessageType>>4] &= ~( 1 << (iMessageType % (1<<4)) );
863:                 }
864:                 
865:                 
866:                 // *****************************************************************************
867:                 /* Function:
868:                     SYS_MSG_OBJECT *SYS_MSG_MailboxMessagesGet( SYS_OBJ_HANDLE hMailbox )
869:                 
870:                   Summary:
871:                     Get queued messages for a mailbox.
872:                 */
873:                 
874:                 SYS_MSG_OBJECT *SYS_MSG_MailboxMessagesGet( SYS_OBJ_HANDLE handleMailbox )
875:                 {
876:                     SYS_MSG_MAILBOX_OBJECT *hMailbox = (SYS_MSG_MAILBOX_OBJECT *)handleMailbox;
877:                     SYS_MSG_MESSAGING_OBJECT *hSysMsg;
878:                     uint16_t iMailbox;
879:                     SYS_MSGQ_ELEMENT *pQElement = NULL;
880:                     uint16_t iQElement;
881:                     uint16_t iBitMap, iBit, bitMap;
882:                     SYS_MSG_MAILBOX_OBJECT  * pMailbox = NULL;
883:                 
884:                     int16_t iPriority;
885:                     uint16_t nMessagePriorities;
886:                     SYS_MSG_QUEUE *pQ;
887:                 
888:                     // Check argument
889:                     SYS_ASSERT( NULL != hMailbox, "Null mailbox handle!" );
890:                 
891:                     // Determine iMailbox index for this mailbox
892:                     hSysMsg = hMailbox->hSysMsg;
893:                     for ( iMailbox=0; iMailbox < hSysMsg->nMessageTypes; iMailbox++ )
894:                     {
895:                         if ( hSysMsg->pMailbox[iMailbox] == hMailbox )
896:                         {
897:                             pMailbox = hSysMsg->pMailbox[iMailbox];
898:                             break;
899:                         }
900:                     }
901:                     if ( NULL != pMailbox )
902:                     {
903:                         SYS_ASSERT( NULL != pMailbox, "Mailbox handle not found!" );
904:                     }
905:                     iBitMap = iMailbox/16; iBit = iMailbox % 16;
906:                 
907:                     // Find first message of interest to this mailbox.
908:                     nMessagePriorities = hSysMsg->nMessagePriorities;
909:                     for (iPriority=nMessagePriorities-1;iPriority>=0;iPriority--)
910:                     {
911:                         pQ = &(hSysMsg->msgQueues[iPriority]);
912:                         iQElement = 0;
913:                         while ( NULL != ( pQElement = SYS_MSGQ_QRefGet(pQ,iQElement) ) )
914:                         {
915:                             bitMap = pQElement->mailboxInterestBitMap[iBitMap];
916:                             if ( (bitMap & 1<<iBit) > 0 )
917:                             {// Found a message of interest
918:                                 bitMap &= ~(1<<iBit); // Clear this mailbox bit.
919:                                 pQElement->mailboxInterestBitMap[iBitMap] = bitMap; // Store it.
920:                                 break;
921:                             }
922:                             iQElement++; // Move on to next element in queue
923:                         }
924:                         if ( NULL != pQElement )
925:                         {// Found a message to report out to mailbox
926:                             break;
927:                         }
928:                     }
929:                     if (  NULL != pQElement )
930:                     {
931:                         return &(pQElement->sMessage);
932:                     }
933:                     else
934:                     {
935:                         return (SYS_MSG_OBJECT *)NULL;
936:                     }
937:                 }
938:                 
939:                 
940:                 // *****************************************************************************
941:                 // *****************************************************************************
942:                 // Section: Message Queues
943:                 // *****************************************************************************
944:                 // *****************************************************************************
945:                 
946:                 // *****************************************************************************
947:                 /* Function:
948:                     SYS_MSG_QUEUE_STATUS SYS_MSG_QueueStatus( const SYS_MSG_INSTANCE iSysMsg, uint8_t nMessagePriority )
949:                 
950:                   Summary:
951:                     Returns message queue status for a given message priority.
952:                 */
953:                 
954:                 SYS_MSG_QUEUE_STATUS SYS_MSG_QueueStatus( const SYS_MSG_INSTANCE iSysMsg, uint8_t nMessagePriority )
955:                 {
956:                     int nCount,nQSize;
957:                     SYS_MSG_MESSAGING_OBJECT *hSysMsg;
958:                 
959:                     // Check arguments
960:                     if ( iSysMsg < SYS_MSG_NUM_INSTANCES &&
961:                          NULL != handleSysMsg[iSysMsg]   &&
962:                          nMessagePriority <= SYS_MSG_MAX_PRIORITY )
963:                     {
964:                         hSysMsg = handleSysMsg[iSysMsg];
965:                         nCount = (hSysMsg->msgQueues)[nMessagePriority].nCount;
966:                         nQSize = (hSysMsg->msgQueues)[nMessagePriority].nQSize;
967:                         if ( nCount == nQSize )
968:                         {
969:                             return SYS_MSG_QUEUE_FULL;
970:                         }
971:                         else
972:                         {
973:                             return nCount;
974:                         }
975:                     }
976:                     else
977:                     {
978:                         return SYS_MSG_QUEUE_BAD;
979:                     }
980:                 }
981:                 
982:                 
983:                 // *****************************************************************************
984:                 // *****************************************************************************
985:                 // Section: Individual Queue Support
986:                 // *****************************************************************************
987:                 // *****************************************************************************
988:                 
989:                 // *****************************************************************************
990:                 /* Function:
991:                     SYS_MSGQ_RESULT SYS_MSGQ_Init(SYS_MSG_QUEUE *pQ, int nQSize)
992:                 
993:                   Summary:
994:                     Initialized individual queue.
995:                 
996:                   Description:
997:                     Initialized individual queue, including allocating memory for queue elements.
998:                 
999:                   Precondition:
1000:                    None
1001:                
1002:                  Parameters:
1003:                    pQ - pointer to queue to be initialized
1004:                    nQSize - number of queue elements for this queue
1005:                
1006:                  Returns:
1007:                    SYS_MSGQ_Success ( if allocation of queue elements succeeds ) or
1008:                    SYS_MSGQ_Failure ( if allocation fails )
1009:                
1010:                  Example:
1011:                  <code>
1012:                    SYS_MSG_QUEUE newQ;
1013:                    SYS_MSGQ_RESULT initResult;
1014:                    initResult = SYS_MSGQ_Init(&newQ,10);
1015:                    SYS_ASSERT( SYS_MSGQ_Success == initResult );
1016:                  </code>
1017:                
1018:                  Remarks:
1019:                    None.
1020:                */
1021:                
1022:                SYS_MSGQ_RESULT SYS_MSGQ_Init(SYS_MSG_QUEUE *pQ, int nQSize)
1023:                {
9D013340  27BDFFE0   ADDIU SP, SP, -32
9D013344  AFBF001C   SW RA, 28(SP)
9D013348  AFB10018   SW S1, 24(SP)
9D01334C  AFB00014   SW S0, 20(SP)
9D013350  00808021   ADDU S0, A0, ZERO
1024:                    SYS_ASSERT( nQSize > 0, "Bad queue size!" );
1025:                
1026:                    pQ->nQSize = nQSize;
9D013354  AC850000   SW A1, 0(A0)
1027:                    pQ->iStart = 0;
9D013358  AC800008   SW ZERO, 8(A0)
1028:                    pQ->iEnd   = 0;
9D01335C  AC80000C   SW ZERO, 12(A0)
1029:                    pQ->nCount = 0;
9D013360  AC800004   SW ZERO, 4(A0)
1030:                    pQ->qElements = (SYS_MSGQ_ELEMENT *)malloc(sizeof(SYS_MSGQ_ELEMENT)*(pQ->nQSize));
9D013364  00051080   SLL V0, A1, 2
9D013368  00052900   SLL A1, A1, 4
9D01336C  00A28823   SUBU S1, A1, V0
9D013370  0F401C09   JAL malloc
9D013374  02202021   ADDU A0, S1, ZERO
1031:                    if ( pQ->qElements == (SYS_MSGQ_ELEMENT *)NULL ) // memory not allocated
9D013378  10400007   BEQ V0, ZERO, 0x9D013398
9D01337C  AE020010   SW V0, 16(S0)
1032:                    {
1033:                        return SYS_MSGQ_Failure;
9D013398  2402FFF6   ADDIU V0, ZERO, -10
1034:                    }
1035:                    memset(pQ->qElements,0x00,sizeof(SYS_MSGQ_ELEMENT)*(pQ->nQSize));
9D013380  00402021   ADDU A0, V0, ZERO
9D013384  00002821   ADDU A1, ZERO, ZERO
9D013388  0F40464F   JAL memset
9D01338C  02203021   ADDU A2, S1, ZERO
1036:                
1037:                    return SYS_MSGQ_Success;
9D013390  0B404CE7   J 0x9D01339C
9D013394  2402000A   ADDIU V0, ZERO, 10
1038:                }
9D01339C  8FBF001C   LW RA, 28(SP)
9D0133A0  8FB10018   LW S1, 24(SP)
9D0133A4  8FB00014   LW S0, 20(SP)
9D0133A8  03E00008   JR RA
9D0133AC  27BD0020   ADDIU SP, SP, 32
1039:                
1040:                
1041:                // *****************************************************************************
1042:                /* Function:
1043:                    void SYS_MSGQ_Delete(SYS_MSG_QUEUE *pQ)
1044:                
1045:                  Summary:
1046:                    Deletes existing message queue.
1047:                
1048:                  Description:
1049:                    Deletes existing message queue, including deallocation of queue elements.
1050:                
1051:                  Precondition:
1052:                    Message queue should have been created by SYS_MSGQ_Init.
1053:                
1054:                  Parameters:
1055:                    pQ - pointer to message queue to be deleted.
1056:                
1057:                  Returns:
1058:                    None.
1059:                
1060:                  Example:
1061:                  <code>
1062:                    SYS_MSG_QUEUE newQ;
1063:                    SYS_MSGQ_RESULT initResult;
1064:                    initResult = SYS_MSGQ_Init(&newQ,10);
1065:                    SYS_ASSERT( SYS_MSGQ_Success == initResult );
1066:                    SYS_MSGQ_Delete(&newQ);
1067:                  </code>
1068:                
1069:                  Remarks:
1070:                    None.
1071:                */
1072:                
1073:                void SYS_MSGQ_Delete(SYS_MSG_QUEUE *pQ)
1074:                {
1075:                    pQ->nQSize = 0;
1076:                    pQ->iStart = 0;
1077:                    pQ->iEnd   = 0;
1078:                    pQ->nCount = 0;
1079:                    free(pQ->qElements); // Deallocate queue elements
1080:                    pQ->qElements = (SYS_MSGQ_ELEMENT *)NULL;
1081:                }
1082:                
1083:                
1084:                // *****************************************************************************
1085:                /* Function:
1086:                    bool SYS_MSGQ_IsFull(SYS_MSG_QUEUE *pQ)
1087:                
1088:                  Summary:
1089:                    Returns true if message queue is full, false otherwise.
1090:                
1091:                  Description:
1092:                    Returns true if message queue is full, false otherwise.
1093:                
1094:                  Precondition:
1095:                    None.
1096:                
1097:                  Parameters:
1098:                    None.
1099:                
1100:                  Returns:
1101:                    true if queue is full, false otherwise.
1102:                
1103:                  Example:
1104:                  <code>
1105:                  </code>
1106:                
1107:                  Remarks:
1108:                    None.
1109:                */
1110:                
1111:                bool SYS_MSGQ_IsFull(SYS_MSG_QUEUE *pQ)
1112:                {
1113:                    SYS_ASSERT( NULL != pQ, "Null queue pointer!" );
1114:                    return (bool)(pQ->nCount == pQ->nQSize);
1115:                }
1116:                
1117:                
1118:                // *****************************************************************************
1119:                /* Function:
1120:                    bool SYS_MSGQ_IsEmpty(SYS_MSG_QUEUE *pQ)
1121:                
1122:                  Summary:
1123:                    Returns true if message queue is empty, false otherwise.
1124:                
1125:                  Description:
1126:                    Returns true if message queue is empty, false otherwise.
1127:                
1128:                  Precondition:
1129:                    None.
1130:                
1131:                  Parameters:
1132:                    None.
1133:                
1134:                  Returns:
1135:                    true if queue is empty, false otherwise.
1136:                
1137:                  Example:
1138:                  <code>
1139:                  </code>
1140:                
1141:                  Remarks:
1142:                    None.
1143:                */
1144:                bool SYS_MSGQ_IsEmpty(SYS_MSG_QUEUE *pQ)
1145:                {
1146:                    SYS_ASSERT( NULL != pQ, "Null queue pointer!" );
1147:                    return (bool)(pQ->nCount == 0);
9D0085F8  02431821   ADDU V1, S2, V1
1148:                }
1149:                
1150:                
1151:                // *****************************************************************************
1152:                /* Function:
1153:                    SYS_MSGQ_RESULT SYS_MSGQ_Enqueue(SYS_MSG_QUEUE *pQ, SYS_MSGQ_ELEMENT *pMsg)
1154:                
1155:                  Summary:
1156:                    Add (enqueue) new message to a message queue.
1157:                
1158:                  Description:
1159:                    Add (enqueue) new message to a message queue.
1160:                
1161:                  Precondition:
1162:                    Message queue must be initialized with SYS_MSGQ_Init.
1163:                
1164:                  Parameters:
1165:                    pQ - pointer to message queue.
1166:                    pMsg - pointer to message
1167:                
1168:                  Returns:
1169:                    SYS_MSGQ_Success ( if message added to queue ) or
1170:                    SYS_MSGQ_Failure ( if queue is full and message not added to queue )
1171:                
1172:                  Example:
1173:                  <code>
1174:                  </code>
1175:                
1176:                  Remarks:
1177:                    None.
1178:                */
1179:                
1180:                SYS_MSGQ_RESULT SYS_MSGQ_Enqueue(SYS_MSG_QUEUE *pQ, SYS_MSGQ_ELEMENT *pMsg)
1181:                {
1182:                    int iEnd;
1183:                
1184:                    SYS_ASSERT( NULL != pQ,   "Null queue pointer!"   );
1185:                    SYS_ASSERT( NULL != pMsg, "Null element pointer!" );
1186:                
1187:                    if (pQ->nCount == pQ->nQSize) //return error, queue is full
1188:                    {
1189:                        return SYS_MSGQ_Failure;
1190:                    }
1191:                    else // Queue is not full
1192:                    {
1193:                        iEnd = (pQ->iStart + pQ->nCount) % pQ->nQSize;
1194:                        pQ->qElements[iEnd] = *pMsg;
1195:                        pQ->nCount += 1;
1196:                        return SYS_MSGQ_Success;
1197:                    }
1198:                }
1199:                
1200:                
1201:                // *****************************************************************************
1202:                /* Function:
1203:                    void SYS_MSGQ_Dequeue(SYS_MSG_QUEUE *pQ)
1204:                
1205:                  Summary:
1206:                    Removes (dequeues) the oldest message from a message queue.
1207:                
1208:                  Description:
1209:                    Removes (dequeues) the oldest message from a message queue.
1210:                
1211:                  Precondition:
1212:                    Message queue must be initialized with SYS_MSGQ_Init.
1213:                
1214:                  Parameters:
1215:                    pQ - pointer to message queue.
1216:                
1217:                  Returns:
1218:                    None.
1219:                
1220:                  Example:
1221:                  <code>
1222:                  </code>
1223:                
1224:                  Remarks:
1225:                    Message should be read using SYS_MSGQ_ReadQueue before removal from the queue.
1226:                */
1227:                
1228:                void SYS_MSGQ_Dequeue(SYS_MSG_QUEUE *pQ)
1229:                {
1230:                    SYS_ASSERT( NULL != pQ, "Null queue pointer!" );
1231:                    if ( pQ->nCount > 0 )
9D014F04  8C820004   LW V0, 4(A0)
9D014F08  18400009   BLEZ V0, 0x9D014F30
9D014F0C  2442FFFF   ADDIU V0, V0, -1
1232:                    {
1233:                        pQ->iStart = (pQ->iStart + 1) % (pQ->nQSize);
9D014F10  8C850008   LW A1, 8(A0)
9D014F14  24A50001   ADDIU A1, A1, 1
9D014F18  8C830000   LW V1, 0(A0)
9D014F1C  00A3001A   DIV A1, V1
9D014F20  006001F4   TEQ V1, ZERO
9D014F24  00003010   MFHI A2
9D014F28  AC860008   SW A2, 8(A0)
1234:                        pQ->nCount -= 1;
9D014F2C  AC820004   SW V0, 4(A0)
9D014F30  03E00008   JR RA
9D014F34  00000000   NOP
1235:                    }
1236:                }
1237:                
1238:                
1239:                // *****************************************************************************
1240:                /* Function:
1241:                    SYS_MSGQ_ELEMENT SYS_MSGQ_ReadQueue(SYS_MSG_QUEUE *pQ )
1242:                
1243:                  Summary:
1244:                    Reads oldest message on a queue.
1245:                
1246:                  Description:
1247:                    Reads oldest message on a queue, but does not remove (dequeue) the message.
1248:                
1249:                  Precondition:
1250:                    Message queue must be initialized with SYS_MSGQ_Init.
1251:                
1252:                  Parameters:
1253:                    pQ - pointer to message queue.
1254:                
1255:                  Returns:
1256:                    Oldest message on the queue.
1257:                
1258:                  Example:
1259:                  <code>
1260:                  </code>
1261:                
1262:                  Remarks:
1263:                    None.
1264:                */
1265:                
1266:                SYS_MSGQ_ELEMENT SYS_MSGQ_ReadQueue(SYS_MSG_QUEUE *pQ )
1267:                {
1268:                    SYS_ASSERT( NULL != pQ, "Null queue pointer!" );
1269:                    return ( pQ->qElements[pQ->iStart] );
1270:                }
1271:                
1272:                
1273:                // *****************************************************************************
1274:                /* Function:
1275:                    SYS_MSGQ_ELEMENT *SYS_MSGQ_GetNextQRef(SYS_MSG_QUEUE *pQ )
1276:                
1277:                  Summary:
1278:                    Returns a pointer to oldest message on a queue.
1279:                
1280:                  Description:
1281:                    Returns a pointer to oldest message on a queue.
1282:                
1283:                  Precondition:
1284:                    Message queue must be initialized with SYS_MSGQ_Init.
1285:                
1286:                  Parameters:
1287:                    pQ - pointer to message queue.
1288:                
1289:                  Returns:
1290:                    Pointer to oldest message element on the queue.
1291:                
1292:                  Example:
1293:                  <code>
1294:                  </code>
1295:                
1296:                  Remarks:
1297:                    None.
1298:                */
1299:                
1300:                SYS_MSGQ_ELEMENT *SYS_MSGQ_GetNextQRef(SYS_MSG_QUEUE *pQ )
1301:                {
1302:                    SYS_ASSERT( NULL != pQ, "Null queue pointer!" );
1303:                    return ( pQ->qElements + pQ->iStart );
9D008650  8C620008   LW V0, 8(V1)
9D008654  00022080   SLL A0, V0, 2
9D008658  00021100   SLL V0, V0, 4
9D00865C  00441023   SUBU V0, V0, A0
9D008660  8C760010   LW S6, 16(V1)
9D008664  02C2B021   ADDU S6, S6, V0
1304:                }
1305:                
1306:                
1307:                // *****************************************************************************
1308:                /* Function:
1309:                    SYS_MSGQ_ELEMENT *SYS_MSGQ_QRefGet(SYS_MSG_QUEUE *pQ, uint8_t iQElement)
1310:                
1311:                  Summary:
1312:                    Returns pointer to the iQElement'th queue element in the queue defined by pQ.
1313:                
1314:                  Description:
1315:                    Returns pointer to the iQElement'th queue element in the queue defined by pQ.
1316:                
1317:                  Precondition:
1318:                    None.
1319:                
1320:                  Parameters:
1321:                    pQ - pointer to message queue.
1322:                    iQElement - index into the message queue.
1323:                                iQElement = 0 identifies oldest queue element.
1324:                
1325:                  Returns:
1326:                    Pointer to queue element defined by iQElement index.
1327:                
1328:                  Example:
1329:                  <code>
1330:                  </code>
1331:                
1332:                  Remarks:
1333:                    None.
1334:                */
1335:                
1336:                SYS_MSGQ_ELEMENT *SYS_MSGQ_QRefGet(SYS_MSG_QUEUE *pQ, uint8_t iQElement)
1337:                {
1338:                    uint8_t iQIndex;
1339:                
1340:                    SYS_ASSERT( NULL != pQ, "Null queue pointer!" );
1341:                
1342:                    if ( iQElement < pQ->nCount )
1343:                    {// Return pointer
1344:                        iQIndex = (pQ->iStart + iQElement) % (pQ->nQSize);
1345:                        return ( pQ->qElements + iQIndex );
1346:                    }
1347:                    else
1348:                    {// Return NULL
1349:                        return NULL;
1350:                    }
1351:                }
---  /home/whatisthis/microchip/harmony/v2_04/framework/system/int/src/sys_int_pic32.c  -----------------
1:                   /*******************************************************************************
2:                     Interrupt System Service
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       sys_int_pic32.c
9:                   
10:                    Summary:
11:                      Interrupt System Service APIs.
12:                  
13:                    Description:
14:                      This file contains functions related to the Interrupt System Service for PIC32
15:                      devices.
16:                  *******************************************************************************/
17:                  
18:                  // DOM-IGNORE-BEGIN
19:                  /*******************************************************************************
20:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
21:                  
22:                  Microchip licenses to you the right to use, modify, copy and distribute
23:                  Software only when embedded on a Microchip microcontroller or digital signal
24:                  controller that is integrated into your product or third party product
25:                  (pursuant to the sublicense terms in the accompanying license agreement).
26:                  
27:                  You should refer to the license agreement accompanying this Software for
28:                  additional information regarding your rights and obligations.
29:                  
30:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
31:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
32:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
33:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
34:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
35:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
36:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
37:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
38:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
39:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
40:                  *******************************************************************************/
41:                  // DOM-IGNORE-END
42:                  
43:                  #include "system/int/sys_int.h"
44:                  
45:                  // *****************************************************************************
46:                  // *****************************************************************************
47:                  // Section: Function Definitions
48:                  // *****************************************************************************
49:                  // *****************************************************************************
50:                  
51:                  
52:                  /******************************************************************************
53:                  
54:                    Function:
55:                      void SYS_INT_Initialize ( void )
56:                  
57:                    Summary:
58:                      Configures and initializes the interrupt sub-system.
59:                  
60:                    Description:
61:                      This function appropriately configures and initializes the interrupt sub-system
62:                      for the current system design.
63:                  
64:                    Precondition:
65:                      None.
66:                  
67:                    Parameters:
68:                      None.
69:                  
70:                    Returns:
71:                      None.
72:                  
73:                    Example:
74:                    <code>
75:                    SYS_INT_Initialize();
76:                    </code>
77:                  
78:                    Remarks:
79:                      This function is not implemented in the System Interrupt library.  It is
80:                      implemented by the board support package (using the processor-specific
81:                      interrupt peripheral library) because it requires knowledge of the specific
82:                      interrupt requirements for each system.
83:                  */
84:                  
85:                  void SYS_INT_Initialize ( void )
86:                  
87:                  {
88:                      /* enable the multi vector */
89:                      PLIB_INT_MultiVectorSelect( INT_ID_0 );
90:                  }
91:                  
92:                  //*******************************************************************************
93:                  /*  Function:
94:                       SYS_INT_PROCESSOR_STATUS  SYS_INT_StatusGetAndDisable ( void )
95:                  
96:                    Summary:
97:                      Disables interrupts to the processor and return the previois status.
98:                      
99:                    Description:
100:                     This function disables interrupts to the processor at the top level. This
101:                     function can be called to prevent any source from being able to generate an
102:                     interrupt. It returns the processor status (which includes global interrupt
103:                     status and Interrupt Priority status) before disabling the interrupts.
104:                 
105:                   Remarks:
106:                     See sys_int.h file for more details.
107:                 */
108:                 
109:                 SYS_INT_PROCESSOR_STATUS  SYS_INT_StatusGetAndDisable ( void )
110:                 {
111:                     SYS_INT_PROCESSOR_STATUS processorStatus;
112:                 
113:                     /* Save the processor status and then Disable the global interrupt */
114:                 
115:                 
116:                     processorStatus = ( SYS_INT_PROCESSOR_STATUS )__builtin_disable_interrupts();
117:                 
118:                     /* return the processor status */
119:                     return processorStatus;
120:                 }
121:                 
122:                 //*******************************************************************************
123:                 /* Function:
124:                     void SYS_INT_StatusRestore ( SYS_INT_PROCESSOR_STATUS processorStatus )
125:                 
126:                   Summary:
127:                     Restores the processor status.
128:                 
129:                   Description:
130:                     This function sets the processor status based on the 32 bit value passed as 
131:                     a parameter. 0th bit of the status is for Master Interrupt status.
132:                 
133:                   Remarks:
134:                     See sys_int.h file for more details.
135:                 */
136:                 
137:                 void SYS_INT_StatusRestore ( SYS_INT_PROCESSOR_STATUS processorStatus )
138:                 {
139:                     __builtin_mtc0(12, 0, processorStatus);
140:                 }
141:                 
142:                 // *****************************************************************************
143:                 /*  Disable the generation of interrupts to the CPU
144:                 
145:                   Summary:
146:                      Disables all interrupts
147:                 
148:                   Description:
149:                      This function disables all interrupts.
150:                 
151:                   Remarks:
152:                     This API will be depricated soon. Use "SYS_INT_StatusGetAndDisable" instead.
153:                  */
154:                 
155:                 bool SYS_INT_Disable( void )
156:                 {
157:                     SYS_INT_PROCESSOR_STATUS processorStatus;
158:                 
159:                     /* Save the processor status and then Disable the global interrupt */
160:                     processorStatus = ( SYS_INT_PROCESSOR_STATUS )__builtin_disable_interrupts();
161:                 
162:                     /* return the interrupt status */
163:                     return (bool)(processorStatus & 0x01);
164:                 }
165:                 
166:                 // *****************************************************************************
167:                 /* Function:
168:                     bool SYS_INT_SourceDisable ( INT_SOURCE source )
169:                 
170:                   Summary:
171:                     Disables the interrupt source.
172:                 
173:                   Description:
174:                     This routine disables the given source from generating interrupts the 
175:                     processor when events occur.It returns the interrupt source enable/disable 
176:                 	status before disabling the interrupt source.
177:                 
178:                   Remarks:
179:                     See sys_int.h file for more details.
180:                  */
181:                 
182:                 
183:                 bool SYS_INT_SourceDisable ( INT_SOURCE source )
184:                 {
9D014160  27BDFFF8   ADDIU SP, SP, -8
9D014164  AFBF0004   SW RA, 4(SP)
185:                     bool intSrcStatus;
186:                     SYS_INT_PROCESSOR_STATUS processorStatus;
187:                 
188:                     /* Save the processor status and then Disable the global interrupt */
189:                     processorStatus = ( SYS_INT_PROCESSOR_STATUS )__builtin_disable_interrupts();
9D014168  41656000   DI A1
9D01416C  000000C0   EHB
190:                     
191:                     /* get the interrupt status of this source before disable is called */
192:                     intSrcStatus = PLIB_INT_SourceIsEnabled (INT_ID_0 , source);
193:                 
194:                     /* disable the interrupts */
195:                     PLIB_INT_SourceDisable (INT_ID_0 , source);
196:                 
197:                     /* restore the state of CP0 Status register before the disable occurred*/
198:                     __builtin_mtc0(12, 0, processorStatus);
9D014198  40856000   MTC0 A1, Status
9D01419C  000000C0   EHB
199:                 
200:                     /* return the source status */
201:                     return intSrcStatus;
202:                 }
9D0141A4  30420001   ANDI V0, V0, 1
9D0141A8  8FBF0004   LW RA, 4(SP)
9D0141AC  03E00008   JR RA
9D0141B0  27BD0008   ADDIU SP, SP, 8
203:                 
204:                 
205:                 // *****************************************************************************
206:                 /* Sets the external interrupt trigger type.
207:                 
208:                   Summary:
209:                     Sets the external interrupt trigger type.
210:                 
211:                   Description:
212:                     This function sets the External interrupt trigger type.
213:                 
214:                   Remarks:
215:                     Refer the datasheet to know the external interrupt sources supported.
216:                  */
217:                 
218:                 void SYS_INT_ExternalInterruptTriggerSet ( 	INT_EXTERNAL_SOURCES source,
219:                 										INT_EXTERNAL_EDGE_TRIGGER edgeTrigger )
220:                 {
221:                 	if ( edgeTrigger == INT_EDGE_TRIGGER_RISING )
9D01525C  24020001   ADDIU V0, ZERO, 1
9D015260  14A20005   BNE A1, V0, SYS_INT_ExternalInterruptTriggerSet::PLIB_INT_ExternalFallingEdgeSelect
9D015264  3C02BF88   LUI V0, -16504
9D015268  3C02BF88   LUI V0, -16504
9D01526C  AC441008   SW A0, 4104(V0)
9D015270  03E00008   JR RA
9D015274  00000000   NOP
9D015278  AC441004   SW A0, 4100(V0)
9D01527C  03E00008   JR RA
9D015280  00000000   NOP
222:                 	{
223:                 		PLIB_INT_ExternalRisingEdgeSelect ( INT_ID_0, source );
224:                 	}
225:                 	else
226:                 	{
227:                 		PLIB_INT_ExternalFallingEdgeSelect ( INT_ID_0, source );
228:                 	}
229:                 }
230:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/system/dma/src/sys_dma.c  -----------------------
1:                   /*******************************************************************************
2:                     DMA System Service Library
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       sys_dma.c
9:                   
10:                    Summary:
11:                      DMA System Service.
12:                  
13:                    Description:
14:                      This file implements the core functionality of the DMA System Service.
15:                      It provides a way to interact with the DMA subsystem to
16:                      manage the data transfer between different peripherals and/or memory
17:                      without intervention from the CPU.
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  //DOM-IGNORE-END
44:                  
45:                  // *****************************************************************************
46:                  // *****************************************************************************
47:                  // Section: File includes
48:                  // *****************************************************************************
49:                  // *****************************************************************************
50:                  
51:                  #include "system_config.h"
52:                  #include "system/int/sys_int.h"
53:                  #include "system/dma/sys_dma.h"
54:                  #include "system/dma/src/sys_dma_local.h"
55:                  
56:                  
57:                  
58:                  // *****************************************************************************
59:                  /* DMA Channel instance objects.
60:                  
61:                    Summary:
62:                      Defines the DMA channel objects
63:                  
64:                    Description:
65:                      This data type defines the DMA channel objects. It holds the information
66:                      about the usage/availability of a channel for DMA data transfers
67:                  
68:                    Remarks:
69:                      Not all modes are available on all micro-controllers.
70:                   */
71:                  
72:                  SYS_DMA_CHANNEL_OBJECT  gSysDMAChannelObj[SYS_DMA_CHANNEL_COUNT];
73:                  
74:                  
75:                  // *****************************************************************************
76:                  // *****************************************************************************
77:                  // Section: DMA System Service Interface Routines
78:                  // *****************************************************************************
79:                  // *****************************************************************************
80:                  
81:                  
82:                  // *****************************************************************************
83:                  // *****************************************************************************
84:                  // Section: Initialization
85:                  // *****************************************************************************
86:                  // *****************************************************************************
87:                  //******************************************************************************
88:                  /* Function:
89:                      SYS_MODULE_OBJ SYS_DMA_Initialize(const SYS_MODULE_INIT * const init)
90:                  
91:                    Summary:
92:                      Initializes and Enables the DMA Controller.
93:                  
94:                    Description:
95:                      This function Enables the DMA module. Enable/Disable stop in idle mode
96:                      feature based on the passed parameter value.
97:                  
98:                      This routine initializes the DMA module making it ready for clients to
99:                      open and use it. The initialization data is specified by the init parameter.
100:                 
101:                   Remarks:
102:                     This routine must be called before any other DMA systems service routines
103:                     are called.
104:                 
105:                     Not all features are available on all micro-controllers.
106:                 */
107:                 SYS_MODULE_OBJ SYS_DMA_Initialize(const SYS_MODULE_INIT * const init)
108:                 {
109:                     SYS_DMA_INIT *initp;
110:                     uint8_t chanIndex;
111:                     SYS_DMA_CHANNEL_OBJECT *chanObj;
112:                 
113:                 
114:                     /* Validate the init object */
115:                     if ((SYS_MODULE_INIT *)NULL == init)
9D01348C  10800018   BEQ A0, ZERO, 0x9D0134F0
9D013490  3C05BF88   LUI A1, -16504
116:                     {
117:                         SYS_ASSERT(false, "Invalid Init Object");
118:                         return SYS_MODULE_OBJ_INVALID;
119:                     }
120:                 
121:                     initp = (SYS_DMA_INIT *)init;
122:                 
123:                     /* Enable/disable the stop in idle mode feature. */
124:                 #if defined (PLIB_DMA_ExistsStopInIdle)
125:                     if(true == PLIB_DMA_ExistsStopInIdle(DMA_ID_0))
126:                     {
127:                         if(SYS_DMA_SIDL_DISABLE == initp->sidl)
128:                         {
129:                             PLIB_DMA_StopInIdleDisable(DMA_ID_0);
130:                         }
131:                         else if(SYS_DMA_SIDL_ENABLE == initp->sidl)
132:                         {
133:                             PLIB_DMA_StopInIdleEnable(DMA_ID_0);
134:                         }
135:                     }
136:                 #endif
137:                     /* Enable the DMA module */
138:                     PLIB_DMA_Enable(DMA_ID_0);
139:                 
140:                     /* Initialize the available channel objects */
141:                     chanObj             =   (SYS_DMA_CHANNEL_OBJECT *)&gSysDMAChannelObj[0];
9D0134A4  3C03A000   LUI V1, -24576
9D0134A8  24630C9C   ADDIU V1, V1, 3228
142:                     for(chanIndex = 0; chanIndex < SYS_DMA_CHANNEL_COUNT; chanIndex++)
9D0134B0  3C08BF88   LUI T0, -16504
9D0134B4  25083360   ADDIU T0, T0, 13152
9D0134E0  14A8FFF5   BNE A1, T0, 0x9D0134B8
9D0134E4  30C60003   ANDI A2, A2, 3
143:                     {
144:                         chanObj->inUse          =    false;
9D0134B8  A0600000   SB ZERO, 0(V1)
145:                         chanObj->pEventCallBack =    NULL;
9D0134BC  AC600008   SW ZERO, 8(V1)
146:                         chanObj->hClientArg     =    0;
9D0134C0  AC60000C   SW ZERO, 12(V1)
147:                         chanObj->errorInfo      =    SYS_DMA_ERROR_NONE;
9D0134AC  24090001   ADDIU T1, ZERO, 1
9D0134C4  AC690004   SW T1, 4(V1)
148:                         chanObj                 =    chanObj + 1;
9D0134C8  24630010   ADDIU V1, V1, 16
149:                         /* Initializing all channel priorities as 0 */
150:                         PLIB_DMA_ChannelXPrioritySelect(DMA_ID_0, chanIndex, chanIndex);
151:                     }
152:                 
153:                     /* Return the object structure */
154:                     return ((SYS_MODULE_OBJ) initp);
9D0134E8  03E00008   JR RA
9D0134EC  00801021   ADDU V0, A0, ZERO
155:                 }
9D0134F0  03E00008   JR RA
9D0134F4  2402FFFF   ADDIU V0, ZERO, -1
156:                 
157:                 
158:                 // *****************************************************************************
159:                 // *****************************************************************************
160:                 // Section:  Channel Setup and management routines
161:                 // *****************************************************************************
162:                 // *****************************************************************************
163:                 
164:                 //******************************************************************************
165:                 /* Function:
166:                     SYS_DMA_CHANNEL_HANDLE SYS_DMA_ChannelAllocate(DMA_CHANNEL channel)
167:                 
168:                   Summary:
169:                     Allocates the specified DMA channel and returns a handle to it
170:                 
171:                   Description:
172:                     This routine opens the specified DMA channel and provides a
173:                     handle that must be provided to all other client-level operations to
174:                     identify the caller and the DMA channel.
175:                 
176:                   Remarks:
177:                     The handle returned is valid until the SYS_DMA_ChannelRelease routine is called.
178:                     This routine must be called before any other DMA channel Setup and management
179:                     routines are called
180:                 */
181:                 SYS_DMA_CHANNEL_HANDLE SYS_DMA_ChannelAllocate(DMA_CHANNEL channel)
182:                 {
9D013BC0  00001821   ADDU V1, ZERO, ZERO
183:                     SYS_DMA_CHANNEL_HANDLE              channelHandle;
184:                     SYS_DMA_CHANNEL_OBJECT              *chanObj;
185:                     uint8_t                             chanIndex;
186:                     bool                                chanAlloc;
187:                 
188:                     channelHandle       =   (SYS_DMA_CHANNEL_HANDLE)NULL;
189:                     chanAlloc           =   false;
190:                     chanObj             =   (SYS_DMA_CHANNEL_OBJECT *)&gSysDMAChannelObj[0];
9D013BC4  3C02A000   LUI V0, -24576
9D013BC8  24420C9C   ADDIU V0, V0, 3228
191:                 
192:                     for(chanIndex = 0; chanIndex < SYS_DMA_CHANNEL_COUNT; chanIndex++)
9D013BD0  3C06A000   LUI A2, -24576
9D013BD4  24C60CDC   ADDIU A2, A2, 3292
9D013C0C  1446FFF2   BNE V0, A2, 0x9D013BD8
9D013C10  24630001   ADDIU V1, V1, 1
193:                     {
194:                         /* Iterate to find a free channel */
195:                         if(false == chanObj->inUse)
9D013BD8  90450000   LBU A1, 0(V0)
9D013BDC  54A0000B   BNEL A1, ZERO, 0x9D013C0C
9D013BE0  24420010   ADDIU V0, V0, 16
196:                         {
197:                             /* If user's choice is any,
198:                              * Allocate the first available free channel */
199:                             if(DMA_CHANNEL_ANY == channel)
9D013BCC  2407FFFE   ADDIU A3, ZERO, -2
9D013BE4  14870004   BNE A0, A3, 0x9D013BF8
9D013BE8  00000000   NOP
200:                             {
201:                                 chanObj->inUse          = true;
9D013BEC  24030001   ADDIU V1, ZERO, 1
202:                                 chanAlloc               = true;
203:                                 break;
9D013BF0  03E00008   JR RA
9D013BF4  A0430000   SB V1, 0(V0)
204:                             }
205:                             /* Check if the requested channel is free */
206:                             else if(chanIndex == channel)
9D013BF8  54640004   BNEL V1, A0, 0x9D013C0C
9D013BFC  24420010   ADDIU V0, V0, 16
207:                             {
208:                                 chanObj->inUse          = true;
9D013C00  24030001   ADDIU V1, ZERO, 1
209:                                 chanAlloc               = true;
210:                                 break;
9D013C04  03E00008   JR RA
9D013C08  A0430000   SB V1, 0(V0)
211:                             }
212:                 
213:                         }
214:                         /* Check the next channel object */
215:                         chanObj += 1;
216:                     }
217:                     if(true == chanAlloc )
218:                     {
219:                         /* Return the valid found handle */
220:                         channelHandle  = (SYS_DMA_CHANNEL_HANDLE)chanObj;
221:                     }
222:                     else
223:                     {
224:                         /* Return an Invalid handle */
225:                         channelHandle = SYS_DMA_CHANNEL_HANDLE_INVALID;
226:                     }
227:                     return channelHandle;
228:                 }
9D013C14  03E00008   JR RA
9D013C18  2402FFFF   ADDIU V0, ZERO, -1
229:                 
230:                 
231:                 //******************************************************************************
232:                 /* Function:
233:                     void SYS_DMA_ChannelRelease(SYS_DMA_CHANNEL_HANDLE handle)
234:                 
235:                   Summary:
236:                     Deallocates and frees the channel specified by the handle.
237:                 
238:                   Description:
239:                     This routine deallocates an allocated-channel of the DMA module,
240:                     invalidating the handle.
241:                 
242:                   Remarks:
243:                     After calling this routine, the handle passed in "handle" must not be used
244:                     with any of the remaining service's routines.  A new handle must be obtained by
245:                     calling SYS_DMA_ChannelAllocate before the caller may use the service again
246:                 */
247:                  void SYS_DMA_ChannelRelease (SYS_DMA_CHANNEL_HANDLE handle)
248:                  {
9D00CE24  27BDFFF0   ADDIU SP, SP, -16
9D00CE28  AFB3000C   SW S3, 12(SP)
9D00CE2C  AFB20008   SW S2, 8(SP)
9D00CE30  AFB10004   SW S1, 4(SP)
9D00CE34  AFB00000   SW S0, 0(SP)
249:                     uint8_t index;
250:                     SYS_DMA_CHANNEL_OBJECT *chanObj;
251:                     DMA_CHANNEL channelNumber;
252:                 
253:                     chanObj = (SYS_DMA_CHANNEL_OBJECT *) handle;
254:                     channelNumber = (chanObj  - (SYS_DMA_CHANNEL_OBJECT *) &gSysDMAChannelObj[0]);
9D00CE3C  3C02A000   LUI V0, -24576
9D00CE40  24420C9C   ADDIU V0, V0, 3228
9D00CE44  00822023   SUBU A0, A0, V0
9D00CE48  00042103   SRA A0, A0, 4
255:                     chanObj->inUse = false;
9D00CE38  A0800000   SB ZERO, 0(A0)
256:                     /* Disable all interrupts on this channel */
257:                     for(index = 0; index < 8 ;index++)
9D00CF70  1464FFCE   BNE V1, A0, SYS_DMA_ChannelRelease::PLIB_DMA_ChannelXINTSourceDisable
9D00CF74  00661004   SLLV V0, A2, V1
258:                     {
259:                         PLIB_DMA_ChannelXINTSourceDisable( DMA_ID_0, channelNumber, (1<<index));
9D00CE68  24060001   ADDIU A2, ZERO, 1
9D00CEA8  00661004   SLLV V0, A2, V1
260:                     }
261:                     return;
262:                  }
9D00CF78  8FB3000C   LW S3, 12(SP)
9D00CF7C  8FB20008   LW S2, 8(SP)
9D00CF80  8FB10004   LW S1, 4(SP)
9D00CF84  8FB00000   LW S0, 0(SP)
9D00CF88  03E00008   JR RA
9D00CF8C  27BD0010   ADDIU SP, SP, 16
263:                 
264:                 
265:                 //******************************************************************************
266:                 /* Function:
267:                     void SYS_DMA_ChannelSetup
268:                     (
269:                         SYS_DMA_CHANNEL_HANDLE handle,
270:                         SYS_DMA_CHANNEL_OP_MODE modeEnable,
271:                         DMA_TRIGGER_SOURCE eventSrc
272:                     )
273:                 
274:                   Summary:
275:                     Setup the DMA channel parameters.
276:                 
277:                   Description:
278:                     This function sets up the DMA channel parameters.
279:                     It sets the channel priority and enables the mode of operations for the
280:                     current system design.
281:                 
282:                   Remarks:
283:                     If SYS_DMA_CHANNEL_OP_MODE_MATCH_ABORT or
284:                     SYS_DMA_CHANNEL_OP_MODE_CRC mode of operation is enabled, then corresponding
285:                     mode setup API's needs to be called to set the related parameters.
286:                 
287:                     If the parameter 'eventSrc' is specified as DMA_TRIGGER_SOURCE_NONE then
288:                     SYS_DMA_ChannelForceStart must be called to start the DMA channel transfer.
289:                 
290:                     Not all features are available on all micro-controllers.
291:                   */
292:                 
293:                 void SYS_DMA_ChannelSetup
294:                 (
295:                     SYS_DMA_CHANNEL_HANDLE handle,
296:                     SYS_DMA_CHANNEL_OP_MODE modeEnable,
297:                     DMA_TRIGGER_SOURCE eventSrc
298:                 )
299:                 {
300:                 
301:                     SYS_DMA_CHANNEL_OBJECT *chanObj;
302:                     DMA_CHANNEL channelNumber;
303:                 
304:                     chanObj = (SYS_DMA_CHANNEL_OBJECT *) handle;
305:                     channelNumber = (chanObj  - (SYS_DMA_CHANNEL_OBJECT *) &gSysDMAChannelObj[0]);
9D00CF90  3C02A000   LUI V0, -24576
9D00CF94  24420C9C   ADDIU V0, V0, 3228
9D00CF98  00822023   SUBU A0, A0, V0
306:                 
307:                     /* Setup the channel modes */
308:                     /* Basic mode, nothing specifically needs to be set */
309:                     if(SYS_DMA_CHANNEL_OP_MODE_BASIC & modeEnable)
310:                     {
311:                         /* Do nothing */
312:                         ;
313:                     }
314:                 
315:                     /* Pattern match Abort */
316:                     if(SYS_DMA_CHANNEL_OP_MODE_MATCH_ABORT & modeEnable)
9D00CF9C  30A20002   ANDI V0, A1, 2
9D00CFA0  10400009   BEQ V0, ZERO, 0x9D00CFC8
9D00CFA4  00042103   SRA A0, A0, 4
317:                     {
318:                         PLIB_DMA_ChannelXTriggerEnable( DMA_ID_0, channelNumber,
319:                                                         DMA_CHANNEL_TRIGGER_PATTERN_MATCH_ABORT);
320:                     }
321:                 
322:                     /* Channel chaining mode */
323:                     if(SYS_DMA_CHANNEL_OP_MODE_CHAIN_HIGH & modeEnable)
9D00CFC8  30A20004   ANDI V0, A1, 4
9D00CFCC  5040000F   BEQL V0, ZERO, 0x9D00D00C
9D00CFD0  30A20008   ANDI V0, A1, 8
324:                     {
325:                         PLIB_DMA_ChannelXChainEnable( DMA_ID_0, channelNumber);
326:                         PLIB_DMA_ChannelXChainToHigher(DMA_ID_0, channelNumber);
327:                         PLIB_DMA_ChannelXDisabledEnablesEvents(DMA_ID_0, channelNumber);
328:                     }
329:                     else if(SYS_DMA_CHANNEL_OP_MODE_CHAIN_LOW & modeEnable)
9D00D00C  1040000E   BEQ V0, ZERO, 0x9D00D048
9D00D010  30A20010   ANDI V0, A1, 16
330:                     {
331:                         PLIB_DMA_ChannelXChainEnable( DMA_ID_0, channelNumber);
332:                         PLIB_DMA_ChannelXChainToLower(DMA_ID_0, channelNumber);
333:                         PLIB_DMA_ChannelXDisabledEnablesEvents(DMA_ID_0, channelNumber);
334:                     }
335:                     else
336:                     {
337:                         ;
338:                     }
339:                 
340:                     /* Auto Enable mode */
341:                     if(SYS_DMA_CHANNEL_OP_MODE_AUTO & modeEnable)
9D00D004  0B403412   J 0x9D00D048
9D00D008  30A20010   ANDI V0, A1, 16
9D00D044  30A20010   ANDI V0, A1, 16
9D00D048  5040000A   BEQL V0, ZERO, 0x9D00D074
9D00D04C  30A50020   ANDI A1, A1, 32
342:                     {
343:                         PLIB_DMA_ChannelXAutoEnable( DMA_ID_0, channelNumber);
344:                     }
345:                 
346:                     /* CRC Enable */
347:                     if(SYS_DMA_CHANNEL_OP_MODE_CRC & modeEnable)
9D00D070  30A50020   ANDI A1, A1, 32
9D00D074  10A00005   BEQ A1, ZERO, 0x9D00D08C
9D00D078  2402FFFF   ADDIU V0, ZERO, -1
348:                     {
349:                             PLIB_DMA_CRCEnable( DMA_ID_0);
350:                     }
351:                 
352:                 
353:                     /* Setup the DMA Trigger Source and Enable it */
354:                     if(DMA_TRIGGER_SOURCE_NONE == eventSrc)
9D00D088  2402FFFF   ADDIU V0, ZERO, -1
9D00D08C  14C2000C   BNE A2, V0, SYS_DMA_ChannelSetup::PLIB_DMA_ChannelXStartIRQSet
9D00D090  00041180   SLL V0, A0, 6
9D00D094  00042200   SLL A0, A0, 8
9D00D098  00822023   SUBU A0, A0, V0
9D00D09C  3C02BF88   LUI V0, -16504
9D00D0A0  24423060   ADDIU V0, V0, 12384
9D00D0A4  00822021   ADDU A0, A0, V0
9D00D0A8  3C020008   LUI V0, 8
9D00D0AC  AC820028   SW V0, 40(A0)
9D00D0B0  3C020001   LUI V0, 1
9D00D0B4  AC820028   SW V0, 40(A0)
9D00D0B8  03E00008   JR RA
9D00D0BC  00000000   NOP
9D00D0C0  00042200   SLL A0, A0, 8
9D00D0C4  00822023   SUBU A0, A0, V0
9D00D0C8  3C02BF88   LUI V0, -16504
9D00D0CC  24423060   ADDIU V0, V0, 12384
9D00D0D0  00822021   ADDU A0, A0, V0
9D00D0D4  30C600FF   ANDI A2, A2, 255
9D00D0D8  A0860011   SB A2, 17(A0)
9D00D0DC  24020010   ADDIU V0, ZERO, 16
9D00D0E0  AC820018   SW V0, 24(A0)
9D00D0E4  3C020008   LUI V0, 8
9D00D0E8  AC820028   SW V0, 40(A0)
9D00D0EC  3C020001   LUI V0, 1
9D00D0F0  AC820028   SW V0, 40(A0)
9D00D0F4  03E00008   JR RA
9D00D0F8  00000000   NOP
355:                     {
356:                         /* This is polling mode of Implementation */
357:                         PLIB_DMA_ChannelXINTSourceEnable(DMA_ID_0, channelNumber,
358:                                                             DMA_INT_BLOCK_TRANSFER_COMPLETE);
359:                         PLIB_DMA_ChannelXINTSourceEnable(DMA_ID_0, channelNumber,
360:                                                             DMA_INT_ADDRESS_ERROR);
361:                     }
362:                     else
363:                     {
364:                         PLIB_DMA_ChannelXStartIRQSet( DMA_ID_0, channelNumber, eventSrc);
365:                         PLIB_DMA_ChannelXTriggerEnable( DMA_ID_0, channelNumber, DMA_CHANNEL_TRIGGER_TRANSFER_START);
366:                 
367:                         /* We need to notify the user on the completion of a transfer request.
368:                          * Setting the DMA block completion transfer interrupt. */
369:                         PLIB_DMA_ChannelXINTSourceEnable(DMA_ID_0, channelNumber,
370:                                                                 DMA_INT_BLOCK_TRANSFER_COMPLETE);
371:                         PLIB_DMA_ChannelXINTSourceEnable(DMA_ID_0, channelNumber,
372:                                                             DMA_INT_ADDRESS_ERROR);
373:                     }
374:                     return;
375:                 }
376:                 
377:                 
378:                 //******************************************************************************
379:                 /* Function:
380:                     void SYS_DMA_ChannelSetupMatchAbortMode
381:                     (
382:                         SYS_DMA_CHANNEL_HANDLE handle,
383:                         uint16_t pattern,
384:                         DMA_PATTERN_LENGTH length,
385:                         SYS_DMA_CHANNEL_IGNORE_MATCH ignore,
386:                         uint8_t ignorePattern
387:                     )
388:                 
389:                   Summary:
390:                     Setup the pattern match abort mode.
391:                 
392:                   Description:
393:                     This  function sets up the termination of DMA operation when the specified
394:                     pattern is matched. Additionally on supported parts the function also
395:                     sets up the ignoring of part of a pattern(8-bit) from match abort
396:                     pattern(16-bit).
397:                 
398:                 
399:                   Remarks:
400:                     The parameter 'pattern' (8-bit or 16-bit) is part specific.
401:                     (Refer the particular datasheet for details)
402:                 
403:                     Not all features are available on all micro-controllers.
404:                     Refer the particular datasheet for details)
405:                 */
406:                 
407:                 void SYS_DMA_ChannelSetupMatchAbortMode
408:                 (
409:                     SYS_DMA_CHANNEL_HANDLE handle,
410:                     uint16_t pattern,
411:                     DMA_PATTERN_LENGTH length,
412:                     SYS_DMA_CHANNEL_IGNORE_MATCH ignore,
413:                     uint8_t ignorePattern
414:                 )
415:                 {
416:                     SYS_DMA_CHANNEL_OBJECT *chanObj;
417:                     DMA_CHANNEL channelNumber;
418:                 
419:                     chanObj = (SYS_DMA_CHANNEL_OBJECT *) handle;
420:                     channelNumber = (chanObj  - (SYS_DMA_CHANNEL_OBJECT *) &gSysDMAChannelObj[0]);
421:                 
422:                 #if defined(PLIB_DMA_ExistsChannelXPatternLength)
423:                     if(true == PLIB_DMA_ExistsChannelXPatternLength(DMA_ID_0))
424:                     {
425:                         PLIB_DMA_ChannelXPatternLengthSet( DMA_ID_0, channelNumber, length );
426:                     }
427:                 #endif
428:                     PLIB_DMA_ChannelXPatternDataSet(DMA_ID_0, channelNumber, pattern);
429:                 
430:                 if(SYS_DMA_CHANNEL_IGNORE_MATCH_ENABLE == ignore)
431:                 {    
432:                     #if defined(PLIB_DMA_ExistsChannelXPatternIgnoreByte)    
433:                         if(true == PLIB_DMA_ExistsChannelXPatternIgnoreByte(DMA_ID_0))
434:                         {
435:                             PLIB_DMA_ChannelXPatternIgnoreByteEnable(DMA_ID_0, channelNumber);
436:                         }
437:                     #endif    
438:                 
439:                     #if defined(PLIB_DMA_ExistsChannelXPatternIgnore)    
440:                         if(true == PLIB_DMA_ExistsChannelXPatternIgnore(DMA_ID_0))
441:                         {
442:                             PLIB_DMA_ChannelXPatternIgnoreSet( DMA_ID_0, channelNumber, ignorePattern );
443:                         }
444:                     #endif
445:                 }
446:                     
447:                     return;
448:                 }
449:                 
450:                 
451:                 //******************************************************************************
452:                 /* Function:
453:                     void SYS_DMA_ChannelCRCSet
454:                     (
455:                         SYS_DMA_CHANNEL_HANDLE handle,
456:                         SYS_DMA_CHANNEL_OPERATION_MODE_CRC crc
457:                     )
458:                 
459:                   Summary:
460:                     Sets up the CRC operation mode
461:                 
462:                   Description:
463:                     This function sets up the CRC computation features.
464:                 
465:                   Remarks:
466:                     Not all features are available on all micro-controllers.
467:                 */
468:                 
469:                 void SYS_DMA_ChannelCRCSet
470:                 (
471:                     SYS_DMA_CHANNEL_HANDLE handle,
472:                     SYS_DMA_CHANNEL_OPERATION_MODE_CRC crc
473:                 )
474:                 {
475:                     SYS_DMA_CHANNEL_OBJECT *chanObj;
476:                     DMA_CHANNEL channelNumber;
477:                 
478:                     chanObj = (SYS_DMA_CHANNEL_OBJECT *) handle;
479:                     channelNumber = (chanObj  - (SYS_DMA_CHANNEL_OBJECT *) &gSysDMAChannelObj[0]);
480:                 
481:                 #if defined (PLIB_DMA_ExistsCRCChannel)
482:                     if(true == PLIB_DMA_ExistsCRCChannel(DMA_ID_0))
483:                     {
484:                         PLIB_DMA_CRCChannelSelect(DMA_ID_0, channelNumber);
485:                     }
486:                 #endif
487:                 
488:                 #if defined (PLIB_DMA_ExistsCRCType)
489:                     if(true == PLIB_DMA_ExistsCRCType(DMA_ID_0))
490:                     {
491:                         PLIB_DMA_CRCTypeSet(DMA_ID_0, crc.type);
492:                     }
493:                 #endif
494:                 
495:                     PLIB_DMA_CRCPolynomialLengthSet(DMA_ID_0, (crc.polyLength-1));
496:                     
497:                 #if defined (PLIB_DMA_ExistsCRCBitOrder)
498:                     if(true == PLIB_DMA_ExistsCRCBitOrder(DMA_ID_0))
499:                     {
500:                         PLIB_DMA_CRCBitOrderSelect(DMA_ID_0, crc.bitOrder);
501:                     }
502:                 #endif
503:                     
504:                 #if defined (PLIB_DMA_ExistsCRCByteOrder)
505:                     if(true == PLIB_DMA_ExistsCRCByteOrder(DMA_ID_0))
506:                     {
507:                         PLIB_DMA_CRCByteOrderSelect(DMA_ID_0, crc.byteOrder);
508:                     }
509:                 #endif
510:                 
511:                 #if defined (PLIB_DMA_ExistsCRCWriteByteOrder)
512:                     if(true == PLIB_DMA_ExistsCRCWriteByteOrder(DMA_ID_0))
513:                     {
514:                         if(SYS_DMA_CRC_WRITE_ORDER_MAINTAIN == crc.writeOrder)
515:                         {
516:                             PLIB_DMA_CRCWriteByteOrderMaintain(DMA_ID_0);
517:                         }
518:                         else if(SYS_DMA_CRC_WRITE_ORDER_CHANGE == crc.writeOrder)
519:                         {
520:                             PLIB_DMA_CRCWriteByteOrderAlter(DMA_ID_0);
521:                         }
522:                         else
523:                         {
524:                         }
525:                     }
526:                 #endif
527:                 
528:                 #if defined (PLIB_DMA_ExistsCRCData)
529:                     if(true == PLIB_DMA_ExistsCRCData(DMA_ID_0))
530:                     {
531:                         PLIB_DMA_CRCDataWrite(DMA_ID_0, crc.data);
532:                     }
533:                 #endif
534:                 
535:                 #if defined (PLIB_DMA_ExistsCRCXOREnable)
536:                     if(true == PLIB_DMA_ExistsCRCXOREnable(DMA_ID_0))
537:                     {
538:                         PLIB_DMA_CRCXOREnableSet(DMA_ID_0, crc.xorBitMask);
539:                     }
540:                 #endif
541:                 
542:                     if(SYS_DMA_CHANNEL_CRC_MODE_APPEND == crc.mode)
543:                     {
544:                         PLIB_DMA_CRCAppendModeEnable(DMA_ID_0);
545:                     }
546:                         return;
547:                 }
548:                 
549:                 
550:                 //******************************************************************************
551:                 /* Function:
552:                     uint32_t SYS_DMA_ChannelCRCGet(void)
553:                 
554:                   Summary:
555:                     Returns the computed CRC
556:                 
557:                   Description:
558:                     This  function returns the computed CRC
559:                 
560:                   Remarks:
561:                     To get the computed CRC value this function must be called after the block
562:                     transfer completion event. ie After getting and processing the callback
563:                     registered with SYS_DMA_ChannelTransferEventHandlerSet.
564:                 
565:                     Not all features are available on all micro-controllers.
566:                 */
567:                 
568:                 uint32_t SYS_DMA_ChannelCRCGet(void)
569:                 {
570:                     uint32_t crcData = 0;
571:                 
572:                 #if defined (PLIB_DMA_ExistsCRCData)
573:                     if(true == PLIB_DMA_ExistsCRCData(DMA_ID_0))
574:                     {
575:                         crcData = PLIB_DMA_CRCDataRead(DMA_ID_0);
576:                     }
577:                 #endif
578:                     return crcData;
579:                 }
580:                 
581:                 
582:                 //******************************************************************************
583:                 /* Function:
584:                     void SYS_DMA_ChannelEnable(SYS_DMA_CHANNEL_HANDLE handle)
585:                 
586:                   Summary:
587:                     Enables a channel.
588:                 
589:                   Description:
590:                     This function enables a channel.
591:                 
592:                   Remarks:
593:                         This function may not required to be called when starting DMA setup
594:                         (by SYS_DMA_ChannelSetup) and transfer Add (by SYS_DMA_ChannelTransferAdd).
595:                         But may be needed to be called in the registered callback to enable the
596:                         channel and continue the data transfer with the existing transfer parameters
597:                         previously set with 'SYS_DMA_ChannelTransferAdd'.
598:                         The DMA channel is by default disabled on the completion of block
599:                         transfer(callback generated)
600:                 */
601:                 
602:                 void SYS_DMA_ChannelEnable(SYS_DMA_CHANNEL_HANDLE handle)
603:                 {
604:                     SYS_DMA_CHANNEL_OBJECT *chanObj;
605:                     DMA_CHANNEL channelNumber;
606:                 
607:                     chanObj = (SYS_DMA_CHANNEL_OBJECT *) handle;
608:                     channelNumber = (chanObj  - (SYS_DMA_CHANNEL_OBJECT *) &gSysDMAChannelObj[0]);
9D014C74  3C02A000   LUI V0, -24576
9D014C78  24420C9C   ADDIU V0, V0, 3228
9D014C7C  00822023   SUBU A0, A0, V0
9D014C80  00042103   SRA A0, A0, 4
9D014C84  00041180   SLL V0, A0, 6
9D014C88  00042200   SLL A0, A0, 8
9D014C8C  00822023   SUBU A0, A0, V0
9D014C90  3C02BF88   LUI V0, -16504
9D014C94  24423060   ADDIU V0, V0, 12384
9D014C98  00822021   ADDU A0, A0, V0
9D014C9C  24020080   ADDIU V0, ZERO, 128
9D014CA0  AC820008   SW V0, 8(A0)
9D014CA4  03E00008   JR RA
9D014CA8  00000000   NOP
609:                 
610:                     PLIB_DMA_ChannelXEnable(DMA_ID_0, channelNumber);
611:                 
612:                     return;
613:                 }
614:                 
615:                 
616:                 //******************************************************************************
617:                 /* Function:
618:                     void SYS_DMA_ChannelDisable(SYS_DMA_CHANNEL_HANDLE handle)
619:                 
620:                   Summary:
621:                     Disables a channel.
622:                 
623:                   Description:
624:                     This function disables a channel.
625:                 
626:                   Remarks:
627:                     None.
628:                 */
629:                 
630:                 void SYS_DMA_ChannelDisable(SYS_DMA_CHANNEL_HANDLE handle)
631:                 {
632:                     SYS_DMA_CHANNEL_OBJECT *chanObj;
633:                     DMA_CHANNEL channelNumber;
634:                 
635:                     chanObj = (SYS_DMA_CHANNEL_OBJECT *) handle;
636:                     channelNumber = (chanObj  - (SYS_DMA_CHANNEL_OBJECT *) &gSysDMAChannelObj[0]);
9D014CAC  3C02A000   LUI V0, -24576
9D014CB0  24420C9C   ADDIU V0, V0, 3228
9D014CB4  00822023   SUBU A0, A0, V0
9D014CB8  00042103   SRA A0, A0, 4
9D014CBC  00041180   SLL V0, A0, 6
9D014CC0  00042200   SLL A0, A0, 8
9D014CC4  00822023   SUBU A0, A0, V0
9D014CC8  3C02BF88   LUI V0, -16504
9D014CCC  24423060   ADDIU V0, V0, 12384
9D014CD0  00822021   ADDU A0, A0, V0
9D014CD4  24020080   ADDIU V0, ZERO, 128
9D014CD8  AC820004   SW V0, 4(A0)
9D014CDC  03E00008   JR RA
9D014CE0  00000000   NOP
637:                 
638:                     PLIB_DMA_ChannelXDisable(DMA_ID_0, channelNumber);
639:                 
640:                     return;
641:                 }
642:                 
643:                 
644:                 //******************************************************************************
645:                 /* Function:
646:                     void SYS_DMA_ChannelTransferAdd
647:                     (
648:                         SYS_DMA_CHANNEL_HANDLE handle,
649:                         const void *srcAddr, size_t srcSize
650:                         const void *destAddr, size_t destSize,
651:                         size_t cellSize
652:                     )
653:                 
654:                   Summary:
655:                     Adds a data transfer to a DMA channel and Enables the channel to start
656:                     data transfer.
657:                 
658:                   Description:
659:                     This function adds a data transfer characteristics for a DMA channel. The
660:                     The source and the destination addresses, source and destination lengths,
661:                     The number of bytes transferred per cell event are set. It also enables
662:                     the channel to start data transfer.
663:                 
664:                     If the requesting client registered an event callback with the service,
665:                     the service will issue a SYS_DMA_TRANSFER_EVENT_COMPLETE or
666:                     SYS_DMA_TRANSFER_EVENT_ABORT  event if the transfered was processed
667:                     successfully of SYS_DMA_TRANSFER_EVENT_ERROR event if the transfer was not
668:                     processed successfully.
669:                 
670:                   Remarks:
671:                     None.
672:                 */
673:                 void SYS_DMA_ChannelTransferAdd
674:                 (
675:                     SYS_DMA_CHANNEL_HANDLE handle,
676:                     const void *srcAddr, size_t srcSize,
677:                     const void *destAddr, size_t destSize,
678:                     size_t cellSize
679:                 )
680:                 {
681:                     SYS_DMA_CHANNEL_OBJECT *chanObj;
682:                     DMA_CHANNEL channelNumber;
683:                 
684:                     chanObj = (SYS_DMA_CHANNEL_OBJECT *) handle;
685:                     channelNumber = (chanObj  - (SYS_DMA_CHANNEL_OBJECT *) &gSysDMAChannelObj[0]);
9D00D690  3C02A000   LUI V0, -24576
9D00D694  24420C9C   ADDIU V0, V0, 3228
9D00D698  00822023   SUBU A0, A0, V0
9D00D69C  00042103   SRA A0, A0, 4
9D00D6A0  00044180   SLL T0, A0, 6
9D00D6A4  00041200   SLL V0, A0, 8
9D00D6A8  00481023   SUBU V0, V0, T0
9D00D6AC  3C08BF88   LUI T0, -16504
9D00D6B0  25083060   ADDIU T0, T0, 12384
9D00D6B4  00481021   ADDU V0, V0, T0
9D00D6B8  00052742   SRL A0, A1, 29
9D00D6BC  24080006   ADDIU T0, ZERO, 6
9D00D6C0  1488000E   BNE A0, T0, SYS_DMA_ChannelTransferAdd::PLIB_DMA_ChannelXSourceStartAddressSet
9D00D6C4  00A01821   ADDU V1, A1, ZERO
9D00D6C8  00052702   SRL A0, A1, 28
9D00D6CC  2408000C   ADDIU T0, ZERO, 12
9D00D6D0  14880005   BNE A0, T0, SYS_DMA_ChannelTransferAdd::PLIB_DMA_ChannelXSourceStartAddressSet
9D00D6D4  2408000D   ADDIU T0, ZERO, 13
9D00D6D8  7CA5D800   EXT A1, A1, 0, 28
9D00D6DC  3C032000   LUI V1, 8192
9D00D6E0  0B4035CE   J 0x9D00D738
9D00D6E4  00A31825   OR V1, A1, V1
9D00D6E8  14880013   BNE A0, T0, 0x9D00D738
9D00D6EC  7CA5D800   EXT A1, A1, 0, 28
9D00D6F0  3C033000   LUI V1, 12288
9D00D6F4  0B4035CE   J 0x9D00D738
9D00D6F8  00A31825   OR V1, A1, V1
9D00D6FC  24080007   ADDIU T0, ZERO, 7
9D00D700  5488000D   BNEL A0, T0, 0x9D00D738
9D00D704  7CA3E000   EXT V1, A1, 0, 29
9D00D708  00052702   SRL A0, A1, 28
9D00D70C  2408000E   ADDIU T0, ZERO, 14
9D00D710  14880005   BNE A0, T0, SYS_DMA_ChannelTransferAdd::PLIB_DMA_ChannelXSourceStartAddressSet
9D00D714  2408000F   ADDIU T0, ZERO, 15
9D00D718  7CA5D800   EXT A1, A1, 0, 28
9D00D71C  3C032000   LUI V1, 8192
9D00D720  0B4035CE   J 0x9D00D738
9D00D724  00A31825   OR V1, A1, V1
9D00D728  14880003   BNE A0, T0, 0x9D00D738
9D00D72C  7CA5D800   EXT A1, A1, 0, 28
9D00D730  3C033000   LUI V1, 12288
9D00D734  00A31825   OR V1, A1, V1
9D00D738  AC430030   SW V1, 48(V0)
9D00D73C  30C6FFFF   ANDI A2, A2, -1
9D00D740  AC460050   SW A2, 80(V0)
9D00D744  00072742   SRL A0, A3, 29
9D00D748  24050006   ADDIU A1, ZERO, 6
9D00D74C  1485000E   BNE A0, A1, SYS_DMA_ChannelTransferAdd::PLIB_DMA_ChannelXDestinationStartAddressSet
9D00D750  00E01821   ADDU V1, A3, ZERO
9D00D754  00072702   SRL A0, A3, 28
9D00D758  2405000C   ADDIU A1, ZERO, 12
9D00D75C  14850005   BNE A0, A1, SYS_DMA_ChannelTransferAdd::PLIB_DMA_ChannelXDestinationStartAddressSet
9D00D760  2405000D   ADDIU A1, ZERO, 13
9D00D764  7CE7D800   EXT A3, A3, 0, 28
9D00D768  3C032000   LUI V1, 8192
9D00D76C  0B4035F2   J 0x9D00D7C8
9D00D770  00E31825   OR V1, A3, V1
9D00D774  14850014   BNE A0, A1, 0x9D00D7C8
9D00D778  7CE7D800   EXT A3, A3, 0, 28
9D00D77C  3C033000   LUI V1, 12288
9D00D780  0B4035F2   J 0x9D00D7C8
9D00D784  00E31825   OR V1, A3, V1
9D00D788  24050007   ADDIU A1, ZERO, 7
9D00D78C  5485000E   BNEL A0, A1, 0x9D00D7C8
9D00D790  7CE3E000   EXT V1, A3, 0, 29
9D00D794  00072702   SRL A0, A3, 28
9D00D798  2405000E   ADDIU A1, ZERO, 14
9D00D79C  14850005   BNE A0, A1, SYS_DMA_ChannelTransferAdd::PLIB_DMA_ChannelXDestinationStartAddressSet
9D00D7A0  2405000F   ADDIU A1, ZERO, 15
9D00D7A4  7CE7D800   EXT A3, A3, 0, 28
9D00D7A8  3C032000   LUI V1, 8192
9D00D7AC  0B4035F2   J 0x9D00D7C8
9D00D7B0  00E31825   OR V1, A3, V1
9D00D7B4  14850004   BNE A0, A1, 0x9D00D7C8
9D00D7B8  00000000   NOP
9D00D7BC  7CE7D800   EXT A3, A3, 0, 28
9D00D7C0  3C033000   LUI V1, 12288
9D00D7C4  00E31825   OR V1, A3, V1
9D00D7C8  AC430040   SW V1, 64(V0)
9D00D7CC  97A30010   LHU V1, 16(SP)
9D00D7D0  AC430060   SW V1, 96(V0)
9D00D7D4  97A30014   LHU V1, 20(SP)
9D00D7D8  AC430090   SW V1, 144(V0)
9D00D7DC  24030080   ADDIU V1, ZERO, 128
9D00D7E0  AC430008   SW V1, 8(V0)
9D00D7E4  03E00008   JR RA
9D00D7E8  00000000   NOP
686:                 
687:                     /* Set the transfer paramteters */
688:                     PLIB_DMA_ChannelXSourceStartAddressSet(DMA_ID_0, channelNumber, (uint32_t) srcAddr);
689:                     PLIB_DMA_ChannelXSourceSizeSet(DMA_ID_0, channelNumber, (uint16_t) srcSize);
690:                     PLIB_DMA_ChannelXDestinationStartAddressSet(DMA_ID_0, channelNumber,(uint32_t) destAddr);
691:                     PLIB_DMA_ChannelXDestinationSizeSet(DMA_ID_0, channelNumber, (uint16_t) destSize);
692:                     PLIB_DMA_ChannelXCellSizeSet(DMA_ID_0, channelNumber,(uint16_t) cellSize);
693:                 
694:                     /* Enable the channel */
695:                     PLIB_DMA_ChannelXEnable(DMA_ID_0, channelNumber);
696:                     return;
697:                 }
698:                 
699:                 //******************************************************************************
700:                 /* Function:
701:                     void SYS_DMA_ChannelTransferSet
702:                     (
703:                         SYS_DMA_CHANNEL_HANDLE handle,
704:                         const void *srcAddr, size_t srcSize
705:                         const void *destAddr, size_t destSize,
706:                         size_t cellSize
707:                     )
708:                 
709:                   Summary:
710:                     Sets up a data transfer to a DMA channel.
711:                 
712:                   Description:
713:                     This function sets up data transfer characteristics for a DMA channel. The
714:                     The source and the destination addresses, source and destination lengths,
715:                     The number of bytes transferred per cell event are set.
716:                     This function does not enables the DMA channel. The channel has to be explicitly
717:                     enabled to start the data transfer.
718:                     The above functions could be used in situations where in the user intends to
719:                     setup transfer parameters but do not intend to enable the channel immediately.
720:                     For example to chain to DMA channels in a cyclic order where the channels remains
721:                     disabled. The channel is enabled automatically by the DMA when the transfer trigger
722:                     condition occurs.
723:                 
724:                   Remarks:
725:                     None.
726:                 */
727:                 void SYS_DMA_ChannelTransferSet
728:                 (
729:                     SYS_DMA_CHANNEL_HANDLE handle,
730:                     const void *srcAddr, size_t srcSize,
731:                     const void *destAddr, size_t destSize,
732:                     size_t cellSize
733:                 )
734:                 {
735:                     SYS_DMA_CHANNEL_OBJECT *chanObj;
736:                     DMA_CHANNEL channelNumber;
737:                 
738:                     chanObj = (SYS_DMA_CHANNEL_OBJECT *) handle;
739:                     channelNumber = (chanObj  - (SYS_DMA_CHANNEL_OBJECT *) &gSysDMAChannelObj[0]);
740:                 
741:                     /* Set the transfer parameters */
742:                     PLIB_DMA_ChannelXSourceStartAddressSet(DMA_ID_0, channelNumber, (uint32_t) srcAddr);
743:                     PLIB_DMA_ChannelXSourceSizeSet(DMA_ID_0, channelNumber, (uint16_t) srcSize);
744:                     PLIB_DMA_ChannelXDestinationStartAddressSet(DMA_ID_0, channelNumber,(uint32_t) destAddr);
745:                     PLIB_DMA_ChannelXDestinationSizeSet(DMA_ID_0, channelNumber, (uint16_t) destSize);
746:                     PLIB_DMA_ChannelXCellSizeSet(DMA_ID_0, channelNumber,(uint16_t) cellSize);
747:                 
748:                     return;
749:                 }
750:                 
751:                 //******************************************************************************
752:                 /* Function:
753:                     size_t SYS_DMA_ChannelSourceTransferredSizeGet(SYS_DMA_CHANNEL_HANDLE handle)
754:                 
755:                   Summary:
756:                     Returns the number of bytes transferred from source.
757:                 
758:                   Description:
759:                     When a data transfer request is submitted. At any time while the transmission
760:                     is in progress the size of the amount of data transferred from source
761:                     can be known by calling this function.
762:                 
763:                   Remarks:
764:                     None.
765:                 */
766:                 size_t SYS_DMA_ChannelSourceTransferredSizeGet(SYS_DMA_CHANNEL_HANDLE handle)
767:                 {
768:                     SYS_DMA_CHANNEL_OBJECT *chanObj;
769:                     DMA_CHANNEL channelNumber;
770:                 
771:                     chanObj = (SYS_DMA_CHANNEL_OBJECT *) handle;
772:                     channelNumber = (chanObj  - (SYS_DMA_CHANNEL_OBJECT *) &gSysDMAChannelObj[0]);
773:                     return (size_t) PLIB_DMA_ChannelXSourcePointerGet(DMA_ID_0,channelNumber);
774:                 }
775:                 
776:                 //******************************************************************************
777:                 /* Function:
778:                     size_t SYS_DMA_ChannelDestinationTransferredSizeGet(SYS_DMA_CHANNEL_HANDLE handle)
779:                 
780:                   Summary:
781:                     Returns the number of bytes transferred to destination.
782:                 
783:                   Description:
784:                     When a data transfer request is submitted. At any time while the transmission
785:                     is in progress the size of the amount of data transferred to destination
786:                     can be known by calling this function.
787:                 
788:                   Remarks:
789:                     None.
790:                 */
791:                 size_t SYS_DMA_ChannelDestinationTransferredSizeGet(SYS_DMA_CHANNEL_HANDLE handle)
792:                 {
793:                     SYS_DMA_CHANNEL_OBJECT *chanObj;
794:                     DMA_CHANNEL channelNumber;
795:                 
796:                     chanObj = (SYS_DMA_CHANNEL_OBJECT *) handle;
797:                     channelNumber = (chanObj  - (SYS_DMA_CHANNEL_OBJECT *) &gSysDMAChannelObj[0]);
798:                     return (size_t) PLIB_DMA_ChannelXDestinationPointerGet(DMA_ID_0,channelNumber);
799:                 }
800:                 
801:                 /******************************************************************************
802:                   Function:
803:                     void SYS_DMA_ChannelTransferEventHandlerSet
804:                     (
805:                         SYS_DMA_CHANNEL_HANDLE handle,
806:                         const SYS_DMA_CHANNEL_TRANSFER_EVENT_HANDLER eventHandler,
807:                         const uintptr_t contextHandle
808:                     )
809:                 
810:                   Summary:
811:                     This function allows a DMA system service client to set an event handler.
812:                 
813:                   Description:
814:                     This function allows a client to set an event handler. The client may want
815:                     to receive transfer related events in cases when it uses non-blocking read and
816:                     write functions. The event handler should be set before the client
817:                     intends to perform operations that could generate events.
818:                 
819:                     This function accepts a contextHandle parameter. This parameter could be
820:                     set by the client to contain (or point to) any client specific data object
821:                     that should be associated with this DMA channel.
822:                 
823:                   Remarks:
824:                     None.
825:                  */
826:                 void SYS_DMA_ChannelTransferEventHandlerSet
827:                 (
828:                     SYS_DMA_CHANNEL_HANDLE handle,
829:                     const SYS_DMA_CHANNEL_TRANSFER_EVENT_HANDLER eventHandler,
830:                     const uintptr_t contextHandle
831:                 )
832:                 {
833:                     SYS_DMA_CHANNEL_OBJECT *chanObj;
834:                     chanObj = (SYS_DMA_CHANNEL_OBJECT *)handle;
835:                 
836:                     if (chanObj == (SYS_DMA_CHANNEL_OBJECT *) NULL ||
9D015544  10800005   BEQ A0, ZERO, 0x9D01555C
9D015548  00000000   NOP
9D01554C  10A00003   BEQ A1, ZERO, 0x9D01555C
9D015550  00000000   NOP
837:                         eventHandler == (SYS_DMA_CHANNEL_TRANSFER_EVENT_HANDLER) NULL)
838:                     {
839:                         SYS_ASSERT(false, "Invalid handle");
840:                         return;
841:                     }
842:                     else
843:                     {
844:                         /* Set the Event Handler and context */
845:                         chanObj->pEventCallBack = eventHandler;
9D015554  AC850008   SW A1, 8(A0)
846:                         chanObj->hClientArg = contextHandle;
9D015558  AC86000C   SW A2, 12(A0)
9D01555C  03E00008   JR RA
9D015560  00000000   NOP
847:                     }
848:                     return;
849:                 }
850:                 
851:                 
852:                 /*******************************************************************************
853:                   Function:
854:                     void SYS_DMA_Tasks(SYS_MODULE_OBJ object );
855:                 
856:                   Summary:
857:                     Maintains the system service's state machine.
858:                 
859:                   Description:
860:                     This routine is used to maintain the DMA system service's internal state machine.
861:                     This function is specifically designed for non DMA interrupt trigger
862:                     implementations(polling mode), and should be used only in polling mode.
863:                     this function should be called from the SYS_Tasks() function.
864:                 
865:                   Remarks:
866:                     This routine is normally not called directly by an application.  It is
867:                     called by the system's Tasks routine (SYS_Tasks).
868:                  
869:                     This function is deprecated. Any calls made to this functions will have no effect.
870:                  */
871:                 
872:                 void SYS_DMA_Tasks(SYS_MODULE_OBJ object)
873:                 {
874:                     return;
875:                 }
876:                 
877:                 
878:                 /*******************************************************************************
879:                   Function:
880:                     void SYS_DMA_TasksISR(SYS_MODULE_OBJ object, DMA_CHANNEL activeChannel)
881:                 
882:                   Summary:
883:                     Maintains the system service's state machine and implements its ISR
884:                 
885:                   Description:
886:                     This routine is used to maintain the DMA system service's internal state machine
887:                     and implement its ISR for DMA interrupt trigger implementations(interrupt mode).
888:                     This function is specifically designed for DMA interrupt trigger
889:                     implementations (interrupt mode).
890:                     In interrupt mode, this function should be called in the interrupt
891:                     service routine of the DMA channel that is associated with this transfer.
892:                 
893:                   Remarks:
894:                     It is called by appropriate raw ISR.
895:                 
896:                     This routine may execute in an ISR context and will never block or access any
897:                     resources that may cause it to block.
898:                  */
899:                 void SYS_DMA_TasksISR(SYS_MODULE_OBJ object, DMA_CHANNEL activeChannel)
900:                 {
9D00FD04  27BDFFE8   ADDIU SP, SP, -24
9D00FD08  AFBF0014   SW RA, 20(SP)
901:                     SYS_DMA_CHANNEL_OBJECT *chanObj;
902:                     DMA_CHANNEL_INT_SOURCE chanIntSrc;
903:                 
904:                     /* Find out the interrupt source number for the active DMA channel */
905:                      chanIntSrc = PLIB_DMA_ChannelXTriggerSourceNumberGet(DMA_ID_0, activeChannel);
906:                 
907:                     /* Check whether the active DMA channel interrupt has occurred */
908:                    // if(true == SYS_INT_SourceStatusGet(chanIntSrc))
909:                    // {
910:                         if(true == PLIB_DMA_ChannelXINTSourceFlagGet(DMA_ID_0,activeChannel,
9D00FD30  10800017   BEQ A0, ZERO, SYS_DMA_TasksISR::PLIB_DMA_ChannelXINTSourceFlagGet
9D00FD34  24040008   ADDIU A0, ZERO, 8
911:                                         DMA_INT_BLOCK_TRANSFER_COMPLETE))
912:                         {
913:                             /* Channel is by default disabled on completion of a block transfer */
914:                 
915:                             /* Clear the Block transfer complete flag */
916:                             PLIB_DMA_ChannelXINTSourceFlagClear(DMA_ID_0,activeChannel,
917:                                      DMA_INT_BLOCK_TRANSFER_COMPLETE);
918:                 
919:                             SYS_INT_SourceStatusClear(chanIntSrc);
920:                 
921:                             /* Find out the channel object and give a callback */
922:                             chanObj = (SYS_DMA_CHANNEL_OBJECT *) &gSysDMAChannelObj[activeChannel];
9D00FD5C  00052900   SLL A1, A1, 4
9D00FD60  3C02A000   LUI V0, -24576
9D00FD64  24420C9C   ADDIU V0, V0, 3228
9D00FD68  00451021   ADDU V0, V0, A1
923:                             chanObj->errorInfo = SYS_DMA_ERROR_NONE;
9D00FD6C  AC440004   SW A0, 4(V0)
924:                 			if(NULL != chanObj->pEventCallBack)
9D00FD70  8C430008   LW V1, 8(V0)
9D00FD74  1060001E   BEQ V1, ZERO, 0x9D00FDF0
9D00FD78  00002021   ADDU A0, ZERO, ZERO
925:                 			{
926:                 	            chanObj->pEventCallBack(SYS_DMA_TRANSFER_EVENT_COMPLETE,
9D00FD7C  00402821   ADDU A1, V0, ZERO
9D00FD80  0060F809   JALR V1
9D00FD84  8C46000C   LW A2, 12(V0)
927:                                          (SYS_DMA_CHANNEL_HANDLE)chanObj,chanObj->hClientArg);
928:                 			}
929:                 
930:                         }
931:                         else if(true == PLIB_DMA_ChannelXINTSourceFlagGet(DMA_ID_0,activeChannel,
9D00FD98  10800015   BEQ A0, ZERO, 0x9D00FDF0
9D00FD9C  24040002   ADDIU A0, ZERO, 2
932:                                         DMA_INT_TRANSFER_ABORT))
933:                         {
934:                             /* Channel is by default disabled on Transfer Abortion */
935:                 
936:                             /* Clear the Abort transfer complete flag */
937:                             PLIB_DMA_ChannelXINTSourceFlagClear(DMA_ID_0,activeChannel,
938:                                         DMA_INT_TRANSFER_ABORT);
939:                 
940:                             SYS_INT_SourceStatusClear(chanIntSrc);
941:                 
942:                             /* Find out the channel object and give a callback */
943:                             chanObj = (SYS_DMA_CHANNEL_OBJECT *) &gSysDMAChannelObj[activeChannel];
9D00FDC4  00052900   SLL A1, A1, 4
9D00FDC8  3C02A000   LUI V0, -24576
9D00FDCC  24420C9C   ADDIU V0, V0, 3228
9D00FDD0  00451021   ADDU V0, V0, A1
944:                             chanObj->errorInfo = SYS_DMA_ERROR_NONE;
9D00FDD4  AC440004   SW A0, 4(V0)
945:                 			if(NULL != chanObj->pEventCallBack)
9D00FDD8  8C430008   LW V1, 8(V0)
9D00FDDC  10600004   BEQ V1, ZERO, 0x9D00FDF0
9D00FDE0  24040002   ADDIU A0, ZERO, 2
946:                 			{
947:                 	            chanObj->pEventCallBack(SYS_DMA_TRANSFER_EVENT_ABORT,
9D00FDE4  00402821   ADDU A1, V0, ZERO
9D00FDE8  0060F809   JALR V1
9D00FDEC  8C46000C   LW A2, 12(V0)
948:                                         (SYS_DMA_CHANNEL_HANDLE)chanObj,chanObj->hClientArg);
949:                 			}
950:                         }
951:                         else
952:                         {
953:                             ;
954:                         }
955:                   //  }
956:                     return;
957:                 }
9D00FD88  0B403F7D   J 0x9D00FDF4
9D00FD8C  8FBF0014   LW RA, 20(SP)
9D00FDF0  8FBF0014   LW RA, 20(SP)
9D00FDF4  03E00008   JR RA
9D00FDF8  27BD0018   ADDIU SP, SP, 24
958:                 
959:                 /*****************************************************************************
960:                   Function:
961:                     void SYS_DMA_TasksError(SYS_MODULE_OBJ object );
962:                 
963:                   Summary:
964:                     Maintains the system service's error state machine.
965:                 
966:                   Description:
967:                     This routine is used to maintain the DMA system service's error state machine.
968:                 	This function is specifically designed for non DMA interrupt trigger
969:                     implementations(polling mode), and should be used only in polling mode.
970:                     this function should be called from the SYS_Tasks() function.
971:                 
972:                   Remarks:
973:                     This routine is normally not called directly by an application.  It is
974:                     called by the system's Tasks routine (SYS_Tasks).
975:                 
976:                  */
977:                 
978:                 void SYS_DMA_TasksError(SYS_MODULE_OBJ object)
979:                 {
980:                     SYS_DMA_CHANNEL_OBJECT *chanObj;
981:                     DMA_CHANNEL channels;
982:                     DMA_CHANNEL_INT_SOURCE chanIntSrc;
983:                 
984:                     /* Go through each DMA channel and service it */
985:                     for (channels = DMA_CHANNEL_0; channels < DMA_NUMBER_OF_CHANNELS; channels++)
986:                     {
987:                 		/* Find out the interrupt source number for the last active DMA channel */
988:                 		chanIntSrc = PLIB_DMA_ChannelXTriggerSourceNumberGet(DMA_ID_0, channels);
989:                 
990:                 		/* Check whether the active DMA channel interrupt has occured */
991:                 		if(true == SYS_INT_SourceStatusGet(chanIntSrc))
992:                 		{
993:                 			if(true == PLIB_DMA_ChannelXINTSourceFlagGet(DMA_ID_0,channels,
994:                 						DMA_INT_ADDRESS_ERROR))
995:                 			{
996:                 				/* Channel is by default disabled on completion of a block transfer */
997:                 
998:                 				/* Clear the Block transfer complete flag */
999:                 				PLIB_DMA_ChannelXINTSourceFlagClear(DMA_ID_0,channels,
1000:                						DMA_INT_ADDRESS_ERROR);
1001:                
1002:                				SYS_INT_SourceStatusClear(chanIntSrc);
1003:                
1004:                				/* Find out the channel object and give a callback */
1005:                				chanObj = (SYS_DMA_CHANNEL_OBJECT *) &gSysDMAChannelObj[channels];
1006:                				chanObj->errorInfo = SYS_DMA_ERROR_ADDRESS_ERROR;
1007:                                if(NULL != chanObj->pEventCallBack)
1008:                                {                
1009:                                    chanObj->pEventCallBack(SYS_DMA_TRANSFER_EVENT_ERROR,
1010:                						(SYS_DMA_CHANNEL_HANDLE)chanObj,chanObj->hClientArg);
1011:                                }
1012:                			}
1013:                		}
1014:                	}
1015:                    return;
1016:                }
1017:                
1018:                
1019:                /*******************************************************************************
1020:                  Function:
1021:                    void SYS_DMA_TasksErrorISR(SYS_MODULE_OBJ object, DMA_CHANNEL activeChannel)
1022:                
1023:                  Summary:
1024:                    Maintains the system service's state machine and implements its ISR
1025:                
1026:                  Description:
1027:                    This routine is used to maintain the DMA system service's internal error state machine
1028:                    and implement its ISR for DMA interrupt trigger implementations(interrupt mode).
1029:                    This function is specifically designed for DMA interrupt trigger
1030:                    implementations (interrupt mode).
1031:                    In interrupt mode, this function should be called in the interrupt
1032:                    service routine of the DMA channel that is associated with this transfer.
1033:                
1034:                  Remarks:
1035:                    It is called by appropriate raw ISR.
1036:                
1037:                    This routine may execute in an ISR context and will never block or access any
1038:                    resources that may cause it to block.
1039:                 */
1040:                void SYS_DMA_TasksErrorISR(SYS_MODULE_OBJ object, DMA_CHANNEL activeChannel)
1041:                {
1042:                    SYS_DMA_CHANNEL_OBJECT *chanObj;
1043:                    DMA_CHANNEL_INT_SOURCE chanIntSrc;
1044:                
1045:                    /* Find out the interrupt source number for the last active DMA channel */
1046:                    chanIntSrc = PLIB_DMA_ChannelXTriggerSourceNumberGet(DMA_ID_0, activeChannel);
1047:                
1048:                    /* Check whether the active DMA channel interrupt has occured */
1049:                    if(true == SYS_INT_SourceStatusGet(chanIntSrc))
1050:                    {
1051:                        if(true == PLIB_DMA_ChannelXINTSourceFlagGet(DMA_ID_0,activeChannel,
1052:                                    DMA_INT_ADDRESS_ERROR))
1053:                        {
1054:                            /* Channel is by default disabled on completion of a block transfer */
1055:                
1056:                            /* Clear the Block transfer complete flag */
1057:                            PLIB_DMA_ChannelXINTSourceFlagClear(DMA_ID_0,activeChannel,
1058:                                    DMA_INT_ADDRESS_ERROR);
1059:                
1060:                            SYS_INT_SourceStatusClear(chanIntSrc);
1061:                
1062:                            /* Find out the channel object and give a callback */
1063:                            chanObj = (SYS_DMA_CHANNEL_OBJECT *) &gSysDMAChannelObj[activeChannel];
1064:                            chanObj->errorInfo = SYS_DMA_ERROR_ADDRESS_ERROR;
1065:                			if(NULL != chanObj->pEventCallBack)
1066:                			{            
1067:                                chanObj->pEventCallBack(SYS_DMA_TRANSFER_EVENT_ERROR,
1068:                                        (SYS_DMA_CHANNEL_HANDLE)chanObj,chanObj->hClientArg);
1069:                            }
1070:                        }
1071:                    }
1072:                    return;
1073:                }
1074:                
1075:                // *****************************************************************************
1076:                /* Function:
1077:                    SYS_DMA_ERROR SYS_DMA_ChannelErrorGet(SYS_DMA_CHANNEL_HANDLE handle)
1078:                
1079:                  Summary:
1080:                    This function returns the error(if any) associated with the last client
1081:                    request.
1082:                
1083:                  Description:
1084:                    This function returns the error(if any) associated with the last client
1085:                    request. If the service send a SYS_DMA_TRANSFER_EVENT_ERROR to the client,
1086:                    the client can call this function to know the error cause.
1087:                    The error status will be updated on every operation and should be read
1088:                    frequently (ideally immediately after the service operation has completed)
1089:                    to know the relevant error status.
1090:                
1091:                  Remarks:
1092:                    It is the client's reponsibility to make sure that the error status is
1093:                    obtained frequently. The service will update the error status
1094:                    irrespective of whether this has been examined by the client.
1095:                */
1096:                
1097:                SYS_DMA_ERROR SYS_DMA_ChannelErrorGet(SYS_DMA_CHANNEL_HANDLE handle)
1098:                {
1099:                    SYS_DMA_CHANNEL_OBJECT *chanObj;
1100:                
1101:                    chanObj = (SYS_DMA_CHANNEL_OBJECT *) handle;
1102:                    return chanObj->errorInfo;
1103:                }
1104:                
1105:                
1106:                //******************************************************************************
1107:                /* Function:
1108:                    void SYS_DMA_ChannelForceStart(SYS_DMA_CHANNEL_HANDLE handle)
1109:                
1110:                  Summary:
1111:                    Force start of transfer on the selected channel
1112:                
1113:                  Description:
1114:                    The function force start a DMA transfer to occur for the selected channel.
1115:                
1116:                  Remarks:
1117:                   This function must be used to start the DMA transfer when the channel has been
1118:                   setup(by calling SYS_DMA_ChannelSetup) with the eventSrc as DMA_TRIGGER_SOURCE_NONE.
1119:                */
1120:                
1121:                void SYS_DMA_ChannelForceStart(SYS_DMA_CHANNEL_HANDLE handle)
1122:                {
1123:                    SYS_DMA_CHANNEL_OBJECT *chanObj;
1124:                    DMA_CHANNEL channelNumber;
1125:                
1126:                    chanObj = (SYS_DMA_CHANNEL_OBJECT *) handle;
1127:                    channelNumber = (chanObj  - (SYS_DMA_CHANNEL_OBJECT *) &gSysDMAChannelObj[0]);
1128:                
1129:                    PLIB_DMA_StartTransferSet(DMA_ID_0, channelNumber);
1130:                
1131:                    return;
1132:                }
1133:                
1134:                //******************************************************************************
1135:                /* Function:
1136:                    void SYS_DMA_ChannelForceAbort(SYS_DMA_CHANNEL_HANDLE handle)
1137:                
1138:                  Summary:
1139:                    Force abort of transfer on the selected channel
1140:                
1141:                  Description:
1142:                    The function abort a DMA transfer to occur for the selected channel.
1143:                
1144:                  Remarks:
1145:                   This function must be used to abort the DMA transfer when the channel has been
1146:                   setup(by calling SYS_DMA_ChannelSetup) with the eventSrc as DMA_TRIGGER_SOURCE_NONE.
1147:                   and SYS_DMA_ChannelAbortEventSet has not been called.
1148:                */
1149:                
1150:                void SYS_DMA_ChannelForceAbort(SYS_DMA_CHANNEL_HANDLE handle)
1151:                {
1152:                    SYS_DMA_CHANNEL_OBJECT *chanObj;
1153:                    DMA_CHANNEL channelNumber;
1154:                
1155:                    chanObj = (SYS_DMA_CHANNEL_OBJECT *) handle;
1156:                    channelNumber = (chanObj  - (SYS_DMA_CHANNEL_OBJECT *) &gSysDMAChannelObj[0]);
9D014CE4  3C02A000   LUI V0, -24576
9D014CE8  24420C9C   ADDIU V0, V0, 3228
9D014CEC  00822023   SUBU A0, A0, V0
9D014CF0  00042103   SRA A0, A0, 4
9D014CF4  00041180   SLL V0, A0, 6
9D014CF8  00042200   SLL A0, A0, 8
9D014CFC  00822023   SUBU A0, A0, V0
9D014D00  3C02BF88   LUI V0, -16504
9D014D04  24423060   ADDIU V0, V0, 12384
9D014D08  00822021   ADDU A0, A0, V0
9D014D0C  24020040   ADDIU V0, ZERO, 64
9D014D10  AC820018   SW V0, 24(A0)
9D014D14  03E00008   JR RA
9D014D18  00000000   NOP
1157:                
1158:                    PLIB_DMA_AbortTransferSet(DMA_ID_0, channelNumber);
1159:                
1160:                    return;
1161:                }
1162:                
1163:                
1164:                //******************************************************************************
1165:                /* Function:
1166:                    void SYS_DMA_ChannelAbortEventSet(SYS_DMA_CHANNEL_HANDLE handle,
1167:                                                        DMA_TRIGGER_SOURCE eventSrc)
1168:                
1169:                  Summary:
1170:                    Sets an event source and enables cell transfer abort event for the same
1171:                    for the selected channel.
1172:                
1173:                  Description:
1174:                    This functions enables a cell transfer abort event for the selected source
1175:                    event.
1176:                
1177:                  Remarks:
1178:                    If the parameter 'eventSrc' is specified as DMA_TRIGGER_SOURCE_NONE the
1179:                    current DMA transfer will be aborted. The behavior is a same as calling
1180:                    SYS_DMA_ChannelForceAbort.
1181:                
1182:                */
1183:                
1184:                void SYS_DMA_ChannelAbortEventSet(SYS_DMA_CHANNEL_HANDLE handle,
1185:                                                    DMA_TRIGGER_SOURCE eventSrc)
1186:                {
1187:                    SYS_DMA_CHANNEL_OBJECT *chanObj;
1188:                    DMA_CHANNEL channelNumber;
1189:                
1190:                    chanObj = (SYS_DMA_CHANNEL_OBJECT *) handle;
1191:                    channelNumber = (chanObj  - (SYS_DMA_CHANNEL_OBJECT *) &gSysDMAChannelObj[0]);
1192:                
1193:                    /* Setup the DMA Trigger Abort Source and Enable it */
1194:                    if(DMA_TRIGGER_SOURCE_NONE == eventSrc)
1195:                    {
1196:                        PLIB_DMA_AbortTransferSet(DMA_ID_0, channelNumber);
1197:                    }
1198:                    else
1199:                    {
1200:                        PLIB_DMA_ChannelXAbortIRQSet( DMA_ID_0, channelNumber, eventSrc);
1201:                        PLIB_DMA_ChannelXTriggerEnable( DMA_ID_0, channelNumber, DMA_CHANNEL_TRIGGER_TRANSFER_ABORT);
1202:                    }
1203:                    return;
1204:                }
1205:                
1206:                
1207:                //******************************************************************************
1208:                /* Function:
1209:                    bool SYS_DMA_ChannelIsBusy(SYS_DMA_CHANNEL_HANDLE handle)
1210:                
1211:                  Summary:
1212:                    Returns the busy status of the specified DMA channel
1213:                
1214:                  Description:
1215:                    This function returns the busy status of the selected DMA channel
1216:                
1217:                  Remarks:
1218:                    Not all features are available on all micro-controllers.
1219:                */
1220:                
1221:                bool SYS_DMA_ChannelIsBusy(SYS_DMA_CHANNEL_HANDLE handle)
1222:                {
1223:                    bool isBusy;
1224:                    SYS_DMA_CHANNEL_OBJECT *chanObj;
1225:                    DMA_CHANNEL channelNumber;
1226:                
1227:                    chanObj = (SYS_DMA_CHANNEL_OBJECT *) handle;
1228:                    channelNumber = (chanObj  - (SYS_DMA_CHANNEL_OBJECT *) &gSysDMAChannelObj[0]);
1229:                    isBusy = false;
1230:                
1231:                #if defined(PLIB_DMA_ExistsChannelXBusy)
1232:                    if(true == PLIB_DMA_ExistsChannelXBusy(DMA_ID_0))
1233:                    {
1234:                        if(true == PLIB_DMA_ChannelXBusyIsBusy( DMA_ID_0, channelNumber))
1235:                        {
1236:                            isBusy = true;
1237:                        }
1238:                    }
1239:                #endif
1240:                    return isBusy;
1241:                }
1242:                
1243:                
1244:                // *****************************************************************************
1245:                // *****************************************************************************
1246:                // Section: Global DMA Management Routines
1247:                // *****************************************************************************
1248:                // *****************************************************************************
1249:                //******************************************************************************
1250:                //******************************************************************************
1251:                /* Function:
1252:                    void SYS_DMA_Suspend(void)
1253:                
1254:                  Summary:
1255:                    Suspend DMA transfers.
1256:                
1257:                  Description:
1258:                    This function suspends DMA transfers to allow CPU uninterrupted access
1259:                    to data bus
1260:                
1261:                  Remarks:
1262:                    None
1263:                */
1264:                
1265:                void SYS_DMA_Suspend(void)
1266:                {
1267:                    PLIB_DMA_SuspendEnable(DMA_ID_0);
1268:                    return;
1269:                }
1270:                
1271:                //******************************************************************************
1272:                /* Function:
1273:                    void SYS_DMA_Resume(void)
1274:                
1275:                  Summary:
1276:                    Resume DMA operations
1277:                
1278:                  Description:
1279:                    This function disables DMA suspend. It resumes the DMA operation suspended
1280:                    by calling SYS_DMA_Suspend. The DMA operates normally.
1281:                
1282:                  Remarks:
1283:                    None
1284:                */
1285:                void SYS_DMA_Resume(void)
1286:                {
1287:                    PLIB_DMA_SuspendDisable(DMA_ID_0);
1288:                    return;
1289:                }
1290:                
1291:                
1292:                //******************************************************************************
1293:                /* Function:
1294:                    bool SYS_DMA_IsBusy(void)
1295:                
1296:                  Summary:
1297:                    Returns the busy status of the DMA module
1298:                
1299:                  Description:
1300:                    This function returns the busy status of the DMA module
1301:                
1302:                  Remarks:
1303:                    Not all features are available on all micro-controllers.
1304:                */
1305:                bool SYS_DMA_IsBusy(void)
1306:                {
1307:                #if defined(PLIB_DMA_ExistsBusy)
1308:                    if(true == PLIB_DMA_ExistsBusy(DMA_ID_0))
1309:                    {
1310:                        return PLIB_DMA_IsBusy(DMA_ID_0);
1311:                    }
1312:                #endif
1313:                    return false;  // added this line to avoid compiler warning
1314:                }
1315:                
1316:                /*******************************************************************************
1317:                 End of File
1318:                */
1319:                
1320:                
1321:                
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/wdt/templates/wdt_WindowEnable_Default.h
1:                   /*******************************************************************************
2:                     WDT Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       wdt_WindowEnable_Default.h
6:                   
7:                     Summary:
8:                       WDT PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : WindowEnable
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_WDT_ExistsWindowEnable
16:                          PLIB_WDT_WindowEnable
17:                          PLIB_WDT_WindowDisable
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _WDT_WINDOWENABLE_DEFAULT_H
48:                  #define _WDT_WINDOWENABLE_DEFAULT_H
49:                  
50:                  //******************************************************************************
51:                  /* Function :  WDT_ExistsWindowEnable_Default
52:                  
53:                    Summary:
54:                      Implements Default variant of PLIB_WDT_ExistsWindowEnable
55:                  
56:                    Description:
57:                      This template implements the Default variant of the PLIB_WDT_ExistsWindowEnable function.
58:                  */
59:                  
60:                  #define PLIB_WDT_ExistsWindowEnable PLIB_WDT_ExistsWindowEnable
61:                  PLIB_TEMPLATE bool WDT_ExistsWindowEnable_Default( WDT_MODULE_ID index )
62:                  {
63:                      return true;
64:                  }
65:                  
66:                  
67:                  //******************************************************************************
68:                  /* Function :  WDT_WindowEnable_Default
69:                  
70:                    Summary:
71:                      Implements Default variant of PLIB_WDT_WindowEnable
72:                  
73:                    Description:
74:                      This template implements the Default variant of the PLIB_WDT_WindowEnable function.
75:                  */
76:                  
77:                  PLIB_TEMPLATE void WDT_WindowEnable_Default( WDT_MODULE_ID index )
78:                  {
79:                      WDTCONSET = _WDTCON_WDTWINEN_MASK;
9D01513C  AC430008   SW V1, 8(V0)
9D015140  03E00008   JR RA
9D015144  00000000   NOP
80:                  }
81:                  
82:                  
83:                  //******************************************************************************
84:                  /* Function :  WDT_WindowDisable_Default
85:                  
86:                    Summary:
87:                      Implements Default variant of PLIB_WDT_WindowDisable
88:                  
89:                    Description:
90:                      This template implements the Default variant of the PLIB_WDT_WindowDisable function.
91:                  */
92:                  
93:                  PLIB_TEMPLATE void WDT_WindowDisable_Default( WDT_MODULE_ID index )
94:                  {
95:                      WDTCONCLR = _WDTCON_WDTWINEN_MASK;
9D015148  3C02BF80   LUI V0, -16512
96:                  }
97:                  
98:                  
99:                  #endif /*_WDT_WINDOWENABLE_DEFAULT_H*/
100:                 
101:                 /******************************************************************************
102:                  End of File
103:                 */
104:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/wdt/templates/wdt_TimerClear_Default.h
1:                   /*******************************************************************************
2:                     WDT Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       wdt_TimerClear_Default.h
6:                   
7:                     Summary:
8:                       WDT PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : TimerClear
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_WDT_ExistsTimerClear
16:                          PLIB_WDT_TimerClear
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _WDT_TIMERCLEAR_DEFAULT_H
47:                  #define _WDT_TIMERCLEAR_DEFAULT_H
48:                  
49:                  //******************************************************************************
50:                  /* Function :  WDT_ExistsTimerClear_Default
51:                  
52:                    Summary:
53:                      Implements Default variant of PLIB_WDT_ExistsTimerClear
54:                  
55:                    Description:
56:                      This template implements the Default variant of the PLIB_WDT_ExistsTimerClear function.
57:                  */
58:                  
59:                  #define PLIB_WDT_ExistsTimerClear PLIB_WDT_ExistsTimerClear
60:                  PLIB_TEMPLATE bool WDT_ExistsTimerClear_Default( WDT_MODULE_ID index )
61:                  {
62:                      return true;
63:                  }
64:                  
65:                  
66:                  //******************************************************************************
67:                  /* Function :  WDT_TimerClear_Default
68:                  
69:                    Summary:
70:                      Implements Default variant of PLIB_WDT_TimerClear
71:                  
72:                    Description:
73:                      This template implements the Default variant of the PLIB_WDT_TimerClear function.
74:                  */
75:                  
76:                  PLIB_TEMPLATE void WDT_TimerClear_Default( WDT_MODULE_ID index )
77:                  {
78:                      WDTCONSET = _WDTCON_WDTCLR_MASK;
9D015900  24030001   ADDIU V1, ZERO, 1
79:                  }
80:                  
81:                  
82:                  #endif /*_WDT_TIMERCLEAR_DEFAULT_H*/
83:                  
84:                  /******************************************************************************
85:                   End of File
86:                  */
87:                  
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/wdt/templates/wdt_EnableControl_Default.h
1:                   /*******************************************************************************
2:                     WDT Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       wdt_EnableControl_Default.h
6:                   
7:                     Summary:
8:                       WDT PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : EnableControl
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_WDT_ExistsEnableControl
16:                          PLIB_WDT_Enable
17:                          PLIB_WDT_Disable
18:                          PLIB_WDT_IsEnabled
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _WDT_ENABLECONTROL_DEFAULT_H
49:                  #define _WDT_ENABLECONTROL_DEFAULT_H
50:                  
51:                  //******************************************************************************
52:                  /* Function :  WDT_ExistsEnableControl_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_WDT_ExistsEnableControl
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_WDT_ExistsEnableControl function.
59:                  */
60:                  
61:                  #define PLIB_WDT_ExistsEnableControl PLIB_WDT_ExistsEnableControl
62:                  PLIB_TEMPLATE bool WDT_ExistsEnableControl_Default( WDT_MODULE_ID index )
63:                  {
64:                      return true;
65:                  }
66:                  
67:                  
68:                  //******************************************************************************
69:                  /* Function :  WDT_Enable_Default
70:                  
71:                    Summary:
72:                      Implements Default variant of PLIB_WDT_Enable
73:                  
74:                    Description:
75:                      This template implements the Default variant of the PLIB_WDT_Enable function.
76:                  */
77:                  
78:                  PLIB_TEMPLATE void WDT_Enable_Default( WDT_MODULE_ID index )
79:                  {
80:                      WDTCONSET = _WDTCON_ON_MASK;
9D015128  34038000   ORI V1, ZERO, -32768
9D01512C  3C02BF80   LUI V0, -16512
9D015130  AC430008   SW V1, 8(V0)
81:                  }
82:                  
83:                  
84:                  //******************************************************************************
85:                  /* Function :  WDT_Disable_Default
86:                  
87:                    Summary:
88:                      Implements Default variant of PLIB_WDT_Disable
89:                  
90:                    Description:
91:                      This template implements the Default variant of the PLIB_WDT_Disable function.
92:                  */
93:                  
94:                  PLIB_TEMPLATE void WDT_Disable_Default( WDT_MODULE_ID index )
95:                  {
96:                      WDTCONCLR = _WDTCON_ON_MASK;
9D0158EC  34038000   ORI V1, ZERO, -32768
97:                  }
98:                  
99:                  
100:                 //******************************************************************************
101:                 /* Function :  WDT_IsEnabled_Default
102:                 
103:                   Summary:
104:                     Implements Default variant of PLIB_WDT_IsEnabled
105:                 
106:                   Description:
107:                     This template implements the Default variant of the PLIB_WDT_IsEnabled function.
108:                 */
109:                 
110:                 PLIB_TEMPLATE bool WDT_IsEnabled_Default( WDT_MODULE_ID index )
111:                 {
112:                     return (bool)WDTCONbits.ON;
113:                 }
114:                 
115:                 
116:                 #endif /*_WDT_ENABLECONTROL_DEFAULT_H*/
117:                 
118:                 /******************************************************************************
119:                  End of File
120:                 */
121:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/usb/templates/usb_StopInIdle_Default.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_StopInIdle_Default.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : StopInIdle
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USB_StopInIdleEnable
16:                          PLIB_USB_StopInIdleDisable
17:                          PLIB_USB_ExistsStopInIdle
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _USB_STOPINIDLE_DEFAULT_H
48:                  #define _USB_STOPINIDLE_DEFAULT_H
49:                  
50:                  #include "../templates/usb_registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  USB_StopInIdleEnable_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_USB_StopInIdleEnable 
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_USB_StopInIdleEnable function.
60:                  */
61:                  
62:                  PLIB_TEMPLATE void USB_StopInIdleEnable_Default( USB_MODULE_ID index )
63:                  {
64:                  	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
65:                      usb->UxCNFG1.USBSIDL = 1;
9D00D88C  922202A0   LBU V0, 672(S1)
9D00D890  7C622104   INS V0, V1, 4, 1
9D00D894  A22202A0   SB V0, 672(S1)
66:                     
67:                  }
68:                  
69:                  //******************************************************************************
70:                  /* Function :  USB_StopInIdleDisable_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_USB_StopInIdleDisable 
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_USB_StopInIdleDisable function.
77:                  */
78:                  
79:                  PLIB_TEMPLATE void USB_StopInIdleDisable_Default( USB_MODULE_ID index )
80:                  {
81:                  	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
82:                      usb->UxCNFG1.USBSIDL = 1;
9D00D8A0  922202A0   LBU V0, 672(S1)
9D00D8A4  24030001   ADDIU V1, ZERO, 1
9D00D8A8  7C622104   INS V0, V1, 4, 1
9D00D8AC  A22202A0   SB V0, 672(S1)
83:                  }
84:                  
85:                  //******************************************************************************
86:                  /* Function :  USB_ExistsStopInIdle_Default
87:                  
88:                    Summary:
89:                      Implements Default variant of PLIB_USB_ExistsStopInIdle
90:                  
91:                    Description:
92:                      This template implements the Default variant of the PLIB_USB_ExistsStopInIdle function.
93:                  */
94:                  
95:                  #define PLIB_USB_ExistsStopInIdle PLIB_USB_ExistsStopInIdle
96:                  PLIB_TEMPLATE bool USB_ExistsStopInIdle_Default( USB_MODULE_ID index )
97:                  {
98:                      return true;
99:                  }
100:                 
101:                 
102:                 #endif /*_USB_STOPINIDLE_DEFAULT_H*/
103:                 
104:                 /******************************************************************************
105:                  End of File
106:                 */
107:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/usb/templates/usb_ResumeSignaling_Default.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_ResumeSignaling_Default.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ResumeSignaling
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USB_ResumeSignalingEnable
16:                          PLIB_USB_ResumeSignalingDisable
17:                          PLIB_USB_ExistsResumeSignaling
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _USB_RESUMESIGNALING_DEFAULT_H
48:                  #define _USB_RESUMESIGNALING_DEFAULT_H
49:                  
50:                  #include "../templates/usb_registers.h"
51:                  
52:                  
53:                  //******************************************************************************
54:                  /* Function :  USB_ResumeSignalingEnable_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_USB_ResumeSignalingEnable 
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_USB_ResumeSignalingEnable function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE void USB_ResumeSignalingEnable_Default( USB_MODULE_ID index )
64:                  {
65:                  	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
9D0153C8  8C820020   LW V0, 32(A0)
66:                  	usb->UxCON.w |=  UxCON_RESUME_MASK ;
9D0153CC  8C430210   LW V1, 528(V0)
67:                     
68:                  }
69:                  
70:                  //******************************************************************************
71:                  /* Function :  USB_ResumeSignalingDisable_Default
72:                  
73:                    Summary:
74:                      Implements Default variant of PLIB_USB_ResumeSignalingDisable 
75:                  
76:                    Description:
77:                      This template implements the Default variant of the PLIB_USB_ResumeSignalingDisable function.
78:                  */
79:                  
80:                  PLIB_TEMPLATE void USB_ResumeSignalingDisable_Default( USB_MODULE_ID index )
81:                  {
82:                  
83:                  	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
9D0153EC  8C820020   LW V0, 32(A0)
84:                  	usb->UxCON.w &= ( ~ UxCON_RESUME_MASK);
9D0153F0  8C430210   LW V1, 528(V0)
85:                    
86:                  }
87:                  
88:                  
89:                  //******************************************************************************
90:                  /* Function :  USB_ExistsResumeSignaling_Default
91:                  
92:                    Summary:
93:                      Implements Default variant of PLIB_USB_ExistsResumeSignaling
94:                  
95:                    Description:
96:                      This template implements the Default variant of the PLIB_USB_ExistsResumeSignaling function.
97:                  */
98:                  
99:                  #define PLIB_USB_ExistsResumeSignaling PLIB_USB_ExistsResumeSignaling
100:                 PLIB_TEMPLATE bool USB_ExistsResumeSignaling_Default( USB_MODULE_ID index )
101:                 {
102:                     return true;
103:                 }
104:                 
105:                 
106:                 #endif /*_USB_RESUMESIGNALING_DEFAULT_H*/
107:                 
108:                 /******************************************************************************
109:                  End of File
110:                 */
111:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/usb/templates/usb_PacketTransfer_Default.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_PacketTransfer_Default.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : PacketTransfer
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USB_PacketTransferIsDisabled
16:                          PLIB_USB_PacketTransferEnable
17:                          PLIB_USB_ExistsPacketTransfer
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _USB_PACKETTRANSFER_DEFAULT_H
48:                  #define _USB_PACKETTRANSFER_DEFAULT_H
49:                  
50:                  #include "../templates/usb_registers.h"
51:                  
52:                  
53:                  //******************************************************************************
54:                  /* Function :  USB_PacketTransferIsDisabled_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_USB_PacketTransferIsDisabled 
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_USB_PacketTransferIsDisabled function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE bool USB_PacketTransferIsDisabled_Default( USB_MODULE_ID index )
64:                  {
65:                  	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
66:                      return ( usb->UxCON.UxCONbits.PKTDIS_TOKBUSY );
67:                  }
68:                  
69:                  //******************************************************************************
70:                  /* Function :  USB_PacketTransferEnable_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_USB_PacketTransferEnable 
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_USB_PacketTransferEnable function.
77:                  */
78:                  
79:                  PLIB_TEMPLATE void USB_PacketTransferEnable_Default( USB_MODULE_ID index )
80:                  {
81:                      volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
82:                      usb->UxCON.UxCONbits.TOKBUSY = 0;
9D0044BC  92020210   LBU V0, 528(S0)
9D0044C0  7C022944   INS V0, ZERO, 5, 1
9D0044C4  A2020210   SB V0, 528(S0)
83:                      
84:                  }
85:                  
86:                  //******************************************************************************
87:                  /* Function :  USB_PacketTransferDisable_Default
88:                  
89:                    Summary:
90:                      Implements Default variant of PLIB_USB_PacketTransferDisable 
91:                  
92:                    Description:
93:                      This template implements the Default variant of the PLIB_USB_PacketTransferDisable function.
94:                  */
95:                  
96:                  PLIB_TEMPLATE void USB_PacketTransferDisable_Default( USB_MODULE_ID index )
97:                  {
98:                      volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
99:                      usb->UxCON.UxCONbits.TOKBUSY = 1;
100:                    
101:                 }
102:                 
103:                 //******************************************************************************
104:                 /* Function :  USB_ExistsPacketTransfer_Default
105:                 
106:                   Summary:
107:                     Implements Default variant of PLIB_USB_ExistsPacketTransfer
108:                 
109:                   Description:
110:                     This template implements the Default variant of the PLIB_USB_ExistsPacketTransfer function.
111:                 */
112:                 
113:                 #define PLIB_USB_ExistsPacketTransfer PLIB_USB_ExistsPacketTransfer
114:                 PLIB_TEMPLATE bool USB_ExistsPacketTransfer_Default( USB_MODULE_ID index )
115:                 {
116:                     return true;
117:                 }
118:                 
119:                 
120:                 #endif /*_USB_PACKETTRANSFER_DEFAULT_H*/
121:                 
122:                 /******************************************************************************
123:                  End of File
124:                 */
125:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/usb/templates/usb_OpModeSelect_Default.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_OpModeSelect_Default.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : OpModeSelect
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USB_OperatingModeSelect
16:                          PLIB_USB_ExistsOpModeSelect
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _USB_OPMODESELECT_DEFAULT_H
47:                  #define _USB_OPMODESELECT_DEFAULT_H
48:                  
49:                  #include "../templates/usb_registers.h"
50:                  
51:                  
52:                  //******************************************************************************
53:                  /* Function :  USB_OperatingModeSelect_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_USB_OperatingModeSelect
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_USB_OperatingModeSelect function.
60:                  */
61:                  
62:                  PLIB_TEMPLATE void USB_OperatingModeSelect_Default( USB_MODULE_ID index , USB_OPMODES opMode )
63:                  {
64:                      volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
9D013508  8C820020   LW V0, 32(A0)
9D014498  8C820020   LW V0, 32(A0)
65:                      usb->UxCON.UxCONbits.USBEN_SOFEN = 0;
9D01350C  90430210   LBU V1, 528(V0)
9D013510  7C030004   INS V1, ZERO, 0, 1
9D013514  A0430210   SB V1, 528(V0)
9D01449C  90430210   LBU V1, 528(V0)
9D0144A0  7C030004   INS V1, ZERO, 0, 1
9D0144A4  A0430210   SB V1, 528(V0)
66:                      usb->UxCON.UxCONbits.HOSTEN = 0 ;
9D013518  90430210   LBU V1, 528(V0)
9D01351C  7C0318C4   INS V1, ZERO, 3, 1
9D013520  A0430210   SB V1, 528(V0)
9D0144A8  90430210   LBU V1, 528(V0)
9D0144AC  7C0318C4   INS V1, ZERO, 3, 1
9D0144B0  A0430210   SB V1, 528(V0)
67:                  	usb->UxOTGCON.OTGEN = 0;
9D013524  90430030   LBU V1, 48(V0)
9D013528  7C031084   INS V1, ZERO, 2, 1
9D01352C  A0430030   SB V1, 48(V0)
9D0144B4  90430030   LBU V1, 48(V0)
68:                      switch ( opMode )
69:                      {
70:                          case USB_OPMODE_NONE:
71:                               break;
72:                  			
73:                          case USB_OPMODE_DEVICE:
74:                               usb->UxCON.UxCONbits.USBEN_SOFEN = 1; 
9D013530  90430210   LBU V1, 528(V0)
9D013534  24050001   ADDIU A1, ZERO, 1
9D013538  7CA30004   INS V1, A1, 0, 1
9D01353C  A0430210   SB V1, 528(V0)
75:                              break;
76:                  
77:                          case USB_OPMODE_HOST:
78:                              usb->UxCON.UxCONbits.HOSTEN = 1 ;
79:                              break;
80:                  
81:                          case USB_OPMODE_OTG:
82:                              usb->UxOTGCON.OTGEN = 1;
83:                              break;
84:                  
85:                          default:
86:                              PLIB_ASSERT( 0, "In USB_OperatingModeSelect, unknown operating mode!" );
87:                              break;
88:                      }
89:                  }
90:                  
91:                  //******************************************************************************
92:                  /* Function :  USB_ExistsOpModeSelect_Default
93:                  
94:                    Summary:
95:                      Implements Default variant of PLIB_USB_ExistsOpModeSelect
96:                  
97:                    Description:
98:                      This template implements the Default variant of the PLIB_USB_ExistsOpModeSelect function.
99:                  */
100:                 
101:                 #define PLIB_USB_ExistsOpModeSelect PLIB_USB_ExistsOpModeSelect
102:                 PLIB_TEMPLATE bool USB_ExistsOpModeSelect_Default( USB_MODULE_ID index )
103:                 {
104:                     return true;
105:                 }
106:                 
107:                 
108:                 #endif /*_USB_OPMODESELECT_DEFAULT_H*/
109:                 
110:                 /******************************************************************************
111:                  End of File
112:                 */
113:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/usb/templates/usb_OTG_SessionValid_Default.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_OTG_SessionValid_Default.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : OTG_SessionValid
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USB_OTG_SessionValid
16:                          PLIB_USB_ExistsOTG_SessionValid
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _USB_OTG_SESSIONVALID_DEFAULT_H
47:                  #define _USB_OTG_SESSIONVALID_DEFAULT_H
48:                  
49:                  #include "../templates/usb_registers.h"
50:                  
51:                  
52:                  //******************************************************************************
53:                  /* Function :  USB_OTG_SessionValid_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_USB_OTG_SessionValid 
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_USB_OTG_SessionValid function.
60:                  */
61:                  
62:                  PLIB_TEMPLATE bool USB_OTG_SessionValid_Default( USB_MODULE_ID index )
63:                  {
64:                      volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
65:                  	return ( usb->UxOTGSTAT.SESVD );
9D0040C0  8E020020   LW V0, 32(S0)
9D0040C4  7C4200C0   EXT V0, V0, 3, 1
66:                  }
67:                  
68:                  //******************************************************************************
69:                  /* Function :  USB_ExistsOTG_SessionValid_Default
70:                  
71:                    Summary:
72:                      Implements Default variant of PLIB_USB_ExistsOTG_SessionValid
73:                  
74:                    Description:
75:                      This template implements the Default variant of the PLIB_USB_ExistsOTG_SessionValid function.
76:                  */
77:                  
78:                  #define PLIB_USB_ExistsOTG_SessionValid PLIB_USB_ExistsOTG_SessionValid
79:                  PLIB_TEMPLATE bool USB_ExistsOTG_SessionValid_Default( USB_MODULE_ID index )
80:                  {
81:                      return true;
82:                  }
83:                  
84:                  
85:                  #endif /*_USB_OTG_SESSIONVALID_DEFAULT_H*/
86:                  
87:                  /******************************************************************************
88:                   End of File
89:                  */
90:                  
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/usb/templates/usb_OTG_Interrupt_Default.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_OTG_Interrupt_Default.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : OTG_Interrupt
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USB_OTG_InterruptEnable
16:                          PLIB_USB_OTG_InterruptDisable
17:                          PLIB_USB_OTG_InterruptIsEnabled
18:                          PLIB_USB_ExistsOTG_Interrupt
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _USB_OTG_INTERRUPT_DEFAULT_H
49:                  #define _USB_OTG_INTERRUPT_DEFAULT_H
50:                  
51:                  #include "../templates/usb_registers.h"
52:                  
53:                  //******************************************************************************
54:                  /* Function :  USB_OTG_InterruptEnable_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_USB_OTG_InterruptEnable 
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_USB_OTG_InterruptEnable function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE void USB_OTG_InterruptEnable_Default( USB_MODULE_ID index , USB_OTG_INTERRUPTS     interruptFlag )
64:                  {
65:                  	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
9D0137A8  8C820020   LW V0, 32(A0)
66:                  	usb->UxOTGIE.w   |= interruptFlag;
9D0137AC  8C430010   LW V1, 16(V0)
9D0137B0  34630008   ORI V1, V1, 8
9D0137B4  AC430010   SW V1, 16(V0)
67:                  }
68:                  
69:                  //******************************************************************************
70:                  /* Function :  USB_OTG_InterruptDisable_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_USB_OTG_InterruptDisable 
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_USB_OTG_InterruptDisable function.
77:                  */
78:                  
79:                  PLIB_TEMPLATE void USB_OTG_InterruptDisable_Default( USB_MODULE_ID index , USB_OTG_INTERRUPTS     interruptFlag )
80:                  {
81:                      volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
82:                      usb->UxOTGIE.w   &= (~interruptFlag);
9D004158  8E020010   LW V0, 16(S0)
9D00415C  7C022104   INS V0, ZERO, 4, 1
9D004160  AE020010   SW V0, 16(S0)
83:                  }
84:                  
85:                  
86:                  //******************************************************************************
87:                  /* Function :  USB_OTG_InterruptIsEnabled_Default
88:                  
89:                    Summary:
90:                      Implements Default variant of PLIB_USB_OTG_InterruptIsEnabled 
91:                  
92:                    Description:
93:                      This template implements the Default variant of the PLIB_USB_OTG_InterruptIsEnabled function.
94:                  */
95:                  
96:                  PLIB_TEMPLATE bool USB_OTG_InterruptIsEnabled_Default( USB_MODULE_ID index , USB_INTERRUPTS interruptFlag )
97:                  {   
98:                  	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
99:                      return ( ( usb->UxOTGIE.w ) & interruptFlag ? 1 : 0 );
9D0040B0  8E020010   LW V0, 16(S0)
9D0040B4  30420008   ANDI V0, V0, 8
9D004144  8E020010   LW V0, 16(S0)
9D004148  30420010   ANDI V0, V0, 16
100:                 }
101:                 
102:                 
103:                 //******************************************************************************
104:                 /* Function :  USB_ExistsOTG_Interrupt_Default
105:                 
106:                   Summary:
107:                     Implements Default variant of PLIB_USB_ExistsOTG_Interrupt
108:                 
109:                   Description:
110:                     This template implements the Default variant of the PLIB_USB_ExistsOTG_Interrupt function.
111:                 */
112:                 
113:                 #define PLIB_USB_ExistsOTG_Interrupt PLIB_USB_ExistsOTG_Interrupt
114:                 PLIB_TEMPLATE bool USB_ExistsOTG_Interrupt_Default( USB_MODULE_ID index )
115:                 {
116:                     return true;
117:                 }
118:                 
119:                 
120:                 #endif /*_USB_OTG_INTERRUPT_DEFAULT_H*/
121:                 
122:                 /******************************************************************************
123:                  End of File
124:                 */
125:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/usb/templates/usb_OTG_InterruptStatus_Default.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_OTG_InterruptStatus_Default.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : OTG_InterruptStatus
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USB_OTG_InterruptFlagSet
16:                          PLIB_USB_OTG_InterruptFlagClear
17:                          PLIB_USB_OTG_InterruptFlagGet
18:                          PLIB_USB_ExistsOTG_InterruptStatus
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _USB_OTG_INTERRUPTSTATUS_DEFAULT_H
49:                  #define _USB_OTG_INTERRUPTSTATUS_DEFAULT_H
50:                  
51:                  #include "../templates/usb_registers.h"
52:                  
53:                  //******************************************************************************
54:                  /* Function :  USB_OTG_InterruptFlagSet_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_USB_OTG_InterruptFlagSet 
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_USB_OTG_InterruptFlagSet function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE void USB_OTG_InterruptFlagSet_Default( USB_MODULE_ID index , USB_OTG_INTERRUPTS     interruptFlag )
64:                  {
65:                  	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
66:                  	usb->UxOTGIR.w  |= interruptFlag ;
67:                      
68:                  }
69:                  
70:                  //******************************************************************************
71:                  /* Function :  USB_OTG_InterruptFlagClear_Default
72:                  
73:                    Summary:
74:                      Implements Default variant of PLIB_USB_OTG_InterruptFlagClear 
75:                  
76:                    Description:
77:                      This template implements the Default variant of the PLIB_USB_OTG_InterruptFlagClear function.
78:                  */
79:                  
80:                  PLIB_TEMPLATE void USB_OTG_InterruptFlagClear_Default( USB_MODULE_ID index , USB_OTG_INTERRUPTS     interruptFlag )
81:                  {
82:                      volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
83:                  	usb->UxOTGIR.w = interruptFlag ;
9D0040FC  24020008   ADDIU V0, ZERO, 8
9D004100  AE020000   SW V0, 0(S0)
9D004124  240200F5   ADDIU V0, ZERO, 245
9D004128  AE020000   SW V0, 0(S0)
9D004154  AE020000   SW V0, 0(S0)
84:                  
85:                  }
86:                  
87:                  //******************************************************************************
88:                  /* Function :  USB_OTG_InterruptFlagGet_Default
89:                  
90:                    Summary:
91:                      Implements Default variant of PLIB_USB_OTG_InterruptFlagGet 
92:                  
93:                    Description:
94:                      This template implements the Default variant of the PLIB_USB_OTG_InterruptFlagGet function.
95:                  */
96:                  
97:                  PLIB_TEMPLATE bool USB_OTG_InterruptFlagGet_Default( USB_MODULE_ID index , USB_OTG_INTERRUPTS     interruptFlag )
98:                  {
99:                  	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
9D00409C  8C900020   LW S0, 32(A0)
100:                     return (  ( ( ( usb->UxOTGIR.w  ) & ( interruptFlag) )) ? 1 : 0 );
9D0040A0  8E020000   LW V0, 0(S0)
9D0040A4  30420008   ANDI V0, V0, 8
9D004134  8E020000   LW V0, 0(S0)
9D004138  30420010   ANDI V0, V0, 16
101:                 }
102:                 
103:                 
104:                 //******************************************************************************
105:                 /* Function :  USB_ExistsOTG_InterruptStatus_Default
106:                 
107:                   Summary:
108:                     Implements Default variant of PLIB_USB_ExistsOTG_InterruptStatus
109:                 
110:                   Description:
111:                     This template implements the Default variant of the PLIB_USB_ExistsOTG_InterruptStatus function.
112:                 */
113:                 
114:                 #define PLIB_USB_ExistsOTG_InterruptStatus PLIB_USB_ExistsOTG_InterruptStatus
115:                 PLIB_TEMPLATE bool USB_ExistsOTG_InterruptStatus_Default( USB_MODULE_ID index )
116:                 {
117:                     return true;
118:                 }
119:                 
120:                 
121:                 #endif /*_USB_OTG_INTERRUPTSTATUS_DEFAULT_H*/
122:                 
123:                 /******************************************************************************
124:                  End of File
125:                 */
126:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/usb/templates/usb_ModulePower_32Bit16Bit.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_ModulePower_32Bit16Bit.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ModulePower
13:                      and its Variant : 32Bit16Bit
14:                      For following APIs :
15:                          PLIB_USB_Enable
16:                          PLIB_USB_Disable
17:                          PLIB_USB_ExistsModulePower
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _USB_MODULEPOWER_32BIT16BIT_H
48:                  #define _USB_MODULEPOWER_32BIT16BIT_H
49:                  
50:                  #include "../templates/usb_registers.h"
51:                  
52:                  
53:                  //******************************************************************************
54:                  /* Function :  USB_Enable_32Bit16Bit
55:                  
56:                    Summary:
57:                      Implements 32Bit16Bit variant of PLIB_USB_Enable 
58:                  
59:                    Description:
60:                      This template implements the 32Bit16Bit variant of the PLIB_USB_Enable function.
61:                  */
62:                  
63:                      
64:                  PLIB_TEMPLATE void USB_Enable_32Bit16Bit( USB_MODULE_ID index )
65:                  {
66:                      volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
67:                  	usb->UxPWRC.USBPWR = 1;
9D00D874  92220040   LBU V0, 64(S1)
9D00D878  7C620004   INS V0, V1, 0, 1
9D00D87C  A2220040   SB V0, 64(S1)
68:                      
69:                  }
70:                  
71:                  //******************************************************************************
72:                  /* Function :  USB_Disable_32Bit16Bit
73:                  
74:                    Summary:
75:                      Implements 32Bit16Bit variant of PLIB_USB_Disable 
76:                  
77:                    Description:
78:                      This template implements the 32Bit16Bit variant of the PLIB_USB_Disable function.
79:                  */
80:                  
81:                  PLIB_TEMPLATE void USB_Disable_32Bit16Bit( USB_MODULE_ID index )
82:                  {
83:                      volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
84:                  	usb->UxPWRC.USBPWR = 0 ;
85:                   
86:                  }
87:                  
88:                  //******************************************************************************
89:                  /* Function :  USB_ExistsModulePower_32Bit16Bit
90:                  
91:                    Summary:
92:                      Implements 32Bit16Bit variant of PLIB_USB_ExistsModulePower
93:                  
94:                    Description:
95:                      This template implements the 32Bit16Bit variant of the PLIB_USB_ExistsModulePower function.
96:                  */
97:                  
98:                  #define PLIB_USB_ExistsModulePower PLIB_USB_ExistsModulePower
99:                  PLIB_TEMPLATE bool USB_ExistsModulePower_32Bit16Bit( USB_MODULE_ID index )
100:                 {
101:                     return true;
102:                 }
103:                 
104:                 
105:                 #endif /*_USB_MODULEPOWER_32BIT16BIT_H*/
106:                 
107:                 /******************************************************************************
108:                  End of File
109:                 */
110:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/usb/templates/usb_LastTransactionDetails_Default.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_LastTransactionDetails_Default.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : LastTransactionDetails
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USB_LastTransactionDetailsGet
16:                          PLIB_USB_ExistsLastTransactionDetails
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _USB_LASTTRANSACTIONDETAILS_DEFAULT_H
47:                  #define _USB_LASTTRANSACTIONDETAILS_DEFAULT_H
48:                  
49:                  #include "../templates/usb_registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  USB_LastTransactionDetailsGet_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_USB_LastTransactionDetailsGet 
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_USB_LastTransactionDetailsGet function.
59:                  */
60:                  
61:                  PLIB_TEMPLATE void USB_LastTransactionDetailsGet_Default( USB_MODULE_ID index , USB_BUFFER_DIRECTION * direction , USB_PING_PONG_STATE * pingpong , uint8_t * endpoint )
62:                  {
63:                      volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
64:                      *direction = usb->UxSTAT.DIR;
9D0043B8  8E120200   LW S2, 512(S0)
9D0043BC  7E5200C0   EXT S2, S2, 3, 1
9D0043C0  02402821   ADDU A1, S2, ZERO
65:                      *pingpong = usb->UxSTAT.PPBI;
9D0043C4  8E170200   LW S7, 512(S0)
9D0043C8  7EF70080   EXT S7, S7, 2, 1
66:                      *endpoint = usb->UxSTAT.ENDPT;
9D0043CC  8E020200   LW V0, 512(S0)
9D0043D0  7C421900   EXT V0, V0, 4, 4
67:                  }
68:                  
69:                  //******************************************************************************
70:                  /* Function :  USB_ExistsLastTransactionDetails_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_USB_ExistsLastTransactionDetails
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_USB_ExistsLastTransactionDetails function.
77:                  */
78:                  
79:                  #define PLIB_USB_ExistsLastTransactionDetails PLIB_USB_ExistsLastTransactionDetails
80:                  PLIB_TEMPLATE bool USB_ExistsLastTransactionDetails_Default( USB_MODULE_ID index )
81:                  {
82:                      return true;
83:                  }
84:                  
85:                  
86:                  #endif /*_USB_LASTTRANSACTIONDETAILS_DEFAULT_H*/
87:                  
88:                  /******************************************************************************
89:                   End of File
90:                  */
91:                  
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/usb/templates/usb_GEN_Interrupt_Default.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_GEN_Interrupt_Default.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : GEN_Interrupt
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USB_InterruptEnable
16:                          PLIB_USB_InterruptDisable
17:                          PLIB_USB_InterruptIsEnabled
18:                          PLIB_USB_ExistsGEN_Interrupt
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _USB_GEN_INTERRUPT_DEFAULT_H
49:                  #define _USB_GEN_INTERRUPT_DEFAULT_H
50:                  
51:                  #include "../templates/usb_registers.h"
52:                  
53:                  //******************************************************************************
54:                  /* Function :  USB_InterruptEnable_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_USB_InterruptEnable 
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_USB_InterruptEnable
61:                      function.
62:                  */
63:                  
64:                  PLIB_TEMPLATE void USB_InterruptEnable_Default
65:                  ( 
66:                      USB_MODULE_ID index , 
67:                      USB_INTERRUPTS interruptFlag 
68:                  )
69:                  {
70:                      volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
71:                  	usb->UxIE.w  |= interruptFlag ;
9D0042A0  8E0201D0   LW V0, 464(S0)
9D0042A4  34420010   ORI V0, V0, 16
9D0042A8  AE0201D0   SW V0, 464(S0)
9D0042AC  8E0201D0   LW V0, 464(S0)
9D0042B0  34420020   ORI V0, V0, 32
9D0042B4  AE0201D0   SW V0, 464(S0)
72:                  }
73:                  
74:                  //******************************************************************************
75:                  /* Function :  USB_InterruptDisable_Default
76:                  
77:                    Summary:
78:                      Implements Default variant of PLIB_USB_InterruptDisable 
79:                  
80:                    Description:
81:                      This template implements the Default variant of the
82:                      PLIB_USB_InterruptDisable function.
83:                  */
84:                  
85:                  PLIB_TEMPLATE void USB_InterruptDisable_Default
86:                  ( 
87:                      USB_MODULE_ID index , 
88:                      USB_INTERRUPTS interruptFlag 
89:                  )
90:                  {
91:                  	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
92:                  	usb->UxIE.w &= (~interruptFlag);
9D0041C4  8E0201D0   LW V0, 464(S0)
9D0041C8  7C022944   INS V0, ZERO, 5, 1
9D0041CC  AE0201D0   SW V0, 464(S0)
93:                  }
94:                  
95:                  //******************************************************************************
96:                  /* Function :  USB_InterruptIsEnabled_Default
97:                  
98:                    Summary:
99:                      Implements Default variant of PLIB_USB_InterruptIsEnabled 
100:                 
101:                   Description:
102:                     This template implements the Default variant of the
103:                     PLIB_USB_InterruptIsEnabled function.
104:                 */
105:                 
106:                 PLIB_TEMPLATE bool USB_InterruptIsEnabled_Default
107:                 ( 
108:                     USB_MODULE_ID index , 
109:                     USB_INTERRUPTS interruptFlag 
110:                 )
111:                 {
112:                     volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
113:                     return ( (usb->UxIE.w )  & interruptFlag ? 1 : 0 );
9D004190  8E0201D0   LW V0, 464(S0)
9D004194  30420020   ANDI V0, V0, 32
9D0041E0  8E0201D0   LW V0, 464(S0)
9D0041E4  30420001   ANDI V0, V0, 1
9D004270  8E0201D0   LW V0, 464(S0)
9D004274  30420010   ANDI V0, V0, 16
9D0042D0  8E0201D0   LW V0, 464(S0)
9D0042D4  30420004   ANDI V0, V0, 4
9D004310  8E0201D0   LW V0, 464(S0)
9D004314  30420080   ANDI V0, V0, 128
9D00436C  8E0201D0   LW V0, 464(S0)
9D004370  30420002   ANDI V0, V0, 2
114:                 }
115:                 
116:                 //******************************************************************************
117:                 /* Function :  USB_ExistsGEN_Interrupt_Default
118:                 
119:                   Summary:
120:                     Implements Default variant of PLIB_USB_ExistsGEN_Interrupt
121:                 
122:                   Description:
123:                     This template implements the Default variant of the
124:                     PLIB_USB_ExistsGEN_Interrupt function.
125:                 */
126:                 
127:                 #define PLIB_USB_ExistsGEN_Interrupt PLIB_USB_ExistsGEN_Interrupt
128:                 PLIB_TEMPLATE bool USB_ExistsGEN_Interrupt_Default( USB_MODULE_ID index )
129:                 {
130:                     return true;
131:                 }
132:                 
133:                 #endif /*_USB_GEN_INTERRUPT_DEFAULT_H*/
134:                 
135:                 /******************************************************************************
136:                  End of File
137:                 */
138:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/usb/templates/usb_GEN_InterruptStatus_Default.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_GEN_InterruptStatus_Default.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : GEN_InterruptStatus
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USB_InterruptFlagSet
16:                          PLIB_USB_InterruptFlagClear
17:                          PLIB_USB_InterruptFlagGet
18:                          PLIB_USB_ExistsGEN_InterruptStatus
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _USB_GEN_INTERRUPTSTATUS_DEFAULT_H
49:                  #define _USB_GEN_INTERRUPTSTATUS_DEFAULT_H
50:                  
51:                  #include "../templates/usb_registers.h"
52:                  
53:                  //******************************************************************************
54:                  /* Function :  USB_InterruptFlagSet_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_USB_InterruptFlagSet 
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_USB_InterruptFlagSet function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE void USB_InterruptFlagSet_Default( USB_MODULE_ID index , USB_INTERRUPTS interruptFlag )
64:                  {
65:                      volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
66:                      usb->UxIR.w  |= interruptFlag;
67:                  }
68:                  
69:                  //******************************************************************************
70:                  /* Function :  USB_InterruptFlagClear_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_USB_InterruptFlagClear 
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_USB_InterruptFlagClear function.
77:                  */
78:                  
79:                  PLIB_TEMPLATE void USB_InterruptFlagClear_Default( USB_MODULE_ID index , USB_INTERRUPTS interruptFlag )
80:                  {
81:                  	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
9D014490  8C820020   LW V0, 32(A0)
82:                  	usb->UxIR.w  = interruptFlag;
9D004120  AE0201C0   SW V0, 448(S0)
9D0041BC  24020020   ADDIU V0, ZERO, 32
9D0041C0  AE0201C0   SW V0, 448(S0)
9D0041F4  AE0201C0   SW V0, 448(S0)
9D0041F8  24020010   ADDIU V0, ZERO, 16
9D0041FC  AE0201C0   SW V0, 448(S0)
9D004258  24020001   ADDIU V0, ZERO, 1
9D00425C  AE0201C0   SW V0, 448(S0)
9D004298  24020010   ADDIU V0, ZERO, 16
9D00429C  AE0201C0   SW V0, 448(S0)
9D0042F8  24020004   ADDIU V0, ZERO, 4
9D0042FC  AE0201C0   SW V0, 448(S0)
9D004354  24020080   ADDIU V0, ZERO, 128
9D004358  AE0201C0   SW V0, 448(S0)
9D004388  24020002   ADDIU V0, ZERO, 2
9D00438C  AE0201C0   SW V0, 448(S0)
9D0043AC  24160008   ADDIU S6, ZERO, 8
9D0043D4  AE1601C0   SW S6, 448(S0)
9D014494  AC4301C0   SW V1, 448(V0)
83:                  }
84:                  
85:                  //******************************************************************************
86:                  /* Function :  USB_InterruptFlagGet_Default
87:                  
88:                    Summary:
89:                      Implements Default variant of PLIB_USB_InterruptFlagGet 
90:                  
91:                    Description:
92:                      This template implements the Default variant of the PLIB_USB_InterruptFlagGet function.
93:                  */
94:                  
95:                  PLIB_TEMPLATE bool USB_InterruptFlagGet_Default( USB_MODULE_ID index , USB_INTERRUPTS interruptFlag )
96:                  {
97:                      volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
98:                      return ( (( usb->UxIR.w ) & interruptFlag) ? 1 : 0 );
9D004180  8E0201C0   LW V0, 448(S0)
9D004184  30420020   ANDI V0, V0, 32
9D0041D0  8E0201C0   LW V0, 448(S0)
9D0041D4  30420001   ANDI V0, V0, 1
9D004260  8E0201C0   LW V0, 448(S0)
9D004264  30420010   ANDI V0, V0, 16
9D0042C0  8E0201C0   LW V0, 448(S0)
9D0042C4  30420004   ANDI V0, V0, 4
9D004300  8E0201C0   LW V0, 448(S0)
9D004304  30420080   ANDI V0, V0, 128
9D00435C  8E0201C0   LW V0, 448(S0)
9D004360  30420002   ANDI V0, V0, 2
9D004630  8E0201C0   LW V0, 448(S0)
9D004634  30420008   ANDI V0, V0, 8
99:                  }
100:                 
101:                 //******************************************************************************
102:                 /* Function :  USB_InterruptFlagGet_Default
103:                 
104:                   Summary:
105:                     Implements Default variant of PLIB_USB_InterruptFlagAllGet 
106:                 
107:                   Description:
108:                     This template implements the Default variant of the PLIB_USB_InterruptFlagAllGet function.
109:                 */
110:                 
111:                 PLIB_TEMPLATE USB_INTERRUPTS USB_InterruptFlagAllGet_Default( USB_MODULE_ID index )
112:                 {
113:                 	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
114:                 	return (USB_INTERRUPTS) (  usb->UxIR.w ) ;
115:                 }
116:                 
117:                 //******************************************************************************
118:                 /* Function :  USB_ExistsGEN_InterruptStatus_Default
119:                 
120:                   Summary:
121:                     Implements Default variant of PLIB_USB_ExistsGEN_InterruptStatus
122:                 
123:                   Description:
124:                     This template implements the Default variant of the PLIB_USB_ExistsGEN_InterruptStatus function.
125:                 */
126:                 
127:                 #define PLIB_USB_ExistsGEN_InterruptStatus PLIB_USB_ExistsGEN_InterruptStatus
128:                 PLIB_TEMPLATE bool USB_ExistsGEN_InterruptStatus_Default( USB_MODULE_ID index )
129:                 {
130:                     return true;
131:                 }
132:                 
133:                 
134:                 #endif /*_USB_GEN_INTERRUPTSTATUS_DEFAULT_H*/
135:                 
136:                 /******************************************************************************
137:                  End of File
138:                 */
139:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/usb/templates/usb_FrameNumber_Default.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_FrameNumber_Default.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : FrameNumber
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USB_FrameNumberGet
16:                          PLIB_USB_ExistsFrameNumber
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _USB_FRAMENUMBER_DEFAULT_H
47:                  #define _USB_FRAMENUMBER_DEFAULT_H
48:                  
49:                  #include "../templates/usb_registers.h"
50:                  
51:                  
52:                  //******************************************************************************
53:                  /* Function :  USB_FrameNumberGet_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_USB_FrameNumberGet 
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_USB_FrameNumberGet
60:                      function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE uint16_t USB_FrameNumberGet_Default( USB_MODULE_ID index )
64:                  {
65:                      uint16_t retval;
66:                  	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
9D014F44  8C830020   LW V1, 32(A0)
67:                  	retval =  (( usb->UxFRML.FRML ) |   ( usb->UxFRMH.FRMH << 8 ) );
9D014F48  90640240   LBU A0, 576(V1)
9D014F4C  308400FF   ANDI A0, A0, 255
9D014F50  8C620250   LW V0, 592(V1)
9D014F54  30420007   ANDI V0, V0, 7
9D014F58  00021200   SLL V0, V0, 8
9D014F5C  03E00008   JR RA
9D014F60  00441025   OR V0, V0, A0
68:                      return retval;
69:                  }
70:                  
71:                  //******************************************************************************
72:                  /* Function :  USB_ExistsFrameNumber_Default
73:                  
74:                    Summary:
75:                      Implements Default variant of PLIB_USB_ExistsFrameNumber
76:                  
77:                    Description:
78:                      This template implements the Default variant of the
79:                      PLIB_USB_ExistsFrameNumber function.
80:                  */
81:                  
82:                  #define PLIB_USB_ExistsFrameNumber PLIB_USB_ExistsFrameNumber
83:                  PLIB_TEMPLATE bool USB_ExistsFrameNumber_Default( USB_MODULE_ID index )
84:                  {
85:                      return true;
86:                  }
87:                  
88:                  #endif /*_USB_FRAMENUMBER_DEFAULT_H*/
89:                  
90:                  /******************************************************************************
91:                   End of File
92:                  */
93:                  
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/usb/templates/usb_ERR_InterruptStatus_Default.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_ERR_InterruptStatus_Default.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ERR_InterruptStatus
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USB_ErrorInterruptFlagSet
16:                          PLIB_USB_ErrorInterruptFlagClear
17:                          PLIB_USB_ErrorInterruptFlagGet
18:                          PLIB_USB_ExistsERR_InterruptStatus
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _USB_ERR_INTERRUPTSTATUS_DEFAULT_H
49:                  #define _USB_ERR_INTERRUPTSTATUS_DEFAULT_H
50:                  
51:                  #include "../templates/usb_registers.h"
52:                  
53:                  //******************************************************************************
54:                  /* Function :  USB_ErrorInterruptFlagSet_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_USB_ErrorInterruptFlagSet 
58:                  
59:                    Description:
60:                      This template implements the Default variant of the
61:                      PLIB_USB_ErrorInterruptFlagSet function.
62:                  */
63:                  
64:                  PLIB_TEMPLATE void USB_ErrorInterruptFlagSet_Default
65:                  ( 
66:                      USB_MODULE_ID index , 
67:                      USB_ERROR_INTERRUPTS   interruptFlag 
68:                  )
69:                  {
70:                  	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
71:                  	usb->UxEIR.w |=  interruptFlag ;
72:                     
73:                  }
74:                  
75:                  //******************************************************************************
76:                  /* Function :  USB_ErrorInterruptFlagClear_Default
77:                  
78:                    Summary:
79:                      Implements Default variant of PLIB_USB_ErrorInterruptFlagClear 
80:                  
81:                    Description:
82:                      This template implements the Default variant of the
83:                      PLIB_USB_ErrorInterruptFlagClear function.
84:                  */
85:                  
86:                  PLIB_TEMPLATE void USB_ErrorInterruptFlagClear_Default
87:                  ( 
88:                      USB_MODULE_ID index , 
89:                      USB_ERROR_INTERRUPTS interruptFlag 
90:                  )
91:                  {
92:                   	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
93:                  	usb->UxEIR.w = interruptFlag ;
9D00411C  AE0201E0   SW V0, 480(S0)
9D004384  AE0201E0   SW V0, 480(S0)
94:                  }
95:                  
96:                  //******************************************************************************
97:                  /* Function :  USB_ErrorInterruptFlagGet_Default
98:                  
99:                    Summary:
100:                     Implements Default variant of PLIB_USB_ErrorInterruptFlagGet 
101:                 
102:                   Description:
103:                     This template implements the Default variant of the
104:                     PLIB_USB_ErrorInterruptFlagGet function.
105:                 */
106:                 
107:                 PLIB_TEMPLATE bool USB_ErrorInterruptFlagGet_Default
108:                 ( 
109:                     USB_MODULE_ID index , 
110:                     USB_ERROR_INTERRUPTS interruptFlag 
111:                 )
112:                 {
113:                 	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
114:                     return ( ( usb->UxEIR.w) & interruptFlag ? 1 : 0 );
115:                 }
116:                 
117:                 //******************************************************************************
118:                 /* Function :  USB_ErrorInterruptFlagAllGet_Default
119:                 
120:                   Summary:
121:                     Implements Default variant of PLIB_USB_ErrorInterruptFlagAllGet 
122:                 
123:                   Description:
124:                     This template implements the Default variant of the
125:                     PLIB_USB_ErrorInterruptFlagAllGet function.
126:                 */
127:                 
128:                 PLIB_TEMPLATE USB_ERROR_INTERRUPTS USB_ErrorInterruptFlagAllGet_Default( USB_MODULE_ID index )
129:                 {
130:                 	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
131:                     return (USB_ERROR_INTERRUPTS)( usb->UxEIR.w);
9D00437C  8E0201E0   LW V0, 480(S0)
132:                 
133:                 }
134:                 
135:                 //******************************************************************************
136:                 /* Function :  USB_ExistsERR_InterruptStatus_Default
137:                 
138:                   Summary:
139:                     Implements Default variant of PLIB_USB_ExistsERR_InterruptStatus
140:                 
141:                   Description:
142:                     This template implements the Default variant of the
143:                     PLIB_USB_ExistsERR_InterruptStatus function.
144:                 */
145:                 
146:                 #define PLIB_USB_ExistsERR_InterruptStatus PLIB_USB_ExistsERR_InterruptStatus
147:                 PLIB_TEMPLATE bool USB_ExistsERR_InterruptStatus_Default( USB_MODULE_ID index )
148:                 {
149:                     return true;
150:                 }
151:                 
152:                 
153:                 #endif /*_USB_ERR_INTERRUPTSTATUS_DEFAULT_H*/
154:                 
155:                 /******************************************************************************
156:                  End of File
157:                 */
158:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/usb/templates/usb_EPnRxEnableEnhanced_PIC32.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_EPnRxEnableEnhanced_PIC32.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : EPnRxEnableEnhanced
13:                      and its Variant : PIC32
14:                      For following APIs :
15:                          PLIB_USB_EPnRxEnable
16:                          PLIB_USB_ExistsEPnRxEnable
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _USB_EPNRXENABLEENHANCED_PIC32_H
47:                  #define _USB_EPNRXENABLEENHANCED_PIC32_H
48:                  
49:                  #include "../templates/usb_registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  USB_EPnRxEnable_PIC32
53:                  
54:                    Summary:
55:                      Implements PIC32 variant of PLIB_USB_EPnRxEnable 
56:                  
57:                    Description:
58:                      This template implements the PIC32 variant of the PLIB_USB_EPnRxEnable
59:                      function.
60:                  */
61:                  
62:                  PLIB_TEMPLATE void USB_EPnRxEnable_PIC32
63:                  ( 
64:                      USB_MODULE_ID index , 
65:                      uint8_t endpoint 
66:                  )
67:                  {
68:                      volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
69:                      usb->UxEP[endpoint].UxEPbits.EPRXEN = 1;
70:                  }
71:                  
72:                  //******************************************************************************
73:                  /* Function :  USB_EPnRxDisable_PIC32
74:                  
75:                    Summary:
76:                      Implements PIC32 variant of PLIB_USB_EPnRxDisable 
77:                  
78:                    Description:
79:                      This template implements the PIC32 variant of the PLIB_USB_EPnRxDisable
80:                      function.
81:                  */
82:                  
83:                  PLIB_TEMPLATE void USB_EPnRxDisable_PIC32
84:                  ( 
85:                      USB_MODULE_ID index , 
86:                      uint8_t endpoint 
87:                  )
88:                  {
89:                      volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
90:                      usb->UxEP[endpoint].UxEPbits.EPRXEN = 0;
91:                  }
92:                  
93:                  //******************************************************************************
94:                  /* Function :  USB_EPnTxEnable_PIC32
95:                  
96:                    Summary:
97:                      Implements PIC32 variant of PLIB_USB_EPnTxEnable 
98:                  
99:                    Description:
100:                     This template implements the PIC32 variant of the PLIB_USB_EPnTxEnable
101:                     function.
102:                 */
103:                 
104:                 PLIB_TEMPLATE void USB_EPnTxEnable_PIC32
105:                 ( 
106:                     USB_MODULE_ID index , 
107:                     uint8_t endpoint 
108:                 )
109:                 {
110:                     volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
111:                     usb->UxEP[endpoint].UxEPbits.EPTXEN = 1;
112:                 }
113:                 
114:                 //******************************************************************************
115:                 /* Function :  USB_EPnTxDisable_PIC32
116:                 
117:                   Summary:
118:                     Implements PIC32 variant of PLIB_USB_EPnTxDisable 
119:                 
120:                   Description:
121:                     This template implements the PIC32 variant of the PLIB_USB_EPnTxDisable
122:                     function.
123:                 */
124:                 
125:                 PLIB_TEMPLATE void USB_EPnTxDisable_PIC32
126:                 ( 
127:                     USB_MODULE_ID index , 
128:                     uint8_t endpoint 
129:                 )
130:                 {
131:                     volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
132:                     usb->UxEP[endpoint].UxEPbits.EPTXEN = 0;
133:                 }
134:                 
135:                 //******************************************************************************
136:                 /* Function :  USB_EPnHandshakeEnable_PIC32
137:                 
138:                   Summary:
139:                     Implements PIC32 variant of PLIB_USB_EPnTxEnable 
140:                 
141:                   Description:
142:                     This template implements the PIC32 variant of the PLIB_USB_EPnTxEnable
143:                     function.
144:                 */
145:                 
146:                 PLIB_TEMPLATE void USB_EPnHandshakeEnable_PIC32
147:                 ( 
148:                     USB_MODULE_ID index , 
149:                     uint8_t endpoint 
150:                 )
151:                 {
152:                     volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
153:                     usb->UxEP[endpoint].UxEPbits.EPHSHK = 1;
154:                    
155:                 }
156:                 
157:                 //******************************************************************************
158:                 /* Function :  USB_EPnTxDisable_PIC32
159:                 
160:                   Summary:
161:                     Implements PIC32 variant of PLIB_USB_EPnTxDisable 
162:                 
163:                   Description:
164:                     This template implements the PIC32 variant of the PLIB_USB_EPnTxDisable
165:                     function.
166:                 */
167:                 
168:                 PLIB_TEMPLATE void USB_EPnHandshakeDisable_PIC32
169:                 ( 
170:                     USB_MODULE_ID index , 
171:                     uint8_t endpoint 
172:                 )
173:                 {
174:                     volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
175:                     usb->UxEP[endpoint].UxEPbits.EPHSHK = 0;
176:                 }
177:                 
178:                 //******************************************************************************
179:                 /* Function :  USB_EPnControlTransferEnable_PIC32
180:                 
181:                   Summary:
182:                     Implements PIC32 variant of PLIB_USB_EPnControlTransferEnable 
183:                 
184:                   Description:
185:                     This template implements the PIC32 variant of the
186:                     PLIB_USB_EPnControlTransferEnable function.
187:                 */
188:                 
189:                 PLIB_TEMPLATE void USB_EPnControlTransferEnable_PIC32
190:                 ( 
191:                     USB_MODULE_ID index , 
192:                     uint8_t endpoint 
193:                 )
194:                 {
195:                     volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
196:                     usb->UxEP[endpoint].w &= (~UxEP_EPCONDIS_MASK);
197:                     usb->UxEP[endpoint].w |= (UxEP_EPTXEN_MASK|UxEP_EPRXEN_MASK);
198:                 }
199:                 
200:                 PLIB_TEMPLATE void USB_EPnAttributesSet_PIC32
201:                 (
202:                     USB_MODULE_ID index, 
203:                     uint8_t endpoint, 
204:                     int direction, 
205:                     bool isControl, 
206:                     bool handshake
207:                 )
208:                 {
209:                     volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
210:                 
211:                     if(isControl)
212:                     {
213:                         usb->UxEP[endpoint].w &= (~UxEP_EPCONDIS_MASK);
9D00DC28  8D2202C0   LW V0, 704(T1)
9D00DC2C  7C022104   INS V0, ZERO, 4, 1
9D00DC30  AD2202C0   SW V0, 704(T1)
214:                         usb->UxEP[endpoint].w |= (UxEP_EPTXEN_MASK|UxEP_EPRXEN_MASK|UxEP_EPHSHK_MASK);
9D00DC34  8D2202C0   LW V0, 704(T1)
9D00DC38  3442000D   ORI V0, V0, 13
9D00DC3C  AD2202C0   SW V0, 704(T1)
215:                     }
216:                     else 
217:                 	{  
218:                 		/* Set the direction and handshake */
219:                         usb->UxEP[endpoint].w |= ((UxEP_EPRXEN_MASK >> direction)|handshake);
9D00DCB4  8D2802C0   LW T0, 704(T1)
9D00DCB8  240A0008   ADDIU T2, ZERO, 8
9D00DCBC  00AA5007   SRAV T2, T2, A1
9D00DCC8  01421025   OR V0, T2, V0
9D00DCCC  00481025   OR V0, V0, T0
9D00DCD0  AD2202C0   SW V0, 704(T1)
220:                 	}
221:                 }
222:                 
223:                 PLIB_TEMPLATE void USB_EPnAttributesClear_PIC32
224:                 (
225:                     USB_MODULE_ID index, 
226:                     uint8_t endpoint
227:                 )
228:                 {
229:                     volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
230:                     
231:                     usb->UxEP[endpoint].w |= UxEP_EPCONDIS_MASK;
9D0100F8  8C4302C0   LW V1, 704(V0)
9D0100FC  34630010   ORI V1, V1, 16
9D010100  AC4302C0   SW V1, 704(V0)
9D01015C  8C4402C0   LW A0, 704(V0)
9D010160  34840010   ORI A0, A0, 16
9D010164  AC4402C0   SW A0, 704(V0)
232:                     usb->UxEP[endpoint].w &= (~(UxEP_EPTXEN_MASK|UxEP_EPRXEN_MASK|UxEP_EPHSHK_MASK));
9D010104  8C4502C0   LW A1, 704(V0)
9D010108  2403FFF2   ADDIU V1, ZERO, -14
9D01010C  00A31824   AND V1, A1, V1
9D010110  AC4302C0   SW V1, 704(V0)
9D010168  8C4502C0   LW A1, 704(V0)
9D01016C  2404FFF2   ADDIU A0, ZERO, -14
9D010170  00A42024   AND A0, A1, A0
9D010174  AC4402C0   SW A0, 704(V0)
233:                 }
234:                 
235:                 PLIB_TEMPLATE void USB_EPnDirectionDisable_PIC32
236:                 (
237:                     USB_MODULE_ID index, 
238:                     uint8_t endpoint, 
239:                     int direction
240:                 )
241:                 {
242:                     volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
243:                     usb->UxEP[endpoint].w &= (~(UxEP_EPRXEN_MASK >> direction));
9D010198  8C4402C0   LW A0, 704(V0)
9D01019C  24050008   ADDIU A1, ZERO, 8
9D0101A0  00C53007   SRAV A2, A1, A2
9D0101A4  00063027   NOR A2, ZERO, A2
9D0101A8  00C43024   AND A2, A2, A0
9D0101AC  AC4602C0   SW A2, 704(V0)
244:                 }
245:                 
246:                 //******************************************************************************
247:                 /* Function :  USB_EPnControlTransferDisable_PIC32
248:                 
249:                   Summary:
250:                     Implements PIC32 variant of PLIB_USB_EPnControlTransferDisable 
251:                 
252:                   Description:
253:                     This template implements the PIC32 variant of the
254:                     PLIB_USB_EPnControlTransferDisable function.
255:                 */
256:                 
257:                 PLIB_TEMPLATE void USB_EPnControlTransferDisable_PIC32
258:                 ( 
259:                     USB_MODULE_ID index , 
260:                     uint8_t endpoint 
261:                 )
262:                 {
263:                     volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
264:                     usb->UxEP[endpoint].UxEPbits.EPCONDIS = 1;
265:                 }
266:                 
267:                 //******************************************************************************
268:                 /* Function :  USB_EPnIsStalled_PIC32
269:                 
270:                   Summary:
271:                     Implements PIC32 variant of PLIB_USB_EPnIsStalled 
272:                 
273:                   Description:
274:                     This template implements the PIC32 variant of the PLIB_USB_EPnIsStalled 
275:                     function.
276:                 */
277:                 
278:                 PLIB_TEMPLATE bool USB_EPnIsStalled_PIC32
279:                 ( 
280:                     USB_MODULE_ID index , 
281:                     uint8_t endpoint 
282:                 )
283:                 {
284:                     volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
285:                 	return ( usb->UxEP[endpoint].UxEPbits.EPSTALL );
9D004320  8E0202C0   LW V0, 704(S0)
9D004324  7C420040   EXT V0, V0, 1, 1
286:                 }
287:                 
288:                 //******************************************************************************
289:                 /* Function :  USB_EPnStallClear_PIC32
290:                 
291:                   Summary:
292:                     Implements PIC32 variant of PLIB_USB_EPnStallClear 
293:                 
294:                   Description:
295:                     This template implements the PIC32 variant of the PLIB_USB_EPnStallClear 
296:                     function.
297:                 */
298:                 
299:                 PLIB_TEMPLATE void USB_EPnStallClear_PIC32
300:                 (
301:                     USB_MODULE_ID index , 
302:                     uint8_t endpoint 
303:                 )
304:                 {
305:                     volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
306:                     usb->UxEP[endpoint].UxEPbits.EPSTALL = 0;
9D004330  920202C0   LBU V0, 704(S0)
9D004334  7C020844   INS V0, ZERO, 1, 1
9D004338  A20202C0   SB V0, 704(S0)
307:                 }
308:                 
309:                 
310:                 PLIB_TEMPLATE void USB_EP0HostSetup_PIC32(USB_MODULE_ID index)
311:                 {
312:                     volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
313:                 	
314:                 	usb->UxEP[0].w = 0x00 ;
315:                 	
316:                     /* Set up endpoint 0 for typical host operation.
317:                      * Enable Transmit, Receive, Control Transfers, Handshake
318:                      * Disable NAK Retry and Low speed connect */
319:                     
320:                     usb->UxEP[0].w |= (UxEP0_RETRYDIS_MASK|UxEP_EPHSHK_MASK|UxEP_EPTXEN_MASK|UxEP_EPRXEN_MASK);
321:                 }
322:                 
323:                 //******************************************************************************
324:                 /* Function :  USB_ExistsEPnRxEnable_PIC32
325:                 
326:                   Summary:
327:                     Implements PIC32 variant of PLIB_USB_ExistsEPnRxEnable
328:                 
329:                   Description:
330:                     This template implements the PIC32 variant of the PLIB_USB_ExistsEPnRxEnable
331:                     function.
332:                 */
333:                 
334:                 #define PLIB_USB_ExistsEPnRxEnable PLIB_USB_ExistsEPnRxEnable
335:                 PLIB_TEMPLATE bool USB_ExistsEPnRxEnable_PIC32( USB_MODULE_ID index )
336:                 {
337:                     return true;
338:                 }
339:                 
340:                 
341:                 #endif /*_USB_EPNRXENABLEENHANCED_PIC32_H*/
342:                 
343:                 /******************************************************************************
344:                  End of File
345:                 */
346:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/usb/templates/usb_DeviceAddress_Default.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_DeviceAddress_Default.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : DeviceAddress
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USB_DeviceAddressSet
16:                          PLIB_USB_DeviceAddressGet
17:                          PLIB_USB_ExistsDeviceAddress
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _USB_DEVICEADDRESS_DEFAULT_H
48:                  #define _USB_DEVICEADDRESS_DEFAULT_H
49:                  
50:                  #include "../templates/usb_registers.h"
51:                  
52:                  
53:                  //******************************************************************************
54:                  /* Function :  USB_DeviceAddressSet_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_USB_DeviceAddressSet 
58:                  
59:                    Description:
60:                      This template implements the Default variant of the
61:                      PLIB_USB_DeviceAddressSet function.
62:                  */
63:                  
64:                  PLIB_TEMPLATE void USB_DeviceAddressSet_Default
65:                  ( 
66:                      USB_MODULE_ID index , 
67:                      uint8_t address 
68:                  )
69:                  {
70:                      volatile usb_registers_t  * usb = ((usb_registers_t *)(index));
9D0153A4  8C820020   LW V0, 32(A0)
71:                  	usb->UxADDR.DEVADDR = ( address & 0x7F ) ;
9D004234  92020220   LBU V0, 544(S0)
9D004238  7C023004   INS V0, ZERO, 0, 7
9D00423C  A2020220   SB V0, 544(S0)
9D0153A8  90430220   LBU V1, 544(V0)
72:                  }
73:                  
74:                  //******************************************************************************
75:                  /* Function :  USB_DeviceAddressGet_Default
76:                  
77:                    Summary:
78:                      Implements Default variant of PLIB_USB_DeviceAddressGet 
79:                  
80:                    Description:
81:                      This template implements the Default variant of the
82:                      PLIB_USB_DeviceAddressGet function.
83:                  */
84:                  
85:                  PLIB_TEMPLATE uint8_t USB_DeviceAddressGet_Default( USB_MODULE_ID index )
86:                  {
87:                      volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
88:                      return ( usb->UxADDR.DEVADDR );
89:                  }
90:                  
91:                  
92:                  //******************************************************************************
93:                  /* Function :  USB_ExistsDeviceAddress_Default
94:                  
95:                    Summary:
96:                      Implements Default variant of PLIB_USB_ExistsDeviceAddress
97:                  
98:                    Description:
99:                      This template implements the Default variant of the
100:                     PLIB_USB_ExistsDeviceAddress function.
101:                 */
102:                 
103:                 #define PLIB_USB_ExistsDeviceAddress PLIB_USB_ExistsDeviceAddress
104:                 PLIB_TEMPLATE bool USB_ExistsDeviceAddress_Default( USB_MODULE_ID index )
105:                 {
106:                     return true;
107:                 }
108:                 
109:                 
110:                 #endif /*_USB_DEVICEADDRESS_DEFAULT_H*/
111:                 
112:                 /******************************************************************************
113:                  End of File
114:                 */
115:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/usb/templates/usb_BufferFreeze_Default.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_BufferFreeze_Default.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : BufferFreeze
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USB_PingPongFreeze
16:                          PLIB_USB_PingPongUnfreeze
17:                          PLIB_USB_ExistsBufferFreeze
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _USB_BUFFERFREEZE_DEFAULT_H
48:                  #define _USB_BUFFERFREEZE_DEFAULT_H
49:                  
50:                  #include "../templates/usb_registers.h"
51:                  
52:                  
53:                  //******************************************************************************
54:                  /* Function :  USB_PingPongFreeze_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_USB_PingPongFreeze 
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_USB_PingPongFreeze
61:                      function.
62:                  */
63:                  
64:                  PLIB_TEMPLATE void USB_PingPongFreeze_Default( USB_MODULE_ID index )
65:                  {
66:                  	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
67:                  	usb->UxCON.w |=  UxCON_PPBRST_MASK ;
68:                    
69:                  }
70:                  
71:                  //******************************************************************************
72:                  /* Function :  USB_PingPongUnfreeze_Default
73:                  
74:                    Summary:
75:                      Implements Default variant of PLIB_USB_PingPongUnfreeze 
76:                  
77:                    Description:
78:                      This template implements the Default variant of the
79:                      PLIB_USB_PingPongUnfreeze function.
80:                  */
81:                  
82:                  PLIB_TEMPLATE void USB_PingPongUnfreeze_Default( USB_MODULE_ID index )
83:                  {
84:                  
85:                  	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
86:                  	usb->UxCON.w &= ( ~ UxCON_PPBRST_MASK);
87:                      
88:                  }
89:                  
90:                  //******************************************************************************
91:                  /* Function :  USB_PingPongReset_Default
92:                  
93:                    Summary:
94:                      Implements Default variant of PLIB_USB_PingPongReset 
95:                  
96:                    Description:
97:                      This template implements the Default variant of the PLIB_USB_PingPongReset
98:                      function.
99:                  */
100:                 
101:                 PLIB_TEMPLATE void USB_PingPongReset_Default( USB_MODULE_ID index )
102:                 {
103:                 
104:                     volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
105:                     usb->UxCON.w |= UxCON_PPBRST_MASK;
9D004214  8E020210   LW V0, 528(S0)
9D004218  34420002   ORI V0, V0, 2
9D00421C  AE020210   SW V0, 528(S0)
106:                 	usb->UxCON.w &= ( ~ UxCON_PPBRST_MASK);
9D004220  8E020210   LW V0, 528(S0)
9D004224  7C020844   INS V0, ZERO, 1, 1
9D004228  AE020210   SW V0, 528(S0)
107:                 }
108:                 
109:                 
110:                 //******************************************************************************
111:                 /* Function :  USB_ExistsBufferFreeze_Default
112:                 
113:                   Summary:
114:                     Implements Default variant of PLIB_USB_ExistsBufferFreeze
115:                 
116:                   Description:
117:                     This template implements the Default variant of the
118:                     PLIB_USB_ExistsBufferFreeze function.
119:                 */
120:                 
121:                 #define PLIB_USB_ExistsBufferFreeze PLIB_USB_ExistsBufferFreeze
122:                 PLIB_TEMPLATE bool USB_ExistsBufferFreeze_Default( USB_MODULE_ID index )
123:                 {
124:                     return true;
125:                 }
126:                 
127:                 
128:                 #endif /*_USB_BUFFERFREEZE_DEFAULT_H*/
129:                 
130:                 /******************************************************************************
131:                  End of File
132:                 */
133:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/usb/templates/usb_BDTBaseAddress_Default.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_BDTBaseAddress_Default.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : BDTBaseAddress
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USB_BDTBaseAddressGet
16:                          PLIB_USB_BDTBaseAddressSet
17:                          PLIB_USB_ExistsBDTBaseAddress
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _USB_BDTBASEADDRESS_DEFAULT_H
48:                  #define _USB_BDTBASEADDRESS_DEFAULT_H
49:                  
50:                  #include "../templates/usb_registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  USB_BDTBaseAddressGet_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_USB_BDTBaseAddressGet 
57:                  
58:                    Description:
59:                      This template implements the Default variant of the
60:                      PLIB_USB_BDTBaseAddressGet function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE void* USB_BDTBaseAddressGet_Default( USB_MODULE_ID index )
64:                  {
65:                      uint32_t retval;
66:                  	volatile usb_registers_t * usb = ((usb_registers_t *)(index));
67:                  	
68:                      retval = ( ( usb->UxBDTP3.BDTPTRU << 24 ) | ( usb->UxBDTP2.BDTPTRH << 16 ) | ( usb->UxBDTP1.BDTPTRL << 9 ) );
69:                  	
70:                  	return ( void * )retval;
71:                  }
72:                  
73:                  //******************************************************************************
74:                  /* Function :  USB_BDTBaseAddressSet_Default
75:                  
76:                    Summary:
77:                      Implements Default variant of PLIB_USB_BDTBaseAddressSet 
78:                  
79:                    Description:
80:                      This template implements the Default variant of the
81:                      PLIB_USB_BDTBaseAddressSet function.
82:                  */
83:                  
84:                  PLIB_TEMPLATE void USB_BDTBaseAddressSet_Default( USB_MODULE_ID index , void* address )
85:                  {
86:                      volatile usb_registers_t * usb = ((usb_registers_t *)(index));
87:                  	uint32_t value = (uint32_t) address;
88:                  	usb->UxBDTP3.BDTPTRU = ( value >> 24 ) & 0xFF ;
9D00D8FC  00022602   SRL A0, V0, 24
9D00D900  A2240290   SB A0, 656(S1)
89:                  	usb->UxBDTP2.BDTPTRH = ( value >> 16 ) & 0xFF ;
9D00D904  7C443C00   EXT A0, V0, 16, 8
9D00D908  A2240280   SB A0, 640(S1)
90:                  	usb->UxBDTP1.BDTPTRL = ( value >> 9 ) & 0x7F;
9D00D90C  7C423240   EXT V0, V0, 9, 7
9D00D910  92240230   LBU A0, 560(S1)
9D00D914  7C443844   INS A0, V0, 1, 7
9D00D918  A2240230   SB A0, 560(S1)
91:                  }
92:                  
93:                  //******************************************************************************
94:                  /* Function :  USB_ExistsBDTBaseAddress_Default
95:                  
96:                    Summary:
97:                      Implements Default variant of PLIB_USB_ExistsBDTBaseAddress
98:                  
99:                    Description:
100:                     This template implements the Default variant of the
101:                     PLIB_USB_ExistsBDTBaseAddress function.
102:                 */
103:                 
104:                 #define PLIB_USB_ExistsBDTBaseAddress PLIB_USB_ExistsBDTBaseAddress
105:                 PLIB_TEMPLATE bool USB_ExistsBDTBaseAddress_Default( USB_MODULE_ID index )
106:                 {
107:                     return true;
108:                 }
109:                 
110:                 
111:                 #endif /*_USB_BDTBASEADDRESS_DEFAULT_H*/
112:                 
113:                 /******************************************************************************
114:                  End of File
115:                 */
116:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/usb/templates/usb_AutomaticSuspend_Default.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_AutomaticSuspend_Default.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : AutomaticSuspend
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USB_AutoSuspendDisable
16:                          PLIB_USB_AutoSuspendEnable
17:                          PLIB_USB_ExistsAutomaticSuspend
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _USB_AUTOMATICSUSPEND_DEFAULT_H
48:                  #define _USB_AUTOMATICSUSPEND_DEFAULT_H
49:                  
50:                  #include "../templates/usb_registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  USB_AutoSuspendDisable_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_USB_AutoSuspendDisable 
57:                  
58:                    Description:
59:                      This template implements the Default variant of the
60:                      PLIB_USB_AutoSuspendDisable function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE void USB_AutoSuspendDisable_Default( USB_MODULE_ID index )
64:                  {
65:                  	volatile usb_registers_t * usb = ((usb_registers_t *)(index));
66:                  	usb->UxCNFG1CLR =  UxCNFG1_UASUSPND_MASK ;
9D00D8C8  AE2202A4   SW V0, 676(S1)
67:                  }
68:                  
69:                  //******************************************************************************
70:                  /* Function :  USB_AutoSuspendEnable_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_USB_AutoSuspendEnable 
74:                  
75:                    Description:
76:                      This template implements the Default variant of the
77:                      PLIB_USB_AutoSuspendEnable function.
78:                  */
79:                  
80:                  PLIB_TEMPLATE void USB_AutoSuspendEnable_Default( USB_MODULE_ID index )
81:                  {
82:                      volatile usb_registers_t * usb = ((usb_registers_t *)(index));
83:                  	usb->UxCNFG1SET =  UxCNFG1_UASUSPND_MASK ;
9D00D8BC  AE2202A8   SW V0, 680(S1)
84:                  }
85:                  
86:                  //******************************************************************************
87:                  /* Function :  USB_ExistsAutomaticSuspend_Default
88:                  
89:                    Summary:
90:                      Implements Default variant of PLIB_USB_ExistsAutomaticSuspend
91:                  
92:                    Description:
93:                      This template implements the Default variant of the
94:                      PLIB_USB_ExistsAutomaticSuspend function.
95:                  */
96:                  
97:                  #define PLIB_USB_ExistsAutomaticSuspend PLIB_USB_ExistsAutomaticSuspend
98:                  PLIB_TEMPLATE bool USB_ExistsAutomaticSuspend_Default( USB_MODULE_ID index )
99:                  {
100:                     return true;
101:                 }
102:                 
103:                 
104:                 #endif /*_USB_AUTOMATICSUSPEND_DEFAULT_H*/
105:                 
106:                 /******************************************************************************
107:                  End of File
108:                 */
109:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/usb/templates/usb_ALL_Interrupt_Default.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_ALL_Interrupt_Default.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ALL_Interrupt
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USB_AllInterruptEnable
16:                          PLIB_USB_ExistsALL_Interrupt
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _USB_ALL_INTERRUPT_DEFAULT_H
47:                  #define _USB_ALL_INTERRUPT_DEFAULT_H
48:                  
49:                  #include "../templates/usb_registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  USB_AllInterruptEnable_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_USB_AllInterruptEnable 
56:                  
57:                    Description:
58:                      This template implements the Default variant of the
59:                      PLIB_USB_AllInterruptEnable function.
60:                  */
61:                  
62:                  PLIB_TEMPLATE void USB_AllInterruptEnable_Default
63:                  ( 
64:                      USB_MODULE_ID index , 
65:                      USB_INTERRUPTS usbInterruptsFlag , 
66:                      USB_ERROR_INTERRUPTS usbErrorInterruptsFlag , 
67:                      USB_OTG_INTERRUPTS otgInterruptFlag 
68:                  )
69:                  {
70:                      volatile usb_registers_t * usb = ((usb_registers_t *)(index));
9D013540  8C820020   LW V0, 32(A0)
9D015164  8C820020   LW V0, 32(A0)
71:                  	usb->UxIE.w = usbInterruptsFlag;
9D013544  240300DF   ADDIU V1, ZERO, 223
9D013548  AC4301D0   SW V1, 464(V0)
9D015168  2403FF00   ADDIU V1, ZERO, -256
9D01516C  AC4301D0   SW V1, 464(V0)
72:                      usb->UxEIE.w = usbErrorInterruptsFlag;
9D01354C  240300FF   ADDIU V1, ZERO, 255
9D013550  AC4301F0   SW V1, 496(V0)
9D015170  AC4301F0   SW V1, 496(V0)
73:                  	usb->UxOTGIE.w = otgInterruptFlag;
9D013554  2403FF1A   ADDIU V1, ZERO, -230
9D015174  2403FF02   ADDIU V1, ZERO, -254
74:                  }
75:                  
76:                  //******************************************************************************
77:                  /* Function :  USB_InterruptEnableGet_Default
78:                  
79:                    Summary:
80:                      Implements Default variant of PLIB_USB_InterruptEnableGet 
81:                  
82:                    Description:
83:                      This template implements the Default variant of the
84:                      PLIB_USB_InterruptEnableGet function.
85:                  */
86:                  
87:                  PLIB_TEMPLATE USB_INTERRUPTS USB_InterruptEnableGet_Default 
88:                  (
89:                      USB_MODULE_ID index
90:                  )
91:                  {
92:                      volatile usb_registers_t * usb = ((usb_registers_t *)(index));
93:                      return (USB_INTERRUPTS)( usb->UxIE.w );
94:                  }
95:                  
96:                  //******************************************************************************
97:                  /* Function :  USB_ExistsALL_Interrupt_Default
98:                  
99:                    Summary:
100:                     Implements Default variant of PLIB_USB_ExistsALL_Interrupt
101:                 
102:                   Description:
103:                     This template implements the Default variant of the
104:                     PLIB_USB_ExistsALL_Interrupt function.
105:                 */
106:                 
107:                 #define PLIB_USB_ExistsALL_Interrupt PLIB_USB_ExistsALL_Interrupt
108:                 PLIB_TEMPLATE bool USB_ExistsALL_Interrupt_Default( USB_MODULE_ID index )
109:                 {
110:                     return true;
111:                 }
112:                 
113:                 
114:                 #endif /*_USB_ALL_INTERRUPT_DEFAULT_H*/
115:                 
116:                 /******************************************************************************
117:                  End of File
118:                 */
119:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/usart/templates/usart_WakeOnStart_Default.h
1:                   /*******************************************************************************
2:                     USART Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usart_WakeOnStart_Default.h
6:                   
7:                     Summary:
8:                       USART PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : WakeOnStart
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USART_ExistsWakeOnStart
16:                          PLIB_USART_WakeOnStartEnable
17:                          PLIB_USART_WakeOnStartDisable
18:                          PLIB_USART_WakeOnStartIsEnabled
19:                          PLIB_USART_InitializeModeGeneral
20:                          PLIB_USART_ErrorsGet
21:                  
22:                  *******************************************************************************/
23:                  
24:                  //DOM-IGNORE-BEGIN
25:                  /*******************************************************************************
26:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
27:                  
28:                  Microchip licenses to you the right to use, modify, copy and distribute
29:                  Software only when embedded on a Microchip microcontroller or digital signal
30:                  controller that is integrated into your product or third party product
31:                  (pursuant to the sublicense terms in the accompanying license agreement).
32:                  
33:                  You should refer to the license agreement accompanying this Software for
34:                  additional information regarding your rights and obligations.
35:                  
36:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
37:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
38:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
39:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
40:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
41:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
42:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
43:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
44:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
45:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
46:                  *******************************************************************************/
47:                  
48:                  //DOM-IGNORE-END
49:                  
50:                  #ifndef _USART_WAKEONSTART_DEFAULT_H
51:                  #define _USART_WAKEONSTART_DEFAULT_H
52:                  
53:                  #include "usart_registers.h"
54:                  
55:                  //******************************************************************************
56:                  /* Function :  USART_ExistsWakeOnStart_Default
57:                  
58:                    Summary:
59:                      Implements Default variant of PLIB_USART_ExistsWakeOnStart
60:                  
61:                    Description:
62:                      This template implements the Default variant of the PLIB_USART_ExistsWakeOnStart function.
63:                  */
64:                  
65:                  #define PLIB_USART_ExistsWakeOnStart PLIB_USART_ExistsWakeOnStart
66:                  PLIB_TEMPLATE bool USART_ExistsWakeOnStart_Default( USART_MODULE_ID index )
67:                  {
68:                      return true;
69:                  }
70:                  
71:                  
72:                  //******************************************************************************
73:                  /* Function :  USART_WakeOnStartEnable_Default
74:                  
75:                    Summary:
76:                      Implements Default variant of PLIB_USART_WakeOnStartEnable
77:                  
78:                    Description:
79:                      This template implements the Default variant of the PLIB_USART_WakeOnStartEnable function.
80:                  */
81:                  
82:                  PLIB_TEMPLATE void USART_WakeOnStartEnable_Default( USART_MODULE_ID index )
83:                  {
84:                      usart_registers_t volatile * usart = ((usart_registers_t *)(index));
85:                      usart->UxMODESET = UxMODE_WAKE_MASK;
86:                  }
87:                  
88:                  
89:                  //******************************************************************************
90:                  /* Function :  USART_WakeOnStartDisable_Default
91:                  
92:                    Summary:
93:                      Implements Default variant of PLIB_USART_WakeOnStartDisable
94:                  
95:                    Description:
96:                      This template implements the Default variant of the PLIB_USART_WakeOnStartDisable function.
97:                  */
98:                  
99:                  PLIB_TEMPLATE void USART_WakeOnStartDisable_Default( USART_MODULE_ID index )
100:                 {
101:                     usart_registers_t volatile * usart = ((usart_registers_t *)(index));
102:                     usart->UxMODECLR = UxMODE_WAKE_MASK;
103:                 }
104:                 
105:                 
106:                 //******************************************************************************
107:                 /* Function :  USART_WakeOnStartIsEnabled_Default
108:                 
109:                   Summary:
110:                     Implements Default variant of PLIB_USART_WakeOnStartIsEnabled
111:                 
112:                   Description:
113:                     This template implements the Default variant of the PLIB_USART_WakeOnStartIsEnabled function.
114:                 */
115:                 
116:                 PLIB_TEMPLATE bool USART_WakeOnStartIsEnabled_Default( USART_MODULE_ID index )
117:                 {
118:                     usart_registers_t volatile * usart = ((usart_registers_t *)(index));
119:                     return (bool)usart->UxMODE.WAKE;
120:                 }
121:                 
122:                 
123:                 //******************************************************************************
124:                 /* Function :  USART_InitializeModeGeneral_Default
125:                 
126:                   Summary:
127:                     Implements Default variant of PLIB_USART_InitializeModeGeneral
128:                 
129:                   Description:
130:                     This template implements the Default variant of the PLIB_USART_InitializeModeGeneral function.
131:                 */
132:                 
133:                 PLIB_TEMPLATE void USART_InitializeModeGeneral_Default( USART_MODULE_ID index, bool autobaud, bool loopBackMode, bool wakeFromSleep, bool irdaMode, bool stopInIdle )
134:                 {
135:                     usart_registers_t volatile * usart = ((usart_registers_t *)(index));
136:                     usart->UxMODE.ABAUD = autobaud;
9D00A5F8  94860000   LHU A2, 0(A0)
9D00A5FC  7D462944   INS A2, T2, 5, 1
9D00A600  A4860000   SH A2, 0(A0)
137:                     usart->UxMODE.LPBACK = loopBackMode;
9D00A604  94860000   LHU A2, 0(A0)
9D00A608  7C463184   INS A2, V0, 6, 1
9D00A60C  A4860000   SH A2, 0(A0)
138:                     usart->UxMODE.WAKE = wakeFromSleep;
9D00A610  94820000   LHU V0, 0(A0)
9D00A614  7C6239C4   INS V0, V1, 7, 1
9D00A618  A4820000   SH V0, 0(A0)
139:                     usart->UxMODE.SIDL = stopInIdle;
9D00A61C  94820000   LHU V0, 0(A0)
9D00A620  7D226B44   INS V0, T1, 13, 1
9D00A624  A4820000   SH V0, 0(A0)
140:                     usart->UxMODE.IREN = irdaMode;
9D00A628  94820000   LHU V0, 0(A0)
9D00A62C  7D026304   INS V0, T0, 12, 1
9D00A630  A4820000   SH V0, 0(A0)
141:                 }
142:                 
143:                 //******************************************************************************
144:                 /* Function :  USART_ErrorsGet_Default
145:                 
146:                   Summary:
147:                     Implements Default variant of PLIB_USART_ErrorsGet
148:                 
149:                   Description:
150:                     This template implements the Default variant of the PLIB_USART_ErrorsGet function.
151:                 */
152:                 
153:                 PLIB_TEMPLATE USART_ERROR USART_ErrorsGet_Default( USART_MODULE_ID index)
154:                 {
155:                     usart_registers_t volatile * usart = ((usart_registers_t *)(index));
9D01088C  8E020000   LW V0, 0(S0)
9D011F9C  8C820000   LW V0, 0(A0)
9D011FB8  0B4047F7   J _DRV_USART_ErrorConditionClear::PLIB_USART_ErrorsGet
9D011FBC  8C830000   LW V1, 0(A0)
9D011FDC  24020009   ADDIU V0, ZERO, 9
156:                     return (USART_ERROR)((usart->UxSTA.w & 0xE) >> 1u);
9D00829C  8E830010   LW V1, 16(S4)
9D0082A0  7C631040   EXT V1, V1, 1, 3
9D0082B8  8C430010   LW V1, 16(V0)
9D0082BC  7C631040   EXT V1, V1, 1, 3
9D008D78  8E830010   LW V1, 16(S4)
9D008D7C  7C631040   EXT V1, V1, 1, 3
9D010890  8C420010   LW V0, 16(V0)
9D010894  7C421040   EXT V0, V0, 1, 3
9D011FA0  8C430010   LW V1, 16(V0)
9D011FE0  8C650010   LW A1, 16(V1)
9D011FE4  7CA51040   EXT A1, A1, 1, 3
157:                 }
158:                 
159:                 #endif /*_USART_WAKEONSTART_DEFAULT_H*/
160:                 
161:                 /******************************************************************************
162:                  End of File
163:                 */
164:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/usart/templates/usart_Transmitter_Default.h
1:                   /*******************************************************************************
2:                     USART Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usart_Transmitter_Default.h
6:                   
7:                     Summary:
8:                       USART PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : Transmitter
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USART_ExistsTransmitter
16:                          PLIB_USART_TransmitterByteSend
17:                          PLIB_USART_TransmitterAddressGet
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _USART_TRANSMITTER_DEFAULT_H
48:                  #define _USART_TRANSMITTER_DEFAULT_H
49:                  
50:                  #include "usart_registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  USART_ExistsTransmitter_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_USART_ExistsTransmitter
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_USART_ExistsTransmitter function.
60:                  */
61:                  
62:                  #define PLIB_USART_ExistsTransmitter PLIB_USART_ExistsTransmitter
63:                  PLIB_TEMPLATE bool USART_ExistsTransmitter_Default( USART_MODULE_ID index )
64:                  {
65:                      return true;
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  USART_TransmitterByteSend_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_USART_TransmitterByteSend
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_USART_TransmitterByteSend function.
77:                  */
78:                  
79:                  PLIB_TEMPLATE void USART_TransmitterByteSend_Default( USART_MODULE_ID index , int8_t data )
80:                  {
81:                      usart_registers_t volatile * usart = ((usart_registers_t *)(index));
82:                      usart->UxTXREG = data;
9D008CE0  82620000   LB V0, 0(S3)
9D008CE4  AE820020   SW V0, 32(S4)
9D008D6C  80630000   LB V1, 0(V1)
9D008D70  AE830020   SW V1, 32(S4)
9D008FA0  80630000   LB V1, 0(V1)
9D008FA4  AC830020   SW V1, 32(A0)
83:                  }
84:                  
85:                  
86:                  //******************************************************************************
87:                  /* Function :  USART_TransmitterAddressGet_Default
88:                  
89:                    Summary:
90:                      Implements Default variant of PLIB_USART_TransmitterAddressGet
91:                  
92:                    Description:
93:                      This template implements the Default variant of the PLIB_USART_TransmitterAddressGet function.
94:                  */
95:                  
96:                  PLIB_TEMPLATE void* USART_TransmitterAddressGet_Default( USART_MODULE_ID index )
97:                  {
98:                      usart_registers_t volatile * usart = ((usart_registers_t *)(index));
99:                      return (uint32_t*)(&usart->UxTXREG);
100:                 }
101:                 
102:                 #endif /*_USART_TRANSMITTER_DEFAULT_H*/
103:                 
104:                 /******************************************************************************
105:                  End of File
106:                 */
107:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/usart/templates/usart_TransmitterBufferFull_Default.h
1:                   /*******************************************************************************
2:                     USART Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usart_TransmitterBufferFull_Default.h
6:                   
7:                     Summary:
8:                       USART PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : TransmitterBufferFull
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USART_ExistsTransmitterBufferFullStatus
16:                          PLIB_USART_TransmitterBufferIsFull
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _USART_TRANSMITTERBUFFERFULL_DEFAULT_H
47:                  #define _USART_TRANSMITTERBUFFERFULL_DEFAULT_H
48:                  
49:                  #include "usart_registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  USART_ExistsTransmitterBufferFullStatus_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_USART_ExistsTransmitterBufferFullStatus
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_USART_ExistsTransmitterBufferFullStatus function.
59:                  */
60:                  
61:                  #define PLIB_USART_ExistsTransmitterBufferFullStatus PLIB_USART_ExistsTransmitterBufferFullStatus
62:                  PLIB_TEMPLATE bool USART_ExistsTransmitterBufferFullStatus_Default( USART_MODULE_ID index )
63:                  {
64:                      return true;
65:                  }
66:                  
67:                  
68:                  //******************************************************************************
69:                  /* Function :  USART_TransmitterBufferIsFull_Default
70:                  
71:                    Summary:
72:                      Implements Default variant of PLIB_USART_TransmitterBufferIsFull 
73:                  
74:                    Description:
75:                      This template implements the Default variant of the PLIB_USART_TransmitterBufferIsFull function.
76:                  */
77:                  
78:                  PLIB_TEMPLATE bool USART_TransmitterBufferIsFull_Default( USART_MODULE_ID index )
79:                  {
80:                      usart_registers_t volatile * usart = ((usart_registers_t *)(index));
81:                      return (bool)usart->UxSTA.UTXBF;
9D008D98  8E830010   LW V1, 16(S4)
9D008D9C  30630200   ANDI V1, V1, 512
9D008EF8  8E030010   LW V1, 16(S0)
9D008EFC  30630200   ANDI V1, V1, 512
9D008F70  8E030010   LW V1, 16(S0)
9D008F74  30630200   ANDI V1, V1, 512
9D008FB4  8C850010   LW A1, 16(A0)
9D008FB8  30A50200   ANDI A1, A1, 512
82:                  }
83:                  
84:                  
85:                  #endif /*_USART_TRANSMITTERBUFFERFULL_DEFAULT_H*/
86:                  
87:                  /******************************************************************************
88:                   End of File
89:                  */
90:                  
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/usart/templates/usart_Transmitter9Bits_InDataOnly.h
1:                   /*******************************************************************************
2:                     USART Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usart_Transmitter9Bits_InDataOnly.h
6:                   
7:                     Summary:
8:                       USART PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : Transmitter9Bits
13:                      and its Variant : InDataOnly
14:                      For following APIs :
15:                          PLIB_USART_ExistsTransmitter9BitsSend
16:                          PLIB_USART_Transmitter9BitsSend
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _USART_TRANSMITTER9BITS_INDATAONLY_H
47:                  #define _USART_TRANSMITTER9BITS_INDATAONLY_H
48:                  
49:                  #include "usart_registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  USART_ExistsTransmitter9BitsSend_InDataOnly
53:                  
54:                    Summary:
55:                      Implements InDataOnly variant of PLIB_USART_ExistsTransmitter9BitsSend
56:                  
57:                    Description:
58:                      This template implements the InDataOnly variant of the PLIB_USART_ExistsTransmitter9BitsSend function.
59:                  */
60:                  
61:                  #define PLIB_USART_ExistsTransmitter9BitsSend PLIB_USART_ExistsTransmitter9BitsSend
62:                  PLIB_TEMPLATE bool USART_ExistsTransmitter9BitsSend_InDataOnly( USART_MODULE_ID index )
63:                  {
64:                      return true;
65:                  }
66:                  
67:                  
68:                  //******************************************************************************
69:                  /* Function :  USART_Transmitter9BitsSend_InDataOnly
70:                  
71:                    Summary:
72:                      Implements InDataOnly variant of PLIB_USART_Transmitter9BitsSend
73:                  
74:                    Description:
75:                      This template implements the InDataOnly variant of the PLIB_USART_Transmitter9BitsSend function.
76:                  */
77:                  
78:                  PLIB_TEMPLATE void USART_Transmitter9BitsSend_InDataOnly( USART_MODULE_ID index , int8_t data , bool bit9th )
79:                  {
80:                      usart_registers_t volatile * usart = ((usart_registers_t *)(index));
81:                      uint32_t temp;
82:                  
83:                      temp = (uint32_t)data;
9D008F44  80430008   LB V1, 8(V0)
84:                      
85:                      if (false == bit9th)
86:                      {
87:                          /* Clear 9th and higher bits */
88:                          temp = ( temp & 0x00FF );
9D008F5C  90630000   LBU V1, 0(V1)
89:                      }
90:                      else
91:                      {
92:                          /* Set 9th bit. */
93:                          temp = ( temp | 0x0100 );
9D008F48  34630100   ORI V1, V1, 256
94:                      }
95:                      
96:                      usart->UxTXREG = temp;
9D008F4C  AE030020   SW V1, 32(S0)
9D008F60  AE030020   SW V1, 32(S0)
97:                  }
98:                  
99:                  
100:                 #endif /*_USART_TRANSMITTER9BITS_INDATAONLY_H*/
101:                 
102:                 /******************************************************************************
103:                  End of File
104:                 */
105:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/usart/templates/usart_Receiver_Default.h
1:                   /*******************************************************************************
2:                     USART Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usart_Receiver_Default.h
6:                   
7:                     Summary:
8:                       USART PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : Receiver
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USART_ExistsReceiver
16:                          PLIB_USART_ReceiverByteReceive
17:                          PLIB_USART_ReceiverAddressGet
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _USART_RECEIVER_DEFAULT_H
48:                  #define _USART_RECEIVER_DEFAULT_H
49:                  
50:                  #include "usart_registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  USART_ExistsReceiver_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_USART_ExistsReceiver
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_USART_ExistsReceiver function.
60:                  */
61:                  
62:                  #define PLIB_USART_ExistsReceiver PLIB_USART_ExistsReceiver
63:                  PLIB_TEMPLATE bool USART_ExistsReceiver_Default( USART_MODULE_ID index )
64:                  {
65:                      return true;
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  USART_ReceiverByteReceive_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_USART_ReceiverByteReceive
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_USART_ReceiverByteReceive function.
77:                  */
78:                  
79:                  PLIB_TEMPLATE int8_t USART_ReceiverByteReceive_Default( USART_MODULE_ID index )
80:                  {
81:                      usart_registers_t volatile * usart = ((usart_registers_t *)(index));
82:                      return (int8_t)usart->UxRXREG;
9D0082E0  8C440030   LW A0, 48(V0)
9D0082E4  02541821   ADDU V1, S2, S4
9D00CBA4  8C640030   LW A0, 48(V1)
9D011FC0  8C650030   LW A1, 48(V1)
9D011FC4  2442FFFF   ADDIU V0, V0, -1
9D011FC8  304200FF   ANDI V0, V0, 255
83:                  }
84:                  
85:                  //******************************************************************************
86:                  /* Function :  USART_ReceiverAddressGet_Default
87:                  
88:                    Summary:
89:                      Implements Default variant of PLIB_USART_ReceiverAddressGet
90:                  
91:                    Description:
92:                      This template implements the Default variant of the PLIB_USART_ReceiverAddressGet function.
93:                  */
94:                  
95:                  PLIB_TEMPLATE void* USART_ReceiverAddressGet_Default( USART_MODULE_ID index )
96:                  {
97:                      usart_registers_t volatile * usart = ((usart_registers_t *)(index));
98:                      return (uint32_t*)(&usart->UxRXREG);
99:                  }
100:                 
101:                 #endif /*_USART_RECEIVER_DEFAULT_H*/
102:                 
103:                 /******************************************************************************
104:                  End of File
105:                 */
106:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/usart/templates/usart_ReceiverOverrunError_Default.h
1:                   /*******************************************************************************
2:                     USART Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usart_ReceiverOverrunError_Default.h
6:                   
7:                     Summary:
8:                       USART PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ReceiverOverrunError
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USART_ExistsReceiverOverrunStatus
16:                          PLIB_USART_ReceiverOverrunErrorClear
17:                          PLIB_USART_ReceiverOverrunHasOccurred
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _USART_RECEIVEROVERRUNERROR_DEFAULT_H
48:                  #define _USART_RECEIVEROVERRUNERROR_DEFAULT_H
49:                  
50:                  #include "usart_registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  USART_ExistsReceiverOverrunStatus_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_USART_ExistsReceiverOverrunStatus
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_USART_ExistsReceiverOverrunStatus function.
60:                  */
61:                  
62:                  #define PLIB_USART_ExistsReceiverOverrunStatus PLIB_USART_ExistsReceiverOverrunStatus
63:                  PLIB_TEMPLATE bool USART_ExistsReceiverOverrunStatus_Default( USART_MODULE_ID index )
64:                  {
65:                      return true;
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  USART_ReceiverOverrunErrorClear_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_USART_ReceiverOverrunErrorClear 
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_USART_ReceiverOverrunErrorClear function.
77:                  */
78:                  
79:                  PLIB_TEMPLATE void USART_ReceiverOverrunErrorClear_Default( USART_MODULE_ID index )
80:                  {
81:                      usart_registers_t volatile * usart = ((usart_registers_t *)(index));
82:                      usart->UxSTACLR = UxSTA_OERR_MASK;
9D011FB0  24030002   ADDIU V1, ZERO, 2
9D011FB4  AC430014   SW V1, 20(V0)
83:                  }
84:                  
85:                  
86:                  //******************************************************************************
87:                  /* Function :  USART_ReceiverOverrunHasOccurred_Default
88:                  
89:                    Summary:
90:                      Implements Default variant of PLIB_USART_ReceiverOverrunHasOccurred 
91:                  
92:                    Description:
93:                      This template implements the Default variant of the PLIB_USART_ReceiverOverrunHasOccurred function.
94:                  */
95:                  
96:                  PLIB_TEMPLATE bool USART_ReceiverOverrunHasOccurred_Default( USART_MODULE_ID index )
97:                  {
98:                      usart_registers_t volatile * usart = ((usart_registers_t *)(index));
99:                      return (bool)usart->UxSTA.OERR;
100:                 }
101:                 
102:                 
103:                 #endif /*_USART_RECEIVEROVERRUNERROR_DEFAULT_H*/
104:                 
105:                 /******************************************************************************
106:                  End of File
107:                 */
108:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/usart/templates/usart_ReceiverInterruptMode_Default.h
1:                   /*******************************************************************************
2:                     USART Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usart_ReceiverInterruptMode_Default.h
6:                   
7:                     Summary:
8:                       USART PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ReceiverInterruptMode
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USART_ExistsReceiverInterruptMode
16:                          PLIB_USART_ReceiverInterruptModeSelect
17:                          PLIB_USART_InitializeOperation
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _USART_RECEIVERINTERRUPTMODE_DEFAULT_H
48:                  #define _USART_RECEIVERINTERRUPTMODE_DEFAULT_H
49:                  
50:                  #include "usart_registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  USART_ExistsReceiverInterruptMode_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_USART_ExistsReceiverInterruptMode
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_USART_ExistsReceiverInterruptMode function.
60:                  */
61:                  
62:                  #define PLIB_USART_ExistsReceiverInterruptMode PLIB_USART_ExistsReceiverInterruptMode
63:                  PLIB_TEMPLATE bool USART_ExistsReceiverInterruptMode_Default( USART_MODULE_ID index )
64:                  {
65:                      return true;
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  USART_ReceiverInterruptModeSelect_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_USART_ReceiverInterruptModeSelect 
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_USART_ReceiverInterruptModeSelect function.
77:                  */
78:                  
79:                  PLIB_TEMPLATE void USART_ReceiverInterruptModeSelect_Default( USART_MODULE_ID index , USART_RECEIVE_INTR_MODE interruptMode )
80:                  {
81:                      usart_registers_t volatile * usart = ((usart_registers_t *)(index));
82:                  
83:                      /* Clear and Set, as UxSTA contains status bits and 
84:                         hence need to be accessed atomically.
85:                         Using bit field access may erroneously cause status bits to get cleared */
86:                      usart->UxSTACLR = UxSTA_URXISEL_MASK;
87:                      usart->UxSTASET = ( UxSTA_URXISEL_MASK & ((uint32_t)interruptMode << UxSTA_URXISEL_POSITION) );
88:                  }
89:                  
90:                  
91:                  //******************************************************************************
92:                  /* Function :  USART_InitializeOperation_Default
93:                  
94:                    Summary:
95:                      Implements Default variant of PLIB_USART_InitializeOperation 
96:                  
97:                    Description:
98:                      This template implements the Default variant of the PLIB_USART_InitializeOperation function.
99:                  */
100:                 
101:                 PLIB_TEMPLATE void USART_InitializeOperation_Default( USART_MODULE_ID index , USART_RECEIVE_INTR_MODE receiveInterruptMode ,
102:                         USART_TRANSMIT_INTR_MODE transmitInterruptMode, USART_OPERATION_MODE operationMode)
103:                 {
104:                     usart_registers_t volatile * usart = ((usart_registers_t *)(index));
105:                 
106:                     /* Clear and Set, as UxSTA contains status bits and 
107:                        hence need to be accessed atomically.
108:                        Using bit field access may erroneously cause status bits to get cleared */
109:                     usart->UxSTACLR = UxSTA_URXISEL_MASK;
9D00A664  240200C0   ADDIU V0, ZERO, 192
9D00A668  AC820014   SW V0, 20(A0)
110:                     usart->UxSTASET = ( UxSTA_URXISEL_MASK & ((uint32_t)receiveInterruptMode << UxSTA_URXISEL_POSITION) );
9D00A66C  AC800018   SW ZERO, 24(A0)
111:                 
112:                     /* Clear and Set, as UxSTA contains status bits and 
113:                        hence need to be accessed atomically.
114:                        Using bit field access may erroneously cause status bits to get cleared */
115:                     usart->UxSTACLR = UxSTA_UTXISEL_MASK;
9D00A670  3402C000   ORI V0, ZERO, -16384
9D00A674  AC820014   SW V0, 20(A0)
116:                     usart->UxSTASET = ( UxSTA_UTXISEL_MASK & ((uint32_t)transmitInterruptMode << UxSTA_UTXISEL_POSITION) );
9D00A678  24024000   ADDIU V0, ZERO, 16384
9D00A67C  AC820018   SW V0, 24(A0)
117:                 
118:                     /* Select the operation mode */
119:                     usart->UxMODE.UEN = operationMode;
9D00A680  94820000   LHU V0, 0(A0)
9D00A684  7CE24A04   INS V0, A3, 8, 2
9D00A688  A4820000   SH V0, 0(A0)
120:                 
121:                 }
122:                 
123:                 
124:                 #endif /*_USART_RECEIVERINTERRUPTMODE_DEFAULT_H*/
125:                 
126:                 /******************************************************************************
127:                  End of File
128:                 */
129:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/usart/templates/usart_ReceiverDataAvailable_Default.h
1:                   /*******************************************************************************
2:                     USART Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usart_ReceiverDataAvailable_Default.h
6:                   
7:                     Summary:
8:                       USART PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ReceiverDataAvailable
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USART_ExistsReceiverDataAvailableStatus
16:                          PLIB_USART_ReceiverDataIsAvailable
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _USART_RECEIVERDATAAVAILABLE_DEFAULT_H
47:                  #define _USART_RECEIVERDATAAVAILABLE_DEFAULT_H
48:                  
49:                  #include "usart_registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  USART_ExistsReceiverDataAvailableStatus_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_USART_ExistsReceiverDataAvailableStatus
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_USART_ExistsReceiverDataAvailableStatus function.
59:                  */
60:                  
61:                  #define PLIB_USART_ExistsReceiverDataAvailableStatus PLIB_USART_ExistsReceiverDataAvailableStatus
62:                  PLIB_TEMPLATE bool USART_ExistsReceiverDataAvailableStatus_Default( USART_MODULE_ID index )
63:                  {
64:                      return true;
65:                  }
66:                  
67:                  
68:                  //******************************************************************************
69:                  /* Function :  USART_ReceiverDataIsAvailable_Default
70:                  
71:                    Summary:
72:                      Implements Default variant of PLIB_USART_ReceiverDataIsAvailable 
73:                  
74:                    Description:
75:                      This template implements the Default variant of the PLIB_USART_ReceiverDataIsAvailable function.
76:                  */
77:                  
78:                  PLIB_TEMPLATE bool USART_ReceiverDataIsAvailable_Default( USART_MODULE_ID index )
79:                  {
80:                      usart_registers_t volatile * usart = ((usart_registers_t *)(index));
9D008288  02801021   ADDU V0, S4, ZERO
9D00CB7C  00401821   ADDU V1, V0, ZERO
81:                     return (usart->UxSTA.URXDA);
9D00828C  8E830010   LW V1, 16(S4)
9D008290  30630001   ANDI V1, V1, 1
9D0082F0  8C430010   LW V1, 16(V0)
9D0082F4  30630001   ANDI V1, V1, 1
9D00CB80  8C420010   LW V0, 16(V0)
9D00CB84  30420001   ANDI V0, V0, 1
9D00CBC0  8C640010   LW A0, 16(V1)
9D00CBC4  30840001   ANDI A0, A0, 1
82:                  }
83:                  
84:                  
85:                  #endif /*_USART_RECEIVERDATAAVAILABLE_DEFAULT_H*/
86:                  
87:                  /******************************************************************************
88:                   End of File
89:                  */
90:                  
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/usart/templates/usart_ReceiverAddress_Default.h
1:                   /*******************************************************************************
2:                     USART Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usart_ReceiverAddress_Default.h
6:                   
7:                     Summary:
8:                       USART PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ReceiverAddress
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USART_ExistsReceiverAddress
16:                          PLIB_USART_AddressSet
17:                          PLIB_USART_AddressGet
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _USART_RECEIVERADDRESS_DEFAULT_H
48:                  #define _USART_RECEIVERADDRESS_DEFAULT_H
49:                  
50:                  #include "usart_registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  USART_ExistsReceiverAddress_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_USART_ExistsReceiverAddress
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_USART_ExistsReceiverAddress function.
60:                  */
61:                  
62:                  #define PLIB_USART_ExistsReceiverAddress PLIB_USART_ExistsReceiverAddress
63:                  PLIB_TEMPLATE bool USART_ExistsReceiverAddress_Default( USART_MODULE_ID index )
64:                  {
65:                      return true;
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  USART_AddressSet_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_USART_AddressSet 
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_USART_AddressSet function.
77:                  */
78:                  
79:                  PLIB_TEMPLATE void USART_AddressSet_Default( USART_MODULE_ID index , uint8_t address )
80:                  {
81:                      usart_registers_t volatile * usart = ((usart_registers_t *)(index));
82:                      
83:                      /* Clear and Set, as UxSTA contains status bits and 
84:                         hence need to be accessed atomically.
85:                         Using bit field access may erroneously cause status bits to get cleared */
86:                      usart->UxSTACLR = UxSTA_ADDR_MASK;
9D00A57C  3C0200FF   LUI V0, 255
9D00A580  AC820014   SW V0, 20(A0)
87:                      usart->UxSTASET = ( UxSTA_ADDR_MASK & (((uint32_t)address) << UxSTA_ADDR_POSITION) );
9D00A584  00031C00   SLL V1, V1, 16
9D00A588  00621824   AND V1, V1, V0
9D00A58C  AC830018   SW V1, 24(A0)
88:                  }
89:                  
90:                  
91:                  //******************************************************************************
92:                  /* Function :  USART_AddressGet_Default
93:                  
94:                    Summary:
95:                      Implements Default variant of PLIB_USART_AddressGet 
96:                  
97:                    Description:
98:                      This template implements the Default variant of the PLIB_USART_AddressGet function.
99:                  */
100:                 
101:                 PLIB_TEMPLATE uint8_t USART_AddressGet_Default( USART_MODULE_ID index )
102:                 {
103:                     usart_registers_t volatile * usart = ((usart_registers_t *)(index));
104:                     return (uint8_t)usart->UxSTA.ADDR;
9D00A590  90830012   LBU V1, 18(A0)
105:                 }
106:                 
107:                 
108:                 #endif /*_USART_RECEIVERADDRESS_DEFAULT_H*/
109:                 
110:                 /******************************************************************************
111:                  End of File
112:                 */
113:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/usart/templates/usart_ReceiverAddressDetect_Default.h
1:                   /*******************************************************************************
2:                     USART Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usart_ReceiverAddressDetect_Default.h
6:                   
7:                     Summary:
8:                       USART PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ReceiverAddressDetect
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USART_ExistsReceiverAddressDetect
16:                          PLIB_USART_ReceiverAddressDetectEnable
17:                          PLIB_USART_ReceiverAddressDetectDisable
18:                          PLIB_USART_ReceiverAddressIsReceived
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _USART_RECEIVERADDRESSDETECT_DEFAULT_H
49:                  #define _USART_RECEIVERADDRESSDETECT_DEFAULT_H
50:                  
51:                  #include "usart_registers.h"
52:                  
53:                  //******************************************************************************
54:                  /* Function :  USART_ExistsReceiverAddressDetect_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_USART_ExistsReceiverAddressDetect
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_USART_ExistsReceiverAddressDetect function.
61:                  */
62:                  
63:                  #define PLIB_USART_ExistsReceiverAddressDetect PLIB_USART_ExistsReceiverAddressDetect
64:                  PLIB_TEMPLATE bool USART_ExistsReceiverAddressDetect_Default( USART_MODULE_ID index )
65:                  {
66:                      return true;
67:                  }
68:                  
69:                  
70:                  //******************************************************************************
71:                  /* Function :  USART_ReceiverAddressDetectEnable_Default
72:                  
73:                    Summary:
74:                      Implements Default variant of PLIB_USART_ReceiverAddressDetectEnable
75:                  
76:                    Description:
77:                      This template implements the Default variant of the PLIB_USART_ReceiverAddressDetectEnable function.
78:                  */
79:                  
80:                  PLIB_TEMPLATE void USART_ReceiverAddressDetectEnable_Default( USART_MODULE_ID index )
81:                  {
82:                      usart_registers_t volatile * usart = ((usart_registers_t *)(index));
83:                      usart->UxSTASET = UxSTA_ADDEN_MASK;
9D00A570  24020020   ADDIU V0, ZERO, 32
9D00A574  AC820018   SW V0, 24(A0)
84:                  }
85:                  
86:                  
87:                  //******************************************************************************
88:                  /* Function :  USART_ReceiverAddressDetectDisable_Default
89:                  
90:                    Summary:
91:                      Implements Default variant of PLIB_USART_ReceiverAddressDetectDisable
92:                  
93:                    Description:
94:                      This template implements the Default variant of the PLIB_USART_ReceiverAddressDetectDisable function.
95:                  */
96:                  
97:                  PLIB_TEMPLATE void USART_ReceiverAddressDetectDisable_Default( USART_MODULE_ID index )
98:                  {
99:                      usart_registers_t volatile * usart = ((usart_registers_t *)(index));
100:                     usart->UxSTACLR = UxSTA_ADDEN_MASK;
101:                 }
102:                 
103:                 
104:                 //******************************************************************************
105:                 /* Function :  USART_ReceiverAddressIsReceived_Default
106:                 
107:                   Summary:
108:                     Implements Default variant of PLIB_USART_ReceiverAddressIsReceived
109:                 
110:                   Description:
111:                     This template implements the Default variant of the PLIB_USART_ReceiverAddressIsReceived function.
112:                 */
113:                 
114:                 PLIB_TEMPLATE bool USART_ReceiverAddressIsReceived_Default( USART_MODULE_ID index )
115:                 {
116:                     usart_registers_t volatile * usart = ((usart_registers_t *)(index));
117:                     return (bool)usart->UxSTA.ADDEN;
118:                 }
119:                 
120:                 
121:                 #endif /*_USART_RECEIVERADDRESSDETECT_DEFAULT_H*/
122:                 
123:                 /******************************************************************************
124:                  End of File
125:                 */
126:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/usart/templates/usart_ReceiverAddressAutoDetect_Default.h
1:                   /*******************************************************************************
2:                     USART Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usart_ReceiverAddressAutoDetect_Default.h
6:                   
7:                     Summary:
8:                       USART PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ReceiverAddressAutoDetect
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USART_ExistsReceiverAddressAutoDetect
16:                          PLIB_USART_ReceiverAddressAutoDetectEnable
17:                          PLIB_USART_ReceiverAddressAutoDetectDisable
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _USART_RECEIVERADDRESSAUTODETECT_DEFAULT_H
48:                  #define _USART_RECEIVERADDRESSAUTODETECT_DEFAULT_H
49:                  
50:                  #include "usart_registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  USART_ExistsReceiverAddressAutoDetect_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_USART_ExistsReceiverAddressAutoDetect
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_USART_ExistsReceiverAddressAutoDetect function.
60:                  */
61:                  
62:                  #define PLIB_USART_ExistsReceiverAddressAutoDetect PLIB_USART_ExistsReceiverAddressAutoDetect
63:                  PLIB_TEMPLATE bool USART_ExistsReceiverAddressAutoDetect_Default( USART_MODULE_ID index )
64:                  {
65:                      return true;
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  USART_ReceiverAddressAutoDetectEnable_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_USART_ReceiverAddressAutoDetectEnable 
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_USART_ReceiverAddressAutoDetectEnable function.
77:                  */
78:                  
79:                  PLIB_TEMPLATE void USART_ReceiverAddressAutoDetectEnable_Default( USART_MODULE_ID index , int8_t mask )
80:                  {
81:                      usart_registers_t volatile * usart = ((usart_registers_t *)(index));
82:                  
83:                      /* Clear and Set, as UxSTA contains status bits and 
84:                         hence need to be accessed atomically.
85:                         Using bit field access may erroneously cause status bits to get cleared */
86:                      usart->UxSTACLR = UxSTA_ADDR_MASK;
9D00A594  AC820014   SW V0, 20(A0)
87:                      usart->UxSTASET = ( UxSTA_ADDR_MASK & (((uint32_t)mask) << UxSTA_ADDR_POSITION) ) | (UxSTA_ADM_EN_MASK);
9D00A598  7C031C20   SEB V1, V1
9D00A59C  00031C00   SLL V1, V1, 16
9D00A5A0  00621024   AND V0, V1, V0
9D00A5A4  3C030100   LUI V1, 256
9D00A5A8  00431025   OR V0, V0, V1
9D00A5AC  AC820018   SW V0, 24(A0)
88:                  }
89:                  
90:                  
91:                  //******************************************************************************
92:                  /* Function :  USART_ReceiverAddressAutoDetectDisable_Default
93:                  
94:                    Summary:
95:                      Implements Default variant of PLIB_USART_ReceiverAddressAutoDetectDisable 
96:                  
97:                    Description:
98:                      This template implements the Default variant of the PLIB_USART_ReceiverAddressAutoDetectDisable function.
99:                  */
100:                 
101:                 PLIB_TEMPLATE void USART_ReceiverAddressAutoDetectDisable_Default( USART_MODULE_ID index )
102:                 {
103:                     usart_registers_t volatile * usart = ((usart_registers_t *)(index));
104:                     usart->UxSTACLR = UxSTA_ADM_EN_MASK;
105:                 }
106:                 
107:                 
108:                 #endif /*_USART_RECEIVERADDRESSAUTODETECT_DEFAULT_H*/
109:                 
110:                 /******************************************************************************
111:                  End of File
112:                 */
113:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/usart/templates/usart_LineControlMode_RXandTXCombined.h
1:                   /*******************************************************************************
2:                     USART Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usart_LineControlMode_RXandTXCombined.h
6:                   
7:                     Summary:
8:                       USART PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : LineControlMode
13:                      and its Variant : RXandTXCombined
14:                      For following APIs :
15:                          PLIB_USART_ExistsLineControlMode
16:                          PLIB_USART_LineControlModeSelect
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _USART_LINECONTROLMODE_RXANDTXCOMBINED_H
47:                  #define _USART_LINECONTROLMODE_RXANDTXCOMBINED_H
48:                  
49:                  #include "usart_registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  USART_ExistsLineControlMode_RXandTXCombined
53:                  
54:                    Summary:
55:                      Implements RXandTXCombined variant of PLIB_USART_ExistsLineControlMode
56:                  
57:                    Description:
58:                      This template implements the RXandTXCombined variant of the PLIB_USART_ExistsLineControlMode function.
59:                  */
60:                  
61:                  #define PLIB_USART_ExistsLineControlMode PLIB_USART_ExistsLineControlMode
62:                  PLIB_TEMPLATE bool USART_ExistsLineControlMode_RXandTXCombined( USART_MODULE_ID index )
63:                  {
64:                      return true;
65:                  }
66:                  
67:                  
68:                  //******************************************************************************
69:                  /* Function :  USART_LineControlModeSelect_RXandTXCombined
70:                  
71:                    Summary:
72:                      Implements RXandTXCombined variant of PLIB_USART_LineControlModeSelect 
73:                  
74:                    Description:
75:                      This template implements the RXandTXCombined variant of the PLIB_USART_LineControlModeSelect function.
76:                  */
77:                  
78:                  PLIB_TEMPLATE void USART_LineControlModeSelect_RXandTXCombined( USART_MODULE_ID index , USART_LINECONTROL_MODE dataFlowConfig )
79:                  {
80:                      usart_registers_t volatile * usart = ((usart_registers_t *)(index));
81:                  
82:                      if (dataFlowConfig > USART_9N1)
9D00A638  2C430004   SLTIU V1, V0, 4
9D00A63C  14600004   BNE V1, ZERO, _DRV_USART_HardwareSetup::PLIB_USART_LineControlModeSelect
9D00A640  24030001   ADDIU V1, ZERO, 1
83:                      {
84:                          usart->UxMODESET = UxMODE_STSEL_MASK;
9D00A644  AC830008   SW V1, 8(A0)
85:                          dataFlowConfig = (USART_LINECONTROL_MODE)(dataFlowConfig - USART_8N2);
9D00A648  0B402996   J 0x9D00A658
9D00A64C  2443FFFC   ADDIU V1, V0, -4
86:                      }
87:                      else
88:                      {
89:                          usart->UxMODECLR = UxMODE_STSEL_MASK;
9D00A650  AC830004   SW V1, 4(A0)
9D00A654  00401821   ADDU V1, V0, ZERO
90:                      }
91:                      usart->UxMODE.PDSEL = dataFlowConfig;
9D00A658  94820000   LHU V0, 0(A0)
9D00A65C  7C621044   INS V0, V1, 1, 2
9D00A660  A4820000   SH V0, 0(A0)
92:                  }
93:                  
94:                  
95:                  #endif /*_USART_LINECONTROLMODE_RXANDTXCOMBINED_H*/
96:                  
97:                  /******************************************************************************
98:                   End of File
99:                  */
100:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/usart/templates/usart_HandShakeMode_Default.h
1:                   /*******************************************************************************
2:                     USART Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usart_HandShakeMode_Default.h
6:                   
7:                     Summary:
8:                       USART PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : HandShakeMode
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USART_ExistsHandshakeMode
16:                          PLIB_USART_HandshakeModeSelect
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _USART_HANDSHAKEMODE_DEFAULT_H
47:                  #define _USART_HANDSHAKEMODE_DEFAULT_H
48:                  
49:                  #include "usart_registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  USART_ExistsHandshakeMode_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_USART_ExistsHandshakeMode
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_USART_ExistsHandshakeMode function.
59:                  */
60:                  
61:                  #define PLIB_USART_ExistsHandshakeMode PLIB_USART_ExistsHandshakeMode
62:                  PLIB_TEMPLATE bool USART_ExistsHandshakeMode_Default( USART_MODULE_ID index )
63:                  {
64:                      return true;
65:                  }
66:                  
67:                  
68:                  //******************************************************************************
69:                  /* Function :  USART_HandshakeModeSelect_Default
70:                  
71:                    Summary:
72:                      Implements Default variant of PLIB_USART_HandshakeModeSelect 
73:                  
74:                    Description:
75:                      This template implements the Default variant of the PLIB_USART_HandshakeModeSelect function.
76:                  */
77:                  
78:                  PLIB_TEMPLATE void USART_HandshakeModeSelect_Default( USART_MODULE_ID index , USART_HANDSHAKE_MODE handshakeConfig )
79:                  {
80:                      usart_registers_t volatile * usart = ((usart_registers_t *)(index));
81:                  
82:                      usart->UxMODE.RTSMD = handshakeConfig;
9D00A5DC  94860000   LHU A2, 0(A0)
9D00A5E0  7C665AC4   INS A2, V1, 11, 1
9D00A5E4  A4860000   SH A2, 0(A0)
83:                  }
84:                  
85:                  
86:                  #endif /*_USART_HANDSHAKEMODE_DEFAULT_H*/
87:                  
88:                  /******************************************************************************
89:                   End of File
90:                  */
91:                  
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/usart/templates/usart_EnableControl_Default.h
1:                   /*******************************************************************************
2:                     USART Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usart_EnableControl_Default.h
6:                   
7:                     Summary:
8:                       USART PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : EnableControl
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USART_ExistsEnable
16:                          PLIB_USART_Disable
17:                          PLIB_USART_Enable
18:                          PLIB_USART_BaudSetAndEnable
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _USART_ENABLECONTROL_DEFAULT_H
49:                  #define _USART_ENABLECONTROL_DEFAULT_H
50:                  
51:                  #include "usart_registers.h"
52:                  
53:                  //******************************************************************************
54:                  /* Function :  USART_ExistsEnable_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_USART_ExistsEnable
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_USART_ExistsEnable function.
61:                  */
62:                  
63:                  #define PLIB_USART_ExistsEnable PLIB_USART_ExistsEnable
64:                  PLIB_TEMPLATE bool USART_ExistsEnable_Default( USART_MODULE_ID index )
65:                  {
66:                      return true;
67:                  }
68:                  
69:                  
70:                  //******************************************************************************
71:                  /* Function :  USART_Disable_Default
72:                  
73:                    Summary:
74:                      Implements Default variant of PLIB_USART_Disable 
75:                  
76:                    Description:
77:                      This template implements the Default variant of the PLIB_USART_Disable function.
78:                  */
79:                  
80:                  PLIB_TEMPLATE void USART_Disable_Default( USART_MODULE_ID index )
81:                  {
82:                      usart_registers_t volatile * usart = ((usart_registers_t *)(index));
9D009FE0  8CA20004   LW V0, 4(A1)
83:                      usart->UxMODECLR = UxMODE_ON_MASK;
9D009FE4  34038000   ORI V1, ZERO, -32768
9D009FE8  AC430004   SW V1, 4(V0)
84:                  }
85:                  
86:                  
87:                  //******************************************************************************
88:                  /* Function :  USART_Enable_Default
89:                  
90:                    Summary:
91:                      Implements Default variant of PLIB_USART_Enable 
92:                  
93:                    Description:
94:                      This template implements the Default variant of the PLIB_USART_Enable function.
95:                  */
96:                  
97:                  PLIB_TEMPLATE void USART_Enable_Default( USART_MODULE_ID index )
98:                  {
99:                      usart_registers_t volatile * usart = ((usart_registers_t *)(index));
9D00A150  8E020004   LW V0, 4(S0)
100:                     usart->UxMODESET = UxMODE_ON_MASK;
9D00A154  34038000   ORI V1, ZERO, -32768
9D00A158  AC430008   SW V1, 8(V0)
101:                 }
102:                 
103:                 //******************************************************************************
104:                 /* Function :  USART_BaudSetAndEnable_Default
105:                 
106:                   Summary:
107:                     Implements Default variant of PLIB_USART_BaudSetAndEnable 
108:                 
109:                   Description:
110:                     This template implements the Default variant of the PLIB_USART_BaudSetAndEnable function.
111:                 */
112:                 
113:                 PLIB_TEMPLATE void USART_BaudSetAndEnable_Default( USART_MODULE_ID index, uint32_t systemClock, uint32_t baud  )
114:                 {
115:                     usart_registers_t volatile * usart = ((usart_registers_t *)(index));
116:                     uint32_t brgValueLow = 0;
117:                     uint32_t brgValueHigh = 0;
118:                 
119:                     /* Enable transmit and receive */
120:                     usart->UxSTASET = (UxSTA_UTXEN_MASK | UxSTA_URXEN_MASK);
9D00A694  24031400   ADDIU V1, ZERO, 5120
9D00A698  AC830018   SW V1, 24(A0)
121:                 
122:                     /* Find the BRG Value */
123:                     brgValueLow  = ( ((systemClock >> 4u) + (baud >> 1u)) / baud ) - 1u;
9D00A69C  00022842   SRL A1, V0, 1
9D00A6E0  00063102   SRL A2, A2, 4
9D00A6E4  00A62821   ADDU A1, A1, A2
9D00A6E8  00A2001B   DIVU A1, V0
9D00A6EC  004001F4   TEQ V0, ZERO
9D00A6F0  00002812   MFLO A1
9D00A6F4  24A5FFFF   ADDIU A1, A1, -1
124:                     brgValueHigh = ( ((systemClock >> 2u) + (baud >> 1u)) / baud ) - 1u;
9D00A6A0  00061882   SRL V1, A2, 2
9D00A6A4  00651821   ADDU V1, V1, A1
9D00A6A8  0062001B   DIVU V1, V0
9D00A6AC  004001F4   TEQ V0, ZERO
9D00A6B0  00001812   MFLO V1
9D00A6B4  2463FFFF   ADDIU V1, V1, -1
125:                 
126:                     /* Check if the baud value can be set with high baud settings */
127:                     if ((brgValueHigh >= 0) && (brgValueHigh <= UINT16_MAX))
9D00A6B8  3C070001   LUI A3, 1
9D00A6BC  0067382B   SLTU A3, V1, A3
9D00A6C0  50E00006   BEQL A3, ZERO, _DRV_USART_HardwareSetup::PLIB_USART_BaudSetAndEnable
9D00A6C4  24030008   ADDIU V1, ZERO, 8
128:                     {
129:                         /* Set BRGH */
130:                         usart->UxMODESET = UxMODE_BRGH_MASK;
9D00A6C8  24020008   ADDIU V0, ZERO, 8
9D00A6CC  AC820008   SW V0, 8(A0)
131:                         usart->UxBRG = brgValueHigh;
9D00A6D0  AC830040   SW V1, 64(A0)
132:                     }
133:                     else
134:                     {
135:                         /* Clear BRGH */
136:                         usart->UxMODECLR = UxMODE_BRGH_MASK;
9D00A6DC  AC830004   SW V1, 4(A0)
137:                         usart->UxBRG = brgValueLow;
9D00A6F8  AC850040   SW A1, 64(A0)
138:                     }
139:                 
140:                     /* Enable the UART */
141:                     usart->UxMODESET = UxMODE_ON_MASK;
9D00A6D4  0B4029C0   J 0x9D00A700
9D00A6D8  34028000   ORI V0, ZERO, -32768
9D00A6FC  34028000   ORI V0, ZERO, -32768
142:                 }
143:                 
144:                 #endif /*_USART_ENABLECONTROL_DEFAULT_H*/
145:                 
146:                 /******************************************************************************
147:                  End of File
148:                 */
149:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/tmr/templates/tmr_Prescale_Default.h  
1:                   /*******************************************************************************
2:                     TMR Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       tmr_Prescale_Default.h
6:                   
7:                     Summary:
8:                       TMR PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : Prescale
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_TMR_PrescaleSelect
16:                          PLIB_TMR_PrescaleGet
17:                          PLIB_TMR_ExistsPrescale
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _TMR_PRESCALE_DEFAULT_H
48:                  #define _TMR_PRESCALE_DEFAULT_H
49:                  
50:                  #include "tmr_registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  TMR_PrescaleSelect_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_TMR_PrescaleSelect
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_TMR_PrescaleSelect function.
60:                  */
61:                  
62:                  PLIB_TEMPLATE void TMR_PrescaleSelect_Default( TMR_MODULE_ID index , TMR_PRESCALE prescale )
63:                  {
64:                      tmr_registers_t volatile * tmr = ((tmr_registers_t *)(index));
65:                      
66:                      if(TMR_ID_1 == index)
67:                      {
68:                          switch(prescale)
69:                          {
70:                              case TMR_PRESCALE_VALUE_1:  tmr->TxCON.TCKPS = 0;
71:                                                          break;
72:                              case TMR_PRESCALE_VALUE_8:  tmr->TxCON.TCKPS = 1;
73:                                                          break;
74:                              case TMR_PRESCALE_VALUE_64: tmr->TxCON.TCKPS = 2;
75:                                                          break;
76:                              case TMR_PRESCALE_VALUE_256: tmr->TxCON.TCKPS = 3;
77:                                                          break;
78:                              default: PLIB_ASSERT(false, " Given Prescale value is not supported for Timer1");
79:                          }
80:                      }
81:                      else
82:                      {
83:                          tmr->TxCON.TCKPS = prescale;
9D012A8C  94440A00   LHU A0, 2560(V0)
9D012A90  7C043104   INS A0, ZERO, 4, 3
9D012A94  A4440A00   SH A0, 2560(V0)
9D013020  94440C00   LHU A0, 3072(V0)
9D013024  24050006   ADDIU A1, ZERO, 6
9D013028  7CA43104   INS A0, A1, 4, 3
9D01302C  A4440C00   SH A0, 3072(V0)
9D0130A0  94450800   LHU A1, 2048(V0)
9D0130A4  7C053104   INS A1, ZERO, 4, 3
9D0130A8  A4450800   SH A1, 2048(V0)
84:                      }
85:                  }
86:                  
87:                  
88:                  //******************************************************************************
89:                  /* Function :  TMR_PrescaleGet_Default
90:                  
91:                    Summary:
92:                      Implements Default variant of PLIB_TMR_PrescaleGet
93:                  
94:                    Description:
95:                      This template implements the Default variant of the PLIB_TMR_PrescaleGet function.
96:                  */
97:                  
98:                  PLIB_TEMPLATE uint16_t TMR_PrescaleGet_Default( TMR_MODULE_ID index )
99:                  {
100:                     tmr_registers_t volatile * tmr = ((tmr_registers_t *)(index));
101:                     uint8_t temp_prescaler;
102:                     uint16_t preScaler;
103:                 
104:                     temp_prescaler = tmr->TxCON.TCKPS;
105:                                           
106:                     if(TMR_ID_1 == index)
107:                     {
108:                         /* 1, 8, 64, 256 */
109:                         switch(temp_prescaler)
110:                         {
111:                             case 0x00u: preScaler = 1u;
112:                                         break;
113:                             case 0x01u: preScaler = 8u;
114:                                         break;
115:                             case 0x02u: preScaler = 64u;
116:                                         break;
117:                             case 0x03u: preScaler = 256u;
118:                                         break;
119:                             default:    preScaler = 0u;
120:                         }
121:                     }
122:                     else
123:                     {
124:                         /* 1, 2, 4, 8, 16, 32, 64, 256 */
125:                         if ( temp_prescaler == 7u )
126:                         {
127:                             temp_prescaler++;
128:                         }
129:                         preScaler = (uint16_t)(0x01u << temp_prescaler);
130:                     }
131:                     return preScaler;
132:                 
133:                 }
134:                 
135:                 
136:                 //******************************************************************************
137:                 /* Function :  TMR_ExistsPrescale_Default
138:                 
139:                   Summary:
140:                     Implements Default variant of PLIB_TMR_ExistsPrescale
141:                 
142:                   Description:
143:                     This template implements the Default variant of the PLIB_TMR_ExistsPrescale function.
144:                 */
145:                 
146:                 #define PLIB_TMR_ExistsPrescale PLIB_TMR_ExistsPrescale
147:                 PLIB_TEMPLATE bool TMR_ExistsPrescale_Default( TMR_MODULE_ID index )
148:                 {
149:                     return true;
150:                 }
151:                 
152:                 
153:                 #endif /*_TMR_PRESCALE_DEFAULT_H*/
154:                 
155:                 /******************************************************************************
156:                  End of File
157:                 */
158:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/tmr/templates/tmr_Period16Bit_Default.h
1:                   /*******************************************************************************
2:                     TMR Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       tmr_Period16Bit_Default.h
6:                   
7:                     Summary:
8:                       TMR PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : Period16Bit
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_TMR_Period16BitSet
16:                          PLIB_TMR_Period16BitGet
17:                          PLIB_TMR_ExistsPeriod16Bit
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _TMR_PERIOD16BIT_Default_H
48:                  #define _TMR_PERIOD16BIT_Default_H
49:                  
50:                  #include "tmr_registers.h"
51:                  
52:                  
53:                  //******************************************************************************
54:                  /* Function :  TMR_Period16BitSet_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_TMR_Period16BitSet
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_TMR_Period16BitSet function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE void TMR_Period16BitSet_Default( TMR_MODULE_ID index , uint16_t period )
64:                  {
65:                      tmr_registers_t volatile * tmr = ((tmr_registers_t *)(index));
66:                      tmr->PRx = period;
9D012A9C  24020271   ADDIU V0, ZERO, 625
9D012AA0  AC620020   SW V0, 32(V1)
9D01303C  240204E2   ADDIU V0, ZERO, 1250
9D013040  AC620020   SW V0, 32(V1)
9D0130B8  AC640020   SW A0, 32(V1)
67:                  }
68:                  
69:                  
70:                  //******************************************************************************
71:                  /* Function :  TMR_Period16BitGet_Default
72:                  
73:                    Summary:
74:                      Implements Default variant of PLIB_TMR_Period16BitGet
75:                  
76:                    Description:
77:                      This template implements the Default variant of the PLIB_TMR_Period16BitGet function.
78:                  */
79:                  
80:                  PLIB_TEMPLATE uint16_t TMR_Period16BitGet_Default( TMR_MODULE_ID index )
81:                  {
82:                      tmr_registers_t volatile * tmr = ((tmr_registers_t *)(index));
83:                      return (uint16_t)tmr->PRx;
84:                  }
85:                  
86:                  
87:                  //******************************************************************************
88:                  /* Function :  TMR_ExistsPeriod16Bit_Default
89:                  
90:                    Summary:
91:                      Implements Default variant of PLIB_TMR_ExistsPeriod16Bit
92:                  
93:                    Description:
94:                      This template implements the Default variant of the PLIB_TMR_ExistsPeriod16Bit function.
95:                  */
96:                  
97:                  #define PLIB_TMR_ExistsPeriod16Bit PLIB_TMR_ExistsPeriod16Bit
98:                  PLIB_TEMPLATE bool TMR_ExistsPeriod16Bit_Default( TMR_MODULE_ID index )
99:                  {
100:                     return true;
101:                 }
102:                 
103:                 
104:                 #endif /*_TMR_PERIOD16BIT_Default_H*/
105:                 
106:                 /******************************************************************************
107:                  End of File
108:                 */
109:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/tmr/templates/tmr_Mode16Bit_Default.h  
1:                   /*******************************************************************************
2:                     TMR Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       tmr_Mode16Bit_Default.h
6:                   
7:                     Summary:
8:                       TMR PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : Mode16Bit
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_TMR_Mode16BitEnable
16:                          PLIB_TMR_ExistsMode16Bit
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _TMR_MODE16BIT_DEFAULT_H
47:                  #define _TMR_MODE16BIT_DEFAULT_H
48:                  
49:                  #include "tmr_registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  TMR_Mode16BitEnable_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_TMR_Mode16BitEnable 
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_TMR_Mode16BitEnable function.
59:                  */
60:                  
61:                  PLIB_TEMPLATE void TMR_Mode16BitEnable_Default( TMR_MODULE_ID index )
62:                  {
63:                      tmr_registers_t volatile * tmr = ((tmr_registers_t *)(index));
64:                      
65:                      if (_TMR_MODULE_ID_IS_EVEN(index))
66:                      {
67:                          tmr->TxCONCLR = TxCON_T32_MASK;
9D013030  24020008   ADDIU V0, ZERO, 8
9D013034  AC620004   SW V0, 4(V1)
9D0130AC  24020008   ADDIU V0, ZERO, 8
9D0130B0  AC620004   SW V0, 4(V1)
68:                      }
69:                      else
70:                      {
71:                          PLIB_ASSERT(false, "Other timers are by default in 16 bit mode");
72:                      }
73:                  }
74:                  
75:                  
76:                  
77:                  //******************************************************************************
78:                  /* Function :  TMR_ExistsMode16Bit_Default
79:                  
80:                    Summary:
81:                      Implements Default variant of PLIB_TMR_ExistsMode16Bit
82:                  
83:                    Description:
84:                      This template implements the Default variant of the PLIB_TMR_ExistsMode16Bit function.
85:                  */
86:                  
87:                  #define PLIB_TMR_ExistsMode16Bit PLIB_TMR_ExistsMode16Bit
88:                  PLIB_TEMPLATE bool TMR_ExistsMode16Bit_Default( TMR_MODULE_ID index )
89:                  {
90:                      /* 16 bit mode always exists */
91:                      return true;
92:                  }
93:                  
94:                  
95:                  #endif /*_TMR_MODE16BIT_DEFAULT_H*/
96:                  
97:                  /******************************************************************************
98:                   End of File
99:                  */
100:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/tmr/templates/tmr_EnableControl_Default.h
1:                   /*******************************************************************************
2:                     TMR Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       tmr_EnableControl_Default.h
6:                   
7:                     Summary:
8:                       TMR PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : EnableControl
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_TMR_Start
16:                          PLIB_TMR_Stop
17:                          PLIB_TMR_ExistsEnableControl
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _TMR_ENABLECONTROL_DEFAULT_H
48:                  #define _TMR_ENABLECONTROL_DEFAULT_H
49:                  
50:                  #include "tmr_registers.h"
51:                  
52:                  
53:                  //******************************************************************************
54:                  /* Function :  TMR_Start_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_TMR_Start 
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_TMR_Start function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE void TMR_Start_Default( TMR_MODULE_ID index )
64:                  {
65:                      tmr_registers_t volatile * tmr = ((tmr_registers_t *)(index));
66:                  
67:                      tmr->TxCONSET = TxCON_ON_MASK;
9D014DA8  34038000   ORI V1, ZERO, -32768
9D014DE0  34038000   ORI V1, ZERO, -32768
9D014E18  34038000   ORI V1, ZERO, -32768
68:                  }
69:                  
70:                  
71:                  //******************************************************************************
72:                  /* Function :  TMR_Stop_Default
73:                  
74:                    Summary:
75:                      Implements Default variant of PLIB_TMR_Stop 
76:                  
77:                    Description:
78:                      This template implements the Default variant of the PLIB_TMR_Stop function.
79:                  */
80:                  
81:                  PLIB_TEMPLATE void TMR_Stop_Default( TMR_MODULE_ID index )
82:                  {
83:                      tmr_registers_t volatile * tmr = ((tmr_registers_t *)(index));
84:                  
85:                      tmr->TxCONCLR = TxCON_ON_MASK;
9D012A70  3C02BF80   LUI V0, -16512
9D012A74  24430A00   ADDIU V1, V0, 2560
9D012A78  34048000   ORI A0, ZERO, -32768
9D012A7C  AC440A04   SW A0, 2564(V0)
9D013004  3C02BF80   LUI V0, -16512
9D013008  24430C00   ADDIU V1, V0, 3072
9D01300C  34048000   ORI A0, ZERO, -32768
9D013010  AC440C04   SW A0, 3076(V0)
9D013080  3C02BF80   LUI V0, -16512
9D013084  24430800   ADDIU V1, V0, 2048
9D013088  34048000   ORI A0, ZERO, -32768
9D01308C  AC440804   SW A0, 2052(V0)
9D014BA0  34038000   ORI V1, ZERO, -32768
9D014BDC  34038000   ORI V1, ZERO, -32768
9D014FF0  34038000   ORI V1, ZERO, -32768
9D014FF4  3C02BF80   LUI V0, -16512
9D014FF8  AC430A04   SW V1, 2564(V0)
86:                  }
87:                  
88:                  
89:                  //******************************************************************************
90:                  /* Function :  TMR_ExistsEnableControl_Default
91:                  
92:                    Summary:
93:                      Implements Default variant of PLIB_TMR_ExistsEnableControl
94:                  
95:                    Description:
96:                      This template implements the Default variant of the PLIB_TMR_ExistsEnableControl function.
97:                  */
98:                  
99:                  #define PLIB_TMR_ExistsEnableControl PLIB_TMR_ExistsEnableControl
100:                 PLIB_TEMPLATE bool TMR_ExistsEnableControl_Default( TMR_MODULE_ID index )
101:                 {
102:                     return true;
103:                 }
104:                 
105:                 
106:                 #endif /*_TMR_ENABLECONTROL_DEFAULT_H*/
107:                 
108:                 /******************************************************************************
109:                  End of File
110:                 */
111:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/tmr/templates/tmr_Counter16Bit_In16BitRegister.h
1:                   /*******************************************************************************
2:                     TMR Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       tmr_Counter16Bit_In16BitRegister.h
6:                   
7:                     Summary:
8:                       TMR PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : Counter16Bit
13:                      and its Variant : In16BitRegister
14:                      For following APIs :
15:                          PLIB_TMR_Counter16BitSet
16:                          PLIB_TMR_Counter16BitGet
17:                          PLIB_TMR_Counter16BitClear
18:                          PLIB_TMR_ExistsCounter16Bit
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _TMR_COUNTER16BIT_IN16BITREGISTER_H
49:                  #define _TMR_COUNTER16BIT_IN16BITREGISTER_H
50:                  
51:                  #include "tmr_registers.h"
52:                  
53:                  //******************************************************************************
54:                  /* Function :  TMR_Counter16BitSet_In16BitRegister
55:                  
56:                    Summary:
57:                      Implements In16BitRegister variant of PLIB_TMR_Counter16BitSet
58:                  
59:                    Description:
60:                      This template implements the In16BitRegister variant of the PLIB_TMR_Counter16BitSet function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE void TMR_Counter16BitSet_In16BitRegister( TMR_MODULE_ID index , uint16_t value )
64:                  {
65:                      tmr_registers_t volatile * tmr = ((tmr_registers_t *)(index));
66:                      
67:                      tmr->TMRx = value;
9D015824  3084FFFF   ANDI A0, A0, -1
9D01584C  3084FFFF   ANDI A0, A0, -1
9D015874  3084FFFF   ANDI A0, A0, -1
68:                  }
69:                  
70:                  
71:                  //******************************************************************************
72:                  /* Function :  TMR_Counter16BitGet_In16BitRegister
73:                  
74:                    Summary:
75:                      Implements In16BitRegister variant of PLIB_TMR_Counter16BitGet
76:                  
77:                    Description:
78:                      This template implements the In16BitRegister variant of the PLIB_TMR_Counter16BitGet function.
79:                  */
80:                  
81:                  PLIB_TEMPLATE uint16_t TMR_Counter16BitGet_In16BitRegister( TMR_MODULE_ID index )
82:                  {
83:                      tmr_registers_t volatile * tmr = ((tmr_registers_t *)(index));
84:                  
85:                      return (uint16_t)tmr->TMRx;
9D015838  3C02BF80   LUI V0, -16512
9D01583C  24420C00   ADDIU V0, V0, 3072
9D015840  8C420010   LW V0, 16(V0)
9D015860  3C02BF80   LUI V0, -16512
9D015864  24420A00   ADDIU V0, V0, 2560
9D015868  8C420010   LW V0, 16(V0)
9D015888  3C02BF80   LUI V0, -16512
9D01588C  24420800   ADDIU V0, V0, 2048
9D015890  8C420010   LW V0, 16(V0)
86:                  }
87:                  
88:                  
89:                  //******************************************************************************
90:                  /* Function :  TMR_Counter16BitClear_In16BitRegister
91:                  
92:                    Summary:
93:                      Implements In16BitRegister variant of PLIB_TMR_Counter16BitClear
94:                  
95:                    Description:
96:                      This template implements the In16BitRegister variant of the PLIB_TMR_Counter16BitClear function.
97:                  */
98:                  
99:                  PLIB_TEMPLATE void TMR_Counter16BitClear_In16BitRegister( TMR_MODULE_ID index )
100:                 {
101:                     tmr_registers_t volatile * tmr = ((tmr_registers_t *)(index));
102:                     
103:                     tmr->TMRx = 0u;
9D012A98  AC400A10   SW ZERO, 2576(V0)
9D013038  AC600010   SW ZERO, 16(V1)
9D0130B4  AC600010   SW ZERO, 16(V1)
9D015954  3C02BF80   LUI V0, -16512
9D015964  3C02BF80   LUI V0, -16512
9D015974  3C02BF80   LUI V0, -16512
104:                 }
105:                 
106:                 
107:                 //******************************************************************************
108:                 /* Function :  TMR_ExistsCounter16Bit_In16BitRegister
109:                 
110:                   Summary:
111:                     Implements In16BitRegister variant of PLIB_TMR_ExistsCounter16Bit
112:                 
113:                   Description:
114:                     This template implements the In16BitRegister variant of the PLIB_TMR_ExistsCounter16Bit function.
115:                 */
116:                 
117:                 #define PLIB_TMR_ExistsCounter16Bit PLIB_TMR_ExistsCounter16Bit
118:                 PLIB_TEMPLATE bool TMR_ExistsCounter16Bit_In16BitRegister( TMR_MODULE_ID index )
119:                 {
120:                     return true;
121:                 }
122:                 
123:                 
124:                 #endif /*_TMR_COUNTER16BIT_IN16BITREGISTER_H*/
125:                 
126:                 /******************************************************************************
127:                  End of File
128:                 */
129:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/tmr/templates/tmr_ClockSource_Default.h
1:                   /*******************************************************************************
2:                     TMR Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       tmr_ClockSource_Default.h
6:                   
7:                     Summary:
8:                       TMR PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ClockSource
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_TMR_ClockSourceSelect
16:                          PLIB_TMR_ExistsClockSource
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _TMR_CLOCKSOURCE_DEFAULT_H
47:                  #define _TMR_CLOCKSOURCE_DEFAULT_H
48:                  
49:                  #include "tmr_registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  TMR_ClockSourceSelect_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_TMR_ClockSourceSelect 
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_TMR_ClockSourceSelect function.
59:                  */
60:                  
61:                  PLIB_TEMPLATE void TMR_ClockSourceSelect_Default( TMR_MODULE_ID index , TMR_CLOCK_SOURCE source )
62:                  {
63:                      tmr_registers_t volatile * tmr = ((tmr_registers_t *)(index));
64:                  
65:                      tmr->TxCON.TCS = source;
9D012A80  94440A00   LHU A0, 2560(V0)
9D012A84  7C040844   INS A0, ZERO, 1, 1
9D012A88  A4440A00   SH A0, 2560(V0)
9D013014  94440C00   LHU A0, 3072(V0)
9D013018  7C040844   INS A0, ZERO, 1, 1
9D01301C  A4440C00   SH A0, 3072(V0)
9D013090  94450800   LHU A1, 2048(V0)
9D013094  24060001   ADDIU A2, ZERO, 1
9D013098  7CC50844   INS A1, A2, 1, 1
9D01309C  A4450800   SH A1, 2048(V0)
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  TMR_ExistsClockSource_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_TMR_ExistsClockSource
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_TMR_ExistsClockSource function.
77:                  */
78:                  
79:                  #define PLIB_TMR_ExistsClockSource PLIB_TMR_ExistsClockSource
80:                  PLIB_TEMPLATE bool TMR_ExistsClockSource_Default( TMR_MODULE_ID index )
81:                  {
82:                      return true;
83:                  }
84:                  
85:                  
86:                  #endif /*_TMR_CLOCKSOURCE_DEFAULT_H*/
87:                  
88:                  /******************************************************************************
89:                   End of File
90:                  */
91:                  
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/rtcc/templates/rtcc_WriteEnable_Default.h
1:                   /*******************************************************************************
2:                     RTCC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       rtcc_WriteEnable_Default.h
6:                   
7:                     Summary:
8:                       RTCC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : WriteEnable
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_RTCC_WriteEnable
16:                          PLIB_RTCC_WriteDisable
17:                          PLIB_RTCC_ExistsWriteEnable
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _RTCC_WRITEENABLE_DEFAULT_H
48:                  #define _RTCC_WRITEENABLE_DEFAULT_H
49:                  
50:                  #include "rtcc_Registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  RTCC_WriteEnable_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_RTCC_WriteEnable 
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_RTCC_WriteEnable function.
60:                  */
61:                  
62:                  PLIB_TEMPLATE void RTCC_WriteEnable_Default( RTCC_MODULE_ID index )
63:                  {
64:                      volatile rtcc_register_t *rtc = (rtcc_register_t *)index;
65:                  
66:                      rtc->RTCCONSET = _RTCCON_RTCWREN_MASK;
9D00F4FC  3C02BF80   LUI V0, -16512
9D00F500  24030008   ADDIU V1, ZERO, 8
9D00F504  AC430208   SW V1, 520(V0)
67:                  }
68:                  
69:                  
70:                  //******************************************************************************
71:                  /* Function :  RTCC_WriteDisable_Default
72:                  
73:                    Summary:
74:                      Implements Default variant of PLIB_RTCC_WriteDisable 
75:                  
76:                    Description:
77:                      This template implements the Default variant of the PLIB_RTCC_WriteDisable function.
78:                  */
79:                  
80:                  PLIB_TEMPLATE void RTCC_WriteDisable_Default( RTCC_MODULE_ID index )
81:                  {
82:                      volatile rtcc_register_t *rtc = (rtcc_register_t *)index;
83:                  
84:                      rtc->RTCCONCLR = _RTCCON_RTCWREN_MASK;
85:                  }
86:                  
87:                  
88:                  //******************************************************************************
89:                  /* Function :  RTCC_ExistsWriteEnable_Default
90:                  
91:                    Summary:
92:                      Implements Default variant of PLIB_RTCC_ExistsWriteEnable
93:                  
94:                    Description:
95:                      This template implements the Default variant of the PLIB_RTCC_ExistsWriteEnable function.
96:                  */
97:                  
98:                  #define PLIB_RTCC_ExistsWriteEnable PLIB_RTCC_ExistsWriteEnable
99:                  PLIB_TEMPLATE bool RTCC_ExistsWriteEnable_Default( RTCC_MODULE_ID index )
100:                 {
101:                     return true;
102:                 }
103:                 
104:                 
105:                 #endif /*_RTCC_WRITEENABLE_DEFAULT_H*/
106:                 
107:                 /******************************************************************************
108:                  End of File
109:                 */
110:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/rtcc/templates/rtcc_RTCTime_Default.h  
1:                   /*******************************************************************************
2:                     RTCC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       rtcc_RTCTime_Default.h
6:                   
7:                     Summary:
8:                       RTCC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : RTCTime
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_RTCC_RTCTimeGet
16:                          PLIB_RTCC_RTCTimeSet
17:                          PLIB_RTCC_RTCHourGet
18:                          PLIB_RTCC_RTCHourSet
19:                          PLIB_RTCC_RTCMinuteGet
20:                          PLIB_RTCC_RTCMinuteSet
21:                          PLIB_RTCC_RTCSecondGet
22:                          PLIB_RTCC_RTCSecondSet
23:                          PLIB_RTCC_ExistsRTCTime
24:                  
25:                  *******************************************************************************/
26:                  
27:                  //DOM-IGNORE-BEGIN
28:                  /*******************************************************************************
29:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
30:                  
31:                  Microchip licenses to you the right to use, modify, copy and distribute
32:                  Software only when embedded on a Microchip microcontroller or digital signal
33:                  controller that is integrated into your product or third party product
34:                  (pursuant to the sublicense terms in the accompanying license agreement).
35:                  
36:                  You should refer to the license agreement accompanying this Software for
37:                  additional information regarding your rights and obligations.
38:                  
39:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
40:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
41:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
42:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
43:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
44:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
45:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
46:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
47:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
48:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
49:                  *******************************************************************************/
50:                  
51:                  //DOM-IGNORE-END
52:                  
53:                  #ifndef _RTCC_RTCTIME_DEFAULT_H
54:                  #define _RTCC_RTCTIME_DEFAULT_H
55:                  
56:                  #include "rtcc_Registers.h"
57:                  
58:                  //******************************************************************************
59:                  /* Routines available for accessing VREGS, MASKS, POS, LEN are 
60:                  
61:                    VREGs: 
62:                      _RTCC_RTCTIME_VREG(index)
63:                      _RTCC_TIME_HR10_VREG(index)
64:                      _RTCC_TIME_HR01_VREG(index)
65:                      _RTCC_TIME_MIN10_VREG(index)
66:                      _RTCC_TIME_MIN01_VREG(index)
67:                      _RTCC_TIME_SEC10_VREG(index)
68:                      _RTCC_TIME_SEC01_VREG(index)
69:                  
70:                    MASKs: 
71:                      _RTCC_RTCTIME_MASK(index)
72:                      _RTCC_TIME_HR10_MASK(index)
73:                      _RTCC_TIME_HR01_MASK(index)
74:                      _RTCC_TIME_MIN10_MASK(index)
75:                      _RTCC_TIME_MIN01_MASK(index)
76:                      _RTCC_TIME_SEC10_MASK(index)
77:                      _RTCC_TIME_SEC01_MASK(index)
78:                  
79:                    POSs: 
80:                      _RTCC_RTCTIME_POS(index)
81:                      _RTCC_TIME_HR10_POS(index)
82:                      _RTCC_TIME_HR01_POS(index)
83:                      _RTCC_TIME_MIN10_POS(index)
84:                      _RTCC_TIME_MIN01_POS(index)
85:                      _RTCC_TIME_SEC10_POS(index)
86:                      _RTCC_TIME_SEC01_POS(index)
87:                  
88:                    LENs: 
89:                      _RTCC_RTCTIME_LEN(index)
90:                      _RTCC_TIME_HR10_LEN(index)
91:                      _RTCC_TIME_HR01_LEN(index)
92:                      _RTCC_TIME_MIN10_LEN(index)
93:                      _RTCC_TIME_MIN01_LEN(index)
94:                      _RTCC_TIME_SEC10_LEN(index)
95:                      _RTCC_TIME_SEC01_LEN(index)
96:                  
97:                  */
98:                  
99:                  
100:                 //******************************************************************************
101:                 /* Function :  RTCC_RTCTimeGet_Default
102:                 
103:                   Summary:
104:                     Implements Default variant of PLIB_RTCC_RTCTimeGet 
105:                 
106:                   Description:
107:                     This template implements the Default variant of the PLIB_RTCC_RTCTimeGet function.
108:                 */
109:                 
110:                 PLIB_TEMPLATE uint32_t RTCC_RTCTimeGet_Default( RTCC_MODULE_ID index )
111:                 {
112:                     volatile rtcc_register_t *rtc = (rtcc_register_t *)index;
113:                 
114:                     return rtc->RTCTIME.w;
9D0122CC  8C720220   LW S2, 544(V1)
9D0156F0  3C02BF80   LUI V0, -16512
9D0156F4  24420200   ADDIU V0, V0, 512
9D0156F8  8C420020   LW V0, 32(V0)
115:                 }
116:                 
117:                 
118:                 //******************************************************************************
119:                 /* Function :  RTCC_RTCTimeSet_Default
120:                 
121:                   Summary:
122:                     Implements Default variant of PLIB_RTCC_RTCTimeSet 
123:                 
124:                   Description:
125:                     This template implements the Default variant of the PLIB_RTCC_RTCTimeSet function.
126:                 */
127:                 
128:                 PLIB_TEMPLATE void RTCC_RTCTimeSet_Default( RTCC_MODULE_ID index , uint32_t data )
129:                 {
130:                     volatile rtcc_register_t *rtc = (rtcc_register_t *)index;
131:                 
132:                     rtc->RTCTIME.w = data;
9D00F524  3C032359   LUI V1, 9049
9D00F528  24635000   ADDIU V1, V1, 20480
9D00F52C  AC430220   SW V1, 544(V0)
9D0122E8  AC520220   SW S2, 544(V0)
9D0155C4  3C02BF80   LUI V0, -16512
9D0155C8  AC440220   SW A0, 544(V0)
133:                 }
134:                 
135:                 
136:                 //******************************************************************************
137:                 /* Function :  RTCC_RTCHourGet_Default
138:                 
139:                   Summary:
140:                     Implements Default variant of PLIB_RTCC_RTCHourGet 
141:                 
142:                   Description:
143:                     This template implements the Default variant of the PLIB_RTCC_RTCHourGet function.
144:                 */
145:                 
146:                 PLIB_TEMPLATE uint32_t RTCC_RTCHourGet_Default( RTCC_MODULE_ID index )
147:                 {
148:                     volatile rtcc_register_t *rtc = (rtcc_register_t *)index;
149:                 
150:                     return rtc->RTCTIME.HR01 | (rtc->RTCTIME.HR10 << _RTCTIME_HR01_LENGTH);
151:                 }
152:                 
153:                 
154:                 //******************************************************************************
155:                 /* Function :  RTCC_RTCHourSet_Default
156:                 
157:                   Summary:
158:                     Implements Default variant of PLIB_RTCC_RTCHourSet 
159:                 
160:                   Description:
161:                     This template implements the Default variant of the PLIB_RTCC_RTCHourSet function.
162:                 */
163:                 
164:                 PLIB_TEMPLATE void RTCC_RTCHourSet_Default( RTCC_MODULE_ID index , uint32_t hour )
165:                 {
166:                     volatile rtcc_register_t *rtc = (rtcc_register_t *)index;
167:                     uint32_t tmpVal = rtc->RTCTIME.w;
168:                 
169:                     tmpVal &= ~(_RTCTIME_HR01_MASK | _RTCTIME_HR10_MASK);
170:                     tmpVal |= hour << _RTCTIME_HR01_POSITION;
171:                     rtc->RTCTIME.w = tmpVal;
172:                 }
173:                 
174:                 
175:                 //******************************************************************************
176:                 /* Function :  RTCC_RTCMinuteGet_Default
177:                 
178:                   Summary:
179:                     Implements Default variant of PLIB_RTCC_RTCMinuteGet 
180:                 
181:                   Description:
182:                     This template implements the Default variant of the PLIB_RTCC_RTCMinuteGet function.
183:                 */
184:                 
185:                 PLIB_TEMPLATE uint32_t RTCC_RTCMinuteGet_Default( RTCC_MODULE_ID index )
186:                 {
187:                     volatile rtcc_register_t *rtc = (rtcc_register_t *)index;
188:                 
189:                     return rtc->RTCTIME.MIN01 | (rtc->RTCTIME.MIN10 << _RTCTIME_MIN01_LENGTH);
190:                 }
191:                 
192:                 
193:                 //******************************************************************************
194:                 /* Function :  RTCC_RTCMinuteSet_Default
195:                 
196:                   Summary:
197:                     Implements Default variant of PLIB_RTCC_RTCMinuteSet 
198:                 
199:                   Description:
200:                     This template implements the Default variant of the PLIB_RTCC_RTCMinuteSet function.
201:                 */
202:                 
203:                 PLIB_TEMPLATE void RTCC_RTCMinuteSet_Default( RTCC_MODULE_ID index , uint32_t minute )
204:                 {
205:                     volatile rtcc_register_t *rtc = (rtcc_register_t *)index;
206:                     uint32_t tmpVal = rtc->RTCTIME.w;
207:                 
208:                     tmpVal &= ~(_RTCTIME_MIN01_MASK | _RTCTIME_MIN10_MASK);
209:                     tmpVal |= minute << _RTCTIME_MIN01_POSITION;
210:                     rtc->RTCTIME.w = tmpVal;
211:                 }
212:                 
213:                 
214:                 //******************************************************************************
215:                 /* Function :  RTCC_RTCSecondGet_Default
216:                 
217:                   Summary:
218:                     Implements Default variant of PLIB_RTCC_RTCSecondGet 
219:                 
220:                   Description:
221:                     This template implements the Default variant of the PLIB_RTCC_RTCSecondGet function.
222:                 */
223:                 
224:                 PLIB_TEMPLATE uint32_t RTCC_RTCSecondGet_Default( RTCC_MODULE_ID index )
225:                 {
226:                     volatile rtcc_register_t *rtc = (rtcc_register_t *)index;
227:                 
228:                     return rtc->RTCTIME.SEC01 | (rtc->RTCTIME.SEC10 << _RTCTIME_SEC01_LENGTH);
229:                 }
230:                 
231:                 
232:                 //******************************************************************************
233:                 /* Function :  RTCC_RTCSecondSet_Default
234:                 
235:                   Summary:
236:                     Implements Default variant of PLIB_RTCC_RTCSecondSet 
237:                 
238:                   Description:
239:                     This template implements the Default variant of the PLIB_RTCC_RTCSecondSet function.
240:                 */
241:                 
242:                 PLIB_TEMPLATE void RTCC_RTCSecondSet_Default( RTCC_MODULE_ID index , uint32_t second )
243:                 {
244:                     volatile rtcc_register_t *rtc = (rtcc_register_t *)index;
245:                     uint32_t tmpVal = rtc->RTCTIME.w;
246:                 
247:                     tmpVal &= ~(_RTCTIME_SEC01_MASK | _RTCTIME_SEC10_MASK);
248:                     tmpVal |= second << _RTCTIME_SEC01_POSITION;
249:                     rtc->RTCTIME.w = tmpVal;
250:                 }
251:                 
252:                 
253:                 //******************************************************************************
254:                 /* Function :  RTCC_ExistsRTCTime_Default
255:                 
256:                   Summary:
257:                     Implements Default variant of PLIB_RTCC_ExistsRTCTime
258:                 
259:                   Description:
260:                     This template implements the Default variant of the PLIB_RTCC_ExistsRTCTime function.
261:                 */
262:                 
263:                 #define PLIB_RTCC_ExistsRTCTime PLIB_RTCC_ExistsRTCTime
264:                 PLIB_TEMPLATE bool RTCC_ExistsRTCTime_Default( RTCC_MODULE_ID index )
265:                 {
266:                     return true;
267:                 }
268:                 
269:                 
270:                 #endif /*_RTCC_RTCTIME_DEFAULT_H*/
271:                 
272:                 /******************************************************************************
273:                  End of File
274:                 */
275:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/rtcc/templates/rtcc_RTCDate_Default.h  
1:                   /*******************************************************************************
2:                     RTCC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       rtcc_RTCDate_Default.h
6:                   
7:                     Summary:
8:                       RTCC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : RTCDate
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_RTCC_RTCDateGet
16:                          PLIB_RTCC_RTCDateSet
17:                          PLIB_RTCC_RTCYearGet
18:                          PLIB_RTCC_RTCYearSet
19:                          PLIB_RTCC_RTCMonthGet
20:                          PLIB_RTCC_RTCMonthSet
21:                          PLIB_RTCC_RTCDayGet
22:                          PLIB_RTCC_RTCDaySet
23:                          PLIB_RTCC_RTCWeekDayGet
24:                          PLIB_RTCC_RTCWeekDaySet
25:                          PLIB_RTCC_ExistsRTCDate
26:                  
27:                  *******************************************************************************/
28:                  
29:                  //DOM-IGNORE-BEGIN
30:                  /*******************************************************************************
31:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
32:                  
33:                  Microchip licenses to you the right to use, modify, copy and distribute
34:                  Software only when embedded on a Microchip microcontroller or digital signal
35:                  controller that is integrated into your product or third party product
36:                  (pursuant to the sublicense terms in the accompanying license agreement).
37:                  
38:                  You should refer to the license agreement accompanying this Software for
39:                  additional information regarding your rights and obligations.
40:                  
41:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
42:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
43:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
44:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
45:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
46:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
47:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
48:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
49:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
50:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
51:                  *******************************************************************************/
52:                  
53:                  //DOM-IGNORE-END
54:                  
55:                  #ifndef _RTCC_RTCDATE_DEFAULT_H
56:                  #define _RTCC_RTCDATE_DEFAULT_H
57:                  #include "rtcc_Registers.h"
58:                  
59:                  //******************************************************************************
60:                  /* Routines available for accessing VREGS, MASKS, POS, LEN are 
61:                  
62:                    VREGs: 
63:                      _RTCC_RTCDATE_VREG(index)
64:                      _RTCC_DATE_YEAR10_VREG(index)
65:                      _RTCC_DATE_YEAR01_VREG(index)
66:                      _RTCC_DATE_MONTH10_VREG(index)
67:                      _RTCC_DATE_MONTH01_VREG(index)
68:                      _RTCC_DATE_DAY10_VREG(index)
69:                      _RTCC_DATE_DAY01_VREG(index)
70:                      _RTCC_DATE_WDAY01_VREG(index)
71:                  
72:                    MASKs: 
73:                      _RTCC_RTCDATE_MASK(index)
74:                      _RTCC_DATE_YEAR10_MASK(index)
75:                      _RTCC_DATE_YEAR01_MASK(index)
76:                      _RTCC_DATE_MONTH10_MASK(index)
77:                      _RTCC_DATE_MONTH01_MASK(index)
78:                      _RTCC_DATE_DAY10_MASK(index)
79:                      _RTCC_DATE_DAY01_MASK(index)
80:                      _RTCC_DATE_WDAY01_MASK(index)
81:                  
82:                    POSs: 
83:                      _RTCC_RTCDATE_POS(index)
84:                      _RTCC_DATE_YEAR10_POS(index)
85:                      _RTCC_DATE_YEAR01_POS(index)
86:                      _RTCC_DATE_MONTH10_POS(index)
87:                      _RTCC_DATE_MONTH01_POS(index)
88:                      _RTCC_DATE_DAY10_POS(index)
89:                      _RTCC_DATE_DAY01_POS(index)
90:                      _RTCC_DATE_WDAY01_POS(index)
91:                  
92:                    LENs: 
93:                      _RTCC_RTCDATE_LEN(index)
94:                      _RTCC_DATE_YEAR10_LEN(index)
95:                      _RTCC_DATE_YEAR01_LEN(index)
96:                      _RTCC_DATE_MONTH10_LEN(index)
97:                      _RTCC_DATE_MONTH01_LEN(index)
98:                      _RTCC_DATE_DAY10_LEN(index)
99:                      _RTCC_DATE_DAY01_LEN(index)
100:                     _RTCC_DATE_WDAY01_LEN(index)
101:                 
102:                 */
103:                 
104:                 
105:                 //******************************************************************************
106:                 /* Function :  RTCC_RTCDateGet_Default
107:                 
108:                   Summary:
109:                     Implements Default variant of PLIB_RTCC_RTCDateGet 
110:                 
111:                   Description:
112:                     This template implements the Default variant of the PLIB_RTCC_RTCDateGet function.
113:                 */
114:                 
115:                 PLIB_TEMPLATE uint32_t RTCC_RTCDateGet_Default( RTCC_MODULE_ID index )
116:                 {
117:                     volatile rtcc_register_t *rtc = (rtcc_register_t *)index;
118:                 
119:                     return rtc->RTCDATE.w;
9D0122D0  8C710230   LW S1, 560(V1)
9D015708  3C02BF80   LUI V0, -16512
9D01570C  24420200   ADDIU V0, V0, 512
9D015710  8C420030   LW V0, 48(V0)
120:                 }
121:                 
122:                 
123:                 //******************************************************************************
124:                 /* Function :  RTCC_RTCDateSet_Default
125:                 
126:                   Summary:
127:                     Implements Default variant of PLIB_RTCC_RTCDateSet 
128:                 
129:                   Description:
130:                     This template implements the Default variant of the PLIB_RTCC_RTCDateSet function.
131:                 */
132:                 
133:                 PLIB_TEMPLATE void RTCC_RTCDateSet_Default( RTCC_MODULE_ID index , uint32_t data )
134:                 {
135:                     volatile rtcc_register_t *rtc = (rtcc_register_t *)index;
136:                 
137:                     rtc->RTCDATE.w = data;
9D00F530  3C031501   LUI V1, 5377
9D00F534  24630100   ADDIU V1, V1, 256
9D00F538  AC430230   SW V1, 560(V0)
9D0122EC  AC510230   SW S1, 560(V0)
9D0159A4  3C02BF80   LUI V0, -16512
9D0159A8  AC440230   SW A0, 560(V0)
138:                 }
139:                 
140:                 
141:                 //******************************************************************************
142:                 /* Function :  RTCC_RTCYearGet_Default
143:                 
144:                   Summary:
145:                     Implements Default variant of PLIB_RTCC_RTCYearGet 
146:                 
147:                   Description:
148:                     This template implements the Default variant of the PLIB_RTCC_RTCYearGet function.
149:                 */
150:                 
151:                 PLIB_TEMPLATE uint32_t RTCC_RTCYearGet_Default( RTCC_MODULE_ID index )
152:                 {
153:                     volatile rtcc_register_t *rtc = (rtcc_register_t *)index;
154:                 
155:                     return rtc->RTCDATE.YEAR01 | (rtc->RTCDATE.YEAR10 << _RTCDATE_YEAR01_LENGTH);
156:                 }
157:                 
158:                 
159:                 //******************************************************************************
160:                 /* Function :  RTCC_RTCYearSet_Default
161:                 
162:                   Summary:
163:                     Implements Default variant of PLIB_RTCC_RTCYearSet 
164:                 
165:                   Description:
166:                     This template implements the Default variant of the PLIB_RTCC_RTCYearSet function.
167:                 */
168:                 
169:                 PLIB_TEMPLATE void RTCC_RTCYearSet_Default( RTCC_MODULE_ID index , uint32_t year )
170:                 {
171:                     volatile rtcc_register_t *rtc = (rtcc_register_t *)index;
172:                     uint32_t tmpVal = rtc->RTCDATE.w;
173:                 
174:                     tmpVal &= ~(_RTCDATE_YEAR01_MASK | _RTCDATE_YEAR10_MASK);
175:                     tmpVal |= year << _RTCDATE_YEAR01_POSITION;
176:                     rtc->RTCDATE.w = tmpVal;
177:                 }
178:                 
179:                 
180:                 //******************************************************************************
181:                 /* Function :  RTCC_RTCMonthGet_Default
182:                 
183:                   Summary:
184:                     Implements Default variant of PLIB_RTCC_RTCMonthGet 
185:                 
186:                   Description:
187:                     This template implements the Default variant of the PLIB_RTCC_RTCMonthGet function.
188:                 */
189:                 
190:                 PLIB_TEMPLATE uint32_t RTCC_RTCMonthGet_Default( RTCC_MODULE_ID index )
191:                 {
192:                     volatile rtcc_register_t *rtc = (rtcc_register_t *)index;
193:                 
194:                     return rtc->RTCDATE.MONTH01 | (rtc->RTCDATE.MONTH10 << _RTCDATE_MONTH01_LENGTH);
195:                 }
196:                 
197:                 
198:                 //******************************************************************************
199:                 /* Function :  RTCC_RTCMonthSet_Default
200:                 
201:                   Summary:
202:                     Implements Default variant of PLIB_RTCC_RTCMonthSet 
203:                 
204:                   Description:
205:                     This template implements the Default variant of the PLIB_RTCC_RTCMonthSet function.
206:                 */
207:                 
208:                 PLIB_TEMPLATE void RTCC_RTCMonthSet_Default( RTCC_MODULE_ID index , uint32_t month )
209:                 {
210:                     volatile rtcc_register_t *rtc = (rtcc_register_t *)index;
211:                     uint32_t tmpVal = rtc->RTCDATE.w;
212:                 
213:                     tmpVal &= ~(_RTCDATE_MONTH01_MASK | _RTCDATE_MONTH10_MASK);
214:                     tmpVal |= month << _RTCDATE_MONTH01_POSITION;
215:                     rtc->RTCDATE.w = tmpVal;
216:                 }
217:                 
218:                 
219:                 //******************************************************************************
220:                 /* Function :  RTCC_RTCDayGet_Default
221:                 
222:                   Summary:
223:                     Implements Default variant of PLIB_RTCC_RTCDayGet 
224:                 
225:                   Description:
226:                     This template implements the Default variant of the PLIB_RTCC_RTCDayGet function.
227:                 */
228:                 
229:                 PLIB_TEMPLATE uint32_t RTCC_RTCDayGet_Default( RTCC_MODULE_ID index )
230:                 {
231:                     volatile rtcc_register_t *rtc = (rtcc_register_t *)index;
232:                 
233:                     return rtc->RTCDATE.DAY01 | (rtc->RTCDATE.DAY10 << _RTCDATE_DAY01_LENGTH);
234:                 }
235:                 
236:                 
237:                 //******************************************************************************
238:                 /* Function :  RTCC_RTCDaySet_Default
239:                 
240:                   Summary:
241:                     Implements Default variant of PLIB_RTCC_RTCDaySet 
242:                 
243:                   Description:
244:                     This template implements the Default variant of the PLIB_RTCC_RTCDaySet function.
245:                 */
246:                 
247:                 PLIB_TEMPLATE void RTCC_RTCDaySet_Default( RTCC_MODULE_ID index , uint32_t day )
248:                 {
249:                     volatile rtcc_register_t *rtc = (rtcc_register_t *)index;
250:                     uint32_t tmpVal = rtc->RTCDATE.w;
251:                 
252:                     tmpVal &=~(_RTCDATE_DAY01_MASK | _RTCDATE_DAY10_MASK);
253:                     tmpVal |= day << _RTCDATE_DAY01_POSITION;
254:                     rtc->RTCDATE.w = tmpVal;
255:                 }
256:                 
257:                 
258:                 //******************************************************************************
259:                 /* Function :  RTCC_RTCWeekDayGet_Default
260:                 
261:                   Summary:
262:                     Implements Default variant of PLIB_RTCC_RTCWeekDayGet 
263:                 
264:                   Description:
265:                     This template implements the Default variant of the PLIB_RTCC_RTCWeekDayGet function.
266:                 */
267:                 
268:                 PLIB_TEMPLATE uint32_t RTCC_RTCWeekDayGet_Default( RTCC_MODULE_ID index )
269:                 {
270:                     volatile rtcc_register_t *rtc = (rtcc_register_t *)index;
271:                 
272:                     return rtc->RTCDATE.WDAY01;
273:                 }
274:                 
275:                 
276:                 //******************************************************************************
277:                 /* Function :  RTCC_RTCWeekDaySet_Default
278:                 
279:                   Summary:
280:                     Implements Default variant of PLIB_RTCC_RTCWeekDaySet 
281:                 
282:                   Description:
283:                     This template implements the Default variant of the PLIB_RTCC_RTCWeekDaySet function.
284:                 */
285:                 
286:                 PLIB_TEMPLATE void RTCC_RTCWeekDaySet_Default( RTCC_MODULE_ID index , uint32_t weekday )
287:                 {
288:                     volatile rtcc_register_t *rtc = (rtcc_register_t *)index;
289:                 
290:                     rtc->RTCDATE.WDAY01 = weekday;
291:                 }
292:                 
293:                 
294:                 //******************************************************************************
295:                 /* Function :  RTCC_ExistsRTCDate_Default
296:                 
297:                   Summary:
298:                     Implements Default variant of PLIB_RTCC_ExistsRTCDate
299:                 
300:                   Description:
301:                     This template implements the Default variant of the PLIB_RTCC_ExistsRTCDate function.
302:                 */
303:                 
304:                 #define PLIB_RTCC_ExistsRTCDate PLIB_RTCC_ExistsRTCDate
305:                 PLIB_TEMPLATE bool RTCC_ExistsRTCDate_Default( RTCC_MODULE_ID index )
306:                 {
307:                     return true;
308:                 }
309:                 
310:                 
311:                 #endif /*_RTCC_RTCDATE_DEFAULT_H*/
312:                 
313:                 /******************************************************************************
314:                  End of File
315:                 */
316:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/rtcc/templates/rtcc_OutputControl_Default.h
1:                   /*******************************************************************************
2:                     RTCC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       rtcc_OutputControl_Default.h
6:                   
7:                     Summary:
8:                       RTCC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : OutputControl
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_RTCC_ClockOutputEnable
16:                          PLIB_RTCC_ClockOutputDisable
17:                          PLIB_RTCC_ExistsOutputControl
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _RTCC_OUTPUTCONTROL_DEFAULT_H
48:                  #define _RTCC_OUTPUTCONTROL_DEFAULT_H
49:                  
50:                  #include "rtcc_Registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  RTCC_ClockOutputEnable_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_RTCC_ClockOutputEnable 
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_RTCC_ClockOutputEnable function.
60:                  */
61:                  
62:                  PLIB_TEMPLATE void RTCC_ClockOutputEnable_Default( RTCC_MODULE_ID index )
63:                  {
64:                      volatile rtcc_register_t *rtc = (rtcc_register_t *)index;
65:                  
66:                      rtc->RTCCONSET = _RTCCON_RTCOE_MASK;
67:                  }
68:                  
69:                  
70:                  //******************************************************************************
71:                  /* Function :  RTCC_ClockOutputDisable_Default
72:                  
73:                    Summary:
74:                      Implements Default variant of PLIB_RTCC_ClockOutputDisable 
75:                  
76:                    Description:
77:                      This template implements the Default variant of the PLIB_RTCC_ClockOutputDisable function.
78:                  */
79:                  
80:                  PLIB_TEMPLATE void RTCC_ClockOutputDisable_Default( RTCC_MODULE_ID index )
81:                  {
82:                      volatile rtcc_register_t *rtc = (rtcc_register_t *)index;
83:                  
84:                      rtc->RTCCONCLR = _RTCCON_RTCOE_MASK;
9D00F584  24020001   ADDIU V0, ZERO, 1
9D00F588  AC620204   SW V0, 516(V1)
85:                  }
86:                  
87:                  
88:                  //******************************************************************************
89:                  /* Function :  RTCC_ExistsOutputControl_Default
90:                  
91:                    Summary:
92:                      Implements Default variant of PLIB_RTCC_ExistsOutputControl
93:                  
94:                    Description:
95:                      This template implements the Default variant of the PLIB_RTCC_ExistsOutputControl function.
96:                  */
97:                  
98:                  #define PLIB_RTCC_ExistsOutputControl PLIB_RTCC_ExistsOutputControl
99:                  PLIB_TEMPLATE bool RTCC_ExistsOutputControl_Default( RTCC_MODULE_ID index )
100:                 {
101:                     return true;
102:                 }
103:                 
104:                 
105:                 #endif /*_RTCC_OUTPUTCONTROL_DEFAULT_H*/
106:                 
107:                 /******************************************************************************
108:                  End of File
109:                 */
110:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/rtcc/templates/rtcc_EnableControl_Default.h
1:                   /*******************************************************************************
2:                     RTCC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       rtcc_EnableControl_Default.h
6:                   
7:                     Summary:
8:                       RTCC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : EnableControl
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_RTCC_Enable
16:                          PLIB_RTCC_Disable
17:                          PLIB_RTCC_ExistsEnableControl
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _RTCC_ENABLECONTROL_DEFAULT_H
48:                  #define _RTCC_ENABLECONTROL_DEFAULT_H
49:                  
50:                  #include "rtcc_Registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  RTCC_Enable_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_RTCC_Enable 
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_RTCC_Enable function.
60:                  */
61:                  
62:                  PLIB_TEMPLATE void RTCC_Enable_Default( RTCC_MODULE_ID index )
63:                  {
64:                      volatile rtcc_register_t *rtc = (rtcc_register_t *)index;
65:                  
66:                      rtc->RTCCONSET = _RTCCON_ON_MASK;
9D00F5E4  34048000   ORI A0, ZERO, -32768
9D0122B4  3C03BF80   LUI V1, -16512
9D0122B8  34028000   ORI V0, ZERO, -32768
9D0122BC  AC620208   SW V0, 520(V1)
9D0155D4  3C02BF80   LUI V0, -16512
9D0158B0  34038000   ORI V1, ZERO, -32768
9D0158B4  3C02BF80   LUI V0, -16512
9D0158B8  AC430208   SW V1, 520(V0)
67:                  }
68:                  
69:                  
70:                  //******************************************************************************
71:                  /* Function :  RTCC_Disable_Default
72:                  
73:                    Summary:
74:                      Implements Default variant of PLIB_RTCC_Disable 
75:                  
76:                    Description:
77:                      This template implements the Default variant of the PLIB_RTCC_Disable function.
78:                  */
79:                  
80:                  PLIB_TEMPLATE void RTCC_Disable_Default( RTCC_MODULE_ID index )
81:                  {
82:                      volatile rtcc_register_t *rtc = (rtcc_register_t *)index;
83:                  
84:                      rtc->RTCCONCLR = _RTCCON_ON_MASK;
9D00F508  34038000   ORI V1, ZERO, -32768
9D00F50C  AC430204   SW V1, 516(V0)
9D0158C4  34038000   ORI V1, ZERO, -32768
9D0158C8  3C02BF80   LUI V0, -16512
9D0158CC  AC430204   SW V1, 516(V0)
85:                  }
86:                  
87:                  
88:                  //******************************************************************************
89:                  /* Function :  RTCC_ExistsEnableControl_Default
90:                  
91:                    Summary:
92:                      Implements Default variant of PLIB_RTCC_ExistsEnableControl
93:                  
94:                    Description:
95:                      This template implements the Default variant of the PLIB_RTCC_ExistsEnableControl function.
96:                  */
97:                  
98:                  #define PLIB_RTCC_ExistsEnableControl PLIB_RTCC_ExistsEnableControl
99:                  PLIB_TEMPLATE bool RTCC_ExistsEnableControl_Default( RTCC_MODULE_ID index )
100:                 {
101:                     return true;
102:                 }
103:                 
104:                 
105:                 #endif /*_RTCC_ENABLECONTROL_DEFAULT_H*/
106:                 
107:                 /******************************************************************************
108:                  End of File
109:                 */
110:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/rtcc/templates/rtcc_ClockRunning_Default.h
1:                   /*******************************************************************************
2:                     RTCC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       rtcc_ClockRunning_Default.h
6:                   
7:                     Summary:
8:                       RTCC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ClockRunning
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_RTCC_ClockRunningStatus
16:                          PLIB_RTCC_ExistsClockRunning
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _RTCC_CLOCKRUNNING_DEFAULT_H
47:                  #define _RTCC_CLOCKRUNNING_DEFAULT_H
48:                  
49:                  #include "rtcc_Registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  RTCC_ClockRunningStatus_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_RTCC_ClockRunningStatus 
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_RTCC_ClockRunningStatus function.
59:                  */
60:                  
61:                  PLIB_TEMPLATE bool RTCC_ClockRunningStatus_Default( RTCC_MODULE_ID index )
62:                  {
63:                      volatile rtcc_register_t *rtc = (rtcc_register_t *)index;
64:                  
65:                      return rtc->RTCCON.RTCCLKON;
9D00F510  3C03BF80   LUI V1, -16512
9D00F514  8C620200   LW V0, 512(V1)
9D00F518  7C420180   EXT V0, V0, 6, 1
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  RTCC_ExistsClockRunning_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_RTCC_ExistsClockRunning
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_RTCC_ExistsClockRunning function.
77:                  */
78:                  
79:                  #define PLIB_RTCC_ExistsClockRunning PLIB_RTCC_ExistsClockRunning
80:                  PLIB_TEMPLATE bool RTCC_ExistsClockRunning_Default( RTCC_MODULE_ID index )
81:                  {
82:                      return true;
83:                  }
84:                  
85:                  
86:                  #endif /*_RTCC_CLOCKRUNNING_DEFAULT_H*/
87:                  
88:                  /******************************************************************************
89:                   End of File
90:                  */
91:                  
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/rtcc/templates/rtcc_AlarmTime_Default.h
1:                   /*******************************************************************************
2:                     RTCC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       rtcc_AlarmTime_Default.h
6:                   
7:                     Summary:
8:                       RTCC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : AlarmTime
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_RTCC_AlarmTimeGet
16:                          PLIB_RTCC_AlarmTimeSet
17:                          PLIB_RTCC_AlarmHourGet
18:                          PLIB_RTCC_AlarmHourSet
19:                          PLIB_RTCC_AlarmMinuteGet
20:                          PLIB_RTCC_AlarmMinuteSet
21:                          PLIB_RTCC_AlarmSecondGet
22:                          PLIB_RTCC_AlarmSecondSet
23:                          PLIB_RTCC_ExistsAlarmTime
24:                  
25:                  *******************************************************************************/
26:                  
27:                  //DOM-IGNORE-BEGIN
28:                  /*******************************************************************************
29:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
30:                  
31:                  Microchip licenses to you the right to use, modify, copy and distribute
32:                  Software only when embedded on a Microchip microcontroller or digital signal
33:                  controller that is integrated into your product or third party product
34:                  (pursuant to the sublicense terms in the accompanying license agreement).
35:                  
36:                  You should refer to the license agreement accompanying this Software for
37:                  additional information regarding your rights and obligations.
38:                  
39:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
40:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
41:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
42:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
43:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
44:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
45:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
46:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
47:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
48:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
49:                  *******************************************************************************/
50:                  
51:                  //DOM-IGNORE-END
52:                  
53:                  #ifndef _RTCC_ALARMTIME_DEFAULT_H
54:                  #define _RTCC_ALARMTIME_DEFAULT_H
55:                  
56:                  #include "rtcc_Registers.h"
57:                  
58:                  //******************************************************************************
59:                  /* Function :  RTCC_AlarmTimeGet_Default
60:                  
61:                    Summary:
62:                      Implements Default variant of PLIB_RTCC_AlarmTimeGet 
63:                  
64:                    Description:
65:                      This template implements the Default variant of the PLIB_RTCC_AlarmTimeGet function.
66:                  */
67:                  
68:                  PLIB_TEMPLATE uint32_t RTCC_AlarmTimeGet_Default( RTCC_MODULE_ID index )
69:                  {
70:                      volatile rtcc_register_t *rtc = (rtcc_register_t *)index;
71:                  
72:                      return rtc->ALRMTIME.w;
73:                  }
74:                  
75:                  
76:                  //******************************************************************************
77:                  /* Function :  RTCC_AlarmTimeSet_Default
78:                  
79:                    Summary:
80:                      Implements Default variant of PLIB_RTCC_AlarmTimeSet 
81:                  
82:                    Description:
83:                      This template implements the Default variant of the PLIB_RTCC_AlarmTimeSet function.
84:                  */
85:                  
86:                  PLIB_TEMPLATE void RTCC_AlarmTimeSet_Default( RTCC_MODULE_ID index , uint32_t data )
87:                  {
88:                      volatile rtcc_register_t *rtc = (rtcc_register_t *)index;
89:                  
90:                      rtc->ALRMTIME.w = data;
9D00F558  3C03BF80   LUI V1, -16512
9D00F55C  AC620240   SW V0, 576(V1)
9D0155E4  3C02BF80   LUI V0, -16512
9D0155E8  AC440240   SW A0, 576(V0)
91:                  }
92:                  
93:                  
94:                  //******************************************************************************
95:                  /* Function :  RTCC_AlarmHourGet_Default
96:                  
97:                    Summary:
98:                      Implements Default variant of PLIB_RTCC_AlarmHourGet 
99:                  
100:                   Description:
101:                     This template implements the Default variant of the PLIB_RTCC_AlarmHourGet function.
102:                 */
103:                 
104:                 PLIB_TEMPLATE uint32_t RTCC_AlarmHourGet_Default( RTCC_MODULE_ID index )
105:                 {
106:                     volatile rtcc_register_t *rtc = (rtcc_register_t *)index;
107:                 
108:                     return (rtc->ALRMTIME.HR10 << _ALRMTIME_HR01_LENGTH) | rtc->ALRMTIME.HR01;
109:                 }
110:                 
111:                 
112:                 //******************************************************************************
113:                 /* Function :  RTCC_AlarmHourSet_Default
114:                 
115:                   Summary:
116:                     Implements Default variant of PLIB_RTCC_AlarmHourSet 
117:                 
118:                   Description:
119:                     This template implements the Default variant of the PLIB_RTCC_AlarmHourSet function.
120:                 */
121:                 
122:                 PLIB_TEMPLATE void RTCC_AlarmHourSet_Default( RTCC_MODULE_ID index , uint32_t hour )
123:                 {
124:                     volatile rtcc_register_t *rtc = (rtcc_register_t *)index;
125:                     uint32_t tmpVal = rtc->ALRMTIME.w;
126:                 
127:                     tmpVal &= ~(_RTCTIME_HR01_MASK | _RTCTIME_HR10_MASK);
128:                     tmpVal |= hour << _RTCTIME_HR01_POSITION;
129:                     rtc->ALRMTIME.w = tmpVal;
130:                 }
131:                 
132:                 
133:                 //******************************************************************************
134:                 /* Function :  RTCC_AlarmMinuteGet_Default
135:                 
136:                   Summary:
137:                     Implements Default variant of PLIB_RTCC_AlarmMinuteGet 
138:                 
139:                   Description:
140:                     This template implements the Default variant of the PLIB_RTCC_AlarmMinuteGet function.
141:                 */
142:                 
143:                 PLIB_TEMPLATE uint32_t RTCC_AlarmMinuteGet_Default( RTCC_MODULE_ID index )
144:                 {
145:                     volatile rtcc_register_t *rtc = (rtcc_register_t *)index;
146:                 
147:                     return rtc->ALRMTIME.MIN01 | (rtc->ALRMTIME.MIN10 << _ALRMTIME_MIN01_LENGTH);
148:                 }
149:                 
150:                 
151:                 //******************************************************************************
152:                 /* Function :  RTCC_AlarmMinuteSet_Default
153:                 
154:                   Summary:
155:                     Implements Default variant of PLIB_RTCC_AlarmMinuteSet 
156:                 
157:                   Description:
158:                     This template implements the Default variant of the PLIB_RTCC_AlarmMinuteSet function.
159:                 */
160:                 
161:                 PLIB_TEMPLATE void RTCC_AlarmMinuteSet_Default( RTCC_MODULE_ID index , uint32_t minute )
162:                 {
163:                     volatile rtcc_register_t *rtc = (rtcc_register_t *)index;
164:                     uint32_t tmpVal = rtc->ALRMTIME.w;
165:                 
166:                     tmpVal &= ~(_RTCTIME_MIN01_MASK | _RTCTIME_MIN10_MASK);
167:                     tmpVal |= minute << _RTCTIME_MIN01_POSITION;
168:                     rtc->ALRMTIME.w = tmpVal;
169:                 }
170:                 
171:                 
172:                 //******************************************************************************
173:                 /* Function :  RTCC_AlarmSecondGet_Default
174:                 
175:                   Summary:
176:                     Implements Default variant of PLIB_RTCC_AlarmSecondGet 
177:                 
178:                   Description:
179:                     This template implements the Default variant of the PLIB_RTCC_AlarmSecondGet function.
180:                 */
181:                 
182:                 PLIB_TEMPLATE uint32_t RTCC_AlarmSecondGet_Default( RTCC_MODULE_ID index )
183:                 {
184:                     volatile rtcc_register_t *rtc = (rtcc_register_t *)index;
185:                 
186:                     return (rtc->ALRMTIME.SEC10 << _ALRMTIME_SEC01_LENGTH) | rtc->ALRMTIME.SEC01;
187:                 }
188:                 
189:                 
190:                 //******************************************************************************
191:                 /* Function :  RTCC_AlarmSecondSet_Default
192:                 
193:                   Summary:
194:                     Implements Default variant of PLIB_RTCC_AlarmSecondSet 
195:                 
196:                   Description:
197:                     This template implements the Default variant of the PLIB_RTCC_AlarmSecondSet function.
198:                 */
199:                 
200:                 PLIB_TEMPLATE void RTCC_AlarmSecondSet_Default( RTCC_MODULE_ID index , uint32_t second )
201:                 {
202:                     volatile rtcc_register_t *rtc = (rtcc_register_t *)index;
203:                     uint32_t tmpVal = rtc->ALRMTIME.w;
204:                 
205:                     tmpVal &= ~(_RTCTIME_SEC01_MASK | _RTCTIME_SEC10_MASK);
206:                     tmpVal |= second << _RTCTIME_SEC01_POSITION;
207:                     rtc->ALRMTIME.w = tmpVal;
208:                 }
209:                 
210:                 
211:                 //******************************************************************************
212:                 /* Function :  RTCC_ExistsAlarmTime_Default
213:                 
214:                   Summary:
215:                     Implements Default variant of PLIB_RTCC_ExistsAlarmTime
216:                 
217:                   Description:
218:                     This template implements the Default variant of the PLIB_RTCC_ExistsAlarmTime function.
219:                 */
220:                 
221:                 #define PLIB_RTCC_ExistsAlarmTime PLIB_RTCC_ExistsAlarmTime
222:                 PLIB_TEMPLATE bool RTCC_ExistsAlarmTime_Default( RTCC_MODULE_ID index )
223:                 {
224:                     return true;
225:                 }
226:                 
227:                 
228:                 #endif /*_RTCC_ALARMTIME_DEFAULT_H*/
229:                 
230:                 /******************************************************************************
231:                  End of File
232:                 */
233:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/rtcc/templates/rtcc_AlarmSync_Default.h
1:                   /*******************************************************************************
2:                     RTCC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       rtcc_AlarmSync_Default.h
6:                   
7:                     Summary:
8:                       RTCC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : AlarmSync
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_RTCC_AlarmSyncStatusGet
16:                          PLIB_RTCC_ExistsAlarmSynchronization
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _RTCC_ALARMSYNC_DEFAULT_H
47:                  #define _RTCC_ALARMSYNC_DEFAULT_H
48:                  
49:                  #include "rtcc_Registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  RTCC_AlarmSyncStatusGet_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_RTCC_AlarmSyncStatusGet 
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_RTCC_AlarmSyncStatusGet function.
59:                  */
60:                  
61:                  PLIB_TEMPLATE bool RTCC_AlarmSyncStatusGet_Default( RTCC_MODULE_ID index )
62:                  {
63:                      volatile rtcc_register_t *rtc = (rtcc_register_t *)index;
64:                  
65:                      return rtc->RTCALRM.ALRMSYNC;
9D00F544  3C03BF80   LUI V1, -16512
9D00F548  8C620210   LW V0, 528(V1)
9D00F54C  7C420300   EXT V0, V0, 12, 1
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  RTCC_ExistsAlarmSynchronization_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_RTCC_ExistsAlarmSynchronization
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_RTCC_ExistsAlarmSynchronization function.
77:                  */
78:                  
79:                  #define PLIB_RTCC_ExistsAlarmSynchronization PLIB_RTCC_ExistsAlarmSynchronization
80:                  PLIB_TEMPLATE bool RTCC_ExistsAlarmSynchronization_Default( RTCC_MODULE_ID index )
81:                  {
82:                      return true;
83:                  }
84:                  
85:                  
86:                  #endif /*_RTCC_ALARMSYNC_DEFAULT_H*/
87:                  
88:                  /******************************************************************************
89:                   End of File
90:                  */
91:                  
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/rtcc/templates/rtcc_AlarmRepeatControl_Default.h
1:                   /*******************************************************************************
2:                     RTCC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       rtcc_AlarmRepeatControl_Default.h
6:                   
7:                     Summary:
8:                       RTCC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : AlarmRepeatControl
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_RTCC_AlarmRepeatCountSet
16:                          PLIB_RTCC_AlarmRepeatCountGet
17:                          PLIB_RTCC_ExistsAlarmRepeatControl
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _RTCC_ALARMREPEATCONTROL_DEFAULT_H
48:                  #define _RTCC_ALARMREPEATCONTROL_DEFAULT_H
49:                  
50:                  #include "rtcc_Registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  RTCC_AlarmRepeatCountSet_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_RTCC_AlarmRepeatCountSet 
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_RTCC_AlarmRepeatCountSet function.
60:                  */
61:                  
62:                  PLIB_TEMPLATE void RTCC_AlarmRepeatCountSet_Default( RTCC_MODULE_ID index , uint8_t data )
63:                  {
64:                      volatile rtcc_register_t *rtc = (rtcc_register_t *)index;
65:                  
66:                      rtc->RTCALRM.ARPT = data;
9D00F570  A0600210   SB ZERO, 528(V1)
67:                  }
68:                  
69:                  
70:                  //******************************************************************************
71:                  /* Function :  RTCC_AlarmRepeatCountGet_Default
72:                  
73:                    Summary:
74:                      Implements Default variant of PLIB_RTCC_AlarmRepeatCountGet 
75:                  
76:                    Description:
77:                      This template implements the Default variant of the PLIB_RTCC_AlarmRepeatCountGet function.
78:                  */
79:                  
80:                  PLIB_TEMPLATE uint8_t RTCC_AlarmRepeatCountGet_Default( RTCC_MODULE_ID index )
81:                  {
82:                      volatile rtcc_register_t *rtc = (rtcc_register_t *)index;
83:                  
84:                      return rtc->RTCALRM.ARPT;
85:                  }
86:                  
87:                  
88:                  //******************************************************************************
89:                  /* Function :  RTCC_ExistsAlarmRepeatControl_Default
90:                  
91:                    Summary:
92:                      Implements Default variant of PLIB_RTCC_ExistsAlarmRepeatControl
93:                  
94:                    Description:
95:                      This template implements the Default variant of the PLIB_RTCC_ExistsAlarmRepeatControl function.
96:                  */
97:                  
98:                  #define PLIB_RTCC_ExistsAlarmRepeatControl PLIB_RTCC_ExistsAlarmRepeatControl
99:                  PLIB_TEMPLATE bool RTCC_ExistsAlarmRepeatControl_Default( RTCC_MODULE_ID index )
100:                 {
101:                     return true;
102:                 }
103:                 
104:                 
105:                 #endif /*_RTCC_ALARMREPEATCONTROL_DEFAULT_H*/
106:                 
107:                 /******************************************************************************
108:                  End of File
109:                 */
110:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/rtcc/templates/rtcc_AlarmMaskControl_Default.h
1:                   /*******************************************************************************
2:                     RTCC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       rtcc_AlarmMaskControl_Default.h
6:                   
7:                     Summary:
8:                       RTCC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : AlarmMaskControl
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_RTCC_AlarmMaskModeSelect
16:                          PLIB_RTCC_ExistsAlarmMaskControl
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _RTCC_ALARMMASKCONTROL_DEFAULT_H
47:                  #define _RTCC_ALARMMASKCONTROL_DEFAULT_H
48:                  
49:                  #include "rtcc_Registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  RTCC_AlarmMaskModeSelect_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_RTCC_AlarmMaskModeSelect 
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_RTCC_AlarmMaskModeSelect function.
59:                  */
60:                  
61:                  PLIB_TEMPLATE void RTCC_AlarmMaskModeSelect_Default( RTCC_MODULE_ID index , RTCC_ALARM_MASK_CONFIGURATION data )
62:                  {
63:                      volatile rtcc_register_t *rtc = (rtcc_register_t *)index;
64:                  
65:                      rtc->RTCALRM.AMASK = data;
9D00F574  94620210   LHU V0, 528(V1)
9D00F578  24040005   ADDIU A0, ZERO, 5
9D00F57C  7C825A04   INS V0, A0, 8, 4
9D00F580  A4620210   SH V0, 528(V1)
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  RTCC_ExistsAlarmMaskControl_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_RTCC_ExistsAlarmMaskControl
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_RTCC_ExistsAlarmMaskControl function.
77:                  */
78:                  
79:                  #define PLIB_RTCC_ExistsAlarmMaskControl PLIB_RTCC_ExistsAlarmMaskControl
80:                  PLIB_TEMPLATE bool RTCC_ExistsAlarmMaskControl_Default( RTCC_MODULE_ID index )
81:                  {
82:                      return true;
83:                  }
84:                  
85:                  
86:                  #endif /*_RTCC_ALARMMASKCONTROL_DEFAULT_H*/
87:                  
88:                  /******************************************************************************
89:                   End of File
90:                  */
91:                  
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/rtcc/templates/rtcc_AlarmDate_Default.h
1:                   /*******************************************************************************
2:                     RTCC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       rtcc_AlarmDate_Default.h
6:                   
7:                     Summary:
8:                       RTCC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : AlarmDate
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_RTCC_AlarmDateGet
16:                          PLIB_RTCC_AlarmDateSet
17:                          PLIB_RTCC_AlarmMonthGet
18:                          PLIB_RTCC_AlarmMonthSet
19:                          PLIB_RTCC_AlarmDayGet
20:                          PLIB_RTCC_AlarmDaySet
21:                          PLIB_RTCC_AlarmWeekDayGet
22:                          PLIB_RTCC_AlarmWeekDaySet
23:                          PLIB_RTCC_ExistsAlarmDate
24:                  
25:                  *******************************************************************************/
26:                  
27:                  //DOM-IGNORE-BEGIN
28:                  /*******************************************************************************
29:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
30:                  
31:                  Microchip licenses to you the right to use, modify, copy and distribute
32:                  Software only when embedded on a Microchip microcontroller or digital signal
33:                  controller that is integrated into your product or third party product
34:                  (pursuant to the sublicense terms in the accompanying license agreement).
35:                  
36:                  You should refer to the license agreement accompanying this Software for
37:                  additional information regarding your rights and obligations.
38:                  
39:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
40:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
41:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
42:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
43:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
44:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
45:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
46:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
47:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
48:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
49:                  *******************************************************************************/
50:                  
51:                  //DOM-IGNORE-END
52:                  
53:                  #ifndef _RTCC_ALARMDATE_DEFAULT_H
54:                  #define _RTCC_ALARMDATE_DEFAULT_H
55:                  
56:                  #include "rtcc_Registers.h"
57:                  
58:                  //******************************************************************************
59:                  /* Function :  RTCC_AlarmDateGet_Default
60:                  
61:                    Summary:
62:                      Implements Default variant of PLIB_RTCC_AlarmDateGet 
63:                  
64:                    Description:
65:                      This template implements the Default variant of the PLIB_RTCC_AlarmDateGet function.
66:                  */
67:                  
68:                  PLIB_TEMPLATE uint32_t RTCC_AlarmDateGet_Default( RTCC_MODULE_ID index )
69:                  {
70:                      volatile rtcc_register_t *rtc = (rtcc_register_t *)index;
71:                  
72:                      return rtc->ALRMDATE.w;
73:                  }
74:                  
75:                  
76:                  //******************************************************************************
77:                  /* Function :  RTCC_AlarmDateSet_Default
78:                  
79:                    Summary:
80:                      Implements Default variant of PLIB_RTCC_AlarmDateSet 
81:                  
82:                    Description:
83:                      This template implements the Default variant of the PLIB_RTCC_AlarmDateSet function.
84:                  */
85:                  
86:                  PLIB_TEMPLATE void RTCC_AlarmDateSet_Default( RTCC_MODULE_ID index , uint32_t data )
87:                  {
88:                      volatile rtcc_register_t *rtc = (rtcc_register_t *)index;
89:                  
90:                      rtc->ALRMDATE.w = data;
9D00F560  24021010   ADDIU V0, ZERO, 4112
9D00F564  AC620250   SW V0, 592(V1)
91:                  }
92:                  
93:                  
94:                  //******************************************************************************
95:                  /* Function :  RTCC_AlarmMonthGet_Default
96:                  
97:                    Summary:
98:                      Implements Default variant of PLIB_RTCC_AlarmMonthGet 
99:                  
100:                   Description:
101:                     This template implements the Default variant of the PLIB_RTCC_AlarmMonthGet function.
102:                 */
103:                 
104:                 PLIB_TEMPLATE uint32_t RTCC_AlarmMonthGet_Default( RTCC_MODULE_ID index )
105:                 {
106:                     volatile rtcc_register_t *rtc = (rtcc_register_t *)index;
107:                 
108:                     return rtc->ALRMDATE.MONTH01 | (rtc->ALRMDATE.MONTH10 << _ALRMDATE_MONTH01_LENGTH);
109:                 }
110:                 
111:                 
112:                 //******************************************************************************
113:                 /* Function :  RTCC_AlarmMonthSet_Default
114:                 
115:                   Summary:
116:                     Implements Default variant of PLIB_RTCC_AlarmMonthSet 
117:                 
118:                   Description:
119:                     This template implements the Default variant of the PLIB_RTCC_AlarmMonthSet function.
120:                 */
121:                 
122:                 PLIB_TEMPLATE void RTCC_AlarmMonthSet_Default( RTCC_MODULE_ID index , uint32_t month )
123:                 {
124:                     volatile rtcc_register_t *rtc = (rtcc_register_t *)index;
125:                     uint32_t tmpVal = rtc->ALRMDATE.w;
126:                 
127:                     tmpVal &=~(_ALRMDATE_MONTH01_MASK | _ALRMDATE_MONTH10_MASK);
128:                     tmpVal |= month << _ALRMDATE_MONTH01_POSITION;
129:                     rtc->ALRMDATE.w = tmpVal;
130:                 }
131:                 
132:                 
133:                 //******************************************************************************
134:                 /* Function :  RTCC_AlarmDayGet_Default
135:                 
136:                   Summary:
137:                     Implements Default variant of PLIB_RTCC_AlarmDayGet 
138:                 
139:                   Description:
140:                     This template implements the Default variant of the PLIB_RTCC_AlarmDayGet function.
141:                 */
142:                 
143:                 PLIB_TEMPLATE uint32_t RTCC_AlarmDayGet_Default( RTCC_MODULE_ID index )
144:                 {
145:                     volatile rtcc_register_t *rtc = (rtcc_register_t *)index;
146:                 
147:                     return rtc->ALRMDATE.DAY01 | (rtc->ALRMDATE.DAY10 << _ALRMDATE_DAY01_LENGTH);
148:                 }
149:                 
150:                 
151:                 //******************************************************************************
152:                 /* Function :  RTCC_AlarmDaySet_Default
153:                 
154:                   Summary:
155:                     Implements Default variant of PLIB_RTCC_AlarmDaySet 
156:                 
157:                   Description:
158:                     This template implements the Default variant of the PLIB_RTCC_AlarmDaySet function.
159:                 */
160:                 
161:                 PLIB_TEMPLATE void RTCC_AlarmDaySet_Default( RTCC_MODULE_ID index , uint32_t day )
162:                 {
163:                     volatile rtcc_register_t *rtc = (rtcc_register_t *)index;
164:                     uint32_t tmpVal = rtc->ALRMDATE.w;
165:                 
166:                     tmpVal &= ~(_ALRMDATE_DAY01_MASK | _ALRMDATE_DAY10_MASK);
167:                     tmpVal |= day << _ALRMDATE_DAY01_POSITION;
168:                     rtc->ALRMDATE.w = tmpVal;
169:                 }
170:                 
171:                 
172:                 //******************************************************************************
173:                 /* Function :  RTCC_AlarmWeekDayGet_Default
174:                 
175:                   Summary:
176:                     Implements Default variant of PLIB_RTCC_AlarmWeekDayGet 
177:                 
178:                   Description:
179:                     This template implements the Default variant of the PLIB_RTCC_AlarmWeekDayGet function.
180:                 */
181:                 
182:                 PLIB_TEMPLATE uint32_t RTCC_AlarmWeekDayGet_Default( RTCC_MODULE_ID index )
183:                 {
184:                     volatile rtcc_register_t *rtc = (rtcc_register_t *)index;
185:                 
186:                     return rtc->ALRMDATE.WDAY01;
187:                 }
188:                 
189:                 
190:                 //******************************************************************************
191:                 /* Function :  RTCC_AlarmWeekDaySet_Default
192:                 
193:                   Summary:
194:                     Implements Default variant of PLIB_RTCC_AlarmWeekDaySet 
195:                 
196:                   Description:
197:                     This template implements the Default variant of the PLIB_RTCC_AlarmWeekDaySet function.
198:                 */
199:                 
200:                 PLIB_TEMPLATE void RTCC_AlarmWeekDaySet_Default( RTCC_MODULE_ID index , uint32_t weekday )
201:                 {
202:                     volatile rtcc_register_t *rtc = (rtcc_register_t *)index;
203:                 
204:                     rtc->ALRMDATE.WDAY01 = weekday;
205:                 }
206:                 
207:                 
208:                 //******************************************************************************
209:                 /* Function :  RTCC_ExistsAlarmDate_Default
210:                 
211:                   Summary:
212:                     Implements Default variant of PLIB_RTCC_ExistsAlarmDate
213:                 
214:                   Description:
215:                     This template implements the Default variant of the PLIB_RTCC_ExistsAlarmDate function.
216:                 */
217:                 
218:                 #define PLIB_RTCC_ExistsAlarmDate PLIB_RTCC_ExistsAlarmDate
219:                 PLIB_TEMPLATE bool RTCC_ExistsAlarmDate_Default( RTCC_MODULE_ID index )
220:                 {
221:                     return true;
222:                 }
223:                 
224:                 
225:                 #endif /*_RTCC_ALARMDATE_DEFAULT_H*/
226:                 
227:                 /******************************************************************************
228:                  End of File
229:                 */
230:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/rtcc/templates/rtcc_AlarmControl_Default.h
1:                   /*******************************************************************************
2:                     RTCC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       rtcc_AlarmControl_Default.h
6:                   
7:                     Summary:
8:                       RTCC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : AlarmControl
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_RTCC_AlarmEnable
16:                          PLIB_RTCC_AlarmDisable
17:                          PLIB_RTCC_ExistsAlarmControl
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _RTCC_ALARMCONTROL_DEFAULT_H
48:                  #define _RTCC_ALARMCONTROL_DEFAULT_H
49:                  
50:                  #include "rtcc_Registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  RTCC_AlarmEnable_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_RTCC_AlarmEnable 
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_RTCC_AlarmEnable function.
60:                  */
61:                  
62:                  PLIB_TEMPLATE void RTCC_AlarmEnable_Default( RTCC_MODULE_ID index )
63:                  {
64:                      volatile rtcc_register_t *rtc = (rtcc_register_t *)index;
65:                  
66:                      rtc->RTCALRMSET = _RTCALRM_ALRMEN_MASK;
9D0155F4  3C02BF80   LUI V0, -16512
9D0158D8  34038000   ORI V1, ZERO, -32768
9D0158DC  3C02BF80   LUI V0, -16512
9D0158E0  AC430218   SW V1, 536(V0)
67:                  }
68:                  
69:                  
70:                  //******************************************************************************
71:                  /* Function :  RTCC_AlarmDisable_Default
72:                  
73:                    Summary:
74:                      Implements Default variant of PLIB_RTCC_AlarmDisable 
75:                  
76:                    Description:
77:                      This template implements the Default variant of the PLIB_RTCC_AlarmDisable function.
78:                  */
79:                  
80:                  PLIB_TEMPLATE void RTCC_AlarmDisable_Default( RTCC_MODULE_ID index )
81:                  {    
82:                      volatile rtcc_register_t *rtc = (rtcc_register_t *)index;
83:                  
84:                      rtc->RTCALRMCLR = _RTCALRM_ALRMEN_MASK;
9D00F53C  34038000   ORI V1, ZERO, -32768
9D00F540  AC430214   SW V1, 532(V0)
85:                  }
86:                  
87:                  
88:                  //******************************************************************************
89:                  /* Function :  RTCC_ExistsAlarmControl_Default
90:                  
91:                    Summary:
92:                      Implements Default variant of PLIB_RTCC_ExistsAlarmControl
93:                  
94:                    Description:
95:                      This template implements the Default variant of the PLIB_RTCC_ExistsAlarmControl function.
96:                  */
97:                  
98:                  #define PLIB_RTCC_ExistsAlarmControl PLIB_RTCC_ExistsAlarmControl
99:                  PLIB_TEMPLATE bool RTCC_ExistsAlarmControl_Default( RTCC_MODULE_ID index )
100:                 {
101:                     return true;
102:                 }
103:                 
104:                 
105:                 #endif /*_RTCC_ALARMCONTROL_DEFAULT_H*/
106:                 
107:                 /******************************************************************************
108:                  End of File
109:                 */
110:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/rtcc/templates/rtcc_AlarmChimeControl_Default.h
1:                   /*******************************************************************************
2:                     RTCC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       rtcc_AlarmChimeControl_Default.h
6:                   
7:                     Summary:
8:                       RTCC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : AlarmChimeControl
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_RTCC_AlarmChimeEnable
16:                          PLIB_RTCC_AlarmChimeDisable
17:                          PLIB_RTCC_ExistsAlarmChimeControl
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _RTCC_ALARMCHIMECONTROL_DEFAULT_H
48:                  #define _RTCC_ALARMCHIMECONTROL_DEFAULT_H
49:                  
50:                  #include "rtcc_Registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  RTCC_AlarmChimeEnable_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_RTCC_AlarmChimeEnable 
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_RTCC_AlarmChimeEnable function.
60:                  */
61:                  
62:                  PLIB_TEMPLATE void RTCC_AlarmChimeEnable_Default( RTCC_MODULE_ID index )
63:                  {
64:                      volatile rtcc_register_t *rtc = (rtcc_register_t *)index;
65:                  
66:                      rtc->RTCALRMSET = _RTCALRM_CHIME_MASK;
67:                  }
68:                  
69:                  
70:                  //******************************************************************************
71:                  /* Function :  RTCC_AlarmChimeDisable_Default
72:                  
73:                    Summary:
74:                      Implements Default variant of PLIB_RTCC_AlarmChimeDisable 
75:                  
76:                    Description:
77:                      This template implements the Default variant of the PLIB_RTCC_AlarmChimeDisable function.
78:                  */
79:                  
80:                  PLIB_TEMPLATE void RTCC_AlarmChimeDisable_Default( RTCC_MODULE_ID index )
81:                  {
82:                      volatile rtcc_register_t *rtc = (rtcc_register_t *)index;
83:                  
84:                      rtc->RTCALRMCLR = _RTCALRM_CHIME_MASK;
9D00F568  24024000   ADDIU V0, ZERO, 16384
9D00F56C  AC620214   SW V0, 532(V1)
85:                  }
86:                  
87:                  
88:                  //******************************************************************************
89:                  /* Function :  RTCC_ExistsAlarmChimeControl_Default
90:                  
91:                    Summary:
92:                      Implements Default variant of PLIB_RTCC_ExistsAlarmChimeControl
93:                  
94:                    Description:
95:                      This template implements the Default variant of the PLIB_RTCC_ExistsAlarmChimeControl function.
96:                  */
97:                  
98:                  #define PLIB_RTCC_ExistsAlarmChimeControl PLIB_RTCC_ExistsAlarmChimeControl
99:                  PLIB_TEMPLATE bool RTCC_ExistsAlarmChimeControl_Default( RTCC_MODULE_ID index )
100:                 {
101:                     return true;
102:                 }
103:                 
104:                 
105:                 #endif /*_RTCC_ALARMCHIMECONTROL_DEFAULT_H*/
106:                 
107:                 /******************************************************************************
108:                  End of File
109:                 */
110:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/reset/templates/reset_ResetReasonStatus_MX.h
1:                   /*******************************************************************************
2:                     RESET Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       reset_ResetReasonStatus_MX.h
6:                   
7:                     Summary:
8:                       RESET PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ResetReasonStatus
13:                      and its Variant : MX
14:                      For following APIs :
15:                          PLIB_RESET_ExistsResetReasonStatus
16:                          PLIB_RESET_ReasonGet
17:                          PLIB_RESET_ReasonClear
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _RESET_RESETREASONSTATUS_MX_H
48:                  #define _RESET_RESETREASONSTATUS_MX_H
49:                  
50:                  //******************************************************************************
51:                  /* Function :  RESET_ExistsResetReasonStatus_MX
52:                  
53:                    Summary:
54:                      Implements MX variant of PLIB_RESET_ExistsResetReasonStatus
55:                  
56:                    Description:
57:                      This template implements the MX variant of the PLIB_RESET_ExistsResetReasonStatus function.
58:                  */
59:                  
60:                  #define PLIB_RESET_ExistsResetReasonStatus PLIB_RESET_ExistsResetReasonStatus
61:                  PLIB_TEMPLATE bool RESET_ExistsResetReasonStatus_MX( RESET_MODULE_ID index )
62:                  {
63:                      return true;
64:                  }
65:                  
66:                  
67:                  //******************************************************************************
68:                  /* Function :  RESET_ReasonGet_MX
69:                  
70:                    Summary:
71:                      Implements MX variant of PLIB_RESET_ReasonGet 
72:                  
73:                    Description:
74:                      This template implements the MX variant of the PLIB_RESET_ReasonGet function.
75:                  */
76:                  
77:                  PLIB_TEMPLATE RESET_REASON RESET_ReasonGet_MX( RESET_MODULE_ID index )
78:                  {
79:                      return (RESET_REASON)(RCON & (_RCON_CMR_MASK | _RCON_EXTR_MASK |
9D0122C0  3C02BF81   LUI V0, -16511
9D0122C4  8C50F600   LW S0, -2560(V0)
9D0122C8  321002D3   ANDI S0, S0, 723
9D015984  3C02BF81   LUI V0, -16511
9D015988  8C42F600   LW V0, -2560(V0)
80:                  				  _RCON_SWR_MASK | _RCON_WDTO_MASK |
81:                  				  _RCON_BOR_MASK | _RCON_POR_MASK));
82:                  }
83:                  
84:                  //******************************************************************************
85:                  /* Function :  RESET_ReasonClear_MX
86:                  
87:                    Summary:
88:                      Implements MX variant of PLIB_RESET_ReasonClear 
89:                  
90:                    Description:
91:                      This template implements the MX variant of the PLIB_RESET_ReasonClear function.
92:                  */
93:                  
94:                  PLIB_TEMPLATE void RESET_ReasonClear_MX( RESET_MODULE_ID index , RESET_REASON reason )
95:                  {
96:                     RCONCLR = reason;
9D015994  3C02BF81   LUI V0, -16511
97:                  }
98:                  
99:                  
100:                 #endif /*_RESET_RESETREASONSTATUS_MX_H*/
101:                 
102:                 /******************************************************************************
103:                  End of File
104:                 */
105:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/ports/templates/ports_RemapOutput_PIC32_2.h
1:                   /*******************************************************************************
2:                     PORTS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       ports_RemapOutput_PIC32_2.h
6:                   
7:                     Summary:
8:                       PORTS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : RemapOutput
13:                      and its Variant : PIC32_2
14:                      For following APIs :
15:                          PLIB_PORTS_RemapOutput
16:                          PLIB_PORTS_ExistsRemapOutput
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _PORTS_REMAPOUTPUT_PIC32_2_H
47:                  #define _PORTS_REMAPOUTPUT_PIC32_2_H
48:                  
49:                  
50:                  //******************************************************************************
51:                  /* Function :  PORTS_RemapOutput_PIC32_2
52:                  
53:                    Summary:
54:                      Implements PIC32_2 variant of PLIB_PORTS_RemapOutput 
55:                  
56:                    Description:
57:                      This template implements the PIC32_2 variant of the PLIB_PORTS_RemapOutput function.
58:                  */
59:                  
60:                  PLIB_TEMPLATE void PORTS_RemapOutput_PIC32_2( PORTS_MODULE_ID      index , PORTS_REMAP_OUTPUT_FUNCTION outputFunction , PORTS_REMAP_OUTPUT_PIN      remapOutputPin )
61:                  {
62:                      *(&RPA0R + remapOutputPin) = ( ( *((SFR_TYPE *)(&RPA0R  + remapOutputPin)) ) & ~(_RPA0R_RPA0R_MASK) ) | ( (_RPA0R_RPA0R_MASK) & ((outputFunction)<<(_RPA0R_RPA0R_POSITION)) );
9D010F04  3C02BF81   LUI V0, -16511
63:                  }
64:                  
65:                  
66:                  //******************************************************************************
67:                  /* Function :  PORTS_ExistsRemapOutput_PIC32_2
68:                  
69:                    Summary:
70:                      Implements PIC32_2 variant of PLIB_PORTS_ExistsRemapOutput
71:                  
72:                    Description:
73:                      This template implements the PIC32_2 variant of the PLIB_PORTS_ExistsRemapOutput function.
74:                  */
75:                  
76:                  #define PLIB_PORTS_ExistsRemapOutput PLIB_PORTS_ExistsRemapOutput
77:                  PLIB_TEMPLATE bool PORTS_ExistsRemapOutput_PIC32_2( PORTS_MODULE_ID index )
78:                  {
79:                      return true;
80:                  }
81:                  
82:                  
83:                  #endif /*_PORTS_REMAPOUTPUT_PIC32_2_H*/
84:                  
85:                  /******************************************************************************
86:                   End of File
87:                  */
88:                  
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/ports/templates/ports_RemapInput_default.h
1:                   /*******************************************************************************
2:                     PORTS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       ports_RemapInput_default.h
6:                   
7:                     Summary:
8:                       PORTS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : RemapInput
13:                      and its Variant : default
14:                      For following APIs :
15:                          PLIB_PORTS_RemapInput
16:                          PLIB_PORTS_ExistsRemapInput
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _PORTS_REMAPINPUT_DEFAULT_H
47:                  #define _PORTS_REMAPINPUT_DEFAULT_H
48:                  
49:                  
50:                  //******************************************************************************
51:                  /* Function :  PORTS_RemapInput_default
52:                  
53:                    Summary:
54:                      Implements default variant of PLIB_PORTS_RemapInput 
55:                  
56:                    Description:
57:                      This template implements the default variant of the PLIB_PORTS_RemapInput function.
58:                  */
59:                  
60:                  PLIB_TEMPLATE void PORTS_RemapInput_default( PORTS_MODULE_ID      index , PORTS_REMAP_INPUT_FUNCTION inputFunction , PORTS_REMAP_INPUT_PIN      remapInputPin )
61:                  {
62:                      *(&INT1R + inputFunction) = ( ( *((SFR_TYPE *)(&INT1R + inputFunction)) ) & ~(_INT1R_INT1R_MASK) ) | ( (_INT1R_INT1R_MASK) & ((remapInputPin)<<(_INT1R_INT1R_POSITION)) );
9D010EF0  3C02BF81   LUI V0, -16511
9D010EF4  2442FA04   ADDIU V0, V0, -1532
9D010EF8  8C430014   LW V1, 20(V0)
9D010EFC  7C031804   INS V1, ZERO, 0, 4
9D010F00  AC430014   SW V1, 20(V0)
63:                  }
64:                  
65:                  
66:                  //******************************************************************************
67:                  /* Function :  PORTS_ExistsRemapInput_default
68:                  
69:                    Summary:
70:                      Implements default variant of PLIB_PORTS_ExistsRemapInput
71:                  
72:                    Description:
73:                      This template implements the default variant of the PLIB_PORTS_ExistsRemapInput function.
74:                  */
75:                  
76:                  #define PLIB_PORTS_ExistsRemapInput PLIB_PORTS_ExistsRemapInput
77:                  PLIB_TEMPLATE bool PORTS_ExistsRemapInput_default( PORTS_MODULE_ID index )
78:                  {
79:                      return true;
80:                  }
81:                  
82:                  
83:                  #endif /*_PORTS_REMAPINPUT_DEFAULT_H*/
84:                  
85:                  /******************************************************************************
86:                   End of File
87:                  */
88:                  
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/ports/templates/ports_PortsWrite_MCU32_PPS.h
1:                   /*******************************************************************************
2:                     PORTS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       ports_PortsWrite_MCU32_PPS.h
6:                   
7:                     Summary:
8:                       PORTS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : PortsWrite
13:                      and its Variant : MCU32_PPS
14:                      For following APIs :
15:                          PLIB_PORTS_PinWrite
16:                          PLIB_PORTS_PinSet
17:                          PLIB_PORTS_PinClear
18:                          PLIB_PORTS_PinToggle
19:                          PLIB_PORTS_Write
20:                          PLIB_PORTS_Set
21:                          PLIB_PORTS_Toggle
22:                          PLIB_PORTS_Clear
23:                          PLIB_PORTS_ExistsPortsWrite
24:                  
25:                  *******************************************************************************/
26:                  
27:                  //DOM-IGNORE-BEGIN
28:                  /*******************************************************************************
29:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
30:                  
31:                  Microchip licenses to you the right to use, modify, copy and distribute
32:                  Software only when embedded on a Microchip microcontroller or digital signal
33:                  controller that is integrated into your product or third party product
34:                  (pursuant to the sublicense terms in the accompanying license agreement).
35:                  
36:                  You should refer to the license agreement accompanying this Software for
37:                  additional information regarding your rights and obligations.
38:                  
39:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
40:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
41:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
42:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
43:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
44:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
45:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
46:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
47:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
48:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
49:                  *******************************************************************************/
50:                  
51:                  //DOM-IGNORE-END
52:                  
53:                  #ifndef _PORTS_PORTSWRITE_MCU32_PPS_H
54:                  #define _PORTS_PORTSWRITE_MCU32_PPS_H
55:                  
56:                  
57:                  //******************************************************************************
58:                  /* Function :  PORTS_PinWrite_MCU32_PPS
59:                  
60:                    Summary:
61:                      Implements MCU32_PPS variant of PLIB_PORTS_PinWrite 
62:                  
63:                    Description:
64:                      This template implements the MCU32_PPS variant of the PLIB_PORTS_PinWrite function.
65:                  */
66:                  
67:                  PLIB_TEMPLATE void PORTS_PinWrite_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_BIT_POS       bitPos , bool            value )
68:                  {
69:                      /* Atomic Implementation */
70:                      if(value == true)
9D013B00  10E0000C   BEQ A3, ZERO, 0x9D013B34
9D013B04  3C0203FF   LUI V0, 1023
71:                      {
72:                          *(&LATBSET + (channel - 1) * 0x40) = 1<<bitPos;
9D013B08  3442FFFF   ORI V0, V0, -1
9D013B0C  00A22821   ADDU A1, A1, V0
9D013B10  00052A00   SLL A1, A1, 8
9D013B14  3C02BF88   LUI V0, -16504
9D013B18  24426138   ADDIU V0, V0, 24888
9D013B1C  00452821   ADDU A1, V0, A1
9D013B20  24020001   ADDIU V0, ZERO, 1
9D013B24  00C23004   SLLV A2, V0, A2
9D013B28  ACA60000   SW A2, 0(A1)
9D013B2C  03E00008   JR RA
9D013B30  00000000   NOP
73:                      }
74:                      else
75:                      {
76:                          *(&LATBCLR + (channel - 1) * 0x40) = 1<<bitPos;
9D013B34  3442FFFF   ORI V0, V0, -1
77:                      }
78:                  }
79:                  
80:                  
81:                  //******************************************************************************
82:                  /* Function :  PORTS_PinSet_MCU32_PPS
83:                  
84:                    Summary:
85:                      Implements MCU32_PPS variant of PLIB_PORTS_PinSet 
86:                  
87:                    Description:
88:                      This template implements the MCU32_PPS variant of the PLIB_PORTS_PinSet function.
89:                  */
90:                  
91:                  PLIB_TEMPLATE void PORTS_PinSet_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_BIT_POS       bitPos )
92:                  {
93:                  
94:                      *(&LATBSET + (channel - 1) * 0x40) = 1<<bitPos;
95:                      
96:                  }
97:                  
98:                  
99:                  //******************************************************************************
100:                 /* Function :  PORTS_PinClear_MCU32_PPS
101:                 
102:                   Summary:
103:                     Implements MCU32_PPS variant of PLIB_PORTS_PinClear 
104:                 
105:                   Description:
106:                     This template implements the MCU32_PPS variant of the PLIB_PORTS_PinClear function.
107:                 */
108:                 
109:                 PLIB_TEMPLATE void PORTS_PinClear_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_BIT_POS       bitPos )
110:                 {
111:                 	
112:                     *(&LATBCLR + (channel - 1) * 0x40) = 1<<bitPos;	
113:                 						   
114:                 }
115:                 
116:                 
117:                 //******************************************************************************
118:                 /* Function :  PORTS_PinToggle_MCU32_PPS
119:                 
120:                   Summary:
121:                     Implements MCU32_PPS variant of PLIB_PORTS_PinToggle 
122:                 
123:                   Description:
124:                     This template implements the MCU32_PPS variant of the PLIB_PORTS_PinToggle function.
125:                 */
126:                 
127:                 PLIB_TEMPLATE void PORTS_PinToggle_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_BIT_POS       bitPos )
128:                 {
129:                 
130:                     *(&LATBINV + (channel - 1) * 0x40) = 1<<bitPos;
131:                 						   
132:                 }
133:                 
134:                 
135:                 //******************************************************************************
136:                 /* Function :  PORTS_Write_MCU32_PPS
137:                 
138:                   Summary:
139:                     Implements MCU32_PPS variant of PLIB_PORTS_Write 
140:                 
141:                   Description:
142:                     This template implements the MCU32_PPS variant of the PLIB_PORTS_Write function.
143:                 */
144:                 
145:                 PLIB_TEMPLATE void PORTS_Write_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_DATA_TYPE value )
146:                 {
147:                     *(&LATB + (channel - 1) * 0x40) = value;
9D010E60  3C09BF88   LUI T1, -16504
9D010E64  25226130   ADDIU V0, T1, 24880
9D010E68  AC40FF00   SW ZERO, -256(V0)
9D010EC8  AD2A6130   SW T2, 24880(T1)
148:                 }
149:                 
150:                 
151:                 //******************************************************************************
152:                 /* Function :  PORTS_Set_MCU32_PPS
153:                 
154:                   Summary:
155:                     Implements MCU32_PPS variant of PLIB_PORTS_Set 
156:                 
157:                   Description:
158:                     This template implements the MCU32_PPS variant of the PLIB_PORTS_Set function.
159:                 */
160:                 
161:                 PLIB_TEMPLATE void PORTS_Set_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_DATA_TYPE value , PORTS_DATA_MASK mask )
162:                 {
163:                     
164:                     *(&LATBSET + (channel - 1) * 0x40) = (value & mask);
165:                 	
166:                 }
167:                 
168:                 
169:                 //******************************************************************************
170:                 /* Function :  PORTS_Toggle_MCU32_PPS
171:                 
172:                   Summary:
173:                     Implements MCU32_PPS variant of PLIB_PORTS_Toggle 
174:                 
175:                   Description:
176:                     This template implements the MCU32_PPS variant of the PLIB_PORTS_Toggle function.
177:                 */
178:                 
179:                 PLIB_TEMPLATE void PORTS_Toggle_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_DATA_MASK toggleMask )
180:                 {
181:                     *(&LATBINV + (channel - 1) * 0x40) = toggleMask;
182:                 }
183:                 
184:                 
185:                 //******************************************************************************
186:                 /* Function :  PORTS_Clear_MCU32_PPS
187:                 
188:                   Summary:
189:                     Implements MCU32_PPS variant of PLIB_PORTS_Clear 
190:                 
191:                   Description:
192:                     This template implements the MCU32_PPS variant of the PLIB_PORTS_Clear function.
193:                 */
194:                 
195:                 PLIB_TEMPLATE void PORTS_Clear_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_DATA_MASK clearMask )
196:                 {
197:                     
198:                     *(&LATBCLR + (channel - 1) * 0x40) = clearMask;	
199:                 						 
200:                 }
201:                 
202:                 
203:                 //******************************************************************************
204:                 /* Function :  PORTS_ExistsPortsWrite_MCU32_PPS
205:                 
206:                   Summary:
207:                     Implements MCU32_PPS variant of PLIB_PORTS_ExistsPortsWrite
208:                 
209:                   Description:
210:                     This template implements the MCU32_PPS variant of the PLIB_PORTS_ExistsPortsWrite function.
211:                 */
212:                 
213:                 #define PLIB_PORTS_ExistsPortsWrite PLIB_PORTS_ExistsPortsWrite
214:                 PLIB_TEMPLATE bool PORTS_ExistsPortsWrite_MCU32_PPS( PORTS_MODULE_ID index )
215:                 {
216:                     return true;
217:                 }
218:                 
219:                 
220:                 #endif /*_PORTS_PORTSWRITE_MCU32_PPS_H*/
221:                 
222:                 /******************************************************************************
223:                  End of File
224:                 */
225:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/ports/templates/ports_PortsRead_MCU32_PPS.h
1:                   /*******************************************************************************
2:                     PORTS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       ports_PortsRead_MCU32_PPS.h
6:                   
7:                     Summary:
8:                       PORTS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : PortsRead
13:                      and its Variant : MCU32_PPS
14:                      For following APIs :
15:                          PLIB_PORTS_PinGet
16:                          PLIB_PORTS_Read
17:                          PLIB_PORTS_ExistsPortsRead
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _PORTS_PORTSREAD_MCU32_PPS_H
48:                  #define _PORTS_PORTSREAD_MCU32_PPS_H
49:                  
50:                  
51:                  //******************************************************************************
52:                  /* Function :  PORTS_PinGet_MCU32_PPS
53:                  
54:                    Summary:
55:                      Implements MCU32_PPS variant of PLIB_PORTS_PinGet 
56:                  
57:                    Description:
58:                      This template implements the MCU32_PPS variant of the PLIB_PORTS_PinGet function.
59:                  */
60:                  
61:                  PLIB_TEMPLATE bool PORTS_PinGet_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_BIT_POS       bitPos )
62:                  {
63:                      return (bool)((*(&PORTB + ((channel - 1) * 0x40)) >> bitPos) & 1);
9D015184  3C0203FF   LUI V0, 1023
9D015188  3442FFFF   ORI V0, V0, -1
9D01518C  00A22821   ADDU A1, A1, V0
9D015190  00052A00   SLL A1, A1, 8
9D015194  3C02BF88   LUI V0, -16504
9D015198  24426120   ADDIU V0, V0, 24864
9D01519C  00451021   ADDU V0, V0, A1
9D0151A0  8C420000   LW V0, 0(V0)
9D0151A4  00C21006   SRLV V0, V0, A2
9D015914  3C02BF88   LUI V0, -16504
9D015918  8C426120   LW V0, 24864(V0)
64:                  }
65:                  
66:                  
67:                  //******************************************************************************
68:                  /* Function :  PORTS_Read_MCU32_PPS
69:                  
70:                    Summary:
71:                      Implements MCU32_PPS variant of PLIB_PORTS_Read 
72:                  
73:                    Description:
74:                      This template implements the MCU32_PPS variant of the PLIB_PORTS_Read function.
75:                  */
76:                  
77:                  PLIB_TEMPLATE PORTS_DATA_TYPE PORTS_Read_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel )
78:                  {
79:                      return (*(&PORTB + ((channel - 1) * 0x40)));
80:                  }
81:                  
82:                  
83:                  //******************************************************************************
84:                  /* Function :  PORTS_ExistsPortsRead_MCU32_PPS
85:                  
86:                    Summary:
87:                      Implements MCU32_PPS variant of PLIB_PORTS_ExistsPortsRead
88:                  
89:                    Description:
90:                      This template implements the MCU32_PPS variant of the PLIB_PORTS_ExistsPortsRead function.
91:                  */
92:                  
93:                  #define PLIB_PORTS_ExistsPortsRead PLIB_PORTS_ExistsPortsRead
94:                  PLIB_TEMPLATE bool PORTS_ExistsPortsRead_MCU32_PPS( PORTS_MODULE_ID index )
95:                  {
96:                      return true;
97:                  }
98:                  
99:                  
100:                 #endif /*_PORTS_PORTSREAD_MCU32_PPS_H*/
101:                 
102:                 /******************************************************************************
103:                  End of File
104:                 */
105:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/ports/templates/ports_PortsOpenDrain_MCU32_PPS.h
1:                   /*******************************************************************************
2:                     PORTS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       ports_PortsOpenDrain_MCU32_PPS.h
6:                   
7:                     Summary:
8:                       PORTS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : PortsOpenDrain
13:                      and its Variant : MCU32_PPS
14:                      For following APIs :
15:                          PLIB_PORTS_PinOpenDrainEnable
16:                          PLIB_PORTS_PinOpenDrainDisable
17:                          PLIB_PORTS_OpenDrainEnable
18:                          PLIB_PORTS_OpenDrainDisable
19:                          PLIB_PORTS_ExistsPortsOpenDrain
20:                  
21:                  *******************************************************************************/
22:                  
23:                  //DOM-IGNORE-BEGIN
24:                  /*******************************************************************************
25:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
26:                  
27:                  Microchip licenses to you the right to use, modify, copy and distribute
28:                  Software only when embedded on a Microchip microcontroller or digital signal
29:                  controller that is integrated into your product or third party product
30:                  (pursuant to the sublicense terms in the accompanying license agreement).
31:                  
32:                  You should refer to the license agreement accompanying this Software for
33:                  additional information regarding your rights and obligations.
34:                  
35:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
36:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
37:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
38:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
39:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
40:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
41:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
42:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
43:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
44:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
45:                  *******************************************************************************/
46:                  
47:                  //DOM-IGNORE-END
48:                  
49:                  #ifndef _PORTS_PORTSOPENDRAIN_MCU32_PPS_H
50:                  #define _PORTS_PORTSOPENDRAIN_MCU32_PPS_H
51:                  
52:                  
53:                  
54:                  
55:                  //******************************************************************************
56:                  /* Function :  PORTS_PinOpenDrainEnable_MCU32_PPS
57:                  
58:                    Summary:
59:                      Implements MCU32_PPS variant of PLIB_PORTS_PinOpenDrainEnable 
60:                  
61:                    Description:
62:                      This template implements the MCU32_PPS variant of the PLIB_PORTS_PinOpenDrainEnable function.
63:                  */
64:                  
65:                  PLIB_TEMPLATE void PORTS_PinOpenDrainEnable_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_BIT_POS       bitPos )
66:                  {
67:                      *(&ODCBSET + (channel - 1) * 0x40) = 1<<bitPos;
68:                  }
69:                  
70:                  
71:                  //******************************************************************************
72:                  /* Function :  PORTS_PinOpenDrainDisable_MCU32_PPS
73:                  
74:                    Summary:
75:                      Implements MCU32_PPS variant of PLIB_PORTS_PinOpenDrainDisable 
76:                  
77:                    Description:
78:                      This template implements the MCU32_PPS variant of the PLIB_PORTS_PinOpenDrainDisable function.
79:                  */
80:                  
81:                  PLIB_TEMPLATE void PORTS_PinOpenDrainDisable_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_BIT_POS       bitPos )
82:                  {
83:                      *(&ODCBCLR + (channel - 1) * 0x40) = 1<<bitPos;
84:                  }
85:                  
86:                  
87:                  //******************************************************************************
88:                  /* Function :  PORTS_OpenDrainEnable_MCU32_PPS
89:                  
90:                    Summary:
91:                      Implements MCU32_PPS variant of PLIB_PORTS_OpenDrainEnable 
92:                  
93:                    Description:
94:                      This template implements the MCU32_PPS variant of the PLIB_PORTS_OpenDrainEnable function.
95:                  */
96:                  
97:                  PLIB_TEMPLATE void PORTS_OpenDrainEnable_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_DATA_MASK mask )
98:                  {
99:                      *(&ODCBSET + (channel - 1) * 0x40) = mask;
9D010E54  3C0BBF88   LUI T3, -16504
9D010E58  25626148   ADDIU V0, T3, 24904
9D010E5C  AC40FF00   SW ZERO, -256(V0)
9D010EC0  240A0020   ADDIU T2, ZERO, 32
9D010EC4  AD6A6148   SW T2, 24904(T3)
100:                 }
101:                 
102:                 
103:                 //******************************************************************************
104:                 /* Function :  PORTS_OpenDrainDisable_MCU32_PPS
105:                 
106:                   Summary:
107:                     Implements MCU32_PPS variant of PLIB_PORTS_OpenDrainDisable 
108:                 
109:                   Description:
110:                     This template implements the MCU32_PPS variant of the PLIB_PORTS_OpenDrainDisable function.
111:                 */
112:                 
113:                 PLIB_TEMPLATE void PORTS_OpenDrainDisable_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_DATA_MASK mask )
114:                 {
115:                     *(&ODCBCLR + (channel - 1) * 0x40) = mask;
116:                 }
117:                 
118:                 
119:                 //******************************************************************************
120:                 /* Function :  PORTS_ExistsPortsOpenDrain_MCU32_PPS
121:                 
122:                   Summary:
123:                     Implements MCU32_PPS variant of PLIB_PORTS_ExistsPortsOpenDrain
124:                 
125:                   Description:
126:                     This template implements the MCU32_PPS variant of the PLIB_PORTS_ExistsPortsOpenDrain function.
127:                 */
128:                 
129:                 #define PLIB_PORTS_ExistsPortsOpenDrain PLIB_PORTS_ExistsPortsOpenDrain
130:                 PLIB_TEMPLATE bool PORTS_ExistsPortsOpenDrain_MCU32_PPS( PORTS_MODULE_ID index )
131:                 {
132:                     return true;
133:                 }
134:                 
135:                 
136:                 #endif /*_PORTS_PORTSOPENDRAIN_MCU32_PPS_H*/
137:                 
138:                 /******************************************************************************
139:                  End of File
140:                 */
141:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/ports/templates/ports_PortsDirection_MCU32_PPS.h
1:                   /*******************************************************************************
2:                     PORTS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       ports_PortsDirection_MCU32_PPS.h
6:                   
7:                     Summary:
8:                       PORTS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : PortsDirection
13:                      and its Variant : MCU32_PPS
14:                      For following APIs :
15:                          PLIB_PORTS_PinDirectionInputSet
16:                          PLIB_PORTS_PinDirectionOutputSet
17:                          PLIB_PORTS_DirectionInputSet
18:                          PLIB_PORTS_DirectionOutputSet
19:                          PLIB_PORTS_DirectionGet
20:                          PLIB_PORTS_ExistsPortsDirection
21:                  
22:                  *******************************************************************************/
23:                  
24:                  //DOM-IGNORE-BEGIN
25:                  /*******************************************************************************
26:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
27:                  
28:                  Microchip licenses to you the right to use, modify, copy and distribute
29:                  Software only when embedded on a Microchip microcontroller or digital signal
30:                  controller that is integrated into your product or third party product
31:                  (pursuant to the sublicense terms in the accompanying license agreement).
32:                  
33:                  You should refer to the license agreement accompanying this Software for
34:                  additional information regarding your rights and obligations.
35:                  
36:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
37:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
38:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
39:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
40:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
41:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
42:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
43:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
44:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
45:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
46:                  *******************************************************************************/
47:                  
48:                  //DOM-IGNORE-END
49:                  
50:                  #ifndef _PORTS_PORTSDIRECTION_MCU32_PPS_H
51:                  #define _PORTS_PORTSDIRECTION_MCU32_PPS_H
52:                  
53:                  
54:                  //******************************************************************************
55:                  /* Function :  PORTS_PinDirectionInputSet_MCU32_PPS
56:                  
57:                    Summary:
58:                      Implements MCU32_PPS variant of PLIB_PORTS_PinDirectionInputSet 
59:                  
60:                    Description:
61:                      This template implements the MCU32_PPS variant of the PLIB_PORTS_PinDirectionInputSet function.
62:                  */
63:                  
64:                  PLIB_TEMPLATE void PORTS_PinDirectionInputSet_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_BIT_POS       bitPos )
65:                  {
66:                      *(&TRISBSET + (channel - 1) * 0x40) = 1<<bitPos;
67:                  }
68:                  
69:                  
70:                  //******************************************************************************
71:                  /* Function :  PORTS_PinDirectionOutputSet_MCU32_PPS
72:                  
73:                    Summary:
74:                      Implements MCU32_PPS variant of PLIB_PORTS_PinDirectionOutputSet 
75:                  
76:                    Description:
77:                      This template implements the MCU32_PPS variant of the PLIB_PORTS_PinDirectionOutputSet function.
78:                  */
79:                  
80:                  PLIB_TEMPLATE void PORTS_PinDirectionOutputSet_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_BIT_POS       bitPos )
81:                  {
82:                      *(&TRISBCLR + (channel - 1) * 0x40) = 1<<bitPos;
83:                  }
84:                  
85:                  
86:                  //******************************************************************************
87:                  /* Function :  PORTS_DirectionInputSet_MCU32_PPS
88:                  
89:                    Summary:
90:                      Implements MCU32_PPS variant of PLIB_PORTS_DirectionInputSet 
91:                  
92:                    Description:
93:                      This template implements the MCU32_PPS variant of the PLIB_PORTS_DirectionInputSet function.
94:                  */
95:                  
96:                  PLIB_TEMPLATE void PORTS_DirectionInputSet_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_DATA_MASK mask )
97:                  {
98:                      *(&TRISBSET + (channel - 1) * 0x40) = mask;
99:                  }
100:                 
101:                 
102:                 //******************************************************************************
103:                 /* Function :  PORTS_DirectionOutputSet_MCU32_PPS
104:                 
105:                   Summary:
106:                     Implements MCU32_PPS variant of PLIB_PORTS_DirectionOutputSet 
107:                 
108:                   Description:
109:                     This template implements the MCU32_PPS variant of the PLIB_PORTS_DirectionOutputSet function.
110:                 */
111:                 
112:                 PLIB_TEMPLATE void PORTS_DirectionOutputSet_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_DATA_MASK mask )
113:                 {
114:                     *(&TRISBCLR + (channel - 1) * 0x40) = mask;
9D010E6C  3C08BF88   LUI T0, -16504
9D010E70  25026114   ADDIU V0, T0, 24852
9D010E74  2403000C   ADDIU V1, ZERO, 12
9D010E78  AC43FF00   SW V1, -256(V0)
9D010ECC  24090024   ADDIU T1, ZERO, 36
9D010ED0  AD096114   SW T1, 24852(T0)
115:                 }
116:                 
117:                 
118:                 //******************************************************************************
119:                 /* Function :  PORTS_DirectionGet_MCU32_PPS
120:                 
121:                   Summary:
122:                     Implements MCU32_PPS variant of PLIB_PORTS_DirectionGet 
123:                 
124:                   Description:
125:                     This template implements the MCU32_PPS variant of the PLIB_PORTS_DirectionGet function.
126:                 */
127:                 
128:                 PLIB_TEMPLATE PORTS_DATA_MASK PORTS_DirectionGet_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel )
129:                 {
130:                     return ( *(&TRISB + (channel - 1) * 0x40) );
131:                 }
132:                 
133:                 
134:                 //******************************************************************************
135:                 /* Function :  PORTS_ExistsPortsDirection_MCU32_PPS
136:                 
137:                   Summary:
138:                     Implements MCU32_PPS variant of PLIB_PORTS_ExistsPortsDirection
139:                 
140:                   Description:
141:                     This template implements the MCU32_PPS variant of the PLIB_PORTS_ExistsPortsDirection function.
142:                 */
143:                 
144:                 #define PLIB_PORTS_ExistsPortsDirection PLIB_PORTS_ExistsPortsDirection
145:                 PLIB_TEMPLATE bool PORTS_ExistsPortsDirection_MCU32_PPS( PORTS_MODULE_ID index )
146:                 {
147:                     return true;
148:                 }
149:                 
150:                 
151:                 #endif /*_PORTS_PORTSDIRECTION_MCU32_PPS_H*/
152:                 
153:                 /******************************************************************************
154:                  End of File
155:                 */
156:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/ports/templates/ports_PinModePerPort_Default.h
1:                   /*******************************************************************************
2:                     PORTS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       ports_PinModePerPort_Default.h
6:                   
7:                     Summary:
8:                       PORTS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : PinModePerPort
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_PORTS_PinModePerPortSelect
16:                          PLIB_PORTS_ChannelModeSelect
17:                          PLIB_PORTS_ExistsPinModePerPort
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _PORTS_PINMODEPERPORT_DEFAULT_H
48:                  #define _PORTS_PINMODEPERPORT_DEFAULT_H
49:                  
50:                  
51:                  //******************************************************************************
52:                  /* Function :  PORTS_PinModePerPortSelect_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_PORTS_PinModePerPortSelect 
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_PORTS_PinModePerPortSelect function.
59:                  */
60:                  
61:                  PLIB_TEMPLATE void PORTS_PinModePerPortSelect_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel , PORTS_BIT_POS  bitPos , PORTS_PIN_MODE   mode )
62:                  {
63:                      if ( mode == PORTS_PIN_MODE_ANALOG )
64:                  	{
65:                          *(&ANSELBSET + (channel - 1) * 0x40) = 1<<bitPos;	
66:                  	}
67:                  	else
68:                  	{
69:                          *(&ANSELBCLR + (channel - 1) * 0x40) = 1<<bitPos;
70:                  	}
71:                  }
72:                  
73:                  
74:                  //******************************************************************************
75:                  /* Function :  PORTS_ChannelModeSelect_Default
76:                  
77:                    Summary:
78:                      Implements Default variant of PLIB_PORTS_ChannelModeSelect 
79:                  
80:                    Description:
81:                      This template implements the Default variant of the PLIB_PORTS_ChannelModeSelect function.
82:                  */
83:                  
84:                  PLIB_TEMPLATE void PORTS_ChannelModeSelect_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel , PORTS_DATA_MASK   modeMask , PORTS_PIN_MODE mode )
85:                  {
86:                      if ( mode == PORTS_PIN_MODE_ANALOG )
87:                  	{
88:                          *(&ANSELBSET + (channel - 1) * 0x40) = modeMask;	
89:                  	}
90:                  	else
91:                  	{
92:                          *(&ANSELBCLR + (channel - 1) * 0x40) = modeMask;
9D010E8C  3C05BF88   LUI A1, -16504
9D010E90  24A26104   ADDIU V0, A1, 24836
9D010E94  24030003   ADDIU V1, ZERO, 3
9D010E98  AC43FF00   SW V1, -256(V0)
9D010ED8  3406E3AF   ORI A2, ZERO, -7249
9D010EDC  ACA66104   SW A2, 24836(A1)
93:                  	}
94:                  }
95:                  
96:                  
97:                  //******************************************************************************
98:                  /* Function :  PORTS_ExistsPinModePerPort_Default
99:                  
100:                   Summary:
101:                     Implements Default variant of PLIB_PORTS_ExistsPinModePerPort
102:                 
103:                   Description:
104:                     This template implements the Default variant of the PLIB_PORTS_ExistsPinModePerPort function.
105:                 */
106:                 
107:                 #define PLIB_PORTS_ExistsPinModePerPort PLIB_PORTS_ExistsPinModePerPort
108:                 PLIB_TEMPLATE bool PORTS_ExistsPinModePerPort_Default( PORTS_MODULE_ID index )
109:                 {
110:                     return true;
111:                 }
112:                 
113:                 
114:                 #endif /*_PORTS_PINMODEPERPORT_DEFAULT_H*/
115:                 
116:                 /******************************************************************************
117:                  End of File
118:                 */
119:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/ports/templates/ports_PinChangeNoticePerPort_Default.h
1:                   /*******************************************************************************
2:                     PORTS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       ports_PinChangeNoticePerPort_Default.h
6:                   
7:                     Summary:
8:                       PORTS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : PinChangeNoticePerPort
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_PORTS_PinChangeNoticePerPortEnable
16:                          PLIB_PORTS_PinChangeNoticePerPortDisable
17:                          PLIB_PORTS_ChannelChangeNoticeEnable
18:                          PLIB_PORTS_ChannelChangeNoticeDisable
19:                          PLIB_PORTS_ExistsPinChangeNoticePerPort
20:                  
21:                  *******************************************************************************/
22:                  
23:                  //DOM-IGNORE-BEGIN
24:                  /*******************************************************************************
25:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
26:                  
27:                  Microchip licenses to you the right to use, modify, copy and distribute
28:                  Software only when embedded on a Microchip microcontroller or digital signal
29:                  controller that is integrated into your product or third party product
30:                  (pursuant to the sublicense terms in the accompanying license agreement).
31:                  
32:                  You should refer to the license agreement accompanying this Software for
33:                  additional information regarding your rights and obligations.
34:                  
35:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
36:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
37:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
38:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
39:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
40:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
41:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
42:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
43:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
44:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
45:                  *******************************************************************************/
46:                  
47:                  //DOM-IGNORE-END
48:                  
49:                  #ifndef _PORTS_PINCHANGENOTICEPERPORT_DEFAULT_H
50:                  #define _PORTS_PINCHANGENOTICEPERPORT_DEFAULT_H
51:                  
52:                  
53:                  
54:                  //******************************************************************************
55:                  /* Function :  PORTS_PinChangeNoticePerPortEnable_Default
56:                  
57:                    Summary:
58:                      Implements Default variant of PLIB_PORTS_PinChangeNoticePerPortEnable 
59:                  
60:                    Description:
61:                      This template implements the Default variant of the PLIB_PORTS_PinChangeNoticePerPortEnable function.
62:                  */
63:                  
64:                  PLIB_TEMPLATE void PORTS_PinChangeNoticePerPortEnable_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel , PORTS_BIT_POS  bitPos )
65:                  {
66:                      *(&CNENBSET + (channel - 1) * 0x40) = 1<<bitPos;
67:                  }
68:                  
69:                  
70:                  //******************************************************************************
71:                  /* Function :  PORTS_PinChangeNoticePerPortDisable_Default
72:                  
73:                    Summary:
74:                      Implements Default variant of PLIB_PORTS_PinChangeNoticePerPortDisable 
75:                  
76:                    Description:
77:                      This template implements the Default variant of the PLIB_PORTS_PinChangeNoticePerPortDisable function.
78:                  */
79:                  
80:                  PLIB_TEMPLATE void PORTS_PinChangeNoticePerPortDisable_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel , PORTS_BIT_POS  bitPos )
81:                  {
82:                      *(&CNENBCLR + (channel - 1) * 0x40) = 1<<bitPos;
83:                  }
84:                  
85:                  
86:                  //******************************************************************************
87:                  /* Function :  PORTS_ChannelChangeNoticeEnable_Default
88:                  
89:                    Summary:
90:                      Implements Default variant of PLIB_PORTS_ChannelChangeNoticeEnable 
91:                  
92:                    Description:
93:                      This template implements the Default variant of the PLIB_PORTS_ChannelChangeNoticeEnable function.
94:                  */
95:                  
96:                  PLIB_TEMPLATE void PORTS_ChannelChangeNoticeEnable_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel , PORTS_DATA_MASK  mask )
97:                  {
98:                      *(&CNENBSET + (channel - 1) * 0x40) = mask;
9D010E9C  3C04BF88   LUI A0, -16504
9D010EA0  24826188   ADDIU V0, A0, 24968
9D010EA4  AC40FF00   SW ZERO, -256(V0)
9D010EE0  AC806188   SW ZERO, 24968(A0)
99:                  }
100:                 
101:                 
102:                 //******************************************************************************
103:                 /* Function :  PORTS_ChannelChangeNoticeDisable_Default
104:                 
105:                   Summary:
106:                     Implements Default variant of PLIB_PORTS_ChannelChangeNoticeDisable 
107:                 
108:                   Description:
109:                     This template implements the Default variant of the PLIB_PORTS_ChannelChangeNoticeDisable function.
110:                 */
111:                 
112:                 PLIB_TEMPLATE void PORTS_ChannelChangeNoticeDisable_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel , PORTS_DATA_MASK  mask )
113:                 {
114:                     *(&CNENBCLR + (channel - 1) * 0x40) = mask;
115:                 }
116:                 
117:                 
118:                 //******************************************************************************
119:                 /* Function :  PORTS_ExistsPinChangeNoticePerPort_Default
120:                 
121:                   Summary:
122:                     Implements Default variant of PLIB_PORTS_ExistsPinChangeNoticePerPort
123:                 
124:                   Description:
125:                     This template implements the Default variant of the PLIB_PORTS_ExistsPinChangeNoticePerPort function.
126:                 */
127:                 
128:                 #define PLIB_PORTS_ExistsPinChangeNoticePerPort PLIB_PORTS_ExistsPinChangeNoticePerPort
129:                 PLIB_TEMPLATE bool PORTS_ExistsPinChangeNoticePerPort_Default( PORTS_MODULE_ID index )
130:                 {
131:                     return true;
132:                 }
133:                 
134:                 
135:                 #endif /*_PORTS_PINCHANGENOTICEPERPORT_DEFAULT_H*/
136:                 
137:                 /******************************************************************************
138:                  End of File
139:                 */
140:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/ports/templates/ports_ChangeNoticePullUpPerPort_Default.h
1:                   /*******************************************************************************
2:                     PORTS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       ports_ChangeNoticePullUpPerPort_Default.h
6:                   
7:                     Summary:
8:                       PORTS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ChangeNoticePullUpPerPort
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_PORTS_ChangeNoticePullUpPerPortEnable
16:                          PLIB_PORTS_ChangeNoticePullUpPerPortDisable
17:                          PLIB_PORTS_ChannelChangeNoticePullUpEnable
18:                          PLIB_PORTS_ChannelChangeNoticePullUpDisable
19:                          PLIB_PORTS_ExistsChangeNoticePullUpPerPort
20:                  
21:                  *******************************************************************************/
22:                  
23:                  //DOM-IGNORE-BEGIN
24:                  /*******************************************************************************
25:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
26:                  
27:                  Microchip licenses to you the right to use, modify, copy and distribute
28:                  Software only when embedded on a Microchip microcontroller or digital signal
29:                  controller that is integrated into your product or third party product
30:                  (pursuant to the sublicense terms in the accompanying license agreement).
31:                  
32:                  You should refer to the license agreement accompanying this Software for
33:                  additional information regarding your rights and obligations.
34:                  
35:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
36:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
37:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
38:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
39:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
40:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
41:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
42:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
43:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
44:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
45:                  *******************************************************************************/
46:                  
47:                  //DOM-IGNORE-END
48:                  
49:                  #ifndef _PORTS_CHANGENOTICEPULLUPPERPORT_DEFAULT_H
50:                  #define _PORTS_CHANGENOTICEPULLUPPERPORT_DEFAULT_H
51:                  
52:                  
53:                  //******************************************************************************
54:                  /* Function :  PORTS_ChangeNoticePullUpPerPortEnable_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_PORTS_ChangeNoticePullUpPerPortEnable 
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_PORTS_ChangeNoticePullUpPerPortEnable function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE void PORTS_ChangeNoticePullUpPerPortEnable_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel , PORTS_BIT_POS  bitPos )
64:                  {
65:                      *(&CNPUBSET + (channel - 1) * 0x40) = 1<<bitPos;
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  PORTS_ChangeNoticePullUpPerPortDisable_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_PORTS_ChangeNoticePullUpPerPortDisable 
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_PORTS_ChangeNoticePullUpPerPortDisable function.
77:                  */
78:                  
79:                  PLIB_TEMPLATE void PORTS_ChangeNoticePullUpPerPortDisable_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel , PORTS_BIT_POS  bitPos )
80:                  {
81:                      *(&CNPUBCLR + (channel - 1) * 0x40) = 1<<bitPos;
82:                  }
83:                  
84:                  //******************************************************************************
85:                  /* Function :  PORTS_ChannelChangeNoticePullUpEnable_Default
86:                  
87:                    Summary:
88:                      Implements Default variant of PLIB_PORTS_ChannelChangeNoticePullUpEnable 
89:                  
90:                    Description:
91:                      This template implements the Default variant of the PLIB_PORTS_ChannelChangeNoticePullUpEnable function.
92:                  */
93:                  
94:                  PLIB_TEMPLATE void PORTS_ChannelChangeNoticePullUpEnable_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel , PORTS_DATA_MASK  mask )
95:                  {
96:                      *(&CNPUBSET + (channel - 1) * 0x40) = mask;
9D010EA8  3C03BF88   LUI V1, -16504
9D010EAC  24626158   ADDIU V0, V1, 24920
9D010EB0  AC40FF00   SW ZERO, -256(V0)
9D010EE4  24040080   ADDIU A0, ZERO, 128
9D010EE8  AC646158   SW A0, 24920(V1)
97:                  }
98:                  
99:                  
100:                 //******************************************************************************
101:                 /* Function :  PORTS_ChannelChangeNoticePullUpDisable_Default
102:                 
103:                   Summary:
104:                     Implements Default variant of PLIB_PORTS_ChannelChangeNoticePullUpDisable 
105:                 
106:                   Description:
107:                     This template implements the Default variant of the PLIB_PORTS_ChannelChangeNoticePullUpDisable function.
108:                 */
109:                 
110:                 PLIB_TEMPLATE void PORTS_ChannelChangeNoticePullUpDisable_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel , PORTS_DATA_MASK  mask )
111:                 {
112:                     *(&CNPUBCLR + (channel - 1) * 0x40) = mask;
113:                 }
114:                 
115:                 
116:                 //******************************************************************************
117:                 /* Function :  PORTS_ExistsChangeNoticePullUpPerPort_Default
118:                 
119:                   Summary:
120:                     Implements Default variant of PLIB_PORTS_ExistsChangeNoticePullUpPerPort
121:                 
122:                   Description:
123:                     This template implements the Default variant of the PLIB_PORTS_ExistsChangeNoticePullUpPerPort function.
124:                 */
125:                 
126:                 #define PLIB_PORTS_ExistsChangeNoticePullUpPerPort PLIB_PORTS_ExistsChangeNoticePullUpPerPort
127:                 PLIB_TEMPLATE bool PORTS_ExistsChangeNoticePullUpPerPort_Default( PORTS_MODULE_ID index )
128:                 {
129:                     return true;
130:                 }
131:                 
132:                 
133:                 #endif /*_PORTS_CHANGENOTICEPULLUPPERPORT_DEFAULT_H*/
134:                 
135:                 /******************************************************************************
136:                  End of File
137:                 */
138:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/ports/templates/ports_ChangeNoticePullDownPerPort_Default.h
1:                   /*******************************************************************************
2:                     PORTS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       ports_ChangeNoticePullDownPerPort_Default.h
6:                   
7:                     Summary:
8:                       PORTS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ChangeNoticePullDownPerPort
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_PORTS_ChangeNoticePullDownPerPortEnable
16:                          PLIB_PORTS_ChangeNoticePullDownPerPortDisable
17:                          PLIB_PORTS_ChannelChangeNoticePullDownEnable
18:                          PLIB_PORTS_ChannelChangeNoticePullDownDisable
19:                          PLIB_PORTS_ExistsChangeNoticePullDownPerPort
20:                  
21:                  *******************************************************************************/
22:                  
23:                  //DOM-IGNORE-BEGIN
24:                  /*******************************************************************************
25:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
26:                  
27:                  Microchip licenses to you the right to use, modify, copy and distribute
28:                  Software only when embedded on a Microchip microcontroller or digital signal
29:                  controller that is integrated into your product or third party product
30:                  (pursuant to the sublicense terms in the accompanying license agreement).
31:                  
32:                  You should refer to the license agreement accompanying this Software for
33:                  additional information regarding your rights and obligations.
34:                  
35:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
36:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
37:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
38:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
39:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
40:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
41:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
42:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
43:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
44:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
45:                  *******************************************************************************/
46:                  
47:                  //DOM-IGNORE-END
48:                  
49:                  #ifndef _PORTS_CHANGENOTICEPULLDOWNPERPORT_DEFAULT_H
50:                  #define _PORTS_CHANGENOTICEPULLDOWNPERPORT_DEFAULT_H
51:                  
52:                  
53:                  //******************************************************************************
54:                  /* Function :  PORTS_ChangeNoticePullDownPerPortEnable_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_PORTS_ChangeNoticePullDownPerPortEnable 
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_PORTS_ChangeNoticePullDownPerPortEnable function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE void PORTS_ChangeNoticePullDownPerPortEnable_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel , PORTS_BIT_POS  bitPos )
64:                  {
65:                      *(&CNPDBSET + (channel - 1) * 0x40) = 1<<bitPos;
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  PORTS_ChangeNoticePullDownPerPortDisable_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_PORTS_ChangeNoticePullDownPerPortDisable 
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_PORTS_ChangeNoticePullDownPerPortDisable function.
77:                  */
78:                  
79:                  PLIB_TEMPLATE void PORTS_ChangeNoticePullDownPerPortDisable_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel , PORTS_BIT_POS  bitPos )
80:                  {
81:                      *(&CNPDBCLR + (channel - 1) * 0x40) = 1<<bitPos;
82:                  }
83:                  
84:                  
85:                  //******************************************************************************
86:                  /* Function :  PORTS_ChannelChangeNoticePullDownEnable_Default
87:                  
88:                    Summary:
89:                      Implements Default variant of PLIB_PORTS_ChannelChangeNoticePullDownEnable 
90:                  
91:                    Description:
92:                      This template implements the Default variant of the PLIB_PORTS_ChannelChangeNoticePullDownEnable function.
93:                  */
94:                  
95:                  PLIB_TEMPLATE void PORTS_ChannelChangeNoticePullDownEnable_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel , PORTS_DATA_MASK  mask )
96:                  {
97:                      *(&CNPDBSET + (channel - 1) * 0x40) = mask;
9D010EB4  3C02BF88   LUI V0, -16504
9D010EB8  244A6168   ADDIU T2, V0, 24936
9D010EBC  AD40FF00   SW ZERO, -256(T2)
9D010EEC  AC406168   SW ZERO, 24936(V0)
98:                  }
99:                  
100:                 
101:                 //******************************************************************************
102:                 /* Function :  PORTS_ChannelChangeNoticePullDownDisable_Default
103:                 
104:                   Summary:
105:                     Implements Default variant of PLIB_PORTS_ChannelChangeNoticePullDownDisable 
106:                 
107:                   Description:
108:                     This template implements the Default variant of the PLIB_PORTS_ChannelChangeNoticePullDownDisable function.
109:                 */
110:                 
111:                 PLIB_TEMPLATE void PORTS_ChannelChangeNoticePullDownDisable_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel , PORTS_DATA_MASK  mask )
112:                 {
113:                     *(&CNPDBCLR + (channel - 1) * 0x40) = mask;
114:                 }
115:                 
116:                 
117:                 //******************************************************************************
118:                 /* Function :  PORTS_ExistsChangeNoticePullDownPerPort_Default
119:                 
120:                   Summary:
121:                     Implements Default variant of PLIB_PORTS_ExistsChangeNoticePullDownPerPort
122:                 
123:                   Description:
124:                     This template implements the Default variant of the PLIB_PORTS_ExistsChangeNoticePullDownPerPort function.
125:                 */
126:                 
127:                 #define PLIB_PORTS_ExistsChangeNoticePullDownPerPort PLIB_PORTS_ExistsChangeNoticePullDownPerPort
128:                 PLIB_TEMPLATE bool PORTS_ExistsChangeNoticePullDownPerPort_Default( PORTS_MODULE_ID index )
129:                 {
130:                     return true;
131:                 }
132:                 
133:                 
134:                 #endif /*_PORTS_CHANGENOTICEPULLDOWNPERPORT_DEFAULT_H*/
135:                 
136:                 /******************************************************************************
137:                  End of File
138:                 */
139:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/ports/templates/ports_ChangeNoticePerPortTurnOn_Default.h
1:                   /*******************************************************************************
2:                     PORTS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       ports_ChangeNoticePerPortTurnOn_Default.h
6:                   
7:                     Summary:
8:                       PORTS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ChangeNoticePerPortTurnOn
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_PORTS_ChangeNoticePerPortTurnOn
16:                          PLIB_PORTS_ChangeNoticePerPortTurnOff
17:                          PLIB_PORTS_ExistsChangeNoticePerPortTurnOn
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _PORTS_CHANGENOTICEPERPORTTURNON_DEFAULT_H
48:                  #define _PORTS_CHANGENOTICEPERPORTTURNON_DEFAULT_H
49:                  
50:                  
51:                  //******************************************************************************
52:                  /* Function :  PORTS_ChangeNoticePerPortTurnOn_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_PORTS_ChangeNoticePerPortTurnOn 
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_PORTS_ChangeNoticePerPortTurnOn function.
59:                  */
60:                  
61:                  PLIB_TEMPLATE void PORTS_ChangeNoticePerPortTurnOn_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel )
62:                  {
63:                      *(&CNCONBSET + (channel - 1) * 0x40) = _CNCONB_ON_MASK;
9D010E7C  3C06BF88   LUI A2, -16504
9D010E80  24C26178   ADDIU V0, A2, 24952
9D010E84  34078000   ORI A3, ZERO, -32768
9D010E88  AC47FF00   SW A3, -256(V0)
9D010ED4  ACC76178   SW A3, 24952(A2)
64:                  }
65:                  
66:                  
67:                  //******************************************************************************
68:                  /* Function :  PORTS_ChangeNoticePerPortTurnOff_Default
69:                  
70:                    Summary:
71:                      Implements Default variant of PLIB_PORTS_ChangeNoticePerPortTurnOff 
72:                  
73:                    Description:
74:                      This template implements the Default variant of the PLIB_PORTS_ChangeNoticePerPortTurnOff function.
75:                  */
76:                  
77:                  PLIB_TEMPLATE void PORTS_ChangeNoticePerPortTurnOff_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel )
78:                  {
79:                      *(&CNCONBCLR + (channel - 1) * 0x40) = _CNCONB_ON_MASK;
80:                  }
81:                  
82:                  
83:                  //******************************************************************************
84:                  /* Function :  PORTS_ExistsChangeNoticePerPortTurnOn_Default
85:                  
86:                    Summary:
87:                      Implements Default variant of PLIB_PORTS_ExistsChangeNoticePerPortTurnOn
88:                  
89:                    Description:
90:                      This template implements the Default variant of the PLIB_PORTS_ExistsChangeNoticePerPortTurnOn function.
91:                  */
92:                  
93:                  #define PLIB_PORTS_ExistsChangeNoticePerPortTurnOn PLIB_PORTS_ExistsChangeNoticePerPortTurnOn
94:                  PLIB_TEMPLATE bool PORTS_ExistsChangeNoticePerPortTurnOn_Default( PORTS_MODULE_ID index )
95:                  {
96:                      return true;
97:                  }
98:                  
99:                  
100:                 #endif /*_PORTS_CHANGENOTICEPERPORTTURNON_DEFAULT_H*/
101:                 
102:                 /******************************************************************************
103:                  End of File
104:                 */
105:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/osc/templates/osc_ReferenceOutputEnable_PIC32_1.h
1:                   /*******************************************************************************
2:                     OSC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       osc_ReferenceOutputEnable_PIC32_1.h
6:                   
7:                     Summary:
8:                       OSC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ReferenceOutputEnable
13:                      and its Variant : PIC32_1
14:                      For following APIs :
15:                          PLIB_OSC_ExistsReferenceOutputEnable
16:                          PLIB_OSC_ReferenceOutputEnable
17:                          PLIB_OSC_ReferenceOutputDisable
18:                          PLIB_OSC_ReferenceOutputIsEnabled
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _OSC_REFERENCEOUTPUTENABLE_PIC32_1_H
49:                  #define _OSC_REFERENCEOUTPUTENABLE_PIC32_1_H
50:                  
51:                  //******************************************************************************
52:                  /* Function :  OSC_ExistsReferenceOutputEnable_PIC32_1
53:                  
54:                    Summary:
55:                      Implements PIC32_1 variant of PLIB_OSC_ExistsReferenceOutputEnable
56:                  
57:                    Description:
58:                      This template implements the PIC32_1 variant of the PLIB_OSC_ExistsReferenceOutputEnable function.
59:                  */
60:                  
61:                  #define PLIB_OSC_ExistsReferenceOutputEnable PLIB_OSC_ExistsReferenceOutputEnable
62:                  PLIB_TEMPLATE bool OSC_ExistsReferenceOutputEnable_PIC32_1( OSC_MODULE_ID index )
63:                  {
64:                      return true;
65:                  }
66:                  
67:                  
68:                  //******************************************************************************
69:                  /* Function :  OSC_ReferenceOutputEnable_PIC32_1
70:                  
71:                    Summary:
72:                      Implements PIC32_1 variant of PLIB_OSC_ReferenceOutputEnable 
73:                  
74:                    Description:
75:                      This template implements the PIC32_1 variant of the PLIB_OSC_ReferenceOutputEnable function.
76:                  */
77:                  
78:                  PLIB_TEMPLATE void OSC_ReferenceOutputEnable_PIC32_1( OSC_MODULE_ID index , OSC_REFERENCE referenceOsc )
79:                  {
80:                      REFOCONSET = _REFOCON_OE_MASK;
81:                  }
82:                  
83:                  
84:                  //******************************************************************************
85:                  /* Function :  OSC_ReferenceOutputDisable_PIC32_1
86:                  
87:                    Summary:
88:                      Implements PIC32_1 variant of PLIB_OSC_ReferenceOutputDisable 
89:                  
90:                    Description:
91:                      This template implements the PIC32_1 variant of the PLIB_OSC_ReferenceOutputDisable function.
92:                  */
93:                  
94:                  PLIB_TEMPLATE void OSC_ReferenceOutputDisable_PIC32_1( OSC_MODULE_ID index , OSC_REFERENCE referenceOsc )
95:                  {
96:                      REFOCONCLR = _REFOCON_OE_MASK;
9D01191C  24031000   ADDIU V1, ZERO, 4096
9D011920  3C02BF81   LUI V0, -16511
9D011924  AC43F024   SW V1, -4060(V0)
97:                  }
98:                  
99:                  
100:                 //******************************************************************************
101:                 /* Function :  OSC_ReferenceOutputIsEnabled_PIC32_1
102:                 
103:                   Summary:
104:                     Implements PIC32_1 variant of PLIB_OSC_ReferenceOutputIsEnabled 
105:                 
106:                   Description:
107:                     This template implements the PIC32_1 variant of the PLIB_OSC_ReferenceOutputIsEnabled function.
108:                 */
109:                 
110:                 PLIB_TEMPLATE bool OSC_ReferenceOutputIsEnabled_PIC32_1( OSC_MODULE_ID index , OSC_REFERENCE referenceOsc )
111:                 {
112:                     return (bool)REFOCONbits.OE;
113:                 }
114:                 
115:                 
116:                 #endif /*_OSC_REFERENCEOUTPUTENABLE_PIC32_1_H*/
117:                 
118:                 /******************************************************************************
119:                  End of File
120:                 */
121:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/osc/templates/osc_ReferenceOscTrim_PIC32_1.h
1:                   /*******************************************************************************
2:                     OSC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       osc_ReferenceOscTrim_PIC32_1.h
6:                   
7:                     Summary:
8:                       OSC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ReferenceOscTrim
13:                      and its Variant : PIC32_1
14:                      For following APIs :
15:                          PLIB_OSC_ExistsReferenceOscTrim
16:                          PLIB_OSC_ReferenceOscTrimSet
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _OSC_REFERENCEOSCTRIM_PIC32_1_H
47:                  #define _OSC_REFERENCEOSCTRIM_PIC32_1_H
48:                  
49:                  // *****************************************************************************
50:                  /* Reference clock out trim type.
51:                  
52:                    Summary:
53:                      Defines Reference clock out trim type.
54:                  
55:                    Description:
56:                      This macro defines the Reference clock out trim type.
57:                  
58:                    Remarks:
59:                      None
60:                  */
61:                  
62:                  #define OSC_REF_TRIM_TYPE						SFR_TYPE
63:                  //******************************************************************************
64:                  /* Function :  OSC_ExistsReferenceOscTrim_PIC32_1
65:                  
66:                    Summary:
67:                      Implements PIC32_1 variant of PLIB_OSC_ExistsReferenceOscTrim
68:                  
69:                    Description:
70:                      This template implements the PIC32_1 variant of the PLIB_OSC_ExistsReferenceOscTrim function.
71:                  */
72:                  
73:                  #define PLIB_OSC_ExistsReferenceOscTrim PLIB_OSC_ExistsReferenceOscTrim
74:                  PLIB_TEMPLATE bool OSC_ExistsReferenceOscTrim_PIC32_1( OSC_MODULE_ID index )
75:                  {
76:                      return true;
77:                  }
78:                  
79:                  
80:                  //******************************************************************************
81:                  /* Function :  OSC_ReferenceOscTrimSet_PIC32_1
82:                  
83:                    Summary:
84:                      Implements PIC32_1 variant of PLIB_OSC_ReferenceOscTrimSet 
85:                  
86:                    Description:
87:                      This template implements the PIC32_1 variant of the PLIB_OSC_ReferenceOscTrimSet function.
88:                  */
89:                  
90:                  PLIB_TEMPLATE void OSC_ReferenceOscTrimSet_PIC32_1( OSC_MODULE_ID index , OSC_REFERENCE referenceOsc , OSC_REF_TRIM_TYPE trimValue )
91:                  {
92:                      REFOTRIMbits.ROTRIM = trimValue;
9D011904  3C02BF81   LUI V0, -16511
9D011908  8C44F030   LW A0, -4048(V0)
9D01190C  7C04FDC4   INS A0, ZERO, 23, 9
9D011910  AC44F030   SW A0, -4048(V0)
93:                  }
94:                  
95:                  
96:                  #endif /*_OSC_REFERENCEOSCTRIM_PIC32_1_H*/
97:                  
98:                  /******************************************************************************
99:                   End of File
100:                 */
101:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/osc/templates/osc_ReferenceOscEnable_PIC32_1.h
1:                   /*******************************************************************************
2:                     OSC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       osc_ReferenceOscEnable_PIC32_1.h
6:                   
7:                     Summary:
8:                       OSC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ReferenceOscEnable
13:                      and its Variant : PIC32_1
14:                      For following APIs :
15:                          PLIB_OSC_ExistsReferenceOscEnable
16:                          PLIB_OSC_ReferenceOscEnable
17:                          PLIB_OSC_ReferenceOscDisable
18:                          PLIB_OSC_ReferenceOscIsEnabled
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _OSC_REFERENCEOSCENABLE_PIC32_1_H
49:                  #define _OSC_REFERENCEOSCENABLE_PIC32_1_H
50:                  
51:                  //******************************************************************************
52:                  /* Function :  OSC_ExistsReferenceOscEnable_PIC32_1
53:                  
54:                    Summary:
55:                      Implements PIC32_1 variant of PLIB_OSC_ExistsReferenceOscEnable
56:                  
57:                    Description:
58:                      This template implements the PIC32_1 variant of the PLIB_OSC_ExistsReferenceOscEnable function.
59:                  */
60:                  
61:                  #define PLIB_OSC_ExistsReferenceOscEnable PLIB_OSC_ExistsReferenceOscEnable
62:                  PLIB_TEMPLATE bool OSC_ExistsReferenceOscEnable_PIC32_1( OSC_MODULE_ID index )
63:                  {
64:                      return true;
65:                  }
66:                  
67:                  
68:                  //******************************************************************************
69:                  /* Function :  OSC_ReferenceOscEnable_PIC32_1
70:                  
71:                    Summary:
72:                      Implements PIC32_1 variant of PLIB_OSC_ReferenceOscEnable 
73:                  
74:                    Description:
75:                      This template implements the PIC32_1 variant of the PLIB_OSC_ReferenceOscEnable function.
76:                  */
77:                  
78:                  PLIB_TEMPLATE void OSC_ReferenceOscEnable_PIC32_1( OSC_MODULE_ID index , OSC_REFERENCE referenceOsc )
79:                  {
80:                      REFOCONSET = _REFOCON_ON_MASK;
9D011914  34028000   ORI V0, ZERO, -32768
9D011918  AC62F028   SW V0, -4056(V1)
81:                  }
82:                  
83:                  
84:                  //******************************************************************************
85:                  /* Function :  OSC_ReferenceOscDisable_PIC32_1
86:                  
87:                    Summary:
88:                      Implements PIC32_1 variant of PLIB_OSC_ReferenceOscDisable 
89:                  
90:                    Description:
91:                      This template implements the PIC32_1 variant of the PLIB_OSC_ReferenceOscDisable function.
92:                  */
93:                  
94:                  PLIB_TEMPLATE void OSC_ReferenceOscDisable_PIC32_1( OSC_MODULE_ID index , OSC_REFERENCE referenceOsc )
95:                  {
96:                      REFOCONCLR = _REFOCON_ON_MASK;
97:                  }
98:                  
99:                  
100:                 //******************************************************************************
101:                 /* Function :  OSC_ReferenceOscIsEnabled_PIC32_1
102:                 
103:                   Summary:
104:                     Implements PIC32_1 variant of PLIB_OSC_ReferenceOscIsEnabled 
105:                 
106:                   Description:
107:                     This template implements the PIC32_1 variant of the PLIB_OSC_ReferenceOscIsEnabled function.
108:                 */
109:                 
110:                 PLIB_TEMPLATE bool OSC_ReferenceOscIsEnabled_PIC32_1( OSC_MODULE_ID index , OSC_REFERENCE referenceOsc )
111:                 {
112:                     return (bool)REFOCONbits.ON;
113:                 }
114:                 
115:                 
116:                 #endif /*_OSC_REFERENCEOSCENABLE_PIC32_1_H*/
117:                 
118:                 /******************************************************************************
119:                  End of File
120:                 */
121:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/osc/templates/osc_ReferenceOscDivisor_PIC32_1.h
1:                   /*******************************************************************************
2:                     OSC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       osc_ReferenceOscDivisor_PIC32_1.h
6:                   
7:                     Summary:
8:                       OSC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ReferenceOscDivisor
13:                      and its Variant : PIC32_1
14:                      For following APIs :
15:                          PLIB_OSC_ExistsReferenceOscDivisor
16:                          PLIB_OSC_ReferenceOscDivisorValueSet
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _OSC_REFERENCEOSCDIVISOR_PIC32_1_H
47:                  #define _OSC_REFERENCEOSCDIVISOR_PIC32_1_H
48:                  
49:                  // *****************************************************************************
50:                  /* Reference divisor type
51:                  
52:                    Summary:
53:                      Defines Reference clock devisor type.
54:                  
55:                    Description:
56:                      This macro defines Reference clock divisor type.
57:                  
58:                    Remarks:
59:                      None
60:                  */
61:                  
62:                  #define OSC_REF_DIVISOR_TYPE  				SFR_TYPE
63:                  
64:                  
65:                  // *****************************************************************************
66:                  /* Oscillator Reference Bus count
67:                  
68:                    Summary:
69:                      The number of Reference clock buses in available in the device.
70:                  
71:                    Description:
72:                      This macro gives the number of Reference clock buses in available in the device.
73:                  
74:                    Remarks:
75:                      None
76:                  */
77:                  
78:                  #define REFERENCE_BUSES_MAX						1
79:                  
80:                  
81:                  //******************************************************************************
82:                  /* Function :  OSC_ExistsReferenceOscDivisor_PIC32_1
83:                  
84:                    Summary:
85:                      Implements PIC32_1 variant of PLIB_OSC_ExistsReferenceOscDivisor
86:                  
87:                    Description:
88:                      This template implements the PIC32_1 variant of the PLIB_OSC_ExistsReferenceOscDivisor function.
89:                  */
90:                  
91:                  #define PLIB_OSC_ExistsReferenceOscDivisor PLIB_OSC_ExistsReferenceOscDivisor
92:                  PLIB_TEMPLATE bool OSC_ExistsReferenceOscDivisor_PIC32_1( OSC_MODULE_ID index )
93:                  {
94:                      return true;
95:                  }
96:                  
97:                  
98:                  //******************************************************************************
99:                  /* Function :  OSC_ReferenceOscDivisorValueSet_PIC32_1
100:                 
101:                   Summary:
102:                     Implements PIC32_1 variant of PLIB_OSC_ReferenceOscDivisorValueSet
103:                 
104:                   Description:
105:                     This template implements the PIC32_1 variant of the PLIB_OSC_ReferenceOscDivisorValueSet function.
106:                 */
107:                 
108:                 PLIB_TEMPLATE void OSC_ReferenceOscDivisorValueSet_PIC32_1( OSC_MODULE_ID index , OSC_REFERENCE referenceOsc , OSC_REF_DIVISOR_TYPE refOscDivValue )
109:                 {
110:                     REFOCONbits.RODIV = refOscDivValue;
9D0118F4  8C44F020   LW A0, -4064(V0)
9D0118F8  24050006   ADDIU A1, ZERO, 6
9D0118FC  7CA4F404   INS A0, A1, 16, 15
9D011900  AC44F020   SW A0, -4064(V0)
111:                 }
112:                 
113:                 
114:                 #endif /*_OSC_REFERENCEOSCDIVISOR_PIC32_1_H*/
115:                 
116:                 /******************************************************************************
117:                  End of File
118:                 */
119:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/osc/templates/osc_ReferenceOscBaseClock_PIC32_1.h
1:                   /*******************************************************************************
2:                     OSC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       osc_ReferenceOscBaseClock_PIC32_1.h
6:                   
7:                     Summary:
8:                       OSC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ReferenceOscBaseClock
13:                      and its Variant : PIC32_1
14:                      For following APIs :
15:                          PLIB_OSC_ExistsReferenceOscBaseClock
16:                          PLIB_OSC_ReferenceOscBaseClockSelect
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _OSC_REFERENCEOSCBASECLOCK_PIC32_1_H
47:                  #define _OSC_REFERENCEOSCBASECLOCK_PIC32_1_H
48:                  
49:                  
50:                  // *****************************************************************************
51:                  /* Reference oscillator clock divisor maximum value.
52:                  
53:                    Summary:
54:                      Defines the Reference oscillator clock divisor maximum value.
55:                  
56:                    Description:
57:                      This macro defines the Reference oscillator clock divisor maximum value.
58:                  
59:                    Remarks:
60:                      None
61:                  */
62:                  
63:                  #define CLK_REFERENCE_DIVISOR_MAX					0xFFFF
64:                  
65:                  
66:                  //******************************************************************************
67:                  /* Function :  OSC_ExistsReferenceOscBaseClock_PIC32_1
68:                  
69:                    Summary:
70:                      Implements PIC32_1 variant of PLIB_OSC_ExistsReferenceOscBaseClock
71:                  
72:                    Description:
73:                      This template implements the PIC32_1 variant of the PLIB_OSC_ExistsReferenceOscBaseClock function.
74:                  */
75:                  
76:                  #define PLIB_OSC_ExistsReferenceOscBaseClock PLIB_OSC_ExistsReferenceOscBaseClock
77:                  PLIB_TEMPLATE bool OSC_ExistsReferenceOscBaseClock_PIC32_1( OSC_MODULE_ID index )
78:                  {
79:                      return true;
80:                  }
81:                  
82:                  
83:                  //******************************************************************************
84:                  /* Function :  OSC_ReferenceOscBaseClockSelect_PIC32_1
85:                  
86:                    Summary:
87:                      Implements PIC32_1 variant of PLIB_OSC_ReferenceOscBaseClockSelect
88:                  
89:                    Description:
90:                      This template implements the PIC32_1 variant of the PLIB_OSC_ReferenceOscBaseClockSelect function.
91:                  */
92:                  
93:                  PLIB_TEMPLATE void OSC_ReferenceOscBaseClockSelect_PIC32_1( OSC_MODULE_ID index , OSC_REFERENCE referenceOsc , OSC_REF_BASECLOCK refOscBaseClock )
94:                  {
95:                      REFOCONbits.ROSEL = refOscBaseClock;
9D0118D4  3C02BF81   LUI V0, -16511
9D0118D8  8C43F020   LW V1, -4064(V0)
9D0118DC  24040006   ADDIU A0, ZERO, 6
9D0118E0  7C831804   INS V1, A0, 0, 4
9D0118E4  AC43F020   SW V1, -4064(V0)
96:                      REFOCONSET = _REFOCON_DIVSWEN_MASK;
9D0118E8  3C03BF81   LUI V1, -16511
9D0118EC  24040200   ADDIU A0, ZERO, 512
9D0118F0  AC64F028   SW A0, -4056(V1)
97:                  }
98:                  
99:                  
100:                 #endif /*_OSC_REFERENCEOSCBASECLOCK_PIC32_1_H*/
101:                 
102:                 /******************************************************************************
103:                  End of File
104:                 */
105:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/osc/templates/osc_PBClockDivisor_PIC32_1.h
1:                   /*******************************************************************************
2:                     OSC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       osc_PBClockDivisor_PIC32_1.h
6:                   
7:                     Summary:
8:                       OSC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : PBClockDivisor
13:                      and its Variant : PIC32_1
14:                      For following APIs :
15:                          PLIB_OSC_ExistsPBClockDivisor
16:                          PLIB_OSC_PBClockDivisorGet
17:                          PLIB_OSC_PBClockDivisorSet
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _OSC_PBCLOCKDIVISOR_PIC32_1_H
48:                  #define _OSC_PBCLOCKDIVISOR_PIC32_1_H
49:                  
50:                  
51:                  // *****************************************************************************
52:                  /* Oscillator Peripheral Bus Clock Divisor Value Type
53:                  
54:                    Summary:
55:                      Type of the oscillator PB Clock divisor value.
56:                  
57:                    Description:
58:                      This macro defines the type of the oscillator PB Clock divisor value.
59:                  
60:                    Remarks:
61:                      None
62:                  */
63:                  
64:                  #define OSC_PB_CLOCK_DIV_TYPE						SFR_TYPE
65:                  
66:                  
67:                  // *****************************************************************************
68:                  /* Oscillator Peripheral Bus count
69:                  
70:                    Summary:
71:                      The number of Peripheral buses in available in the device.
72:                  
73:                    Description:
74:                      This macro gives the number of Peripheral buses in available in the device.
75:                  
76:                    Remarks:
77:                      None
78:                  */
79:                  
80:                  #define PERIPHERAL_BUSES_MAX						1
81:                  
82:                  
83:                  //******************************************************************************
84:                  /* Function :  OSC_ExistsPBClockDivisor_PIC32_1
85:                  
86:                    Summary:
87:                      Implements PIC32_1 variant of PLIB_OSC_ExistsPBClockDivisor
88:                  
89:                    Description:
90:                      This template implements the PIC32_1 variant of the PLIB_OSC_ExistsPBClockDivisor function.
91:                  */
92:                  
93:                  #define PLIB_OSC_ExistsPBClockDivisor PLIB_OSC_ExistsPBClockDivisor
94:                  PLIB_TEMPLATE bool OSC_ExistsPBClockDivisor_PIC32_1( OSC_MODULE_ID index )
95:                  {
96:                      return true;
97:                  }
98:                  
99:                  
100:                 //******************************************************************************
101:                 /* Function :  OSC_PBClockDivisorGet_PIC32_1
102:                 
103:                   Summary:
104:                     Implements PIC32_1 variant of PLIB_OSC_PBClockDivisorGet
105:                 
106:                   Description:
107:                     This template implements the PIC32_1 variant of the PLIB_OSC_PBClockDivisorGet function.
108:                 */
109:                 
110:                 PLIB_TEMPLATE OSC_PB_CLOCK_DIV_TYPE OSC_PBClockDivisorGet_PIC32_1( OSC_MODULE_ID index , OSC_PERIPHERAL_BUS peripheralBusNumber )
111:                 {
112:                     return (OSC_PB_CLOCK_DIV_TYPE)(0x01u << OSCCONbits.PBDIV);
113:                 }
114:                 
115:                 
116:                 //******************************************************************************
117:                 /* Function :  OSC_PBClockDivisorSet_PIC32_1
118:                 
119:                   Summary:
120:                     Implements PIC32_1 variant of PLIB_OSC_PBClockDivisorSet
121:                 
122:                   Description:
123:                     This template implements the PIC32_1 variant of the PLIB_OSC_PBClockDivisorSet function.
124:                 */
125:                 
126:                 PLIB_TEMPLATE void OSC_PBClockDivisorSet_PIC32_1( OSC_MODULE_ID index , OSC_PERIPHERAL_BUS peripheralBusNumber , OSC_PB_CLOCK_DIV_TYPE peripheralBusClkDiv )
127:                 {
128:                     uint8_t regValue;
129:                 
130:                     for (regValue = 0u; regValue < 4u; regValue++)
131:                     {
132:                         if ( peripheralBusClkDiv == ( 0x01u << regValue ) )
9D0118B8  24020002   ADDIU V0, ZERO, 2
9D0118BC  10400006   BEQ V0, ZERO, 0x9D0118D8
9D0118C0  3C02BF81   LUI V0, -16511
133:                         {
134:                             OSCCONbits.PBDIV = regValue;
9D0118C4  3C02BF81   LUI V0, -16511
9D0118C8  8C43F000   LW V1, -4096(V0)
9D0118CC  7C83A4C4   INS V1, A0, 19, 2
9D0118D0  AC43F000   SW V1, -4096(V0)
135:                             return;
136:                         }
137:                     }
138:                     PLIB_ASSERT(false, "Given PB Divisor value is not supported for the selected device");
139:                 }
140:                 
141:                 
142:                 #endif /*_OSC_PBCLOCKDIVISOR_PIC32_1_H*/
143:                 
144:                 /******************************************************************************
145:                  End of File
146:                 */
147:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/osc/templates/osc_FRCDivisor_Default.h
1:                   /*******************************************************************************
2:                     OSC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       osc_FRCDivisor_Default.h
6:                   
7:                     Summary:
8:                       OSC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : FRCDivisor
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_OSC_ExistsFRCDivisor
16:                          PLIB_OSC_FRCDivisorSelect
17:                          PLIB_OSC_FRCDivisorGet
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _OSC_FRCDIVISOR_DEFAULT_H
48:                  #define _OSC_FRCDIVISOR_DEFAULT_H
49:                  
50:                  //******************************************************************************
51:                  /* Function :  OSC_ExistsFRCDivisor_Default
52:                  
53:                    Summary:
54:                      Implements Default variant of PLIB_OSC_ExistsFRCDivisor
55:                  
56:                    Description:
57:                      This template implements the Default variant of the PLIB_OSC_ExistsFRCDivisor function.
58:                  */
59:                  
60:                  #define PLIB_OSC_ExistsFRCDivisor PLIB_OSC_ExistsFRCDivisor
61:                  PLIB_TEMPLATE bool OSC_ExistsFRCDivisor_Default( OSC_MODULE_ID index )
62:                  {
63:                      return true;
64:                  }
65:                  
66:                  
67:                  //******************************************************************************
68:                  /* Function :  OSC_FRCDivisorSelect_Default
69:                  
70:                    Summary:
71:                      Implements Default variant of PLIB_OSC_FRCDivisorSelect 
72:                  
73:                    Description:
74:                      This template implements the Default variant of the PLIB_OSC_FRCDivisorSelect function.
75:                  */
76:                  
77:                  PLIB_TEMPLATE void OSC_FRCDivisorSelect_Default( OSC_MODULE_ID index , OSC_FRC_DIV divisorFRC )
78:                  {
79:                      OSCCONbits.FRCDIV = divisorFRC;
9D0118A4  3C02BF81   LUI V0, -16511
9D0118A8  8C43F000   LW V1, -4096(V0)
9D0118AC  24040001   ADDIU A0, ZERO, 1
9D0118B0  7C83D604   INS V1, A0, 24, 3
9D0118B4  AC43F000   SW V1, -4096(V0)
80:                  }
81:                  
82:                  
83:                  //******************************************************************************
84:                  /* Function :  OSC_FRCDivisorGet_Default
85:                  
86:                    Summary:
87:                      Implements Default variant of PLIB_OSC_FRCDivisorGet
88:                  
89:                    Description:
90:                      This template implements the Default variant of the PLIB_OSC_FRCDivisorGet function.
91:                  */
92:                  
93:                  PLIB_TEMPLATE uint16_t OSC_FRCDivisorGet_Default( OSC_MODULE_ID index )
94:                  {
95:                      uint16_t returnValue  = 0u;
96:                  
97:                      if ( OSCCONbits.FRCDIV != 7u )
98:                      {
99:                          returnValue = ( 1u << OSCCONbits.FRCDIV );
100:                     }
101:                     else
102:                     {
103:                         returnValue = 256u;
104:                     }
105:                 
106:                     return returnValue;
107:                 }
108:                 
109:                 
110:                 #endif /*_OSC_FRCDIVISOR_DEFAULT_H*/
111:                 
112:                 /******************************************************************************
113:                  End of File
114:                 */
115:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/oc/templates/oc_TimerSelect_Default.h  
1:                   /*******************************************************************************
2:                     OC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       oc_TimerSelect_Default.h
6:                   
7:                     Summary:
8:                       OC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : TimerSelect
13:                      and its Variant : Default
14:                      For following APIs :
15:                  	PLIB_OC_TimerSelect
16:                  	PLIB_OC_ExistsTimerSelect
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _OC_TIMERSELECT_DEFAULT_H
47:                  #define _OC_TIMERSELECT_DEFAULT_H
48:                  
49:                  #include "oc_Registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  OC_TimerSelect_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_OC_TimerSelect
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_OC_TimerSelect function.
59:                  */
60:                  
61:                  PLIB_TEMPLATE void OC_TimerSelect_Default( OC_MODULE_ID index , OC_16BIT_TIMERS tmr )
62:                  {
63:                      volatile oc_register_t *regs = (volatile oc_register_t *)index;
64:                  
65:                      regs->OCxCON.OCTSEL = tmr;
9D0145C4  94443200   LHU A0, 12800(V0)
9D0145C8  24050001   ADDIU A1, ZERO, 1
9D0145CC  7CA418C4   INS A0, A1, 3, 1
9D0145D0  A4443200   SH A0, 12800(V0)
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  OC_ExistsTimerSelect_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_OC_ExistsTimerSelect
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_OC_ExistsTimerSelect function.
77:                  */
78:                  
79:                  #define PLIB_OC_ExistsTimerSelect PLIB_OC_ExistsTimerSelect
80:                  PLIB_TEMPLATE bool OC_ExistsTimerSelect_Default( OC_MODULE_ID index )
81:                  {
82:                      return true;
83:                  }
84:                  
85:                  
86:                  #endif /*_OC_TIMERSELECT_DEFAULT_H*/
87:                  
88:                  /******************************************************************************
89:                   End of File
90:                  */
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/oc/templates/oc_PulseWidth_32Bit_Variant.h
1:                   /*******************************************************************************
2:                     OC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       oc_PulseWidth_32Bit_Variant.h
6:                   
7:                     Summary:
8:                       OC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : PulseWidth
13:                      and its Variant : 32Bit_Variant
14:                      For following APIs :
15:                          PLIB_OC_PulseWidth32BitSet
16:                          PLIB_OC_PulseWidth16BitSet
17:                          PLIB_OC_ExistsPulseWidth
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _OC_PULSEWIDTH_32BIT_VARIANT_H
48:                  #define _OC_PULSEWIDTH_32BIT_VARIANT_H
49:                  
50:                  #include "oc_Registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  OC_PulseWidth32BitSet_32Bit_Variant
54:                  
55:                    Summary:
56:                      Implements 32Bit_Variant variant of PLIB_OC_PulseWidth32BitSet 
57:                  
58:                    Description:
59:                      This template implements the 32Bit_Variant variant of the PLIB_OC_PulseWidth32BitSet function.
60:                  */
61:                  
62:                  PLIB_TEMPLATE void OC_PulseWidth32BitSet_32Bit_Variant( OC_MODULE_ID index , uint32_t pulseWidth )
63:                  {
64:                      volatile oc_register_t *regs = (volatile oc_register_t *)index;
65:                  
66:                      regs->OCxRS = pulseWidth;
67:                  }
68:                  
69:                  
70:                  //******************************************************************************
71:                  /* Function :  OC_PulseWidth16BitSet_32Bit_Variant
72:                  
73:                    Summary:
74:                      Implements 32Bit_Variant variant of PLIB_OC_PulseWidth16BitSet 
75:                  
76:                    Description:
77:                      This template implements the 32Bit_Variant variant of the PLIB_OC_PulseWidth16BitSet function.
78:                  */
79:                  
80:                  PLIB_TEMPLATE void OC_PulseWidth16BitSet_32Bit_Variant( OC_MODULE_ID index , uint16_t pulseWidth )
81:                  {
82:                      volatile oc_register_t *regs = (volatile oc_register_t *)index;
83:                  
84:                      regs->OCxRS = pulseWidth;
9D0145D8  24020064   ADDIU V0, ZERO, 100
9D015810  3084FFFF   ANDI A0, A0, -1
85:                  }
86:                  
87:                  
88:                  //******************************************************************************
89:                  /* Function :  OC_ExistsPulseWidth_32Bit_Variant
90:                  
91:                    Summary:
92:                      Implements 32Bit_Variant variant of PLIB_OC_ExistsPulseWidth
93:                  
94:                    Description:
95:                      This template implements the 32Bit_Variant variant of the PLIB_OC_ExistsPulseWidth function.
96:                  */
97:                  
98:                  #define PLIB_OC_ExistsPulseWidth PLIB_OC_ExistsPulseWidth
99:                  PLIB_TEMPLATE bool OC_ExistsPulseWidth_32Bit_Variant( OC_MODULE_ID index )
100:                 {
101:                     return true;
102:                 }
103:                 
104:                 
105:                 #endif /*_OC_PULSEWIDTH_32BIT_VARIANT_H*/
106:                 
107:                 /******************************************************************************
108:                  End of File
109:                 */
110:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/oc/templates/oc_EnableControl_Default.h
1:                   /*******************************************************************************
2:                     OC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       oc_EnableControl_Default.h
6:                   
7:                     Summary:
8:                       OC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : EnableControl
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_OC_Enable
16:                          PLIB_OC_Disable
17:                          PLIB_OC_IsEnabled
18:                          PLIB_OC_ExistsEnableControl
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _OC_ENABLECONTROL_DEFAULT_H
49:                  #define _OC_ENABLECONTROL_DEFAULT_H
50:                  
51:                  #include "oc_Registers.h"
52:                  
53:                  //******************************************************************************
54:                  /* Function :  OC_Enable_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_OC_Enable 
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_OC_Enable function.
61:                      Operation is atomic.
62:                  */
63:                  
64:                  PLIB_TEMPLATE void OC_Enable_Default( OC_MODULE_ID index )
65:                  {
66:                      volatile oc_register_t *regs = (volatile oc_register_t *)index;
67:                  
68:                      regs->OCxCONSET = OCxCON_ON_MASK;
9D0157E8  34038000   ORI V1, ZERO, -32768
69:                  }
70:                  
71:                  
72:                  //******************************************************************************
73:                  /* Function :  OC_Disable_Default
74:                  
75:                    Summary:
76:                      Implements Default variant of PLIB_OC_Disable 
77:                  
78:                    Description:
79:                      This template implements the Default variant of the PLIB_OC_Disable function.
80:                      Operation is atomic.
81:                  */
82:                  
83:                  PLIB_TEMPLATE void OC_Disable_Default( OC_MODULE_ID index )
84:                  {
85:                      volatile oc_register_t *regs = (volatile oc_register_t *)index;
86:                  
87:                      regs->OCxCONCLR = OCxCON_ON_MASK;
9D0157FC  34038000   ORI V1, ZERO, -32768
88:                  }
89:                  
90:                  
91:                  //******************************************************************************
92:                  /* Function :  OC_IsEnabled_Default
93:                  
94:                    Summary:
95:                      Implements Default variant of PLIB_OC_IsEnabled 
96:                  
97:                    Description:
98:                      This template implements the Default variant of the PLIB_OC_IsEnabled function.
99:                      Operation is atomic.
100:                 */
101:                 
102:                 PLIB_TEMPLATE bool OC_IsEnabled_Default( OC_MODULE_ID index )
103:                 {
104:                     volatile oc_register_t *regs = (volatile oc_register_t *)index;
105:                 
106:                     return regs->OCxCON.ON;
107:                 }
108:                 
109:                 
110:                 //******************************************************************************
111:                 /* Function :  OC_ExistsEnableControl_Default
112:                 
113:                   Summary:
114:                     Implements Default variant of PLIB_OC_ExistsEnableControl
115:                 
116:                   Description:
117:                     This template implements the Default variant of the PLIB_OC_ExistsEnableControl function.
118:                 */
119:                 
120:                 #define PLIB_OC_ExistsEnableControl PLIB_OC_ExistsEnableControl
121:                 PLIB_TEMPLATE bool OC_ExistsEnableControl_Default( OC_MODULE_ID index )
122:                 {
123:                     return true;
124:                 }
125:                 
126:                 
127:                 #endif /*_OC_ENABLECONTROL_DEFAULT_H*/
128:                 
129:                 /******************************************************************************
130:                  End of File
131:                 */
132:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/oc/templates/oc_CompareModeSelect_Default.h
1:                   /*******************************************************************************
2:                     OC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       oc_CompareModeSelect_Default.h
6:                   
7:                     Summary:
8:                       OC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : CompareModeSelect
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_OC_ModeSelect
16:                          PLIB_OC_ExistsCompareModeSelect
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _OC_COMPAREMODESELECT_DEFAULT_H
47:                  #define _OC_COMPAREMODESELECT_DEFAULT_H
48:                  
49:                  #include "oc_Registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  OC_ModeSelect_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_OC_ModeSelect 
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_OC_ModeSelect function.
59:                  */
60:                  
61:                  PLIB_TEMPLATE void OC_ModeSelect_Default( OC_MODULE_ID index , OC_COMPARE_MODES cmpMode )
62:                  {
63:                      volatile oc_register_t *regs = (volatile oc_register_t *)index;
64:                  
65:                      regs->OCxCON.OCM = cmpMode;
9D0145A0  3C02BF80   LUI V0, -16512
9D0145A4  24433200   ADDIU V1, V0, 12800
9D0145A8  94443200   LHU A0, 12800(V0)
9D0145AC  24050006   ADDIU A1, ZERO, 6
9D0145B0  7CA41004   INS A0, A1, 0, 3
9D0145B4  A4443200   SH A0, 12800(V0)
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  OC_ExistsCompareModeSelect_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_OC_ExistsCompareModeSelect
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_OC_ExistsCompareModeSelect function.
77:                  */
78:                  
79:                  #define PLIB_OC_ExistsCompareModeSelect PLIB_OC_ExistsCompareModeSelect
80:                  PLIB_TEMPLATE bool OC_ExistsCompareModeSelect_Default( OC_MODULE_ID index )
81:                  {
82:                      return true;
83:                  }
84:                  
85:                  
86:                  #endif /*_OC_COMPAREMODESELECT_DEFAULT_H*/
87:                  
88:                  /******************************************************************************
89:                   End of File
90:                  */
91:                  
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/oc/templates/oc_BufferValue_32Bit_Variant.h
1:                   /*******************************************************************************
2:                     OC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       oc_BufferValue_32Bit_Variant.h
6:                   
7:                     Summary:
8:                       OC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : BufferValue
13:                      and its Variant : 32Bit_Variant
14:                      For following APIs :
15:                          PLIB_OC_Buffer32BitSet
16:                          PLIB_OC_Buffer16BitSet
17:                          PLIB_OC_ExistsBufferValue
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _OC_BUFFERVALUE_32BIT_VARIANT_H
48:                  #define _OC_BUFFERVALUE_32BIT_VARIANT_H
49:                  
50:                  #include "oc_Registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  OC_Buffer32BitSet_32Bit_Variant
54:                  
55:                    Summary:
56:                      Implements 32Bit_Variant variant of PLIB_OC_Buffer32BitSet 
57:                  
58:                    Description:
59:                      This template implements the 32Bit_Variant variant of the PLIB_OC_Buffer32BitSet function.
60:                  */
61:                  
62:                  PLIB_TEMPLATE void OC_Buffer32BitSet_32Bit_Variant( OC_MODULE_ID index , uint32_t val32Bit )
63:                  {
64:                      volatile oc_register_t *regs = (volatile oc_register_t *)index;
65:                  
66:                      regs->OCxR = val32Bit;
67:                  }
68:                  
69:                  
70:                  //******************************************************************************
71:                  /* Function :  OC_Buffer16BitSet_32Bit_Variant
72:                  
73:                    Summary:
74:                      Implements 32Bit_Variant variant of PLIB_OC_Buffer16BitSet 
75:                  
76:                    Description:
77:                      This template implements the 32Bit_Variant variant of the PLIB_OC_Buffer16BitSet function.
78:                  */
79:                  
80:                  PLIB_TEMPLATE void OC_Buffer16BitSet_32Bit_Variant( OC_MODULE_ID index , uint16_t val16Bit )
81:                  {
82:                      volatile oc_register_t *regs = (volatile oc_register_t *)index;
83:                  
84:                      regs->OCxR = val16Bit;
9D0145D4  AC403210   SW ZERO, 12816(V0)
85:                  }
86:                  
87:                  
88:                  //******************************************************************************
89:                  /* Function :  OC_ExistsBufferValue_32Bit_Variant
90:                  
91:                    Summary:
92:                      Implements 32Bit_Variant variant of PLIB_OC_ExistsBufferValue
93:                  
94:                    Description:
95:                      This template implements the 32Bit_Variant variant of the PLIB_OC_ExistsBufferValue function.
96:                  */
97:                  
98:                  #define PLIB_OC_ExistsBufferValue PLIB_OC_ExistsBufferValue
99:                  PLIB_TEMPLATE bool OC_ExistsBufferValue_32Bit_Variant( OC_MODULE_ID index )
100:                 {
101:                     return true;
102:                 }
103:                 
104:                 #endif /*_OC_BUFFERVALUE_32BIT_VARIANT_H*/
105:                 
106:                 /******************************************************************************
107:                  End of File
108:                 */
109:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/oc/templates/oc_BufferSize_Default.h  
1:                   /*******************************************************************************
2:                     OC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       oc_BufferSize_Default.h
6:                   
7:                     Summary:
8:                       OC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : BufferSize
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_OC_BufferSizeSelect
16:                          PLIB_OC_ExistsBufferSize
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _OC_BUFFERSIZE_DEFAULT_H
47:                  #define _OC_BUFFERSIZE_DEFAULT_H
48:                  
49:                  #include "oc_Registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  OC_BufferSizeSelect_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_OC_BufferSizeSelect 
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_OC_BufferSizeSelect function.
59:                  */
60:                  
61:                  PLIB_TEMPLATE void OC_BufferSizeSelect_Default( OC_MODULE_ID index , OC_BUFFER_SIZE size )
62:                  {
63:                      volatile oc_register_t *regs = (volatile oc_register_t *)index;
64:                  
65:                      regs->OCxCON.OC32 = size;
9D0145B8  94443200   LHU A0, 12800(V0)
9D0145BC  7C042944   INS A0, ZERO, 5, 1
9D0145C0  A4443200   SH A0, 12800(V0)
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  OC_ExistsBufferSize_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_OC_ExistsBufferSize
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_OC_ExistsBufferSize function.
77:                  */
78:                  
79:                  #define PLIB_OC_ExistsBufferSize PLIB_OC_ExistsBufferSize
80:                  PLIB_TEMPLATE bool OC_ExistsBufferSize_Default( OC_MODULE_ID index )
81:                  {
82:                      return true;
83:                  }
84:                  
85:                  
86:                  #endif /*_OC_BUFFERSIZE_DEFAULT_H*/
87:                  
88:                  /******************************************************************************
89:                   End of File
90:                  */
91:                  
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/int/templates/int_VectorSelect_Default.h
1:                   /*******************************************************************************
2:                     INT Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       int_VectorSelect_Default.h
6:                   
7:                     Summary:
8:                       INT PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : VectorSelect
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_INT_ExistsVectorSelect
16:                          PLIB_INT_MultiVectorSelect
17:                          PLIB_INT_SingleVectorSelect
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _INT_VECTORSELECT_DEFAULT_H
48:                  #define _INT_VECTORSELECT_DEFAULT_H
49:                  
50:                  //******************************************************************************
51:                  /* Function :  INT_ExistsVectorSelect_Default
52:                  
53:                    Summary:
54:                      Implements Default variant of PLIB_INT_ExistsVectorSelect
55:                  
56:                    Description:
57:                      This template implements the Default variant of the PLIB_INT_ExistsVectorSelect function.
58:                  */
59:                  #define PLIB_INT_ExistsVectorSelect PLIB_INT_ExistsVectorSelect
60:                  PLIB_TEMPLATE bool INT_ExistsVectorSelect_Default( INT_MODULE_ID index )
61:                  {
62:                      return true;
63:                  }
64:                  
65:                  //******************************************************************************
66:                  /* Function :  INT_MultiVectorSelect_Default
67:                  
68:                    Summary:
69:                      Implements Default variant of PLIB_INT_MultiVectorSelect 
70:                  
71:                    Description:
72:                      This template implements the Default variant of the PLIB_INT_MultiVectorSelect function.
73:                  */
74:                  PLIB_TEMPLATE void INT_MultiVectorSelect_Default( INT_MODULE_ID index )
75:                  {
76:                      INTCONSET = _INTCON_MVEC_MASK;
9D015798  24031000   ADDIU V1, ZERO, 4096
77:                  }
78:                  
79:                  //******************************************************************************
80:                  /* Function :  INT_SingleVectorSelect_Default
81:                  
82:                    Summary:
83:                      Implements Default variant of PLIB_INT_SingleVectorSelect 
84:                  
85:                    Description:
86:                      This template implements the Default variant of the PLIB_INT_SingleVectorSelect function.
87:                  */
88:                  PLIB_TEMPLATE void INT_SingleVectorSelect_Default( INT_MODULE_ID index )
89:                  {
90:                      INTCONCLR = _INTCON_MVEC_MASK;
91:                  }
92:                  
93:                  #endif /*_INT_VECTORSELECT_DEFAULT_H*/
94:                  
95:                  /******************************************************************************
96:                   End of File
97:                  */
98:                  
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/int/templates/int_VectorPriority_Default.h
1:                   /*******************************************************************************
2:                     INT Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       int_VectorPriority_Default.h
6:                   
7:                     Summary:
8:                       INT PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : VectorPriority
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_INT_ExistsVectorPriority
16:                          PLIB_INT_VectorPrioritySet
17:                          PLIB_INT_VectorPriorityGet
18:                          PLIB_INT_VectorSubPrioritySet
19:                          PLIB_INT_VectorSubPriorityGet
20:                  
21:                  *******************************************************************************/
22:                  
23:                  //DOM-IGNORE-BEGIN
24:                  /*******************************************************************************
25:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
26:                  
27:                  Microchip licenses to you the right to use, modify, copy and distribute
28:                  Software only when embedded on a Microchip microcontroller or digital signal
29:                  controller that is integrated into your product or third party product
30:                  (pursuant to the sublicense terms in the accompanying license agreement).
31:                  
32:                  You should refer to the license agreement accompanying this Software for
33:                  additional information regarding your rights and obligations.
34:                  
35:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
36:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
37:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
38:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
39:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
40:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
41:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
42:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
43:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
44:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
45:                  *******************************************************************************/
46:                  
47:                  //DOM-IGNORE-END
48:                  
49:                  #ifndef _INT_VECTORPRIORITY_DEFAULT_H
50:                  #define _INT_VECTORPRIORITY_DEFAULT_H
51:                  
52:                  //******************************************************************************
53:                  /* Function :  INT_ExistsVectorPriority_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_INT_ExistsVectorPriority
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_INT_ExistsVectorPriority function.
60:                  */
61:                  #define PLIB_INT_ExistsVectorPriority PLIB_INT_ExistsVectorPriority
62:                  PLIB_TEMPLATE bool INT_ExistsVectorPriority_Default( INT_MODULE_ID index )
63:                  {
64:                      return true;
65:                  }
66:                  
67:                  //******************************************************************************
68:                  /* Function :  INT_VectorPrioritySet_Default
69:                  
70:                    Summary:
71:                      Implements Default variant of PLIB_INT_VectorPrioritySet 
72:                  
73:                    Description:
74:                      This template implements the Default variant of the PLIB_INT_VectorPrioritySet function.
75:                  
76:                    Note:
77:                      The algorithm to calculate and write the field location has changed to use
78:                      actual vector numbers. The enumeration for INT_VECTOR should now match the
79:                      names to the actual vector numbers.
80:                  */
81:                  PLIB_TEMPLATE void INT_VectorPrioritySet_Default( INT_MODULE_ID index , INT_VECTOR vector , INT_PRIORITY_LEVEL priority )
82:                  {
83:                      volatile uint32_t *IPCx = (volatile uint32_t *)(&IPC0 + ((0x10 * (vector >> 2)) >> 2));
84:                      uint32_t mask = 0x07 << ((vector & 0x03) * 8 + 2);
85:                      uint32_t position = (vector & 0x03) * 8 + 2;
86:                  
87:                      /* read-modify-write */
88:                      *IPCx &= ~mask;
9D007CC4  3C11BF88   LUI S1, -16504
9D007CC8  26301090   ADDIU S0, S1, 4240
9D007CCC  8E020080   LW V0, 128(S0)
9D007CD0  7C026284   INS V0, ZERO, 10, 3
9D007CD4  AE020080   SW V0, 128(S0)
9D007D08  8E0200A0   LW V0, 160(S0)
9D007D0C  7C022084   INS V0, ZERO, 2, 3
9D007D10  AE0200A0   SW V0, 160(S0)
9D007D34  8E0200A0   LW V0, 160(S0)
9D007D38  7C026284   INS V0, ZERO, 10, 3
9D007D3C  AE0200A0   SW V0, 160(S0)
9D007DAC  8E020080   LW V0, 128(S0)
9D007DB0  7C022084   INS V0, ZERO, 2, 3
9D007DB4  AE020080   SW V0, 128(S0)
9D007DFC  8E221090   LW V0, 4240(S1)
9D007E00  7C02E684   INS V0, ZERO, 26, 3
9D007E04  AE221090   SW V0, 4240(S1)
9D007E64  8E020070   LW V0, 112(S0)
9D007E68  7C02A484   INS V0, ZERO, 18, 3
9D007E6C  AE020070   SW V0, 112(S0)
9D00F59C  3C02BF88   LUI V0, -16504
9D00F5A0  24421090   ADDIU V0, V0, 4240
9D00F5A4  8C440060   LW A0, 96(V0)
9D00F5A8  7C046284   INS A0, ZERO, 10, 3
9D00F5AC  AC440060   SW A0, 96(V0)
9D012ABC  3C02BF88   LUI V0, -16504
9D012AC0  24421090   ADDIU V0, V0, 4240
9D012AC4  8C430030   LW V1, 48(V0)
9D012AC8  7C032084   INS V1, ZERO, 2, 3
9D012ACC  AC430030   SW V1, 48(V0)
9D013044  3C02BF88   LUI V0, -16504
9D013048  24421090   ADDIU V0, V0, 4240
9D01304C  8C430040   LW V1, 64(V0)
9D013050  7C032084   INS V1, ZERO, 2, 3
9D013054  AC430040   SW V1, 64(V0)
9D0130BC  3C02BF88   LUI V0, -16504
9D0130C0  24421090   ADDIU V0, V0, 4240
9D0130C4  8C430020   LW V1, 32(V0)
9D0130C8  7C032084   INS V1, ZERO, 2, 3
9D0130CC  AC430020   SW V1, 32(V0)
89:                      *IPCx |= (priority << position) & mask;
9D007CD8  8E020080   LW V0, 128(S0)
9D007CDC  34420400   ORI V0, V0, 1024
9D007CE0  AE020080   SW V0, 128(S0)
9D007D14  8E0200A0   LW V0, 160(S0)
9D007D18  34420004   ORI V0, V0, 4
9D007D1C  AE0200A0   SW V0, 160(S0)
9D007D40  8E0200A0   LW V0, 160(S0)
9D007D44  34420400   ORI V0, V0, 1024
9D007D48  AE0200A0   SW V0, 160(S0)
9D007DB8  8E020080   LW V0, 128(S0)
9D007DBC  34420004   ORI V0, V0, 4
9D007DC0  AE020080   SW V0, 128(S0)
9D007E08  8E231090   LW V1, 4240(S1)
9D007E0C  3C020400   LUI V0, 1024
9D007E10  00621025   OR V0, V1, V0
9D007E14  AE221090   SW V0, 4240(S1)
9D007E70  8E030070   LW V1, 112(S0)
9D007E74  3C020010   LUI V0, 16
9D007E78  00621025   OR V0, V1, V0
9D007E7C  AE020070   SW V0, 112(S0)
9D00F5B0  8C440060   LW A0, 96(V0)
9D00F5B4  34840800   ORI A0, A0, 2048
9D00F5B8  AC440060   SW A0, 96(V0)
9D012AD0  8C430030   LW V1, 48(V0)
9D012AD4  34630004   ORI V1, V1, 4
9D012AD8  AC430030   SW V1, 48(V0)
9D013058  8C430040   LW V1, 64(V0)
9D01305C  34630004   ORI V1, V1, 4
9D013060  AC430040   SW V1, 64(V0)
9D0130D0  8C430020   LW V1, 32(V0)
9D0130D4  34630004   ORI V1, V1, 4
9D0130D8  AC430020   SW V1, 32(V0)
90:                  }
91:                  
92:                  //******************************************************************************
93:                  /* Function :  INT_VectorPriorityGet_Default
94:                  
95:                    Summary:
96:                      Implements Default variant of PLIB_INT_VectorPriorityGet 
97:                  
98:                    Description:
99:                      This template implements the Default variant of the PLIB_INT_VectorPriorityGet function.
100:                 
101:                   Note:
102:                     The algorithm to calculate and write the field location has changed to use
103:                     actual vector numbers. The enumeration for INT_VECTOR should now match the
104:                     names to the actual vector numbers.
105:                 */
106:                 PLIB_TEMPLATE INT_PRIORITY_LEVEL INT_VectorPriorityGet_Default( INT_MODULE_ID index , INT_VECTOR vector )
107:                 {
108:                     volatile uint32_t *IPCx = (volatile uint32_t *)(&IPC0 + ((0x10 * (vector >> 2)) >> 2));
109:                     uint32_t mask = 0x07 << (((vector & 0x03) * 8) + 2);
110:                     uint32_t position = (((vector & 0x03) * 8) + 2);
111:                 
112:                     return (INT_PRIORITY_LEVEL) ((*IPCx & mask) >> position);
113:                 }
114:                 
115:                 //******************************************************************************
116:                 /* Function :  INT_VectorSubPrioritySet_Default
117:                 
118:                   Summary:
119:                     Implements Default variant of PLIB_INT_VectorSubPrioritySet 
120:                 
121:                   Description:
122:                     This template implements the Default variant of the PLIB_INT_VectorSubPrioritySet function.
123:                 
124:                   Note:
125:                     The algorithm to calculate and write the field location has changed to use
126:                     actual vector numbers. The enumeration for INT_VECTOR should now match the
127:                     names to the actual vector numbers.
128:                 */
129:                 PLIB_TEMPLATE void INT_VectorSubPrioritySet_Default( INT_MODULE_ID index , INT_VECTOR vector , INT_SUBPRIORITY_LEVEL subPriority )
130:                 {
131:                     volatile uint32_t *IPCx = (volatile uint32_t *)(&IPC0 + ((0x10 * (vector >> 2)) >> 2));
132:                     uint32_t mask = 0x03 << ((vector & 0x03) * 8);
133:                     uint32_t position = (vector & 0x03) * 8;
134:                 
135:                     /* read-modify-write */
136:                     *IPCx &= ~mask; /* zeroed mask */
9D007CE4  8E020080   LW V0, 128(S0)
9D007CE8  7C024A04   INS V0, ZERO, 8, 2
9D007CEC  AE020080   SW V0, 128(S0)
9D007D20  8E0200A0   LW V0, 160(S0)
9D007D24  7C020804   INS V0, ZERO, 0, 2
9D007D28  AE0200A0   SW V0, 160(S0)
9D007D4C  8E0200A0   LW V0, 160(S0)
9D007D50  7C024A04   INS V0, ZERO, 8, 2
9D007D54  AE0200A0   SW V0, 160(S0)
9D007DC4  8E020080   LW V0, 128(S0)
9D007DC8  7C020804   INS V0, ZERO, 0, 2
9D007DCC  AE020080   SW V0, 128(S0)
9D007E18  8E221090   LW V0, 4240(S1)
9D007E1C  7C02CE04   INS V0, ZERO, 24, 2
9D007E20  AE221090   SW V0, 4240(S1)
9D007E80  8E020070   LW V0, 112(S0)
9D007E84  7C028C04   INS V0, ZERO, 16, 2
9D007E88  AE020070   SW V0, 112(S0)
9D00F5BC  8C440060   LW A0, 96(V0)
9D00F5C0  7C044A04   INS A0, ZERO, 8, 2
9D00F5C4  AC440060   SW A0, 96(V0)
9D012ADC  8C430030   LW V1, 48(V0)
9D012AE0  7C030804   INS V1, ZERO, 0, 2
9D012AE4  AC430030   SW V1, 48(V0)
9D013064  8C430040   LW V1, 64(V0)
9D013068  7C030804   INS V1, ZERO, 0, 2
9D01306C  AC430040   SW V1, 64(V0)
9D0130DC  8C430020   LW V1, 32(V0)
9D0130E0  7C030804   INS V1, ZERO, 0, 2
9D0130E4  AC430020   SW V1, 32(V0)
137:                     *IPCx |= (subPriority << position) & mask; /* set value */
9D007CF0  8E020080   LW V0, 128(S0)
9D007CF4  AE020080   SW V0, 128(S0)
9D007D2C  8E0200A0   LW V0, 160(S0)
9D007D30  AE0200A0   SW V0, 160(S0)
9D007D58  8E0200A0   LW V0, 160(S0)
9D007D5C  AE0200A0   SW V0, 160(S0)
9D007DD0  8E020080   LW V0, 128(S0)
9D007DD4  AE020080   SW V0, 128(S0)
9D007E24  8E221090   LW V0, 4240(S1)
9D007E28  AE221090   SW V0, 4240(S1)
9D007E8C  8E020070   LW V0, 112(S0)
9D007E90  AE020070   SW V0, 112(S0)
9D00F5C8  8C440060   LW A0, 96(V0)
9D00F5CC  34840200   ORI A0, A0, 512
9D00F5D0  AC440060   SW A0, 96(V0)
9D012AE8  8C430030   LW V1, 48(V0)
9D013070  8C430040   LW V1, 64(V0)
9D0130E8  8C430020   LW V1, 32(V0)
138:                 }
139:                 
140:                 //******************************************************************************
141:                 /* Function :  INT_VectorSubPriorityGet_Default
142:                 
143:                   Summary:
144:                     Implements Default variant of PLIB_INT_VectorSubPriorityGet 
145:                 
146:                   Description:
147:                     This template implements the Default variant of the PLIB_INT_VectorSubPriorityGet function.
148:                 
149:                   Note:
150:                     The algorithm to calculate and write the field location has changed to use
151:                     actual vector numbers. The enumeration for INT_VECTOR should now match the
152:                     names to the actual vector numbers.
153:                 */
154:                 PLIB_TEMPLATE INT_SUBPRIORITY_LEVEL INT_VectorSubPriorityGet_Default( INT_MODULE_ID index , INT_VECTOR vector )
155:                 {
156:                     volatile uint32_t *IPCx = (volatile uint32_t *)(&IPC0 + ((0x10 * (vector >> 2)) >> 2));
157:                     uint32_t mask = 0x03 << ((vector & 0x03) * 8);
158:                     uint32_t position = (vector & 0x03) * 8;
159:                 
160:                     return (INT_SUBPRIORITY_LEVEL) ((*IPCx & mask) >> position);
161:                 }
162:                 
163:                 #endif /*_INT_VECTORPRIORITY_DEFAULT_H*/
164:                 
165:                 /******************************************************************************
166:                  End of File
167:                 */
168:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/int/templates/int_SourceFlag_Default.h
1:                   /*******************************************************************************
2:                     INT Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       int_SourceFlag_Default.h
6:                   
7:                     Summary:
8:                       INT PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : SourceFlag
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_INT_ExistsSourceFlag
16:                          PLIB_INT_SourceFlagGet
17:                          PLIB_INT_SourceFlagSet
18:                          PLIB_INT_SourceFlagClear
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _INT_SOURCEFLAG_DEFAULT_H
49:                  #define _INT_SOURCEFLAG_DEFAULT_H
50:                  
51:                  //******************************************************************************
52:                  /* Function :  INT_ExistsSourceFlag_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_INT_ExistsSourceFlag
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_INT_ExistsSourceFlag function.
59:                  */
60:                  #define PLIB_INT_ExistsSourceFlag PLIB_INT_ExistsSourceFlag
61:                  PLIB_TEMPLATE bool INT_ExistsSourceFlag_Default( INT_MODULE_ID index )
62:                  {
63:                      return true;
64:                  }
65:                  
66:                  //******************************************************************************
67:                  /* Function :  INT_SourceFlagGet_Default
68:                  
69:                    Summary:
70:                      Implements Default variant of PLIB_INT_SourceFlagGet 
71:                  
72:                    Description:
73:                      This template implements the Default variant of the PLIB_INT_SourceFlagGet function.
74:                  
75:                    Note:
76:                      The source enum encoding is (x * 32) + y, where x is the register number 
77:                      (IFSx) and y is the bit position. 0b0xxy_yyyy
78:                  */
79:                  PLIB_TEMPLATE bool INT_SourceFlagGet_Default( INT_MODULE_ID index , INT_SOURCE source )
80:                  {
81:                      volatile uint32_t *IFSx = (volatile uint32_t *)(&IFS0 + ((0x10 * (source / 32)) / 4));
9D003EC4  00022142   SRL A0, V0, 5
9D003EC8  00042100   SLL A0, A0, 4
9D003ECC  3C03BF88   LUI V1, -16504
9D003ED0  24631030   ADDIU V1, V1, 4144
9D003ED4  00641821   ADDU V1, V1, A0
9D003F2C  00022142   SRL A0, V0, 5
9D003F30  00042100   SLL A0, A0, 4
9D003F34  3C03BF88   LUI V1, -16504
9D003F38  24631030   ADDIU V1, V1, 4144
9D003F3C  00641821   ADDU V1, V1, A0
9D003F68  00022142   SRL A0, V0, 5
9D003F6C  00042100   SLL A0, A0, 4
9D003F70  3C03BF88   LUI V1, -16504
9D003F74  24631030   ADDIU V1, V1, 4144
9D003F78  00641821   ADDU V1, V1, A0
9D003FAC  00022142   SRL A0, V0, 5
9D003FB0  00042100   SLL A0, A0, 4
9D003FB4  3C03BF88   LUI V1, -16504
9D003FB8  24631030   ADDIU V1, V1, 4144
9D003FBC  00641821   ADDU V1, V1, A0
9D009B88  00031142   SRL V0, V1, 5
9D009B8C  00021100   SLL V0, V0, 4
9D009B90  3C04BF88   LUI A0, -16504
9D009B94  24841030   ADDIU A0, A0, 4144
9D009B98  00822021   ADDU A0, A0, V0
9D009F5C  00031142   SRL V0, V1, 5
9D009F60  00021100   SLL V0, V0, 4
9D009F64  3C04BF88   LUI A0, -16504
9D009F68  24841030   ADDIU A0, A0, 4144
9D009F6C  00822021   ADDU A0, A0, V0
9D011B70  00022942   SRL A1, V0, 5
9D011B74  00052900   SLL A1, A1, 4
9D011B78  3C03BF88   LUI V1, -16504
9D011B7C  24631030   ADDIU V1, V1, 4144
9D011B80  00651821   ADDU V1, V1, A1
9D011C14  00022942   SRL A1, V0, 5
9D011C18  00052900   SLL A1, A1, 4
9D011C1C  3C03BF88   LUI V1, -16504
9D011C20  24631030   ADDIU V1, V1, 4144
9D011C24  00651821   ADDU V1, V1, A1
9D011CB8  00022942   SRL A1, V0, 5
9D011CBC  00052900   SLL A1, A1, 4
9D011CC0  3C03BF88   LUI V1, -16504
9D011CC4  24631030   ADDIU V1, V1, 4144
9D011CC8  00651821   ADDU V1, V1, A1
9D013100  00032942   SRL A1, V1, 5
9D013104  00052900   SLL A1, A1, 4
9D013108  3C04BF88   LUI A0, -16504
9D01310C  24841030   ADDIU A0, A0, 4144
9D013110  00852021   ADDU A0, A0, A1
82:                  
83:                      return (bool)((*IFSx >> (source & 0x1f)) & 0x1);
9D003ED8  8C630000   LW V1, 0(V1)
9D003EDC  00431006   SRLV V0, V1, V0
9D003EE0  30420001   ANDI V0, V0, 1
9D003F40  8C640000   LW A0, 0(V1)
9D003F44  3042001F   ANDI V0, V0, 31
9D003F48  00442006   SRLV A0, A0, V0
9D003F4C  30840001   ANDI A0, A0, 1
9D003F7C  8C640000   LW A0, 0(V1)
9D003F80  3042001F   ANDI V0, V0, 31
9D003F84  00442006   SRLV A0, A0, V0
9D003F88  30840001   ANDI A0, A0, 1
9D003FC0  8C640000   LW A0, 0(V1)
9D003FC4  3042001F   ANDI V0, V0, 31
9D003FC8  00442006   SRLV A0, A0, V0
9D003FCC  30840001   ANDI A0, A0, 1
9D009B9C  8C840000   LW A0, 0(A0)
9D009BA0  3063001F   ANDI V1, V1, 31
9D009BA4  00642006   SRLV A0, A0, V1
9D009BA8  30840001   ANDI A0, A0, 1
9D009F70  8C840000   LW A0, 0(A0)
9D009F74  3063001F   ANDI V1, V1, 31
9D009F78  00642006   SRLV A0, A0, V1
9D009F7C  30840001   ANDI A0, A0, 1
9D011B84  8C630000   LW V1, 0(V1)
9D011B88  00431006   SRLV V0, V1, V0
9D011B8C  30420001   ANDI V0, V0, 1
9D011C28  8C630000   LW V1, 0(V1)
9D011C2C  00431006   SRLV V0, V1, V0
9D011C30  30420001   ANDI V0, V0, 1
9D011CCC  8C630000   LW V1, 0(V1)
9D011CD0  00431006   SRLV V0, V1, V0
9D011CD4  30420001   ANDI V0, V0, 1
9D013114  8C850000   LW A1, 0(A0)
9D013118  3063001F   ANDI V1, V1, 31
9D01311C  00652806   SRLV A1, A1, V1
9D013120  30A50001   ANDI A1, A1, 1
84:                  }
85:                  
86:                  //******************************************************************************
87:                  /* Function :  INT_SourceFlagSet_Default
88:                  
89:                    Summary:
90:                      Implements Default variant of PLIB_INT_SourceFlagSet 
91:                  
92:                    Description:
93:                      This template implements the Default variant of the PLIB_INT_SourceFlagSet function.
94:                  
95:                    Note:
96:                      The source enum encoding is (x * 32) + y, where x is the register number 
97:                      (IFSx) and y is the bit position. 0b0xxy_yyyy
98:                  */
99:                  PLIB_TEMPLATE void INT_SourceFlagSet_Default( INT_MODULE_ID index , INT_SOURCE source )
100:                 {
101:                     volatile uint32_t *IFSx = (volatile uint32_t *) (&IFS0 + ((0x10 * (source / 32)) / 4));
102:                     volatile uint32_t *IFSxSET = (volatile uint32_t *)(IFSx + 2);
103:                 
104:                     *IFSxSET = 1 << (source & 0x1f);
105:                 }
106:                 
107:                 //******************************************************************************
108:                 /* Function :  INT_SourceFlagClear_Default
109:                 
110:                   Summary:
111:                     Implements Default variant of PLIB_INT_SourceFlagClear 
112:                 
113:                   Description:
114:                     This template implements the Default variant of the PLIB_INT_SourceFlagClear function.
115:                 
116:                   Note:
117:                     The source enum encoding is (x * 32) + y, where x is the register number 
118:                     (IFSx) and y is the bit position. 0b0xxy_yyyy
119:                 */
120:                 PLIB_TEMPLATE void INT_SourceFlagClear_Default( INT_MODULE_ID index , INT_SOURCE source )
121:                 {
122:                     volatile uint32_t *IFSx = (volatile uint32_t *) (&IFS0 + ((0x10 * (source / 32)) / 4));
9D003D98  00031142   SRL V0, V1, 5
9D003D9C  00021100   SLL V0, V0, 4
9D003DA0  3C04BF88   LUI A0, -16504
9D003DA4  24841030   ADDIU A0, A0, 4144
9D003DA8  00822021   ADDU A0, A0, V0
9D003F08  00022142   SRL A0, V0, 5
9D003F0C  00042100   SLL A0, A0, 4
9D003F10  3C03BF88   LUI V1, -16504
9D003F14  24631030   ADDIU V1, V1, 4144
9D003F18  00641821   ADDU V1, V1, A0
9D0062D4  3C04BF88   LUI A0, -16504
9D0062D8  24841030   ADDIU A0, A0, 4144
9D0062DC  00831821   ADDU V1, A0, V1
9D006334  00053142   SRL A2, A1, 5
9D006338  00063100   SLL A2, A2, 4
9D00633C  3C03BF88   LUI V1, -16504
9D006340  24631030   ADDIU V1, V1, 4144
9D006344  00663021   ADDU A2, V1, A2
9D006358  00053142   SRL A2, A1, 5
9D00635C  00063100   SLL A2, A2, 4
9D006360  00663021   ADDU A2, V1, A2
9D006370  00053142   SRL A2, A1, 5
9D006374  00063100   SLL A2, A2, 4
9D006378  00661821   ADDU V1, V1, A2
9D009B38  00021942   SRL V1, V0, 5
9D009B3C  00031900   SLL V1, V1, 4
9D009B40  3C04BF88   LUI A0, -16504
9D009B44  24841030   ADDIU A0, A0, 4144
9D009B48  00832021   ADDU A0, A0, V1
9D009F0C  00021942   SRL V1, V0, 5
9D009F10  00031900   SLL V1, V1, 4
9D009F14  3C04BF88   LUI A0, -16504
9D009F18  24841030   ADDIU A0, A0, 4144
9D009F1C  00832021   ADDU A0, A0, V1
9D00A090  00032142   SRL A0, V1, 5
9D00A094  00042100   SLL A0, A0, 4
9D00A098  3C02BF88   LUI V0, -16504
9D00A09C  24421030   ADDIU V0, V0, 4144
9D00A0A0  00442021   ADDU A0, V0, A0
9D00A0B4  00032142   SRL A0, V1, 5
9D00A0B8  00042100   SLL A0, A0, 4
9D00A0BC  00442021   ADDU A0, V0, A0
9D00A0CC  00032142   SRL A0, V1, 5
9D00A0D0  00042100   SLL A0, A0, 4
9D00A0D4  00441021   ADDU V0, V0, A0
9D00FD3C  00032142   SRL A0, V1, 5
9D00FD40  00042100   SLL A0, A0, 4
9D00FD44  3C02BF88   LUI V0, -16504
9D00FD48  24421030   ADDIU V0, V0, 4144
9D00FD4C  00441021   ADDU V0, V0, A0
9D00FDA4  00032142   SRL A0, V1, 5
9D00FDA8  00042100   SLL A0, A0, 4
9D00FDAC  3C02BF88   LUI V0, -16504
9D00FDB0  24421030   ADDIU V0, V0, 4144
9D00FDB4  00441021   ADDU V0, V0, A0
9D011BA4  00022142   SRL A0, V0, 5
9D011BA8  00042100   SLL A0, A0, 4
9D011BAC  3C03BF88   LUI V1, -16504
9D011BB0  24631030   ADDIU V1, V1, 4144
9D011BB4  00641821   ADDU V1, V1, A0
9D011C48  00022142   SRL A0, V0, 5
9D011C4C  00042100   SLL A0, A0, 4
9D011C50  3C03BF88   LUI V1, -16504
9D011C54  24631030   ADDIU V1, V1, 4144
9D011C58  00641821   ADDU V1, V1, A0
9D011CEC  00022142   SRL A0, V0, 5
9D011CF0  00042100   SLL A0, A0, 4
9D011CF4  3C03BF88   LUI V1, -16504
9D011CF8  24631030   ADDIU V1, V1, 4144
9D011CFC  00641821   ADDU V1, V1, A0
9D011FF8  00023142   SRL A2, V0, 5
9D011FFC  00063100   SLL A2, A2, 4
9D012000  3C05BF88   LUI A1, -16504
9D012004  24A51030   ADDIU A1, A1, 4144
9D012008  00A63021   ADDU A2, A1, A2
9D01201C  00022142   SRL A0, V0, 5
9D012020  00042100   SLL A0, A0, 4
9D012024  00A42821   ADDU A1, A1, A0
9D012DC4  00031142   SRL V0, V1, 5
9D012DC8  00021100   SLL V0, V0, 4
9D012DCC  3C04BF88   LUI A0, -16504
9D012DD0  24841030   ADDIU A0, A0, 4144
9D012DD4  00822021   ADDU A0, A0, V0
123:                     volatile uint32_t *IFSxCLR = (volatile uint32_t *)(IFSx + 1);
124:                 
125:                     *IFSxCLR = 1 << (source & 0x1f);
9D003DAC  24020001   ADDIU V0, ZERO, 1
9D003DB0  00621804   SLLV V1, V0, V1
9D003DB4  AC830004   SW V1, 4(A0)
9D003F1C  24040001   ADDIU A0, ZERO, 1
9D003F20  00441004   SLLV V0, A0, V0
9D003F24  AC620004   SW V0, 4(V1)
9D003F58  24040001   ADDIU A0, ZERO, 1
9D003F5C  00441004   SLLV V0, A0, V0
9D003F60  AC620004   SW V0, 4(V1)
9D003F94  24040001   ADDIU A0, ZERO, 1
9D003F98  00441004   SLLV V0, A0, V0
9D003F9C  AC620004   SW V0, 4(V1)
9D003FD8  24040001   ADDIU A0, ZERO, 1
9D003FDC  00441004   SLLV V0, A0, V0
9D003FE0  AC620004   SW V0, 4(V1)
9D0062E0  AC620004   SW V0, 4(V1)
9D006348  24100001   ADDIU S0, ZERO, 1
9D00634C  00B02804   SLLV A1, S0, A1
9D006350  ACC50004   SW A1, 4(A2)
9D006364  00B02804   SLLV A1, S0, A1
9D006368  ACC50004   SW A1, 4(A2)
9D00637C  00B02804   SLLV A1, S0, A1
9D006380  AC650004   SW A1, 4(V1)
9D009B4C  24030001   ADDIU V1, ZERO, 1
9D009B50  00431004   SLLV V0, V1, V0
9D009B54  AC820004   SW V0, 4(A0)
9D009F20  24030001   ADDIU V1, ZERO, 1
9D009F24  00431004   SLLV V0, V1, V0
9D009F28  AC820004   SW V0, 4(A0)
9D00A0A4  24120001   ADDIU S2, ZERO, 1
9D00A0A8  00721804   SLLV V1, S2, V1
9D00A0AC  AC830004   SW V1, 4(A0)
9D00A0C0  00721804   SLLV V1, S2, V1
9D00A0C4  AC830004   SW V1, 4(A0)
9D00A0D8  00721804   SLLV V1, S2, V1
9D00A0DC  AC430004   SW V1, 4(V0)
9D00FD50  24040001   ADDIU A0, ZERO, 1
9D00FD54  00641804   SLLV V1, A0, V1
9D00FD58  AC430004   SW V1, 4(V0)
9D00FDB8  24040001   ADDIU A0, ZERO, 1
9D00FDBC  00641804   SLLV V1, A0, V1
9D00FDC0  AC430004   SW V1, 4(V0)
9D011BB8  24040001   ADDIU A0, ZERO, 1
9D011BBC  00441004   SLLV V0, A0, V0
9D011BC0  AC620004   SW V0, 4(V1)
9D011C5C  24040001   ADDIU A0, ZERO, 1
9D011C60  00441004   SLLV V0, A0, V0
9D011C64  AC620004   SW V0, 4(V1)
9D011D00  24040001   ADDIU A0, ZERO, 1
9D011D04  00441004   SLLV V0, A0, V0
9D011D08  AC620004   SW V0, 4(V1)
9D01200C  24030001   ADDIU V1, ZERO, 1
9D012010  00431004   SLLV V0, V1, V0
9D012014  ACC20004   SW V0, 4(A2)
9D012028  00431004   SLLV V0, V1, V0
9D012DD8  24020001   ADDIU V0, ZERO, 1
9D012DDC  00621804   SLLV V1, V0, V1
9D012DE0  AC830004   SW V1, 4(A0)
9D01312C  24050001   ADDIU A1, ZERO, 1
9D013130  00651804   SLLV V1, A1, V1
9D013134  AC830004   SW V1, 4(A0)
9D014BAC  3C030008   LUI V1, 8
9D014BB0  3C02BF88   LUI V0, -16504
9D014BB4  24421030   ADDIU V0, V0, 4144
9D014BB8  AC430004   SW V1, 4(V0)
9D014BE8  24030200   ADDIU V1, ZERO, 512
9D014BEC  3C02BF88   LUI V0, -16504
9D014BF0  24421030   ADDIU V0, V0, 4144
9D014BF4  AC430004   SW V1, 4(V0)
9D014D8C  3C020008   LUI V0, 8
9D014D90  3C03BF88   LUI V1, -16504
9D014D94  24631030   ADDIU V1, V1, 4144
9D014D98  AC620004   SW V0, 4(V1)
9D014DC4  24024000   ADDIU V0, ZERO, 16384
9D014DC8  3C03BF88   LUI V1, -16504
9D014DCC  24631030   ADDIU V1, V1, 4144
9D014DD0  AC620004   SW V0, 4(V1)
9D014DFC  24020200   ADDIU V0, ZERO, 512
9D014E00  3C03BF88   LUI V1, -16504
9D014E04  24631030   ADDIU V1, V1, 4144
9D014E08  AC620004   SW V0, 4(V1)
9D015108  24034000   ADDIU V1, ZERO, 16384
9D01510C  3C02BF88   LUI V0, -16504
9D015110  24421030   ADDIU V0, V0, 4144
9D015114  AC430004   SW V1, 4(V0)
9D0151B8  24034000   ADDIU V1, ZERO, 16384
9D0151BC  3C02BF88   LUI V0, -16504
9D0151C0  24421030   ADDIU V0, V0, 4144
9D0151C4  AC430004   SW V1, 4(V0)
9D015720  24030008   ADDIU V1, ZERO, 8
9D015738  3C030008   LUI V1, 8
9D015750  24030200   ADDIU V1, ZERO, 512
126:                 }
127:                 
128:                 #endif /*_INT_SOURCEFLAG_DEFAULT_H*/
129:                 
130:                 /******************************************************************************
131:                  End of File
132:                 */
133:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/int/templates/int_SourceControl_Default.h
1:                   /*******************************************************************************
2:                     INT Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       int_SourceControl_Default.h
6:                   
7:                     Summary:
8:                       INT PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : SourceControl
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_INT_ExistsSourceControl
16:                          PLIB_INT_SourceEnable
17:                          PLIB_INT_SourceDisable
18:                          PLIB_INT_SourceIsEnabled
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _INT_SOURCECONTROL_DEFAULT_H
49:                  #define _INT_SOURCECONTROL_DEFAULT_H
50:                  
51:                  //******************************************************************************
52:                  /* Function :  INT_ExistsSourceControl_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_INT_ExistsSourceControl
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_INT_ExistsSourceControl function.
59:                  */
60:                  #define PLIB_INT_ExistsSourceControl PLIB_INT_ExistsSourceControl
61:                  PLIB_TEMPLATE bool INT_ExistsSourceControl_Default( INT_MODULE_ID index )
62:                  {
63:                      return true;
64:                  }
65:                  
66:                  //******************************************************************************
67:                  /* Function :  INT_SourceEnable_Default
68:                  
69:                    Summary:
70:                      Implements Default variant of PLIB_INT_SourceEnable 
71:                  
72:                    Description:
73:                      This template implements the Default variant of the PLIB_INT_SourceEnable function.
74:                  
75:                    Note:
76:                      The source enum encoding is (x * 32) + y, where x is the register number 
77:                      (IECx) and y is the bit position. 0b0xxy_yyyy
78:                  */
79:                  PLIB_TEMPLATE void INT_SourceEnable_Default( INT_MODULE_ID index , INT_SOURCE source )
80:                  {
81:                      volatile uint32_t *IECx = (volatile uint32_t *) (&IEC0 + ((0x10 * (source / 32)) / 4));
9D0062B4  00021942   SRL V1, V0, 5
9D0062B8  00031900   SLL V1, V1, 4
9D0062BC  3C04BF88   LUI A0, -16504
9D0062C0  24841060   ADDIU A0, A0, 4192
9D0062C4  00832021   ADDU A0, A0, V1
9D008214  00022942   SRL A1, V0, 5
9D008218  00052900   SLL A1, A1, 4
9D00821C  3C04BF88   LUI A0, -16504
9D008220  24841060   ADDIU A0, A0, 4192
9D008224  00852821   ADDU A1, A0, A1
9D008238  00022942   SRL A1, V0, 5
9D00823C  00052900   SLL A1, A1, 4
9D008240  00852021   ADDU A0, A0, A1
9D008D04  00021942   SRL V1, V0, 5
9D008D08  00031900   SLL V1, V1, 4
9D008D0C  3C04BF88   LUI A0, -16504
9D008D10  24841060   ADDIU A0, A0, 4192
9D008D14  00831821   ADDU V1, A0, V1
9D009784  00022142   SRL A0, V0, 5
9D009788  00042100   SLL A0, A0, 4
9D00978C  24631060   ADDIU V1, V1, 4192
9D009790  00641821   ADDU V1, V1, A0
9D009AF8  24841060   ADDIU A0, A0, 4192
9D009AFC  00822821   ADDU A1, A0, V0
9D009B10  00032942   SRL A1, V1, 5
9D009B14  00052900   SLL A1, A1, 4
9D009B18  00852021   ADDU A0, A0, A1
9D009B5C  00022942   SRL A1, V0, 5
9D009B60  00052900   SLL A1, A1, 4
9D009B64  3C04BF88   LUI A0, -16504
9D009B68  24841060   ADDIU A0, A0, 4192
9D009B6C  00852021   ADDU A0, A0, A1
9D009ECC  3C04BF88   LUI A0, -16504
9D009ED0  24841060   ADDIU A0, A0, 4192
9D009ED4  00822821   ADDU A1, A0, V0
9D009EE8  00032942   SRL A1, V1, 5
9D009EEC  00052900   SLL A1, A1, 4
9D009EF0  00852021   ADDU A0, A0, A1
9D009F30  00022942   SRL A1, V0, 5
9D009F34  00052900   SLL A1, A1, 4
9D009F38  3C04BF88   LUI A0, -16504
9D009F3C  24841060   ADDIU A0, A0, 4192
9D009F40  00852021   ADDU A0, A0, A1
9D00A0E0  3C02BF88   LUI V0, -16504
9D00A0E4  24421060   ADDIU V0, V0, 4192
9D00A0E8  00442021   ADDU A0, V0, A0
9D00A24C  00022142   SRL A0, V0, 5
9D00A250  00042100   SLL A0, A0, 4
9D00A254  3C03BF88   LUI V1, -16504
9D00A258  24631060   ADDIU V1, V1, 4192
9D00A25C  00641821   ADDU V1, V1, A0
9D00A274  00022142   SRL A0, V0, 5
9D00A278  00042100   SLL A0, A0, 4
9D00A27C  3C03BF88   LUI V1, -16504
9D00A280  24631060   ADDIU V1, V1, 4192
9D00A284  00641821   ADDU V1, V1, A0
9D00A2F4  00022142   SRL A0, V0, 5
9D00A2F8  00042100   SLL A0, A0, 4
9D00A2FC  3C03BF88   LUI V1, -16504
9D00A300  24631060   ADDIU V1, V1, 4192
9D00A304  00641821   ADDU V1, V1, A0
9D00A31C  00022142   SRL A0, V0, 5
9D00A320  00042100   SLL A0, A0, 4
9D00A324  3C03BF88   LUI V1, -16504
9D00A328  24631060   ADDIU V1, V1, 4192
9D00A32C  00641821   ADDU V1, V1, A0
9D00DDF4  00022142   SRL A0, V0, 5
9D00DDF8  00042100   SLL A0, A0, 4
9D00DDFC  24631060   ADDIU V1, V1, 4192
9D00DE00  00641821   ADDU V1, V1, A0
9D00E178  00022142   SRL A0, V0, 5
9D00E17C  00042100   SLL A0, A0, 4
9D00E180  24631060   ADDIU V1, V1, 4192
9D00E184  00641821   ADDU V1, V1, A0
9D00E7AC  00022142   SRL A0, V0, 5
9D00E7B0  00042100   SLL A0, A0, 4
9D00E7B4  24631060   ADDIU V1, V1, 4192
9D00E7B8  00641821   ADDU V1, V1, A0
9D00F22C  00022142   SRL A0, V0, 5
9D00F230  00042100   SLL A0, A0, 4
9D00F234  24631060   ADDIU V1, V1, 4192
9D00F238  00641821   ADDU V1, V1, A0
9D0137BC  00022142   SRL A0, V0, 5
9D0137C0  00042100   SLL A0, A0, 4
9D0137C4  3C03BF88   LUI V1, -16504
9D0137C8  24631060   ADDIU V1, V1, 4192
9D0137CC  00641821   ADDU V1, V1, A0
82:                      volatile uint32_t *IECxSET = (volatile uint32_t *)(IECx + 2);
83:                  
84:                      *IECxSET = 1 << (source & 0x1f);
9D0062C8  24050001   ADDIU A1, ZERO, 1
9D0062CC  00451004   SLLV V0, A1, V0
9D0062D0  AC820008   SW V0, 8(A0)
9D007D60  3C13BF88   LUI S3, -16504
9D007D64  26731060   ADDIU S3, S3, 4192
9D007D68  3C021000   LUI V0, 4096
9D007D6C  AE620018   SW V0, 24(S3)
9D007D70  3C022000   LUI V0, 8192
9D007D74  AE620018   SW V0, 24(S3)
9D007E38  24020008   ADDIU V0, ZERO, 8
9D007E3C  AE620008   SW V0, 8(S3)
9D008228  24030001   ADDIU V1, ZERO, 1
9D00822C  00431004   SLLV V0, V1, V0
9D008230  ACA20008   SW V0, 8(A1)
9D008244  00431004   SLLV V0, V1, V0
9D008248  AC820008   SW V0, 8(A0)
9D008D18  24040001   ADDIU A0, ZERO, 1
9D008D1C  00441004   SLLV V0, A0, V0
9D008D20  AC620008   SW V0, 8(V1)
9D009794  24040001   ADDIU A0, ZERO, 1
9D009798  00441004   SLLV V0, A0, V0
9D00979C  AC620008   SW V0, 8(V1)
9D009B00  24020001   ADDIU V0, ZERO, 1
9D009B04  00621804   SLLV V1, V0, V1
9D009B08  ACA30008   SW V1, 8(A1)
9D009B1C  00621804   SLLV V1, V0, V1
9D009B20  AC830008   SW V1, 8(A0)
9D009B70  00431004   SLLV V0, V1, V0
9D009B74  AC820008   SW V0, 8(A0)
9D009ED8  24020001   ADDIU V0, ZERO, 1
9D009EDC  00621804   SLLV V1, V0, V1
9D009EE0  ACA30008   SW V1, 8(A1)
9D009EF4  00621804   SLLV V1, V0, V1
9D009EF8  AC830008   SW V1, 8(A0)
9D009F44  00431004   SLLV V0, V1, V0
9D009F48  AC820008   SW V0, 8(A0)
9D00A0EC  AC830008   SW V1, 8(A0)
9D00A260  24040001   ADDIU A0, ZERO, 1
9D00A264  00441004   SLLV V0, A0, V0
9D00A268  AC620008   SW V0, 8(V1)
9D00A288  24040001   ADDIU A0, ZERO, 1
9D00A28C  00441004   SLLV V0, A0, V0
9D00A290  AC620008   SW V0, 8(V1)
9D00A308  24040001   ADDIU A0, ZERO, 1
9D00A30C  00441004   SLLV V0, A0, V0
9D00A310  AC620008   SW V0, 8(V1)
9D00A330  24040001   ADDIU A0, ZERO, 1
9D00A334  00441004   SLLV V0, A0, V0
9D00A338  AC620008   SW V0, 8(V1)
9D00DE04  24040001   ADDIU A0, ZERO, 1
9D00DE08  00441004   SLLV V0, A0, V0
9D00DE0C  AC620008   SW V0, 8(V1)
9D00E188  24040001   ADDIU A0, ZERO, 1
9D00E18C  00441004   SLLV V0, A0, V0
9D00E190  AC620008   SW V0, 8(V1)
9D00E7BC  24040001   ADDIU A0, ZERO, 1
9D00E7C0  00441004   SLLV V0, A0, V0
9D00E7C4  AC620008   SW V0, 8(V1)
9D00F23C  24040001   ADDIU A0, ZERO, 1
9D00F240  00441004   SLLV V0, A0, V0
9D00F244  AC620008   SW V0, 8(V1)
9D00F58C  3C044000   LUI A0, 16384
9D00F590  3C02BF88   LUI V0, -16504
9D00F594  24421060   ADDIU V0, V0, 4192
9D00F598  AC440008   SW A0, 8(V0)
9D0137D0  24040001   ADDIU A0, ZERO, 1
9D014D9C  3C03BF88   LUI V1, -16504
9D014DD4  3C03BF88   LUI V1, -16504
9D014E0C  3C03BF88   LUI V1, -16504
85:                  }
86:                  
87:                  //******************************************************************************
88:                  /* Function :  INT_SourceDisable_Default
89:                  
90:                    Summary:
91:                      Implements Default variant of PLIB_INT_SourceDisable 
92:                  
93:                    Description:
94:                      This template implements the Default variant of the PLIB_INT_SourceDisable function.
95:                  
96:                    Note:
97:                      The source enum encoding is (x * 32) + y, where x is the register number
98:                      (IECx) and y is the bit position. 0b0xxy_yyyy
99:                  */
100:                 PLIB_TEMPLATE void INT_SourceDisable_Default( INT_MODULE_ID index , INT_SOURCE source )
101:                 {
102:                     volatile uint32_t *IECx = (volatile uint32_t *) (&IEC0 + ((0x10 * (source / 32)) / 4));
103:                     volatile uint32_t *IECxCLR = (volatile uint32_t *)(IECx + 1);
104:                 
105:                     *IECxCLR = 1 << (source & 0x1f);
9D01418C  24060001   ADDIU A2, ZERO, 1
9D014190  00863004   SLLV A2, A2, A0
9D014194  AC660004   SW A2, 4(V1)
9D014B94  3C02BF88   LUI V0, -16504
9D014BD0  3C02BF88   LUI V0, -16504
9D014FE0  24034000   ADDIU V1, ZERO, 16384
9D014FE4  3C02BF88   LUI V0, -16504
9D014FE8  24421060   ADDIU V0, V0, 4192
9D014FEC  AC430004   SW V1, 4(V0)
9D015434  24054000   ADDIU A1, ZERO, 16384
9D015438  3C04BF88   LUI A0, -16504
9D01543C  24841060   ADDIU A0, A0, 4192
9D015440  AC850004   SW A1, 4(A0)
106:                 }
107:                 
108:                 //******************************************************************************
109:                 /* Function :  INT_SourceIsEnabled_Default
110:                 
111:                   Summary:
112:                     Implements Default variant of PLIB_INT_SourceIsEnabled 
113:                 
114:                   Description:
115:                     This template implements the Default variant of the PLIB_INT_SourceIsEnabled function.
116:                 
117:                   Note:
118:                     The source enum encoding is (x * 32) + y, where x is the register number 
119:                     (IECx) and y is the bit position. 0b0xxy_yyyy
120:                 */
121:                 PLIB_TEMPLATE bool INT_SourceIsEnabled_Default( INT_MODULE_ID index , INT_SOURCE source )
122:                 {
123:                     volatile uint32_t *IECx = (volatile uint32_t *) (&IEC0 + ((0x10 * (source / 32)) / 4));
9D014170  00041142   SRL V0, A0, 5
9D014174  00021100   SLL V0, V0, 4
9D014178  3C03BF88   LUI V1, -16504
9D01417C  24631060   ADDIU V1, V1, 4192
9D014180  00621821   ADDU V1, V1, V0
124:                 
125:                     return (bool)((*IECx >> (source & 0x1f)) & 0x01);
9D014184  8C620000   LW V0, 0(V1)
9D014188  3084001F   ANDI A0, A0, 31
9D0141A0  00821006   SRLV V0, V0, A0
126:                 }
127:                 
128:                 #endif /*_INT_SOURCECONTROL_DEFAULT_H*/
129:                 
130:                 /******************************************************************************
131:                  End of File
132:                 */
133:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/int/templates/int_ExternalINTEdgeSelect_Default.h
1:                   /*******************************************************************************
2:                     INT Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       int_ExternalINTEdgeSelect_Default.h
6:                   
7:                     Summary:
8:                       INT PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ExternalINTEdgeSelect
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_INT_ExistsExternalINTEdgeSelect
16:                          PLIB_INT_ExternalRisingEdgeSelect
17:                          PLIB_INT_ExternalFallingEdgeSelect
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _INT_EXTERNALINTEDGESELECT_DEFAULT_H
48:                  #define _INT_EXTERNALINTEDGESELECT_DEFAULT_H
49:                  
50:                  //******************************************************************************
51:                  /* Function :  INT_ExistsExternalINTEdgeSelect_Default
52:                  
53:                    Summary:
54:                      Implements Default variant of PLIB_INT_ExistsExternalINTEdgeSelect
55:                  
56:                    Description:
57:                      This template implements the Default variant of the PLIB_INT_ExistsExternalINTEdgeSelect function.
58:                  */
59:                  #define PLIB_INT_ExistsExternalINTEdgeSelect PLIB_INT_ExistsExternalINTEdgeSelect
60:                  PLIB_TEMPLATE bool INT_ExistsExternalINTEdgeSelect_Default( INT_MODULE_ID index )
61:                  {
62:                      return true;
63:                  }
64:                  
65:                  //******************************************************************************
66:                  /* Function :  INT_ExternalRisingEdgeSelect_Default
67:                  
68:                    Summary:
69:                      Implements Default variant of PLIB_INT_ExternalRisingEdgeSelect
70:                  
71:                    Description:
72:                      This template implements the Default variant of the PLIB_INT_ExternalRisingEdgeSelect function.
73:                  */
74:                  
75:                  PLIB_TEMPLATE void INT_ExternalRisingEdgeSelect_Default( INT_MODULE_ID index , INT_EXTERNAL_SOURCES source )
76:                  {
77:                      INTCONSET = source << _INTCON_INT0EP_POSITION;
9D015268  3C02BF88   LUI V0, -16504
9D01526C  AC441008   SW A0, 4104(V0)
9D015270  03E00008   JR RA
9D015274  00000000   NOP
78:                  }
79:                  
80:                  //******************************************************************************
81:                  /* Function :  INT_ExternalFallingEdgeSelect_Default
82:                  
83:                    Summary:
84:                      Implements Default variant of PLIB_INT_ExternalFallingEdgeSelect
85:                  
86:                    Description:
87:                      This template implements the Default variant of the PLIB_INT_ExternalFallingEdgeSelect function.
88:                  */
89:                  PLIB_TEMPLATE void INT_ExternalFallingEdgeSelect_Default( INT_MODULE_ID index , INT_EXTERNAL_SOURCES source )
90:                  {
91:                      INTCONCLR = source << _INTCON_INT0EP_POSITION;
9D015278  AC441004   SW A0, 4100(V0)
92:                  }
93:                  
94:                  #endif /*_INT_EXTERNALINTEDGESELECT_DEFAULT_H*/
95:                  
96:                  /******************************************************************************
97:                   End of File
98:                  */
99:                  
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/int/templates/int_EnableControl_PIC32.h
1:                   /*******************************************************************************
2:                     INT Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       int_EnableControl_PIC32.h
6:                   
7:                     Summary:
8:                       INT PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : EnableControl
13:                      and its Variant : PIC32
14:                      For following APIs :
15:                          PLIB_INT_ExistsEnableControl
16:                          PLIB_INT_Enable
17:                          PLIB_INT_Disable
18:                          PLIB_INT_IsEnabled
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _INT_ENABLECONTROL_PIC32_H
49:                  #define _INT_ENABLECONTROL_PIC32_H
50:                  
51:                  #include "peripheral/int/plib_int_private_pic32.h"
52:                  
53:                  //******************************************************************************
54:                  /* Function :  INT_ExistsEnableControl_PIC32
55:                  
56:                    Summary:
57:                      Implements PIC32 variant of PLIB_INT_ExistsEnableControl
58:                  
59:                    Description:
60:                      This template implements the PIC32 variant of the PLIB_INT_ExistsEnableControl function.
61:                  */
62:                  #define PLIB_INT_ExistsEnableControl PLIB_INT_ExistsEnableControl
63:                  PLIB_TEMPLATE bool INT_ExistsEnableControl_PIC32( INT_MODULE_ID index )
64:                  {
65:                      return true;
66:                  }
67:                  
68:                  //******************************************************************************
69:                  /* Function :  INT_Enable_PIC32
70:                  
71:                    Summary:
72:                      Implements PIC32 variant of PLIB_INT_Enable 
73:                  
74:                    Description:
75:                      This template implements the PIC32 variant of the PLIB_INT_Enable function.
76:                  */
77:                  PLIB_TEMPLATE __attribute__((nomips16,always_inline)) void INT_Enable_PIC32( INT_MODULE_ID index )
78:                  {
79:                      __builtin_mtc0(12, 0,(__builtin_mfc0(12, 0) | 0x0001));
9D014098  40026000   MFC0 V0, Status
9D01409C  34420001   ORI V0, V0, 1
9D0140A0  40826000   MTC0 V0, Status
9D0140A4  000000C0   EHB
9D0140F0  40026000   MFC0 V0, Status
9D0140F4  34420001   ORI V0, V0, 1
9D0140F8  40826000   MTC0 V0, Status
9D0140FC  000000C0   EHB
9D014614  40026000   MFC0 V0, Status
9D014618  34420001   ORI V0, V0, 1
9D01461C  40826000   MTC0 V0, Status
9D014620  000000C0   EHB
80:                      
81:                  }
82:                  
83:                  //******************************************************************************
84:                  /* Function :  INT_Disable_PIC32
85:                  
86:                    Summary:
87:                      Implements PIC32 variant of PLIB_INT_Disable 
88:                  
89:                    Description:
90:                      This template implements the PIC32 variant of the PLIB_INT_Disable function.
91:                  */
92:                  PLIB_TEMPLATE __attribute__((nomips16,always_inline))void INT_Disable_PIC32( INT_MODULE_ID index )
93:                  {
94:                      __builtin_disable_interrupts();
95:                  }
96:                  
97:                  //******************************************************************************
98:                  /* Function :  PLIB_INT_SetState_PIC32
99:                  
100:                   Summary:
101:                     Implements PIC32 variant of PLIB_INT_Enable 
102:                 
103:                   Description:
104:                     This template implements the PIC32 variant of the PLIB_INT_Enable function.
105:                 */
106:                 PLIB_TEMPLATE __attribute__((nomips16,always_inline)) void INT_SetState_PIC32( INT_MODULE_ID index, INT_STATE_GLOBAL interrupt_state )
107:                 {
108:                     __builtin_mtc0(12, 0, interrupt_state);
109:                 }
110:                 
111:                 //******************************************************************************
112:                 /* Function :  PLIB_INT_GetStateAndDisable_PIC32
113:                 
114:                   Summary:
115:                     Implements PIC32 variant of PLIB_INT_Disable 
116:                 
117:                   Description:
118:                     This template implements the PIC32 variant of the PLIB_INT_Disable function.
119:                 */
120:                 INT_STATE_GLOBAL PLIB_TEMPLATE __attribute__((nomips16,always_inline)) INT_GetStateAndDisable_PIC32( INT_MODULE_ID index )
121:                 {
122:                     return (INT_STATE_GLOBAL)__builtin_disable_interrupts();
9D014064  41636000   DI V1
9D014068  000000C0   EHB
9D0140CC  41646000   DI A0
9D0140D0  000000C0   EHB
9D0145F0  41626000   DI V0
9D0145F4  000000C0   EHB
123:                 }
124:                 
125:                 //******************************************************************************
126:                 /* Function :  INT_IsEnabled_PIC32
127:                 
128:                   Summary:
129:                     Implements PIC32 variant of PLIB_INT_IsEnabled 
130:                 
131:                   Description:
132:                     This template implements the PIC32 variant of the PLIB_INT_IsEnabled function.
133:                 */
134:                 PLIB_TEMPLATE bool __attribute__((nomips16,always_inline)) INT_IsEnabled_PIC32( INT_MODULE_ID index )
135:                 {
136:                     return (bool)(_CP0_GET_STATUS() & 0x01);
137:                 }
138:                 
139:                 #endif /*_INT_ENABLECONTROL_PIC32_H*/
140:                 
141:                 /******************************************************************************
142:                  End of File
143:                 */
144:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/i2c/templates/i2c_TransmitterByteSend_Default.h
1:                   /*******************************************************************************
2:                     I2C Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       i2c_TransmitterByteSend_Default.h
6:                   
7:                     Summary:
8:                       I2C PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : TransmitterByteSend
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_I2C_TransmitterByteSend
16:                          PLIB_I2C_ExistsTransmitterByteSend
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _I2C_TRANSMITTERBYTESEND_DEFAULT_H
47:                  #define _I2C_TRANSMITTERBYTESEND_DEFAULT_H
48:                  
49:                  #include "i2c_Registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  I2C_TransmitterByteSend_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_I2C_TransmitterByteSend 
56:                      Operation is atomic
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_I2C_TransmitterByteSend function.
60:                  */
61:                  
62:                  PLIB_TEMPLATE void I2C_TransmitterByteSend_Default( I2C_MODULE_ID index , uint8_t data )
63:                  {
64:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
65:                  
66:                      regs->I2CxTRN = data;
9D00375C  304200FF   ANDI V0, V0, 255
9D003760  AE420050   SW V0, 80(S2)
9D00377C  AE420050   SW V0, 80(S2)
9D003890  90420000   LBU V0, 0(V0)
9D003894  AE420050   SW V0, 80(S2)
9D003A0C  90420000   LBU V0, 0(V0)
9D003A10  AE420050   SW V0, 80(S2)
9D003AAC  AE400050   SW ZERO, 80(S2)
9D003B34  00031842   SRL V1, V1, 1
9D003B38  AE430050   SW V1, 80(S2)
9D003B3C  0B400FB0   J 0x9D003EC0
9D003B40  AC820048   SW V0, 72(A0)
9D003B4C  00021042   SRL V0, V0, 1
9D003B50  AE420050   SW V0, 80(S2)
9D003B74  304200FF   ANDI V0, V0, 255
9D003B78  AE420050   SW V0, 80(S2)
9D003CE4  90420000   LBU V0, 0(V0)
9D003CE8  AE420050   SW V0, 80(S2)
9D003D18  90420000   LBU V0, 0(V0)
9D003D1C  AE420050   SW V0, 80(S2)
67:                  }
68:                  
69:                  
70:                  //******************************************************************************
71:                  /* Function :  I2C_ExistsTransmitterByteSend_Default
72:                  
73:                    Summary:
74:                      Implements Default variant of PLIB_I2C_ExistsTransmitterByteSend
75:                  
76:                    Description:
77:                      This template implements the Default variant of the PLIB_I2C_ExistsTransmitterByteSend function.
78:                  */
79:                  
80:                  #define PLIB_I2C_ExistsTransmitterByteSend PLIB_I2C_ExistsTransmitterByteSend
81:                  PLIB_TEMPLATE bool I2C_ExistsTransmitterByteSend_Default( I2C_MODULE_ID index )
82:                  {
83:                      return true;
84:                  }
85:                  
86:                  
87:                  #endif /*_I2C_TRANSMITTERBYTESEND_DEFAULT_H*/
88:                  
89:                  /******************************************************************************
90:                   End of File
91:                  */
92:                  
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/i2c/templates/i2c_TransmitterByteComplete_Default.h
1:                   /*******************************************************************************
2:                     I2C Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       i2c_TransmitterByteComplete_Default.h
6:                   
7:                     Summary:
8:                       I2C PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : TransmitterByteComplete
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_I2C_TransmitterByteHasCompleted
16:                          PLIB_I2C_ExistsTransmitterByteComplete
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _I2C_TRANSMITTERBYTECOMPLETE_DEFAULT_H
47:                  #define _I2C_TRANSMITTERBYTECOMPLETE_DEFAULT_H
48:                  
49:                  #include "i2c_Registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  I2C_TransmitterByteHasCompleted_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_I2C_TransmitterByteHasCompleted 
56:                      Operation is atomic
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_I2C_TransmitterByteHasCompleted function.
60:                  */
61:                  
62:                  PLIB_TEMPLATE bool I2C_TransmitterByteHasCompleted_Default( I2C_MODULE_ID index )
63:                  {
64:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
65:                  
66:                      return (bool)!regs->I2CxSTAT.TRSTAT;
9D003C94  8E430010   LW V1, 16(S2)
9D003C98  30634000   ANDI V1, V1, 16384
9D003D64  8E420010   LW V0, 16(S2)
9D003D68  30424000   ANDI V0, V0, 16384
9D003DFC  8E420010   LW V0, 16(S2)
9D003E00  30424000   ANDI V0, V0, 16384
67:                  }
68:                  
69:                  
70:                  //******************************************************************************
71:                  /* Function :  I2C_ExistsTransmitterByteComplete_Default
72:                  
73:                    Summary:
74:                      Implements Default variant of PLIB_I2C_ExistsTransmitterByteComplete
75:                  
76:                    Description:
77:                      This template implements the Default variant of the PLIB_I2C_ExistsTransmitterByteComplete function.
78:                  */
79:                  
80:                  #define PLIB_I2C_ExistsTransmitterByteComplete PLIB_I2C_ExistsTransmitterByteComplete
81:                  PLIB_TEMPLATE bool I2C_ExistsTransmitterByteComplete_Default( I2C_MODULE_ID index )
82:                  {
83:                      return true;
84:                  }
85:                  
86:                  
87:                  #endif /*_I2C_TRANSMITTERBYTECOMPLETE_DEFAULT_H*/
88:                  
89:                  /******************************************************************************
90:                   End of File
91:                  */
92:                  
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/i2c/templates/i2c_TransmitterByteAcknowledge_Default.h
1:                   /*******************************************************************************
2:                     I2C Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       i2c_TransmitterByteAcknowledge_Default.h
6:                   
7:                     Summary:
8:                       I2C PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : TransmitterByteAcknowledge
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_I2C_TransmitterByteWasAcknowledged
16:                          PLIB_I2C_ExistsTransmitterByteAcknowledge
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _I2C_TRANSMITTERBYTEACKNOWLEDGE_DEFAULT_H
47:                  #define _I2C_TRANSMITTERBYTEACKNOWLEDGE_DEFAULT_H
48:                  
49:                  #include "i2c_Registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  I2C_TransmitterByteWasAcknowledged_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_I2C_TransmitterByteWasAcknowledged 
56:                      Operation is atomic
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_I2C_TransmitterByteWasAcknowledged function.
60:                  */
61:                  
62:                  PLIB_TEMPLATE bool I2C_TransmitterByteWasAcknowledged_Default( I2C_MODULE_ID index )
63:                  {
64:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
65:                  
66:                      return (bool)!regs->I2CxSTAT.ACKSTAT;
9D0039D4  8E420010   LW V0, 16(S2)
9D0039D8  30428000   ANDI V0, V0, -32768
9D003AB8  8E420010   LW V0, 16(S2)
9D003ABC  30428000   ANDI V0, V0, -32768
9D003CA4  8E430010   LW V1, 16(S2)
9D003CA8  30638000   ANDI V1, V1, -32768
9D003D54  8E420010   LW V0, 16(S2)
9D003D58  30428000   ANDI V0, V0, -32768
9D003D74  8E420010   LW V0, 16(S2)
9D003D78  30428000   ANDI V0, V0, -32768
9D003E0C  8E420010   LW V0, 16(S2)
9D003E10  30428000   ANDI V0, V0, -32768
67:                  }
68:                  
69:                  
70:                  //******************************************************************************
71:                  /* Function :  I2C_ExistsTransmitterByteAcknowledge_Default
72:                  
73:                    Summary:
74:                      Implements Default variant of PLIB_I2C_ExistsTransmitterByteAcknowledge
75:                  
76:                    Description:
77:                      This template implements the Default variant of the PLIB_I2C_ExistsTransmitterByteAcknowledge function.
78:                  */
79:                  
80:                  #define PLIB_I2C_ExistsTransmitterByteAcknowledge PLIB_I2C_ExistsTransmitterByteAcknowledge
81:                  PLIB_TEMPLATE bool I2C_ExistsTransmitterByteAcknowledge_Default( I2C_MODULE_ID index )
82:                  {
83:                      return true;
84:                  }
85:                  
86:                  
87:                  #endif /*_I2C_TRANSMITTERBYTEACKNOWLEDGE_DEFAULT_H*/
88:                  
89:                  /******************************************************************************
90:                   End of File
91:                  */
92:                  
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/i2c/templates/i2c_StopInIdle_Default.h
1:                   /*******************************************************************************
2:                     I2C Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       i2c_StopInIdle_Default.h
6:                   
7:                     Summary:
8:                       I2C PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : StopInIdle
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_I2C_StopInIdleEnable
16:                          PLIB_I2C_StopInIdleDisable
17:                          PLIB_I2C_ExistsStopInIdle
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _I2C_STOPINIDLE_DEFAULT_H
48:                  #define _I2C_STOPINIDLE_DEFAULT_H
49:                  
50:                  #include "i2c_Registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  I2C_StopInIdleEnable_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_I2C_StopInIdleEnable 
57:                      Operation is atomic
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_I2C_StopInIdleEnable function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE void I2C_StopInIdleEnable_Default( I2C_MODULE_ID index )
64:                  {
65:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
66:                  
67:                      regs->I2CxCONSET = I2CxCON_SIDL_MASK;
9D006128  24022000   ADDIU V0, ZERO, 8192
9D00612C  AE220008   SW V0, 8(S1)
9D00616C  24022000   ADDIU V0, ZERO, 8192
9D006170  AE220008   SW V0, 8(S1)
68:                  }
69:                  
70:                  
71:                  //******************************************************************************
72:                  /* Function :  I2C_StopInIdleDisable_Default
73:                  
74:                    Summary:
75:                      Implements Default variant of PLIB_I2C_StopInIdleDisable
76:                      Operation is atomic
77:                  
78:                    Description:
79:                      This template implements the Default variant of the PLIB_I2C_StopInIdleDisable function.
80:                  */
81:                  
82:                  PLIB_TEMPLATE void I2C_StopInIdleDisable_Default( I2C_MODULE_ID index )
83:                  {
84:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
85:                  
86:                      regs->I2CxCONCLR = I2CxCON_SIDL_MASK;
9D00614C  24022000   ADDIU V0, ZERO, 8192
9D006150  AE220004   SW V0, 4(S1)
87:                  }
88:                  
89:                  
90:                  //******************************************************************************
91:                  /* Function :  I2C_ExistsStopInIdle_Default
92:                  
93:                    Summary:
94:                      Implements Default variant of PLIB_I2C_ExistsStopInIdle
95:                  
96:                    Description:
97:                      This template implements the Default variant of the PLIB_I2C_ExistsStopInIdle function.
98:                  */
99:                  
100:                 #define PLIB_I2C_ExistsStopInIdle PLIB_I2C_ExistsStopInIdle
101:                 PLIB_TEMPLATE bool I2C_ExistsStopInIdle_Default( I2C_MODULE_ID index )
102:                 {
103:                     return true;
104:                 }
105:                 
106:                 
107:                 #endif /*_I2C_STOPINIDLE_DEFAULT_H*/
108:                 
109:                 /******************************************************************************
110:                  End of File
111:                 */
112:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/i2c/templates/i2c_StopDetect_Default.h
1:                   /*******************************************************************************
2:                     I2C Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       i2c_StopDetect_Default.h
6:                   
7:                     Summary:
8:                       I2C PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : StopDetect
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_I2C_StopWasDetected
16:                          PLIB_I2C_StopClear
17:                          PLIB_I2C_ExistsStopDetect
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _I2C_STOPDETECT_DEFAULT_H
48:                  #define _I2C_STOPDETECT_DEFAULT_H
49:                  
50:                  #include "i2c_Registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  I2C_StopWasDetected_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_I2C_StopWasDetected
57:                      Operation is atomic
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_I2C_StopWasDetected function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE bool I2C_StopWasDetected_Default( I2C_MODULE_ID index )
64:                  {
65:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
66:                  
67:                      return (bool)regs->I2CxSTAT.P;
9D009AB0  8C430010   LW V1, 16(V0)
9D009AB4  30630010   ANDI V1, V1, 16
9D009AC0  8C430010   LW V1, 16(V0)
9D009AC4  30630010   ANDI V1, V1, 16
9D009E84  8C430010   LW V1, 16(V0)
9D009E88  30630010   ANDI V1, V1, 16
9D009E94  8C430010   LW V1, 16(V0)
9D009E98  30630010   ANDI V1, V1, 16
68:                  }
69:                  
70:                  
71:                  //******************************************************************************
72:                  /* Function :  I2C_StopClear_Default
73:                  
74:                    Summary:
75:                      Implements Default variant of PLIB_I2C_StopClear
76:                      Operation is atomic
77:                  
78:                    Description:
79:                      This template implements the Default variant of the PLIB_I2C_StopClear function.
80:                  */
81:                  
82:                  PLIB_TEMPLATE void I2C_StopClear_Default( I2C_MODULE_ID index )
83:                  {
84:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
85:                  
86:                      regs->I2CxSTATCLR = I2CxSTAT_P_MASK;
87:                  }
88:                  
89:                  
90:                  //******************************************************************************
91:                  /* Function :  I2C_ExistsStopDetect_Default
92:                  
93:                    Summary:
94:                      Implements Default variant of PLIB_I2C_ExistsStopDetect
95:                  
96:                    Description:
97:                      This template implements the Default variant of the PLIB_I2C_ExistsStopDetect function.
98:                  */
99:                  
100:                 #define PLIB_I2C_ExistsStopDetect PLIB_I2C_ExistsStopDetect
101:                 PLIB_TEMPLATE bool I2C_ExistsStopDetect_Default( I2C_MODULE_ID index )
102:                 {
103:                     return true;
104:                 }
105:                 
106:                 
107:                 #endif /*_I2C_STOPDETECT_DEFAULT_H*/
108:                 
109:                 /******************************************************************************
110:                  End of File
111:                 */
112:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/i2c/templates/i2c_StartDetect_Default.h
1:                   /*******************************************************************************
2:                     I2C Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       i2c_StartDetect_Default.h
6:                   
7:                     Summary:
8:                       I2C PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : StartDetect
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_I2C_StartWasDetected
16:                          PLIB_I2C_StartClear
17:                          PLIB_I2C_ExistsStartDetect
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _I2C_STARTDETECT_DEFAULT_H
48:                  #define _I2C_STARTDETECT_DEFAULT_H
49:                  
50:                  #include "i2c_Registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  I2C_StartWasDetected_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_I2C_StartWasDetected
57:                      Operation is atomic
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_I2C_StartWasDetected function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE bool I2C_StartWasDetected_Default( I2C_MODULE_ID index )
64:                  {
65:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
9D009A9C  8E220004   LW V0, 4(S1)
9D009E70  8E220004   LW V0, 4(S1)
66:                  
67:                      return (bool)regs->I2CxSTAT.S;
9D009AA0  8C430010   LW V1, 16(V0)
9D009AA4  30630008   ANDI V1, V1, 8
9D009E74  8C430010   LW V1, 16(V0)
9D009E78  30630008   ANDI V1, V1, 8
68:                  }
69:                  
70:                  
71:                  //******************************************************************************
72:                  /* Function :  I2C_StartClear_Default
73:                  
74:                    Summary:
75:                      Implements Default variant of PLIB_I2C_StartClear 
76:                      Operation is atomic
77:                  
78:                    Description:
79:                      This template implements the Default variant of the PLIB_I2C_StartClear function.
80:                  */
81:                  
82:                  PLIB_TEMPLATE void I2C_StartClear_Default( I2C_MODULE_ID index )
83:                  {
84:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
85:                  
86:                      regs->I2CxSTATCLR = I2CxSTAT_S_MASK;
87:                  }
88:                  
89:                  
90:                  //******************************************************************************
91:                  /* Function :  I2C_ExistsStartDetect_Default
92:                  
93:                    Summary:
94:                      Implements Default variant of PLIB_I2C_ExistsStartDetect
95:                  
96:                    Description:
97:                      This template implements the Default variant of the PLIB_I2C_ExistsStartDetect function.
98:                  */
99:                  
100:                 #define PLIB_I2C_ExistsStartDetect PLIB_I2C_ExistsStartDetect
101:                 PLIB_TEMPLATE bool I2C_ExistsStartDetect_Default( I2C_MODULE_ID index )
102:                 {
103:                     return true;
104:                 }
105:                 
106:                 
107:                 #endif /*_I2C_STARTDETECT_DEFAULT_H*/
108:                 
109:                 /******************************************************************************
110:                  End of File
111:                 */
112:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/i2c/templates/i2c_SlaveReadRequest_Default.h
1:                   /*******************************************************************************
2:                     I2C Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       i2c_SlaveReadRequest_Default.h
6:                   
7:                     Summary:
8:                       I2C PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : SlaveReadRequest
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_I2C_SlaveReadIsRequested
16:                          PLIB_I2C_ExistsSlaveReadRequest
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _I2C_SLAVEREADREQUEST_DEFAULT_H
47:                  #define _I2C_SLAVEREADREQUEST_DEFAULT_H
48:                  
49:                  #include "i2c_Registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  I2C_SlaveReadIsRequested_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_I2C_SlaveReadIsRequested
56:                      Operation is atomic
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_I2C_SlaveReadIsRequested function.
60:                  */
61:                  
62:                  PLIB_TEMPLATE bool I2C_SlaveReadIsRequested_Default( I2C_MODULE_ID index )
63:                  {
64:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
65:                  
66:                      return (bool)regs->I2CxSTAT.R_W;
9D0037B8  8E420010   LW V0, 16(S2)
9D0037BC  30420004   ANDI V0, V0, 4
9D003820  8E420010   LW V0, 16(S2)
9D003824  30420004   ANDI V0, V0, 4
9D0038B4  8E420010   LW V0, 16(S2)
9D0038B8  30420004   ANDI V0, V0, 4
9D0039AC  8E420010   LW V0, 16(S2)
9D0039B0  30420004   ANDI V0, V0, 4
67:                  }
68:                  
69:                  
70:                  //******************************************************************************
71:                  /* Function :  I2C_ExistsSlaveReadRequest_Default
72:                  
73:                    Summary:
74:                      Implements Default variant of PLIB_I2C_ExistsSlaveReadRequest
75:                  
76:                    Description:
77:                      This template implements the Default variant of the PLIB_I2C_ExistsSlaveReadRequest function.
78:                  */
79:                  
80:                  #define PLIB_I2C_ExistsSlaveReadRequest PLIB_I2C_ExistsSlaveReadRequest
81:                  PLIB_TEMPLATE bool I2C_ExistsSlaveReadRequest_Default( I2C_MODULE_ID index )
82:                  {
83:                      return true;
84:                  }
85:                  
86:                  
87:                  #endif /*_I2C_SLAVEREADREQUEST_DEFAULT_H*/
88:                  
89:                  /******************************************************************************
90:                   End of File
91:                  */
92:                  
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/i2c/templates/i2c_SlaveMask_Default.h  
1:                   /*******************************************************************************
2:                     I2C Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       i2c_SlaveMask_Default.h
6:                   
7:                     Summary:
8:                       I2C PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : SlaveMask
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_I2C_SlaveMask7BitSet
16:                          PLIB_I2C_SlaveMask7BitGet
17:                          PLIB_I2C_SlaveMask10BitSet
18:                          PLIB_I2C_SlaveMask10BitGet
19:                          PLIB_I2C_ExistsSlaveMask
20:                  
21:                  *******************************************************************************/
22:                  
23:                  //DOM-IGNORE-BEGIN
24:                  /*******************************************************************************
25:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
26:                  
27:                  Microchip licenses to you the right to use, modify, copy and distribute
28:                  Software only when embedded on a Microchip microcontroller or digital signal
29:                  controller that is integrated into your product or third party product
30:                  (pursuant to the sublicense terms in the accompanying license agreement).
31:                  
32:                  You should refer to the license agreement accompanying this Software for
33:                  additional information regarding your rights and obligations.
34:                  
35:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
36:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
37:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
38:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
39:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
40:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
41:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
42:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
43:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
44:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
45:                  *******************************************************************************/
46:                  
47:                  //DOM-IGNORE-END
48:                  
49:                  #ifndef _I2C_SLAVEMASK_DEFAULT_H
50:                  #define _I2C_SLAVEMASK_DEFAULT_H
51:                  
52:                  #include "i2c_Registers.h"
53:                  
54:                  //******************************************************************************
55:                  /* Function :  I2C_SlaveMask7BitSet_Default
56:                  
57:                    Summary:
58:                      Implements Default variant of PLIB_I2C_SlaveMask7BitSet 
59:                  
60:                    Description:
61:                      This template implements the Default variant of the PLIB_I2C_SlaveMask7BitSet function.
62:                  */
63:                  
64:                  PLIB_TEMPLATE void I2C_SlaveMask7BitSet_Default( I2C_MODULE_ID index , uint8_t mask )
65:                  {
66:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
67:                  
68:                      regs->I2CxMSK = mask;
9D0062A4  92020048   LBU V0, 72(S0)
9D0062A8  AE220030   SW V0, 48(S1)
69:                  }
70:                  
71:                  
72:                  //******************************************************************************
73:                  /* Function :  I2C_SlaveMask7BitGet_Default
74:                  
75:                    Summary:
76:                      Implements Default variant of PLIB_I2C_SlaveMask7BitGet 
77:                      Operation is atomic
78:                  
79:                    Description:
80:                      This template implements the Default variant of the PLIB_I2C_SlaveMask7BitGet function.
81:                  */
82:                  
83:                  PLIB_TEMPLATE uint8_t I2C_SlaveMask7BitGet_Default( I2C_MODULE_ID index )
84:                  {
85:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
86:                  
87:                      return (uint8_t)regs->I2CxMSK;
88:                  }
89:                  
90:                  
91:                  //******************************************************************************
92:                  /* Function :  I2C_SlaveMask10BitSet_Default
93:                  
94:                    Summary:
95:                      Implements Default variant of PLIB_I2C_SlaveMask10BitSet 
96:                  
97:                    Description:
98:                      This template implements the Default variant of the PLIB_I2C_SlaveMask10BitSet function.
99:                  */
100:                 
101:                 PLIB_TEMPLATE void I2C_SlaveMask10BitSet_Default( I2C_MODULE_ID index , uint16_t mask )
102:                 {
103:                     volatile i2c_register_t *regs = (i2c_register_t *)index;
104:                 
105:                     regs->I2CxMSK = mask;
106:                 }
107:                 
108:                 
109:                 //******************************************************************************
110:                 /* Function :  I2C_SlaveMask10BitGet_Default
111:                 
112:                   Summary:
113:                     Implements Default variant of PLIB_I2C_SlaveMask10BitGet
114:                     Operation is atomic
115:                 
116:                   Description:
117:                     This template implements the Default variant of the PLIB_I2C_SlaveMask10BitGet function.
118:                 */
119:                 
120:                 PLIB_TEMPLATE uint16_t I2C_SlaveMask10BitGet_Default( I2C_MODULE_ID index )
121:                 {
122:                     volatile i2c_register_t *regs = (i2c_register_t *)index;
123:                 
124:                     return (uint16_t)regs->I2CxMSK;
125:                 }
126:                 
127:                 
128:                 //******************************************************************************
129:                 /* Function :  I2C_ExistsSlaveMask_Default
130:                 
131:                   Summary:
132:                     Implements Default variant of PLIB_I2C_ExistsSlaveMask
133:                 
134:                   Description:
135:                     This template implements the Default variant of the PLIB_I2C_ExistsSlaveMask function.
136:                 */
137:                 
138:                 #define PLIB_I2C_ExistsSlaveMask PLIB_I2C_ExistsSlaveMask
139:                 PLIB_TEMPLATE bool I2C_ExistsSlaveMask_Default( I2C_MODULE_ID index )
140:                 {
141:                     return true;
142:                 }
143:                 
144:                 
145:                 #endif /*_I2C_SLAVEMASK_DEFAULT_H*/
146:                 
147:                 /******************************************************************************
148:                  End of File
149:                 */
150:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/i2c/templates/i2c_SlaveDataDetect_Default.h
1:                   /*******************************************************************************
2:                     I2C Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       i2c_SlaveDataDetect_Default.h
6:                   
7:                     Summary:
8:                       I2C PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : SlaveDataDetect
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_I2C_SlaveDataIsDetected
16:                          PLIB_I2C_SlaveAddressIsDetected
17:                          PLIB_I2C_ExistsSlaveDataDetect
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _I2C_SLAVEDATADETECT_DEFAULT_H
48:                  #define _I2C_SLAVEDATADETECT_DEFAULT_H
49:                  
50:                  #include "i2c_Registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  I2C_SlaveDataIsDetected_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_I2C_SlaveDataIsDetected
57:                      Operation is atomic
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_I2C_SlaveDataIsDetected function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE bool I2C_SlaveDataIsDetected_Default( I2C_MODULE_ID index )
64:                  {
65:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
66:                  
67:                      return (bool)regs->I2CxSTAT.D_A;
9D0038C4  8E420010   LW V0, 16(S2)
9D0038C8  30420020   ANDI V0, V0, 32
9D0039BC  8E420010   LW V0, 16(S2)
9D0039C0  30420020   ANDI V0, V0, 32
68:                  }
69:                  
70:                  
71:                  //******************************************************************************
72:                  /* Function :  I2C_SlaveAddressIsDetected_Default
73:                  
74:                    Summary:
75:                      Implements Default variant of PLIB_I2C_SlaveAddressIsDetected 
76:                      Operation is atomic
77:                  
78:                    Description:
79:                      This template implements the Default variant of the PLIB_I2C_SlaveAddressIsDetected function.
80:                  */
81:                  
82:                  PLIB_TEMPLATE bool I2C_SlaveAddressIsDetected_Default( I2C_MODULE_ID index )
83:                  {
84:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
85:                  
86:                      return (bool)!regs->I2CxSTAT.D_A;
9D0037C8  8E420010   LW V0, 16(S2)
9D0037CC  30420020   ANDI V0, V0, 32
9D003830  8E420010   LW V0, 16(S2)
9D003834  30420020   ANDI V0, V0, 32
87:                  }
88:                  
89:                  
90:                  //******************************************************************************
91:                  /* Function :  I2C_ExistsSlaveDataDetect_Default
92:                  
93:                    Summary:
94:                      Implements Default variant of PLIB_I2C_ExistsSlaveDataDetect
95:                  
96:                    Description:
97:                      This template implements the Default variant of the PLIB_I2C_ExistsSlaveDataDetect function.
98:                  */
99:                  
100:                 #define PLIB_I2C_ExistsSlaveDataDetect PLIB_I2C_ExistsSlaveDataDetect
101:                 PLIB_TEMPLATE bool I2C_ExistsSlaveDataDetect_Default( I2C_MODULE_ID index )
102:                 {
103:                     return true;
104:                 }
105:                 
106:                 
107:                 #endif /*_I2C_SLAVEDATADETECT_DEFAULT_H*/
108:                 
109:                 /******************************************************************************
110:                  End of File
111:                 */
112:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/i2c/templates/i2c_SlaveClockHold_Default.h
1:                   /*******************************************************************************
2:                     I2C Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       i2c_SlaveClockHold_Default.h
6:                   
7:                     Summary:
8:                       I2C PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : SlaveClockHold
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_I2C_SlaveClockHold
16:                          PLIB_I2C_SlaveClockRelease
17:                          PLIB_I2C_ExistsSlaveClockHold
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _I2C_SLAVECLOCKHOLD_DEFAULT_H
48:                  #define _I2C_SLAVECLOCKHOLD_DEFAULT_H
49:                  
50:                  #include "i2c_Registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  I2C_SlaveClockHold_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_I2C_SlaveClockHold
57:                      Operation is atomic
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_I2C_SlaveClockHold function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE void I2C_SlaveClockHold_Default( I2C_MODULE_ID index )
64:                  {
65:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
66:                  
67:                      regs->I2CxCONCLR = I2CxCON_SCLREL_MASK;
9D003844  24021000   ADDIU V0, ZERO, 4096
9D003848  AE420004   SW V0, 4(S2)
9D0039CC  24021000   ADDIU V0, ZERO, 4096
9D0039D0  AE420004   SW V0, 4(S2)
68:                  }
69:                  
70:                  
71:                  //******************************************************************************
72:                  /* Function :  I2C_SlaveClockRelease_Default
73:                  
74:                    Summary:
75:                      Implements Default variant of PLIB_I2C_SlaveClockRelease 
76:                      Operation is atomic
77:                  
78:                    Description:
79:                      This template implements the Default variant of the PLIB_I2C_SlaveClockRelease function.
80:                  */
81:                  
82:                  PLIB_TEMPLATE void I2C_SlaveClockRelease_Default( I2C_MODULE_ID index )
83:                  {
84:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
85:                  
86:                      regs->I2CxCONSET = I2CxCON_SCLREL_MASK;
9D003810  24021000   ADDIU V0, ZERO, 4096
9D003814  AE420008   SW V0, 8(S2)
9D0038A4  24021000   ADDIU V0, ZERO, 4096
9D0038A8  AE420008   SW V0, 8(S2)
9D0038E0  24021000   ADDIU V0, ZERO, 4096
9D0038E4  AE420008   SW V0, 8(S2)
9D0039F8  24021000   ADDIU V0, ZERO, 4096
9D0039FC  AE420008   SW V0, 8(S2)
9D003FA0  24021000   ADDIU V0, ZERO, 4096
9D003FA4  AE420008   SW V0, 8(S2)
87:                  }
88:                  
89:                  
90:                  //******************************************************************************
91:                  /* Function :  I2C_ExistsSlaveClockHold_Default
92:                  
93:                    Summary:
94:                      Implements Default variant of PLIB_I2C_ExistsSlaveClockHold
95:                  
96:                    Description:
97:                      This template implements the Default variant of the PLIB_I2C_ExistsSlaveClockHold function.
98:                  */
99:                  
100:                 #define PLIB_I2C_ExistsSlaveClockHold PLIB_I2C_ExistsSlaveClockHold
101:                 PLIB_TEMPLATE bool I2C_ExistsSlaveClockHold_Default( I2C_MODULE_ID index )
102:                 {
103:                     return true;
104:                 }
105:                 
106:                 
107:                 #endif /*_I2C_SLAVECLOCKHOLD_DEFAULT_H*/
108:                 
109:                 /******************************************************************************
110:                  End of File
111:                 */
112:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/i2c/templates/i2c_SlaveAddress7Bit_Default.h
1:                   /*******************************************************************************
2:                     I2C Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       i2c_SlaveAddress7Bit_Default.h
6:                   
7:                     Summary:
8:                       I2C PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : SlaveAddress7Bit
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_I2C_SlaveAddress7BitSet
16:                          PLIB_I2C_SlaveAddress7BitGet
17:                          PLIB_I2C_ExistsSlaveAddress7Bit
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _I2C_SLAVEADDRESS7BIT_DEFAULT_H
48:                  #define _I2C_SLAVEADDRESS7BIT_DEFAULT_H
49:                  
50:                  #include "i2c_Registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  I2C_SlaveAddress7BitSet_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_I2C_SlaveAddress7BitSet 
57:                      Operation is atomic
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_I2C_SlaveAddress7BitSet function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE void I2C_SlaveAddress7BitSet_Default( I2C_MODULE_ID index , uint8_t address )
64:                  {
65:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
66:                  
67:                      regs->I2CxADD = address;
9D006260  7C423840   EXT V0, V0, 1, 8
9D006264  AE220020   SW V0, 32(S1)
68:                  
69:                      /* Configure for 7-bit address */
70:                      regs->I2CxCONCLR = I2CxCON_A10M_MASK;
9D006268  24020400   ADDIU V0, ZERO, 1024
9D00626C  AE220004   SW V0, 4(S1)
71:                  }
72:                  
73:                  
74:                  //******************************************************************************
75:                  /* Function :  I2C_SlaveAddress7BitGet_Default
76:                  
77:                    Summary:
78:                      Implements Default variant of PLIB_I2C_SlaveAddress7BitGet 
79:                      Operation is atomic
80:                  
81:                    Description:
82:                      This template implements the Default variant of the PLIB_I2C_SlaveAddress7BitGet function.
83:                  */
84:                  
85:                  PLIB_TEMPLATE uint8_t I2C_SlaveAddress7BitGet_Default( I2C_MODULE_ID index )
86:                  {
87:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
88:                  
89:                      return (uint8_t)regs->I2CxADD;
90:                  }
91:                  
92:                  
93:                  //******************************************************************************
94:                  /* Function :  I2C_ExistsSlaveAddress7Bit_Default
95:                  
96:                    Summary:
97:                      Implements Default variant of PLIB_I2C_ExistsSlaveAddress7Bit
98:                      Operation is atomic
99:                  
100:                   Description:
101:                     This template implements the Default variant of the PLIB_I2C_ExistsSlaveAddress7Bit function.
102:                 */
103:                 
104:                 #define PLIB_I2C_ExistsSlaveAddress7Bit PLIB_I2C_ExistsSlaveAddress7Bit
105:                 PLIB_TEMPLATE bool I2C_ExistsSlaveAddress7Bit_Default( I2C_MODULE_ID index )
106:                 {
107:                     return true;
108:                 }
109:                 
110:                 
111:                 #endif /*_I2C_SLAVEADDRESS7BIT_DEFAULT_H*/
112:                 
113:                 /******************************************************************************
114:                  End of File
115:                 */
116:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/i2c/templates/i2c_SlaveAddress10Bit_Default.h
1:                   /*******************************************************************************
2:                     I2C Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       i2c_SlaveAddress10Bit_Default.h
6:                   
7:                     Summary:
8:                       I2C PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : SlaveAddress10Bit
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_I2C_SlaveAddress10BitSet
16:                          PLIB_I2C_SlaveAddress10BitGet
17:                          PLIB_I2C_SlaveAddressModeIs10Bits
18:                          PLIB_I2C_ExistsSlaveAddress10Bit
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _I2C_SLAVEADDRESS10BIT_DEFAULT_H
49:                  #define _I2C_SLAVEADDRESS10BIT_DEFAULT_H
50:                  
51:                  #include "i2c_Registers.h"
52:                  
53:                  //******************************************************************************
54:                  /* Function :  I2C_SlaveAddress10BitSet_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_I2C_SlaveAddress10BitSet 
58:                      Operation is atomic
59:                  
60:                    Description:
61:                      This template implements the Default variant of the PLIB_I2C_SlaveAddress10BitSet function.
62:                  */
63:                  
64:                  PLIB_TEMPLATE void I2C_SlaveAddress10BitSet_Default( I2C_MODULE_ID index , uint16_t address )
65:                  {
66:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
67:                  
68:                      regs->I2CxADD = address;
9D006278  00021042   SRL V0, V0, 1
9D00627C  AE220020   SW V0, 32(S1)
69:                  
70:                      /* Configure for 10-bit address */
71:                      regs->I2CxCONSET = I2CxCON_A10M_MASK;
9D006280  24020400   ADDIU V0, ZERO, 1024
9D006284  AE220008   SW V0, 8(S1)
72:                  }
73:                  
74:                  
75:                  //******************************************************************************
76:                  /* Function :  I2C_SlaveAddress10BitGet_Default
77:                  
78:                    Summary:
79:                      Implements Default variant of PLIB_I2C_SlaveAddress10BitGet 
80:                      Operation is atomic
81:                  
82:                    Description:
83:                      This template implements the Default variant of the PLIB_I2C_SlaveAddress10BitGet function.
84:                  */
85:                  
86:                  PLIB_TEMPLATE uint16_t I2C_SlaveAddress10BitGet_Default( I2C_MODULE_ID index )
87:                  {
88:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
89:                  
90:                      return (uint16_t)regs->I2CxADD;
91:                  }
92:                  
93:                  
94:                  //******************************************************************************
95:                  /* Function :  I2C_SlaveAddressModeIs10Bits_Default
96:                  
97:                    Summary:
98:                      Implements Default variant of PLIB_I2C_SlaveAddressModeIs10Bits 
99:                      Operation is atomic
100:                 
101:                   Description:
102:                     This template implements the Default variant of the PLIB_I2C_SlaveAddressModeIs10Bits function.
103:                 */
104:                 
105:                 PLIB_TEMPLATE bool I2C_SlaveAddressModeIs10Bits_Default( I2C_MODULE_ID index )
106:                 {
107:                     volatile i2c_register_t *regs = (i2c_register_t *)index;
108:                     return (bool)regs->I2CxCON.A10M;
109:                 }
110:                 
111:                 
112:                 //******************************************************************************
113:                 /* Function :  I2C_ExistsSlaveAddress10Bit_Default
114:                 
115:                   Summary:
116:                     Implements Default variant of PLIB_I2C_ExistsSlaveAddress10Bit
117:                 
118:                   Description:
119:                     This template implements the Default variant of the PLIB_I2C_ExistsSlaveAddress10Bit function.
120:                 */
121:                 
122:                 #define PLIB_I2C_ExistsSlaveAddress10Bit PLIB_I2C_ExistsSlaveAddress10Bit
123:                 PLIB_TEMPLATE bool I2C_ExistsSlaveAddress10Bit_Default( I2C_MODULE_ID index )
124:                 {
125:                     return true;
126:                 }
127:                 
128:                 
129:                 #endif /*_I2C_SLAVEADDRESS10BIT_DEFAULT_H*/
130:                 
131:                 /******************************************************************************
132:                  End of File
133:                 */
134:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/i2c/templates/i2c_ReservedAddressProtect_Default.h
1:                   /*******************************************************************************
2:                     I2C Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       i2c_ReservedAddressProtect_Default.h
6:                   
7:                     Summary:
8:                       I2C PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ReservedAddressProtect
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_I2C_ReservedAddressProtectEnable
16:                          PLIB_I2C_ReservedAddressProtectDisable
17:                          PLIB_I2C_ExistsReservedAddressProtect
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _I2C_RESERVEDADDRESSPROTECT_DEFAULT_H
48:                  #define _I2C_RESERVEDADDRESSPROTECT_DEFAULT_H
49:                  
50:                  #include "i2c_Registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  I2C_ReservedAddressProtectEnable_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_I2C_ReservedAddressProtectEnable
57:                      Operation is atomic
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_I2C_ReservedAddressProtectEnable function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE void I2C_ReservedAddressProtectEnable_Default( I2C_MODULE_ID index )
64:                  {
65:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
66:                  
67:                      regs->I2CxCONSET = I2CxCON_STRICT_MASK;
9D006290  24020800   ADDIU V0, ZERO, 2048
9D006294  AE220008   SW V0, 8(S1)
9D0062A0  AE220008   SW V0, 8(S1)
68:                  }
69:                  
70:                  
71:                  //******************************************************************************
72:                  /* Function :  I2C_ReservedAddressProtectDisable_Default
73:                  
74:                    Summary:
75:                      Implements Default variant of PLIB_I2C_ReservedAddressProtectDisable 
76:                      Operation is atomic
77:                  
78:                    Description:
79:                      This template implements the Default variant of the PLIB_I2C_ReservedAddressProtectDisable function.
80:                  */
81:                  
82:                  PLIB_TEMPLATE void I2C_ReservedAddressProtectDisable_Default( I2C_MODULE_ID index )
83:                  {
84:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
85:                  
86:                      regs->I2CxCONCLR = I2CxCON_STRICT_MASK;
87:                  }
88:                  
89:                  
90:                  //******************************************************************************
91:                  /* Function :  I2C_ExistsReservedAddressProtect_Default
92:                  
93:                    Summary:
94:                      Implements Default variant of PLIB_I2C_ExistsReservedAddressProtect
95:                  
96:                    Description:
97:                      This template implements the Default variant of the PLIB_I2C_ExistsReservedAddressProtect function.
98:                  */
99:                  
100:                 #define PLIB_I2C_ExistsReservedAddressProtect PLIB_I2C_ExistsReservedAddressProtect
101:                 PLIB_TEMPLATE bool I2C_ExistsReservedAddressProtect_Default( I2C_MODULE_ID index )
102:                 {
103:                     return true;
104:                 }
105:                 
106:                 
107:                 #endif /*_I2C_RESERVEDADDRESSPROTECT_DEFAULT_H*/
108:                 
109:                 /******************************************************************************
110:                  End of File
111:                 */
112:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/i2c/templates/i2c_ReceiverOverflow_Default.h
1:                   /*******************************************************************************
2:                     I2C Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       i2c_ReceiverOverflow_Default.h
6:                   
7:                     Summary:
8:                       I2C PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ReceiverOverflow
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_I2C_ReceiverOverflowHasOccurred
16:                          PLIB_I2C_ReceiverOverflowClear
17:                          PLIB_I2C_ExistsReceiverOverflow
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _I2C_RECEIVEROVERFLOW_DEFAULT_H
48:                  #define _I2C_RECEIVEROVERFLOW_DEFAULT_H
49:                  
50:                  #include "i2c_Registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  I2C_ReceiverOverflowHasOccurred_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_I2C_ReceiverOverflowHasOccurred
57:                      Operation is atomic
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_I2C_ReceiverOverflowHasOccurred function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE bool I2C_ReceiverOverflowHasOccurred_Default( I2C_MODULE_ID index )
64:                  {
65:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
66:                  
67:                      return (bool)regs->I2CxSTAT.I2COV;
9D003EEC  8E420010   LW V0, 16(S2)
9D003EF0  30420040   ANDI V0, V0, 64
68:                  }
69:                  
70:                  
71:                  //******************************************************************************
72:                  /* Function :  I2C_ReceiverOverflowClear_Default
73:                  
74:                    Summary:
75:                      Implements Default variant of PLIB_I2C_ReceiverOverflowClear
76:                      Operation is atomic
77:                  
78:                    Description:
79:                      This template implements the Default variant of the PLIB_I2C_ReceiverOverflowClear function.
80:                  */
81:                  
82:                  PLIB_TEMPLATE void I2C_ReceiverOverflowClear_Default( I2C_MODULE_ID index )
83:                  {
84:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
85:                  
86:                      regs->I2CxSTATCLR = I2CxSTAT_I2COV_MASK;
9D003EFC  24020040   ADDIU V0, ZERO, 64
9D003F00  AE420014   SW V0, 20(S2)
87:                  }
88:                  
89:                  
90:                  //******************************************************************************
91:                  /* Function :  I2C_ExistsReceiverOverflow_Default
92:                  
93:                    Summary:
94:                      Implements Default variant of PLIB_I2C_ExistsReceiverOverflow
95:                  
96:                    Description:
97:                      This template implements the Default variant of the PLIB_I2C_ExistsReceiverOverflow function.
98:                  */
99:                  
100:                 #define PLIB_I2C_ExistsReceiverOverflow PLIB_I2C_ExistsReceiverOverflow
101:                 PLIB_TEMPLATE bool I2C_ExistsReceiverOverflow_Default( I2C_MODULE_ID index )
102:                 {
103:                     return true;
104:                 }
105:                 
106:                 
107:                 #endif /*_I2C_RECEIVEROVERFLOW_DEFAULT_H*/
108:                 
109:                 /******************************************************************************
110:                  End of File
111:                 */
112:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/i2c/templates/i2c_ReceivedByteGet_Default.h
1:                   /*******************************************************************************
2:                     I2C Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       i2c_ReceivedByteGet_Default.h
6:                   
7:                     Summary:
8:                       I2C PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ReceivedByteGet
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_I2C_ReceivedByteGet
16:                          PLIB_I2C_ExistsReceivedByteGet
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _I2C_RECEIVEDBYTEGET_DEFAULT_H
47:                  #define _I2C_RECEIVEDBYTEGET_DEFAULT_H
48:                  
49:                  #include "i2c_Registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  I2C_ReceivedByteGet_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_I2C_ReceivedByteGet
56:                      Operation is atomic
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_I2C_ReceivedByteGet function.
60:                  */
61:                  
62:                  PLIB_TEMPLATE uint8_t I2C_ReceivedByteGet_Default( I2C_MODULE_ID index )
63:                  {
64:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
65:                  
66:                      return (uint8_t)regs->I2CxRCV;
9D00380C  8E420060   LW V0, 96(S2)
9D003840  8E420060   LW V0, 96(S2)
9D003908  8E430060   LW V1, 96(S2)
9D00390C  A0430000   SB V1, 0(V0)
9D003968  8E420060   LW V0, 96(S2)
9D003BD4  8E430060   LW V1, 96(S2)
9D003BD8  A0430000   SB V1, 0(V0)
9D003C48  8E430060   LW V1, 96(S2)
9D003C4C  A0430000   SB V1, 0(V0)
67:                  }
68:                  
69:                  
70:                  //******************************************************************************
71:                  /* Function :  I2C_ExistsReceivedByteGet_Default
72:                  
73:                    Summary:
74:                      Implements Default variant of PLIB_I2C_ExistsReceivedByteGet
75:                  
76:                    Description:
77:                      This template implements the Default variant of the PLIB_I2C_ExistsReceivedByteGet function.
78:                  */
79:                  
80:                  #define PLIB_I2C_ExistsReceivedByteGet PLIB_I2C_ExistsReceivedByteGet
81:                  PLIB_TEMPLATE bool I2C_ExistsReceivedByteGet_Default( I2C_MODULE_ID index )
82:                  {
83:                      return true;
84:                  }
85:                  
86:                  
87:                  #endif /*_I2C_RECEIVEDBYTEGET_DEFAULT_H*/
88:                  
89:                  /******************************************************************************
90:                   End of File
91:                  */
92:                  
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/i2c/templates/i2c_ReceivedByteAvailable_Default.h
1:                   /*******************************************************************************
2:                     I2C Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       i2c_ReceivedByteAvailable_Default.h
6:                   
7:                     Summary:
8:                       I2C PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ReceivedByteAvailable
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_I2C_ReceivedByteIsAvailable
16:                          PLIB_I2C_ExistsReceivedByteAvailable
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _I2C_RECEIVEDBYTEAVAILABLE_DEFAULT_H
47:                  #define _I2C_RECEIVEDBYTEAVAILABLE_DEFAULT_H
48:                  
49:                  #include "i2c_Registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  I2C_ReceivedByteIsAvailable_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_I2C_ReceivedByteIsAvailable
56:                      Operation is atomic
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_I2C_ReceivedByteIsAvailable function.
60:                  */
61:                  
62:                  PLIB_TEMPLATE bool I2C_ReceivedByteIsAvailable_Default( I2C_MODULE_ID index )
63:                  {
64:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
65:                  
66:                      return (bool)regs->I2CxSTAT.RBF;
9D003BA8  8E420010   LW V0, 16(S2)
9D003BAC  30420002   ANDI V0, V0, 2
67:                  }
68:                  
69:                  
70:                  //******************************************************************************
71:                  /* Function :  I2C_ExistsReceivedByteAvailable_Default
72:                  
73:                    Summary:
74:                      Implements Default variant of PLIB_I2C_ExistsReceivedByteAvailable
75:                  
76:                    Description:
77:                      This template implements the Default variant of the PLIB_I2C_ExistsReceivedByteAvailable function.
78:                  */
79:                  
80:                  #define PLIB_I2C_ExistsReceivedByteAvailable PLIB_I2C_ExistsReceivedByteAvailable
81:                  PLIB_TEMPLATE bool I2C_ExistsReceivedByteAvailable_Default( I2C_MODULE_ID index )
82:                  {
83:                      return true;
84:                  }
85:                  
86:                  
87:                  #endif /*_I2C_RECEIVEDBYTEAVAILABLE_DEFAULT_H*/
88:                  
89:                  /******************************************************************************
90:                   End of File
91:                  */
92:                  
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/i2c/templates/i2c_ReceivedByteAcknowledge_Default.h
1:                   /*******************************************************************************
2:                     I2C Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       i2c_ReceivedByteAcknowledge_Default.h
6:                   
7:                     Summary:
8:                       I2C PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ReceivedByteAcknowledge
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_I2C_ReceivedByteAcknowledge
16:                          PLIB_I2C_ReceiverByteAcknowledgeHasCompleted
17:                          PLIB_I2C_MasterReceiverReadyToAcknowledge
18:                          PLIB_I2C_ExistsReceivedByteAcknowledge
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _I2C_RECEIVEDBYTEACKNOWLEDGE_DEFAULT_H
49:                  #define _I2C_RECEIVEDBYTEACKNOWLEDGE_DEFAULT_H
50:                  
51:                  #include "i2c_Registers.h"
52:                  
53:                  //******************************************************************************
54:                  /* Function :  I2C_ReceivedByteAcknowledge_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_I2C_ReceivedByteAcknowledge 
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_I2C_ReceivedByteAcknowledge function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE void I2C_ReceivedByteAcknowledge_Default( I2C_MODULE_ID index , bool ack )
64:                  {
65:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
66:                  
67:                      if (ack) {
68:                  	/* Clearing this bit will positively acknowledge */
69:                  	regs->I2CxCONCLR = I2CxCON_ACKDT_MASK;
9D003C14  24020020   ADDIU V0, ZERO, 32
9D003C18  AE420004   SW V0, 4(S2)
70:                  	regs->I2CxCONSET = I2CxCON_ACKEN_MASK;
9D003C1C  24020010   ADDIU V0, ZERO, 16
9D003C20  AE420008   SW V0, 8(S2)
71:                      } else {
72:                  	regs->I2CxCONSET = I2CxCON_ACKDT_MASK | I2CxCON_ACKEN_MASK;
9D003C68  24020030   ADDIU V0, ZERO, 48
9D003C6C  AE420008   SW V0, 8(S2)
73:                      }
74:                  }
75:                  
76:                  
77:                  //******************************************************************************
78:                  /* Function :  I2C_ReceiverByteAcknowledgeHasCompleted_Default
79:                  
80:                    Summary:
81:                      Implements Default variant of PLIB_I2C_ReceiverByteAcknowledgeHasCompleted
82:                      Operation is atomic
83:                  
84:                    Description:
85:                      This template implements the Default variant of the PLIB_I2C_ReceiverByteAcknowledgeHasCompleted function.
86:                  */
87:                  
88:                  PLIB_TEMPLATE bool I2C_ReceiverByteAcknowledgeHasCompleted_Default( I2C_MODULE_ID index )
89:                  {
90:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
91:                      return (bool)!regs->I2CxCON.ACKEN;
9D003E1C  8E420000   LW V0, 0(S2)
9D003E20  30420010   ANDI V0, V0, 16
92:                  }
93:                  
94:                  
95:                  //******************************************************************************
96:                  /* Function :  I2C_MasterReceiverReadyToAcknowledge_Default
97:                  
98:                    Summary:
99:                      Implements Default variant of PLIB_I2C_MasterReceiverReadyToAcknowledge
100:                     Operation is atomic
101:                 
102:                   Description:
103:                     This template implements the Default variant of the PLIB_I2C_MasterReceiverReadyToAcknowledge function.
104:                 */
105:                 
106:                 PLIB_TEMPLATE bool I2C_MasterReceiverReadyToAcknowledge_Default( I2C_MODULE_ID index )
107:                 {
108:                     volatile i2c_register_t *regs = (i2c_register_t *)index;
109:                     volatile uint32_t *i2c_ctrl_reg = (volatile uint32_t *)&regs->I2CxCON;
110:                 
111:                     /* It is not okay to acknowledge if the last five bits in the I2CCON register is high */
112:                     return (bool)!(*i2c_ctrl_reg & I2C_BUS_IDLE_BITS);
9D003BFC  8E420000   LW V0, 0(S2)
9D003C00  3042001F   ANDI V0, V0, 31
9D003C50  8E420000   LW V0, 0(S2)
9D003C54  3042001F   ANDI V0, V0, 31
113:                 }
114:                 
115:                 
116:                 //******************************************************************************
117:                 /* Function :  I2C_ExistsReceivedByteAcknowledge_Default
118:                 
119:                   Summary:
120:                     Implements Default variant of PLIB_I2C_ExistsReceivedByteAcknowledge
121:                 
122:                   Description:
123:                     This template implements the Default variant of the PLIB_I2C_ExistsReceivedByteAcknowledge function.
124:                 */
125:                 
126:                 #define PLIB_I2C_ExistsReceivedByteAcknowledge PLIB_I2C_ExistsReceivedByteAcknowledge
127:                 PLIB_TEMPLATE bool I2C_ExistsReceivedByteAcknowledge_Default( I2C_MODULE_ID index )
128:                 {
129:                     return true;
130:                 }
131:                 
132:                 
133:                 #endif /*_I2C_RECEIVEDBYTEACKNOWLEDGE_DEFAULT_H*/
134:                 
135:                 /******************************************************************************
136:                  End of File
137:                 */
138:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/i2c/templates/i2c_ModuleEnable_Default.h
1:                   /*******************************************************************************
2:                     I2C Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       i2c_ModuleEnable_Default.h
6:                   
7:                     Summary:
8:                       I2C PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ModuleEnable
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_I2C_Enable
16:                          PLIB_I2C_Disable
17:                          PLIB_I2C_ExistsModuleEnable
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _I2C_MODULEENABLE_DEFAULT_H
48:                  #define _I2C_MODULEENABLE_DEFAULT_H
49:                  
50:                  #include "i2c_Registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  I2C_Enable_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_I2C_Enable
57:                      Operation is atomic
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_I2C_Enable function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE void I2C_Enable_Default( I2C_MODULE_ID index )
64:                  {
65:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
66:                      regs->I2CxCONSET = I2CxCON_ON_MASK;
9D0063F0  34028000   ORI V0, ZERO, -32768
9D0063F4  AE220008   SW V0, 8(S1)
67:                  }
68:                  
69:                  
70:                  //******************************************************************************
71:                  /* Function :  I2C_Disable_Default
72:                  
73:                    Summary:
74:                      Implements Default variant of PLIB_I2C_Disable 
75:                      Operation is atomic
76:                  
77:                    Description:
78:                      This template implements the Default variant of the PLIB_I2C_Disable function.
79:                  */
80:                  
81:                  PLIB_TEMPLATE void I2C_Disable_Default( I2C_MODULE_ID index )
82:                  {
83:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
84:                      regs->I2CxCONCLR = I2CxCON_ON_MASK;
85:                  }
86:                  
87:                  
88:                  //******************************************************************************
89:                  /* Function :  I2C_ExistsModuleEnable_Default
90:                  
91:                    Summary:
92:                      Implements Default variant of PLIB_I2C_ExistsModuleEnable
93:                  
94:                    Description:
95:                      This template implements the Default variant of the PLIB_I2C_ExistsModuleEnable function.
96:                  */
97:                  
98:                  #define PLIB_I2C_ExistsModuleEnable PLIB_I2C_ExistsModuleEnable
99:                  PLIB_TEMPLATE bool I2C_ExistsModuleEnable_Default( I2C_MODULE_ID index )
100:                 {
101:                     return true;
102:                 }
103:                 
104:                 
105:                 #endif /*_I2C_MODULEENABLE_DEFAULT_H*/
106:                 
107:                 /******************************************************************************
108:                  End of File
109:                 */
110:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/i2c/templates/i2c_MasterStop_Default.h
1:                   /*******************************************************************************
2:                     I2C Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       i2c_MasterStop_Default.h
6:                   
7:                     Summary:
8:                       I2C PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : MasterStop
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_I2C_MasterStop
16:                          PLIB_I2C_ExistsMasterStop
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _I2C_MASTERSTOP_DEFAULT_H
47:                  #define _I2C_MASTERSTOP_DEFAULT_H
48:                  
49:                  #include "i2c_Registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  I2C_MasterStop_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_I2C_MasterStop
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_I2C_MasterStop function.
59:                  */
60:                  
61:                  PLIB_TEMPLATE void I2C_MasterStop_Default( I2C_MODULE_ID index )
62:                  {
63:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
64:                  
65:                      regs->I2CxCONSET = I2CxCON_PEN_MASK;
9D003D30  24020004   ADDIU V0, ZERO, 4
9D003D34  AE420008   SW V0, 8(S2)
9D003D44  24020004   ADDIU V0, ZERO, 4
9D003D48  AE420008   SW V0, 8(S2)
9D003DEC  24020004   ADDIU V0, ZERO, 4
9D003DF0  AE420008   SW V0, 8(S2)
9D003E44  24020004   ADDIU V0, ZERO, 4
9D003E48  AE420008   SW V0, 8(S2)
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  I2C_ExistsMasterStop_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_I2C_ExistsMasterStop
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_I2C_ExistsMasterStop function.
77:                  */
78:                  
79:                  #define PLIB_I2C_ExistsMasterStop PLIB_I2C_ExistsMasterStop
80:                  PLIB_TEMPLATE bool I2C_ExistsMasterStop_Default( I2C_MODULE_ID index )
81:                  {
82:                      return true;
83:                  }
84:                  
85:                  
86:                  #endif /*_I2C_MASTERSTOP_DEFAULT_H*/
87:                  
88:                  /******************************************************************************
89:                   End of File
90:                  */
91:                  
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/i2c/templates/i2c_MasterStart_Default.h
1:                   /*******************************************************************************
2:                     I2C Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       i2c_MasterStart_Default.h
6:                   
7:                     Summary:
8:                       I2C PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : MasterStart
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_I2C_MasterStart
16:                          PLIB_I2C_ExistsMasterStart
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _I2C_MASTERSTART_DEFAULT_H
47:                  #define _I2C_MASTERSTART_DEFAULT_H
48:                  
49:                  #include "i2c_Registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  I2C_MasterStart_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_I2C_MasterStart 
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_I2C_MasterStart function.
59:                  */
60:                  
61:                  PLIB_TEMPLATE void I2C_MasterStart_Default( I2C_MODULE_ID index )
62:                  {
63:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
9D009B28  8E230004   LW V1, 4(S1)
9D009EFC  8E230004   LW V1, 4(S1)
64:                  
65:                      regs->I2CxCONSET = I2CxCON_SEN_MASK;
9D004048  24030001   ADDIU V1, ZERO, 1
9D00404C  AC430008   SW V1, 8(V0)
9D009B2C  AC620008   SW V0, 8(V1)
9D009F00  AC620008   SW V0, 8(V1)
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  I2C_ExistsMasterStart_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_I2C_ExistsMasterStart
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_I2C_ExistsMasterStart function.
77:                  */
78:                  
79:                  #define PLIB_I2C_ExistsMasterStart PLIB_I2C_ExistsMasterStart
80:                  PLIB_TEMPLATE bool I2C_ExistsMasterStart_Default( I2C_MODULE_ID index )
81:                  {
82:                      return true;
83:                  }
84:                  
85:                  
86:                  #endif /*_I2C_MASTERSTART_DEFAULT_H*/
87:                  
88:                  /******************************************************************************
89:                   End of File
90:                  */
91:                  
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/i2c/templates/i2c_MasterStartRepeat_Default.h
1:                   /*******************************************************************************
2:                     I2C Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       i2c_MasterStartRepeat_Default.h
6:                   
7:                     Summary:
8:                       I2C PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations (atomic)
12:                      For Feature : MasterStartRepeat
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_I2C_MasterStartRepeat
16:                          PLIB_I2C_ExistsMasterStartRepeat
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _I2C_MASTERSTARTREPEAT_DEFAULT_H
47:                  #define _I2C_MASTERSTARTREPEAT_DEFAULT_H
48:                  
49:                  #include "i2c_Registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  I2C_MasterStartRepeat_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_I2C_MasterStartRepeat.
56:                      This operation is atomic.
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_I2C_MasterStartRepeat function.
60:                  */
61:                  
62:                  PLIB_TEMPLATE void I2C_MasterStartRepeat_Default( I2C_MODULE_ID index )
63:                  {
64:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
9D003DD4  8E020004   LW V0, 4(S0)
65:                  
66:                      regs->I2CxCONSET = I2CxCON_RSEN_MASK;
9D003DD8  24030002   ADDIU V1, ZERO, 2
9D003DDC  AC430008   SW V1, 8(V0)
67:                  }
68:                  
69:                  
70:                  //******************************************************************************
71:                  /* Function :  I2C_ExistsMasterStartRepeat_Default
72:                  
73:                    Summary:
74:                      Implements Default variant of PLIB_I2C_ExistsMasterStartRepeat
75:                  
76:                    Description:
77:                      This template implements the Default variant of the PLIB_I2C_ExistsMasterStartRepeat function.
78:                  */
79:                  
80:                  #define PLIB_I2C_ExistsMasterStartRepeat PLIB_I2C_ExistsMasterStartRepeat
81:                  PLIB_TEMPLATE bool I2C_ExistsMasterStartRepeat_Default( I2C_MODULE_ID index )
82:                  {
83:                      return true;
84:                  }
85:                  
86:                  
87:                  #endif /*_I2C_MASTERSTARTREPEAT_DEFAULT_H*/
88:                  
89:                  /******************************************************************************
90:                   End of File
91:                  */
92:                  
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/i2c/templates/i2c_MasterReceiverClock1Byte_Default.h
1:                   /*******************************************************************************
2:                     I2C Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       i2c_MasterReceiverClock1Byte_Default.h
6:                   
7:                     Summary:
8:                       I2C PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : MasterReceiverClock1Byte
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_I2C_MasterReceiverClock1Byte
16:                          PLIB_I2C_ExistsMasterReceiverClock1Byte
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _I2C_MASTERRECEIVERCLOCK1BYTE_DEFAULT_H
47:                  #define _I2C_MASTERRECEIVERCLOCK1BYTE_DEFAULT_H
48:                  
49:                  #include "i2c_Registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  I2C_MasterReceiverClock1Byte_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_I2C_MasterReceiverClock1Byte
56:                      Operation is atomic
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_I2C_MasterReceiverClock1Byte function.
60:                  */
61:                  
62:                  PLIB_TEMPLATE void I2C_MasterReceiverClock1Byte_Default( I2C_MODULE_ID index )
63:                  {
64:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
65:                  
66:                      regs->I2CxCONSET = I2CxCON_RCEN_MASK;
9D003E2C  24020008   ADDIU V0, ZERO, 8
9D003E30  AE420008   SW V0, 8(S2)
67:                  }
68:                  
69:                  
70:                  //******************************************************************************
71:                  /* Function :  I2C_ExistsMasterReceiverClock1Byte_Default
72:                  
73:                    Summary:
74:                      Implements Default variant of PLIB_I2C_ExistsMasterReceiverClock1Byte
75:                  
76:                    Description:
77:                      This template implements the Default variant of the PLIB_I2C_ExistsMasterReceiverClock1Byte function.
78:                  */
79:                  
80:                  #define PLIB_I2C_ExistsMasterReceiverClock1Byte PLIB_I2C_ExistsMasterReceiverClock1Byte
81:                  PLIB_TEMPLATE bool I2C_ExistsMasterReceiverClock1Byte_Default( I2C_MODULE_ID index )
82:                  {
83:                      return true;
84:                  }
85:                  
86:                  
87:                  #endif /*_I2C_MASTERRECEIVERCLOCK1BYTE_DEFAULT_H*/
88:                  
89:                  /******************************************************************************
90:                   End of File
91:                  */
92:                  
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/i2c/templates/i2c_HighFrequency_Default.h
1:                   /*******************************************************************************
2:                     I2C Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       i2c_HighFrequency_Default.h
6:                   
7:                     Summary:
8:                       I2C PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : HighFrequency
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_I2C_HighFrequencyEnable
16:                          PLIB_I2C_HighFrequencyDisable
17:                          PLIB_I2C_ExistsHighFrequency
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _I2C_HIGHFREQUENCY_DEFAULT_H
48:                  #define _I2C_HIGHFREQUENCY_DEFAULT_H
49:                  
50:                  #include "i2c_Registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  I2C_HighFrequencyEnable_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_I2C_HighFrequencyEnable 
57:                      Operation is atomic
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_I2C_HighFrequencyEnable function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE void I2C_HighFrequencyEnable_Default( I2C_MODULE_ID index )
64:                  {
65:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
66:                  
67:                      regs->I2CxCONSET = I2CxCON_DISSLW_MASK;
9D00621C  AE220008   SW V0, 8(S1)
68:                  }
69:                  
70:                  
71:                  //******************************************************************************
72:                  /* Function :  I2C_HighFrequencyDisable_Default
73:                  
74:                    Summary:
75:                      Implements Default variant of PLIB_I2C_HighFrequencyDisable 
76:                  
77:                    Description:
78:                      This template implements the Default variant of the PLIB_I2C_HighFrequencyDisable function.
79:                  */
80:                  
81:                  PLIB_TEMPLATE void I2C_HighFrequencyDisable_Default( I2C_MODULE_ID index )
82:                  {
83:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
84:                  
85:                      regs->I2CxCONCLR = I2CxCON_DISSLW_MASK;
9D006228  AE220004   SW V0, 4(S1)
86:                  }
87:                  
88:                  
89:                  //******************************************************************************
90:                  /* Function :  I2C_ExistsHighFrequency_Default
91:                  
92:                    Summary:
93:                      Implements Default variant of PLIB_I2C_ExistsHighFrequency
94:                  
95:                    Description:
96:                      This template implements the Default variant of the PLIB_I2C_ExistsHighFrequency function.
97:                  */
98:                  
99:                  #define PLIB_I2C_ExistsHighFrequency PLIB_I2C_ExistsHighFrequency
100:                 PLIB_TEMPLATE bool I2C_ExistsHighFrequency_Default( I2C_MODULE_ID index )
101:                 {
102:                     return true;
103:                 }
104:                 
105:                 
106:                 #endif /*_I2C_HIGHFREQUENCY_DEFAULT_H*/
107:                 
108:                 /******************************************************************************
109:                  End of File
110:                 */
111:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/i2c/templates/i2c_GeneralCall_Default.h
1:                   /*******************************************************************************
2:                     I2C Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       i2c_GeneralCall_Default.h
6:                   
7:                     Summary:
8:                       I2C PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : GeneralCall
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_I2C_GeneralCallEnable
16:                          PLIB_I2C_GeneralCallDisable
17:                          PLIB_I2C_ExistsGeneralCall
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _I2C_GENERALCALL_DEFAULT_H
48:                  #define _I2C_GENERALCALL_DEFAULT_H
49:                  
50:                  #include "i2c_Registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  I2C_GeneralCallEnable_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_I2C_GeneralCallEnable
57:                      Operation is atomic.
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_I2C_GeneralCallEnable function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE void I2C_GeneralCallEnable_Default( I2C_MODULE_ID index )
64:                  {
65:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
66:                  
67:                      regs->I2CxCONSET = I2CxCON_GCEN_MASK;
68:                  }
69:                  
70:                  
71:                  //******************************************************************************
72:                  /* Function :  I2C_GeneralCallDisable_Default
73:                  
74:                    Summary:
75:                      Implements Default variant of PLIB_I2C_GeneralCallDisable 
76:                      Operation is atomic.
77:                  
78:                    Description:
79:                      This template implements the Default variant of the PLIB_I2C_GeneralCallDisable function.
80:                  */
81:                  
82:                  PLIB_TEMPLATE void I2C_GeneralCallDisable_Default( I2C_MODULE_ID index )
83:                  {
84:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
85:                  
86:                      regs->I2CxCONCLR = I2CxCON_GCEN_MASK;
9D006298  24030080   ADDIU V1, ZERO, 128
9D00629C  AE230004   SW V1, 4(S1)
87:                  }
88:                  
89:                  
90:                  //******************************************************************************
91:                  /* Function :  I2C_ExistsGeneralCall_Default
92:                  
93:                    Summary:
94:                      Implements Default variant of PLIB_I2C_ExistsGeneralCall
95:                  
96:                    Description:
97:                      This template implements the Default variant of the PLIB_I2C_ExistsGeneralCall function.
98:                  */
99:                  
100:                 #define PLIB_I2C_ExistsGeneralCall PLIB_I2C_ExistsGeneralCall
101:                 PLIB_TEMPLATE bool I2C_ExistsGeneralCall_Default( I2C_MODULE_ID index )
102:                 {
103:                     return true;
104:                 }
105:                 
106:                 
107:                 #endif /*_I2C_GENERALCALL_DEFAULT_H*/
108:                 
109:                 /******************************************************************************
110:                  End of File
111:                 */
112:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/i2c/templates/i2c_ClockStretching_Default.h
1:                   /*******************************************************************************
2:                     I2C Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       i2c_ClockStretching_Default.h
6:                   
7:                     Summary:
8:                       I2C PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ClockStretching
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_I2C_SlaveClockStretchingEnable
16:                          PLIB_I2C_SlaveClockStretchingDisable
17:                          PLIB_I2C_ExistsClockStretching
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _I2C_CLOCKSTRETCHING_DEFAULT_H
48:                  #define _I2C_CLOCKSTRETCHING_DEFAULT_H
49:                  
50:                  #include "i2c_Registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  I2C_SlaveClockStretchingEnable_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_I2C_SlaveClockStretchingEnable 
57:                      Operation is atomic
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_I2C_SlaveClockStretchingEnable function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE void I2C_SlaveClockStretchingEnable_Default( I2C_MODULE_ID index )
64:                  {
65:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
66:                  
67:                      regs->I2CxCONSET = I2CxCON_STREN_MASK;
9D006270  0B4018A3   J 0x9D00628C
9D006274  24020040   ADDIU V0, ZERO, 64
9D006288  24020040   ADDIU V0, ZERO, 64
9D00628C  AE220008   SW V0, 8(S1)
68:                  }
69:                  
70:                  
71:                  //******************************************************************************
72:                  /* Function :  I2C_SlaveClockStretchingDisable_Default
73:                  
74:                    Summary:
75:                      Implements Default variant of PLIB_I2C_SlaveClockStretchingDisable 
76:                      Operation is atomic
77:                  
78:                    Description:
79:                      This template implements the Default variant of the PLIB_I2C_SlaveClockStretchingDisable function.
80:                  */
81:                  
82:                  PLIB_TEMPLATE void I2C_SlaveClockStretchingDisable_Default( I2C_MODULE_ID index )
83:                  {
84:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
85:                  
86:                      regs->I2CxCONCLR = I2CxCON_STREN_MASK;
87:                  }
88:                  
89:                  
90:                  //******************************************************************************
91:                  /* Function :  I2C_ExistsClockStretching_Default
92:                  
93:                    Summary:
94:                      Implements Default variant of PLIB_I2C_ExistsClockStretching
95:                  
96:                    Description:
97:                      This template implements the Default variant of the PLIB_I2C_ExistsClockStretching function.
98:                  */
99:                  
100:                 #define PLIB_I2C_ExistsClockStretching PLIB_I2C_ExistsClockStretching
101:                 PLIB_TEMPLATE bool I2C_ExistsClockStretching_Default( I2C_MODULE_ID index )
102:                 {
103:                     return true;
104:                 }
105:                 
106:                 
107:                 #endif /*_I2C_CLOCKSTRETCHING_DEFAULT_H*/
108:                 
109:                 /******************************************************************************
110:                  End of File
111:                 */
112:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/i2c/templates/i2c_BusIdle_Default.h  -
1:                   /*******************************************************************************
2:                     I2C Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       i2c_BusIdle_Default.h
6:                   
7:                     Summary:
8:                       I2C PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : BusIdle
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_I2C_BusIsIdle
16:                          PLIB_I2C_ExistsBusIsIdle
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _I2C_BUSIDLE_DEFAULT_H
47:                  #define _I2C_BUSIDLE_DEFAULT_H
48:                  
49:                  #include "i2c_Registers.h"
50:                  
51:                  // *****************************************************************************
52:                  /* I2C bus idle status bits
53:                  
54:                    Summary:
55:                      Creates a mask for i2c bus idle status bits.
56:                  
57:                    Description:
58:                      This macro defines a mask for bus idle bits in the i2c control register.
59:                  
60:                    Remarks:
61:                      None
62:                  */
63:                  
64:                  #define I2C_BUS_IDLE_BITS						0x1F
65:                  
66:                  //******************************************************************************
67:                  /* Function :  I2C_BusIsIdle_Default
68:                  
69:                    Summary:
70:                      Implements Default variant of PLIB_I2C_BusIsIdle
71:                      Operation is atomic
72:                  
73:                    Description:
74:                      This template implements the Default variant of the PLIB_I2C_BusIsIdle function.
75:                  */
76:                  
77:                  PLIB_TEMPLATE bool I2C_BusIsIdle_Default( I2C_MODULE_ID index )
78:                  {
79:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
9D004024  8E020004   LW V0, 4(S0)
80:                      volatile uint32_t *i2c_ctrl_reg = (volatile uint32_t *)&regs->I2CxCON;
81:                  
82:                      return (bool)!((*i2c_ctrl_reg & I2C_BUS_IDLE_BITS) || regs->I2CxSTAT.TRSTAT);
9D004028  8C430000   LW V1, 0(V0)
9D00402C  3063001F   ANDI V1, V1, 31
9D004030  1460000A   BNE V1, ZERO, 0x9D00405C
9D004034  8FB20018   LW S2, 24(SP)
9D004038  8C430010   LW V1, 16(V0)
9D00403C  30634000   ANDI V1, V1, 16384
9D004040  14600007   BNE V1, ZERO, 0x9D004060
9D004044  8FB10014   LW S1, 20(SP)
9D009AD0  8C430000   LW V1, 0(V0)
9D009AD4  3063001F   ANDI V1, V1, 31
9D009AD8  54600037   BNEL V1, ZERO, 0x9D009BB8
9D009ADC  02001021   ADDU V0, S0, ZERO
9D009AE0  8C420010   LW V0, 16(V0)
9D009AE4  30424000   ANDI V0, V0, 16384
9D009AE8  50400027   BEQL V0, ZERO, DRV_I2C_TransmitThenReceive::PLIB_INT_SourceFlagGet
9D009AEC  8E230034   LW V1, 52(S1)
9D009EA4  8C430000   LW V1, 0(V0)
9D009EA8  3063001F   ANDI V1, V1, 31
9D009EAC  54600037   BNEL V1, ZERO, 0x9D009F8C
9D009EB0  02001021   ADDU V0, S0, ZERO
9D009EB4  8C420010   LW V0, 16(V0)
9D009EB8  30424000   ANDI V0, V0, 16384
9D009EBC  50400027   BEQL V0, ZERO, DRV_I2C_Transmit::PLIB_INT_SourceFlagGet
9D009EC0  8E230034   LW V1, 52(S1)
83:                  }
84:                  
85:                  
86:                  //******************************************************************************
87:                  /* Function :  I2C_ExistsBusIsIdle_Default
88:                  
89:                    Summary:
90:                      Implements Default variant of PLIB_I2C_ExistsBusIsIdle
91:                  
92:                    Description:
93:                      This template implements the Default variant of the PLIB_I2C_ExistsBusIsIdle function.
94:                  */
95:                  
96:                  #define PLIB_I2C_ExistsBusIsIdle PLIB_I2C_ExistsBusIsIdle
97:                  PLIB_TEMPLATE bool I2C_ExistsBusIsIdle_Default( I2C_MODULE_ID index )
98:                  {
99:                      return true;
100:                 }
101:                 
102:                 
103:                 #endif /*_I2C_BUSIDLE_DEFAULT_H*/
104:                 
105:                 /******************************************************************************
106:                  End of File
107:                 */
108:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/i2c/templates/i2c_BaudRate_Default.h  
1:                   /*******************************************************************************
2:                     I2C Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       i2c_BaudRate_Default.h
6:                   
7:                     Summary:
8:                       I2C PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : BaudRate
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_I2C_BaudRateSet
16:                          PLIB_I2C_BaudRateGet
17:                          PLIB_I2C_ExistsBaudRate
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _I2C_BAUDRATE_DEFAULT_H
48:                  #define _I2C_BAUDRATE_DEFAULT_H
49:                  
50:                  #include "i2c_Registers.h"
51:                  
52:                  // *****************************************************************************
53:                  /* Pulse gobbler delay
54:                  
55:                    Summary:
56:                      Defines the Pulse gobbler delay in micro seconds.
57:                  
58:                    Description:
59:                      This macro defines the Pulse gobbler delay in micro seconds.
60:                  
61:                    Remarks:
62:                      None
63:                  */
64:                  
65:                  #define PULSE_GOBBLER_DELAY						0.104f
66:                  
67:                  //******************************************************************************
68:                  /* Function :  I2C_BaudRateSet_Default
69:                  
70:                    Summary:
71:                      Implements Default variant of PLIB_I2C_BaudRateSet
72:                      Operation is atomic.
73:                  
74:                    Description:
75:                      This template implements the Default variant of the PLIB_I2C_BaudRateSet function.
76:                  */
77:                  
78:                  PLIB_TEMPLATE void I2C_BaudRateSet_Default( I2C_MODULE_ID index , uint32_t clockFrequency , I2C_BAUD_RATE baudRate )
79:                  {
80:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
81:                  
82:                      regs->I2CxBRG = (clockFrequency / baudRate / 2) - (clockFrequency / 10000000) - 2;
9D0061B8  8E030028   LW V1, 40(S0)
9D0061BC  0043001B   DIVU V0, V1
9D0061C0  006001F4   TEQ V1, ZERO
9D0061C4  00001812   MFLO V1
9D0061C8  00031842   SRL V1, V1, 1
9D0061CC  3C046B5F   LUI A0, 27487
9D0061D0  3484CA6B   ORI A0, A0, -13717
9D0061D4  00440019   MULTU 0, V0, A0
9D0061D8  00001010   MFHI V0
9D0061DC  00021582   SRL V0, V0, 22
9D0061E0  00621023   SUBU V0, V1, V0
9D0061E4  2442FFFE   ADDIU V0, V0, -2
9D0061E8  AE220040   SW V0, 64(S1)
83:                  }
84:                  
85:                  
86:                  //******************************************************************************
87:                  /* Function :  I2C_BaudRateGet_Default
88:                  
89:                    Summary:
90:                      Implements Default variant of PLIB_I2C_BaudRateGet
91:                      Operation is atomic
92:                  
93:                    Description:
94:                      This template implements the Default variant of the PLIB_I2C_BaudRateGet function.
95:                  */
96:                  
97:                  PLIB_TEMPLATE I2C_BAUD_RATE I2C_BaudRateGet_Default( I2C_MODULE_ID index , uint32_t clockFrequency )
98:                  {
99:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
100:                     uint32_t div = regs->I2CxBRG;
101:                 
102:                     return (clockFrequency / ((div + 2) + (clockFrequency / 10000000))) >> 1;
103:                 }
104:                 
105:                 
106:                 //******************************************************************************
107:                 /* Function :  I2C_ExistsBaudRate_Default
108:                 
109:                   Summary:
110:                     Implements Default variant of PLIB_I2C_ExistsBaudRate
111:                 
112:                   Description:
113:                     This template implements the Default variant of the PLIB_I2C_ExistsBaudRate function.
114:                 */
115:                 
116:                 #define PLIB_I2C_ExistsBaudRate PLIB_I2C_ExistsBaudRate
117:                 PLIB_TEMPLATE bool I2C_ExistsBaudRate_Default( I2C_MODULE_ID index )
118:                 {
119:                     return true;
120:                 }
121:                 
122:                 
123:                 #endif /*_I2C_BAUDRATE_DEFAULT_H*/
124:                 
125:                 /******************************************************************************
126:                  End of File
127:                 */
128:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/dma/templates/dma_EnableControl_Default.h
1:                   /*******************************************************************************
2:                     DMA Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       dma_EnableControl_Default.h
6:                   
7:                     Summary:
8:                       DMA PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : EnableControl
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_DMA_ExistsEnableControl
16:                          PLIB_DMA_Enable
17:                          PLIB_DMA_Disable
18:                          PLIB_DMA_IsEnabled
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _DMA_ENABLECONTROL_DEFAULT_H
49:                  #define _DMA_ENABLECONTROL_DEFAULT_H
50:                  
51:                  #include "dma_Registers.h"
52:                  
53:                  //******************************************************************************
54:                  /* Function :  DMA_ExistsEnableControl_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_DMA_ExistsEnableControl
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_DMA_ExistsEnableControl function.
61:                  */
62:                  
63:                  #define PLIB_DMA_ExistsEnableControl PLIB_DMA_ExistsEnableControl
64:                  PLIB_TEMPLATE bool DMA_ExistsEnableControl_Default( DMA_MODULE_ID index )
65:                  {
66:                      return true;
67:                  }
68:                  
69:                  
70:                  //******************************************************************************
71:                  /* Function :  DMA_Enable_Default
72:                  
73:                    Summary:
74:                      Implements Default variant of PLIB_DMA_Enable
75:                  
76:                    Description:
77:                      This template implements the Default variant of the PLIB_DMA_Enable function.
78:                      Operation is atomic.
79:                  */
80:                  
81:                  PLIB_TEMPLATE void DMA_Enable_Default( DMA_MODULE_ID index )
82:                  {
83:                      volatile dma_register_t *regs = (dma_register_t *)index;
84:                  
85:                      regs->DMACONSET = _DMACON_ON_MASK;
9D013494  34038000   ORI V1, ZERO, -32768
9D013498  ACA33008   SW V1, 12296(A1)
9D01349C  24A53060   ADDIU A1, A1, 12384
9D0134A0  00003021   ADDU A2, ZERO, ZERO
86:                  }
87:                  
88:                  
89:                  //******************************************************************************
90:                  /* Function :  DMA_Disable_Default
91:                  
92:                    Summary:
93:                      Implements Default variant of PLIB_DMA_Disable
94:                  
95:                    Description:
96:                      This template implements the Default variant of the PLIB_DMA_Disable function.
97:                      Operation is atomic.
98:                  */
99:                  
100:                 PLIB_TEMPLATE void DMA_Disable_Default( DMA_MODULE_ID index )
101:                 {
102:                     volatile dma_register_t *regs = (dma_register_t *)index;
103:                 
104:                     regs->DMACONCLR = _DMACON_ON_MASK;
105:                 }
106:                 
107:                 
108:                 //******************************************************************************
109:                 /* Function :  DMA_IsEnabled_Default
110:                 
111:                   Summary:
112:                     Implements Default variant of PLIB_DMA_IsEnabled
113:                 
114:                   Description:
115:                     This template implements the Default variant of the PLIB_DMA_IsEnabled function.
116:                     Operation is atomic.
117:                 */
118:                 
119:                 PLIB_TEMPLATE bool DMA_IsEnabled_Default( DMA_MODULE_ID index )
120:                 {
121:                     volatile dma_register_t *regs = (dma_register_t *)index;
122:                 
123:                     return (bool)regs->DMACON.ON;
124:                 }
125:                 
126:                 
127:                 #endif /*_DMA_ENABLECONTROL_DEFAULT_H*/
128:                 
129:                 /******************************************************************************
130:                  End of File
131:                 */
132:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/dma/templates/dma_Crc_Default.h  -----
1:                   /*******************************************************************************
2:                     DMA Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       dma_Crc_Default.h
6:                   
7:                     Summary:
8:                       DMA PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : Crc
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_DMA_ExistsCRC
16:                          PLIB_DMA_CRCEnable
17:                          PLIB_DMA_CRCDisable
18:                          PLIB_DMA_CRCIsEnabled
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _DMA_CRC_DEFAULT_H
49:                  #define _DMA_CRC_DEFAULT_H
50:                  
51:                  #include "dma_Registers.h"
52:                  
53:                  //******************************************************************************
54:                  /* Function :  DMA_ExistsCRC_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_DMA_ExistsCRC
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_DMA_ExistsCRC function.
61:                  */
62:                  
63:                  #define PLIB_DMA_ExistsCRC PLIB_DMA_ExistsCRC
64:                  PLIB_TEMPLATE bool DMA_ExistsCRC_Default( DMA_MODULE_ID index )
65:                  {
66:                      return true;
67:                  }
68:                  
69:                  
70:                  //******************************************************************************
71:                  /* Function :  DMA_CRCEnable_Default
72:                  
73:                    Summary:
74:                      Implements Default variant of PLIB_DMA_CRCEnable
75:                  
76:                    Description:
77:                      This template implements the Default variant of the PLIB_DMA_CRCEnable function.
78:                      Operation is atomic.
79:                  */
80:                  
81:                  PLIB_TEMPLATE void DMA_CRCEnable_Default( DMA_MODULE_ID index )
82:                  {
83:                      volatile dma_register_t *regs = (dma_register_t *)index;
84:                  
85:                      regs->DCRCCONSET = _DCRCCON_CRCEN_MASK;
9D00D07C  24030080   ADDIU V1, ZERO, 128
9D00D080  3C02BF88   LUI V0, -16504
9D00D084  AC433038   SW V1, 12344(V0)
86:                  }
87:                  
88:                  
89:                  //******************************************************************************
90:                  /* Function :  DMA_CRCDisable_Default
91:                  
92:                    Summary:
93:                      Implements Default variant of PLIB_DMA_CRCDisable
94:                  
95:                    Description:
96:                      This template implements the Default variant of the PLIB_DMA_CRCDisable function.
97:                      Operation is atomic.
98:                  */
99:                  
100:                 PLIB_TEMPLATE void DMA_CRCDisable_Default( DMA_MODULE_ID index )
101:                 {
102:                     volatile dma_register_t *regs = (dma_register_t *)index;
103:                 
104:                     regs->DCRCCONCLR = _DCRCCON_CRCEN_MASK;
105:                 }
106:                 
107:                 
108:                 //******************************************************************************
109:                 /* Function :  DMA_CRCIsEnabled_Default
110:                 
111:                   Summary:
112:                     Implements Default variant of PLIB_DMA_CRCIsEnabled
113:                 
114:                   Description:
115:                     This template implements the Default variant of the PLIB_DMA_CRCIsEnabled function.
116:                     Operation is atomic.
117:                 */
118:                 
119:                 PLIB_TEMPLATE bool DMA_CRCIsEnabled_Default( DMA_MODULE_ID index )
120:                 {
121:                     volatile dma_register_t *regs = (dma_register_t *)index;
122:                 
123:                     return (bool)regs->DCRCCON.CRCEN;
124:                 }
125:                 
126:                 #endif /*_DMA_CRC_DEFAULT_H*/
127:                 
128:                 /******************************************************************************
129:                  End of File
130:                 */
131:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/dma/templates/dma_ChannelX_Default.h  
1:                   /*******************************************************************************
2:                     DMA Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       dma_ChannelX_Default.h
6:                   
7:                     Summary:
8:                       DMA PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ChannelX
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_DMA_ExistsChannelX
16:                          PLIB_DMA_ChannelXEnable
17:                          PLIB_DMA_ChannelXIsEnabled
18:                          PLIB_DMA_ChannelXDisable
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _DMA_CHANNELX_DEFAULT_H
49:                  #define _DMA_CHANNELX_DEFAULT_H
50:                  
51:                  #include "dma_Registers.h"
52:                  
53:                  //******************************************************************************
54:                  /* Function :  DMA_ExistsChannelX_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_DMA_ExistsChannelX
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_DMA_ExistsChannelX function.
61:                  */
62:                  
63:                  #define PLIB_DMA_ExistsChannelX PLIB_DMA_ExistsChannelX
64:                  PLIB_TEMPLATE bool DMA_ExistsChannelX_Default( DMA_MODULE_ID index )
65:                  {
66:                      return true;
67:                  }
68:                  
69:                  
70:                  //******************************************************************************
71:                  /* Function :  DMA_ChannelXEnable_Default
72:                  
73:                    Summary:
74:                      Implements Default variant of PLIB_DMA_ChannelXEnable
75:                  
76:                    Description:
77:                      This template implements the Default variant of the PLIB_DMA_ChannelXEnable function.
78:                      Operation is atomic.
79:                  */
80:                  
81:                  PLIB_TEMPLATE void DMA_ChannelXEnable_Default( DMA_MODULE_ID index , DMA_CHANNEL channel )
82:                  {
83:                      volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
9D014C84  00041180   SLL V0, A0, 6
9D014C88  00042200   SLL A0, A0, 8
9D014C8C  00822023   SUBU A0, A0, V0
9D014C90  3C02BF88   LUI V0, -16504
9D014C94  24423060   ADDIU V0, V0, 12384
9D014C98  00822021   ADDU A0, A0, V0
84:                  
85:                      regs->DCHxCONSET = _DCH0CON_CHEN_MASK;
9D00D7DC  24030080   ADDIU V1, ZERO, 128
9D014C9C  24020080   ADDIU V0, ZERO, 128
86:                  }
87:                  
88:                  
89:                  //******************************************************************************
90:                  /* Function :  DMA_ChannelXIsEnabled_Default
91:                  
92:                    Summary:
93:                      Implements Default variant of PLIB_DMA_ChannelXIsEnabled
94:                  
95:                    Description:
96:                      This template implements the Default variant of the PLIB_DMA_ChannelXIsEnabled function.
97:                      Operation is atomic.
98:                  */
99:                  
100:                 PLIB_TEMPLATE bool DMA_ChannelXIsEnabled_Default( DMA_MODULE_ID index , DMA_CHANNEL channel )
101:                 {
102:                     volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
103:                 
104:                     return (bool)regs->DCHxCON.CHEN;
105:                 }
106:                 
107:                 
108:                 //******************************************************************************
109:                 /* Function :  DMA_ChannelXDisable_Default
110:                 
111:                   Summary:
112:                     Implements Default variant of PLIB_DMA_ChannelXDisable
113:                 
114:                   Description:
115:                     This template implements the Default variant of the PLIB_DMA_ChannelXDisable function.
116:                     Operation is atomic.
117:                 */
118:                 
119:                 PLIB_TEMPLATE void DMA_ChannelXDisable_Default( DMA_MODULE_ID index , DMA_CHANNEL channel )
120:                 {
121:                     volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
9D014CBC  00041180   SLL V0, A0, 6
9D014CC0  00042200   SLL A0, A0, 8
9D014CC4  00822023   SUBU A0, A0, V0
9D014CC8  3C02BF88   LUI V0, -16504
9D014CCC  24423060   ADDIU V0, V0, 12384
9D014CD0  00822021   ADDU A0, A0, V0
122:                 
123:                     regs->DCHxCONCLR = _DCH0CON_CHEN_MASK;
9D014CD4  24020080   ADDIU V0, ZERO, 128
124:                 }
125:                 
126:                 
127:                 #endif /*_DMA_CHANNELX_DEFAULT_H*/
128:                 
129:                 /******************************************************************************
130:                  End of File
131:                 */
132:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/dma/templates/dma_ChannelXTrigger_Default.h
1:                   /*******************************************************************************
2:                     DMA Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       dma_ChannelXTrigger_Default.h
6:                   
7:                     Summary:
8:                       DMA PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ChannelXTrigger
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_DMA_ExistsChannelXTrigger
16:                          PLIB_DMA_ChannelXTriggerEnable
17:                          PLIB_DMA_ChannelXTriggerIsEnabled
18:                          PLIB_DMA_ChannelXTriggerDisable
19:                          PLIB_DMA_ChannelXTriggerSourceNumberGet
20:                  
21:                  *******************************************************************************/
22:                  
23:                  //DOM-IGNORE-BEGIN
24:                  /*******************************************************************************
25:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
26:                  
27:                  Microchip licenses to you the right to use, modify, copy and distribute
28:                  Software only when embedded on a Microchip microcontroller or digital signal
29:                  controller that is integrated into your product or third party product
30:                  (pursuant to the sublicense terms in the accompanying license agreement).
31:                  
32:                  You should refer to the license agreement accompanying this Software for
33:                  additional information regarding your rights and obligations.
34:                  
35:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
36:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
37:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
38:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
39:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
40:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
41:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
42:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
43:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
44:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
45:                  *******************************************************************************/
46:                  
47:                  //DOM-IGNORE-END
48:                  
49:                  #ifndef _DMA_CHANNELXTRIGGER_DEFAULT_H
50:                  #define _DMA_CHANNELXTRIGGER_DEFAULT_H
51:                  
52:                  #include "dma_Registers.h"
53:                  
54:                  //******************************************************************************
55:                  /* Function :  DMA_ExistsChannelXTrigger_Default
56:                  
57:                    Summary:
58:                      Implements Default variant of PLIB_DMA_ExistsChannelXTrigger
59:                  
60:                    Description:
61:                      This template implements the Default variant of the PLIB_DMA_ExistsChannelXTrigger function.
62:                      Operation is atomic.
63:                  */
64:                  
65:                  #define PLIB_DMA_ExistsChannelXTrigger PLIB_DMA_ExistsChannelXTrigger
66:                  PLIB_TEMPLATE bool DMA_ExistsChannelXTrigger_Default( DMA_MODULE_ID index )
67:                  {
68:                      return true;
69:                  }
70:                  
71:                  
72:                  //******************************************************************************
73:                  /* Function :  DMA_ChannelXTriggerEnable_Default
74:                  
75:                    Summary:
76:                      Implements Default variant of PLIB_DMA_ChannelXTriggerEnable
77:                  
78:                    Description:
79:                      This template implements the Default variant of the PLIB_DMA_ChannelXTriggerEnable function.
80:                      Operation is atomic.
81:                  */
82:                  
83:                  PLIB_TEMPLATE void DMA_ChannelXTriggerEnable_Default( DMA_MODULE_ID index , DMA_CHANNEL channel , DMA_CHANNEL_TRIGGER_TYPE trigger )
84:                  {
85:                      volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
9D00CFA8  00041180   SLL V0, A0, 6
9D00CFAC  00041A00   SLL V1, A0, 8
9D00CFB0  00621023   SUBU V0, V1, V0
9D00CFB4  3C03BF88   LUI V1, -16504
9D00CFB8  24633060   ADDIU V1, V1, 12384
9D00CFBC  00431021   ADDU V0, V0, V1
86:                  
87:                      switch (trigger) {
88:                      case DMA_CHANNEL_TRIGGER_TRANSFER_START:
89:                  	   regs->DCHxECONSET = _DCH0ECON_SIRQEN_MASK;
9D00D0DC  24020010   ADDIU V0, ZERO, 16
9D00D0E0  AC820018   SW V0, 24(A0)
90:                  	   break;
91:                      case DMA_CHANNEL_TRIGGER_TRANSFER_ABORT:
92:                  	   regs->DCHxECONSET = _DCH0ECON_AIRQEN_MASK;
93:                  	   break;
94:                      case DMA_CHANNEL_TRIGGER_PATTERN_MATCH_ABORT:
95:                  	   regs->DCHxECONSET = _DCH0ECON_PATEN_MASK;
9D00CFC0  24030020   ADDIU V1, ZERO, 32
9D00CFC4  AC430018   SW V1, 24(V0)
96:                  	   break;
97:                      }
98:                  }
99:                  
100:                 
101:                 //******************************************************************************
102:                 /* Function :  DMA_ChannelXTriggerIsEnabled_Default
103:                 
104:                   Summary:
105:                     Implements Default variant of PLIB_DMA_ChannelXTriggerIsEnabled
106:                 
107:                   Description:
108:                     This template implements the Default variant of the PLIB_DMA_ChannelXTriggerIsEnabled function.
109:                     Operation is atomic.
110:                 */
111:                 
112:                 PLIB_TEMPLATE bool DMA_ChannelXTriggerIsEnabled_Default( DMA_MODULE_ID index , DMA_CHANNEL channel , DMA_CHANNEL_TRIGGER_TYPE trigger )
113:                 {
114:                     volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
115:                 
116:                     switch (trigger) {
117:                     case DMA_CHANNEL_TRIGGER_TRANSFER_START:
118:                 	   return (bool)regs->DCHxECON.SIRQEN;
119:                     case DMA_CHANNEL_TRIGGER_TRANSFER_ABORT:
120:                 	   return (bool)regs->DCHxECON.AIRQEN;
121:                     case DMA_CHANNEL_TRIGGER_PATTERN_MATCH_ABORT:
122:                 	   return (bool)regs->DCHxECON.PATEN;
123:                     }
124:                     return false;
125:                 }
126:                 
127:                 
128:                 //******************************************************************************
129:                 /* Function :  DMA_ChannelXTriggerDisable_Default
130:                 
131:                   Summary:
132:                     Implements Default variant of PLIB_DMA_ChannelXTriggerDisable
133:                 
134:                   Description:
135:                     This template implements the Default variant of the PLIB_DMA_ChannelXTriggerDisable function.
136:                 */
137:                 
138:                 PLIB_TEMPLATE void DMA_ChannelXTriggerDisable_Default( DMA_MODULE_ID index , DMA_CHANNEL channel , DMA_CHANNEL_TRIGGER_TYPE trigger )
139:                 {
140:                     volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
141:                 
142:                     switch (trigger) {
143:                     case DMA_CHANNEL_TRIGGER_TRANSFER_START:
144:                 	   regs->DCHxECONCLR = _DCH0ECON_SIRQEN_MASK;
145:                 	   break;
146:                     case DMA_CHANNEL_TRIGGER_TRANSFER_ABORT:
147:                 	   regs->DCHxECONCLR = _DCH0ECON_AIRQEN_MASK;
148:                 	   break;
149:                     case DMA_CHANNEL_TRIGGER_PATTERN_MATCH_ABORT:
150:                 	   regs->DCHxECONCLR = _DCH0ECON_PATEN_MASK;
151:                 	   break;
152:                     }
153:                 }
154:                 
155:                 
156:                 //******************************************************************************
157:                 /* Function :  DMA_ChannelXTriggerSourceNumberGet_Default
158:                 
159:                   Summary:
160:                     Implements Default variant of PLIB_DMA_ChannelXTriggerSourceNumberGet
161:                 
162:                   Description:
163:                     This template implements the Default variant of the PLIB_DMA_ChannelXTriggerSourceNumberGet function.
164:                 */
165:                 
166:                 PLIB_TEMPLATE DMA_CHANNEL_INT_SOURCE DMA_ChannelXTriggerSourceNumberGet_Default( DMA_MODULE_ID index , DMA_CHANNEL channel)
167:                 {
168:                 	return (DMA_CHANNEL_INT_SOURCE)(DMA_CHANNEL_0_INT_SOURCE + channel);
9D00FD0C  24A3003C   ADDIU V1, A1, 60
169:                 }
170:                 
171:                 
172:                 #endif /*_DMA_CHANNELXTRIGGER_DEFAULT_H*/
173:                 
174:                 /******************************************************************************
175:                  End of File
176:                 */
177:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/dma/templates/dma_ChannelXStartIRQ_Default.h
1:                   /*******************************************************************************
2:                     DMA Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       dma_ChannelXStartIRQ_Default.h
6:                   
7:                     Summary:
8:                       DMA PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ChannelXStartIRQ
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_DMA_ExistsChannelXStartIRQ
16:                          PLIB_DMA_ChannelXStartIRQSet
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _DMA_CHANNELXSTARTIRQ_DEFAULT_H
47:                  #define _DMA_CHANNELXSTARTIRQ_DEFAULT_H
48:                  
49:                  #include "dma_Registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  DMA_ExistsChannelXStartIRQ_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_DMA_ExistsChannelXStartIRQ
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_DMA_ExistsChannelXStartIRQ function.
59:                  */
60:                  
61:                  #define PLIB_DMA_ExistsChannelXStartIRQ PLIB_DMA_ExistsChannelXStartIRQ
62:                  PLIB_TEMPLATE bool DMA_ExistsChannelXStartIRQ_Default( DMA_MODULE_ID index )
63:                  {
64:                      return true;
65:                  }
66:                  
67:                  
68:                  //******************************************************************************
69:                  /* Function :  DMA_ChannelXStartIRQSet_Default
70:                  
71:                    Summary:
72:                      Implements Default variant of PLIB_DMA_ChannelXStartIRQSet
73:                  
74:                    Description:
75:                      This template implements the Default variant of the PLIB_DMA_ChannelXStartIRQSet function.
76:                      Operation is not atomic.
77:                  */
78:                  
79:                  PLIB_TEMPLATE void DMA_ChannelXStartIRQSet_Default( DMA_MODULE_ID index , DMA_CHANNEL channel , DMA_TRIGGER_SOURCE IRQnum )
80:                  {
81:                      volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
9D00D0C0  00042200   SLL A0, A0, 8
9D00D0C4  00822023   SUBU A0, A0, V0
9D00D0C8  3C02BF88   LUI V0, -16504
9D00D0CC  24423060   ADDIU V0, V0, 12384
9D00D0D0  00822021   ADDU A0, A0, V0
82:                  
83:                      regs->DCHxECON.CHSIRQ = IRQnum;
9D00D0D4  30C600FF   ANDI A2, A2, 255
9D00D0D8  A0860011   SB A2, 17(A0)
84:                  }
85:                  
86:                  
87:                  #endif /*_DMA_CHANNELXSTARTIRQ_DEFAULT_H*/
88:                  
89:                  /******************************************************************************
90:                   End of File
91:                  */
92:                  
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/dma/templates/dma_ChannelXSourceStartAddress_Default.h
1:                   /*******************************************************************************
2:                     DMA Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       dma_ChannelXSourceStartAddress_Default.h
6:                   
7:                     Summary:
8:                       DMA PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ChannelXSourceStartAddress
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_DMA_ExistsChannelXSourceStartAddress
16:                          PLIB_DMA_ChannelXSourceStartAddressGet
17:                          PLIB_DMA_ChannelXSourceStartAddressSet
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _DMA_CHANNELXSOURCESTARTADDRESS_DEFAULT_H
48:                  #define _DMA_CHANNELXSOURCESTARTADDRESS_DEFAULT_H
49:                  
50:                  #include <sys/kmem.h>
51:                  #include "dma_Registers.h"
52:                  
53:                  #define ConvertToPhysicalAddress(a) ((uint32_t)KVA_TO_PA(a))
54:                  #define ConvertToVirtualAddress(a)  PA_TO_KVA1(a)
55:                  
56:                  //******************************************************************************
57:                  /* Function :  DMA_ExistsChannelXSourceStartAddress_Default
58:                  
59:                    Summary:
60:                      Implements Default variant of PLIB_DMA_ExistsChannelXSourceStartAddress
61:                  
62:                    Description:
63:                      This template implements the Default variant of the PLIB_DMA_ExistsChannelXSourceStartAddress function.
64:                  */
65:                  
66:                  #define PLIB_DMA_ExistsChannelXSourceStartAddress PLIB_DMA_ExistsChannelXSourceStartAddress
67:                  PLIB_TEMPLATE bool DMA_ExistsChannelXSourceStartAddress_Default( DMA_MODULE_ID index )
68:                  {
69:                      return true;
70:                  }
71:                  
72:                  
73:                  //******************************************************************************
74:                  /* Function :  DMA_ChannelXSourceStartAddressGet_Default
75:                  
76:                    Summary:
77:                      Implements Default variant of PLIB_DMA_ChannelXSourceStartAddressGet
78:                  
79:                    Description:
80:                      This template implements the Default variant of the PLIB_DMA_ChannelXSourceStartAddressGet function.
81:                      Operation is atomic.
82:                  */
83:                  
84:                  PLIB_TEMPLATE uint32_t DMA_ChannelXSourceStartAddressGet_Default( DMA_MODULE_ID index , DMA_CHANNEL channel )
85:                  {
86:                      volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
87:                      uint32_t addr = regs->DCHxSSA;
88:                  
89:                      /* Check if the address lies in the KSEG2 for MZ devices */
90:                      if ((addr & 0x20000000) == 0x20000000) {
91:                  	if((addr >> 28)== 0x2) {
92:                  	    // EBI Address translation
93:                  	    addr = (addr | 0xc0000000) & 0xcFFFFFFF;
94:                  	} else if ((addr >> 28)== 0x3) {
95:                  	    //SQI Address translation
96:                  	    addr = (addr | 0xD0000000) & 0xDFFFFFFF;
97:                          }
98:                      } else {
99:                  	addr = (uint32_t)ConvertToVirtualAddress(addr);
100:                     }
101:                 
102:                     return addr;
103:                 }
104:                 
105:                 
106:                 //******************************************************************************
107:                 /* Function :  DMA_ChannelXSourceStartAddressSet_Default
108:                 
109:                   Summary:
110:                     Implements Default variant of PLIB_DMA_ChannelXSourceStartAddressSet
111:                 
112:                   Description:
113:                     This template implements the Default variant of the PLIB_DMA_ChannelXSourceStartAddressSet function.
114:                     Operation is atomic.
115:                 */
116:                 
117:                 PLIB_TEMPLATE void DMA_ChannelXSourceStartAddressSet_Default( DMA_MODULE_ID index , DMA_CHANNEL channel , uint32_t sourceStartAddress )
118:                 {
119:                     volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
9D00D6A0  00044180   SLL T0, A0, 6
9D00D6A4  00041200   SLL V0, A0, 8
9D00D6A8  00481023   SUBU V0, V0, T0
9D00D6AC  3C08BF88   LUI T0, -16504
9D00D6B0  25083060   ADDIU T0, T0, 12384
9D00D6B4  00481021   ADDU V0, V0, T0
120:                 
121:                     /* Check if the address lies in the KSEG2 for MZ devices */
122:                     if ((sourceStartAddress >> 29) == 0x6) {
9D00D6B8  00052742   SRL A0, A1, 29
9D00D6BC  24080006   ADDIU T0, ZERO, 6
9D00D6C0  1488000E   BNE A0, T0, SYS_DMA_ChannelTransferAdd::PLIB_DMA_ChannelXSourceStartAddressSet
9D00D6C4  00A01821   ADDU V1, A1, ZERO
123:                 	if ((sourceStartAddress >> 28)== 0xc) {
9D00D6C8  00052702   SRL A0, A1, 28
9D00D6CC  2408000C   ADDIU T0, ZERO, 12
9D00D6D0  14880005   BNE A0, T0, SYS_DMA_ChannelTransferAdd::PLIB_DMA_ChannelXSourceStartAddressSet
9D00D6D4  2408000D   ADDIU T0, ZERO, 13
124:                 	    // EBI Address translation
125:                             sourceStartAddress = ((sourceStartAddress | 0x20000000) & 0x2FFFFFFF);
9D00D6D8  7CA5D800   EXT A1, A1, 0, 28
9D00D6DC  3C032000   LUI V1, 8192
9D00D6E0  0B4035CE   J 0x9D00D738
9D00D6E4  00A31825   OR V1, A1, V1
126:                 	} else if((sourceStartAddress >> 28)== 0xD) {
9D00D6E8  14880013   BNE A0, T0, 0x9D00D738
9D00D6EC  7CA5D800   EXT A1, A1, 0, 28
127:                 	    //SQI Address translation
128:                             sourceStartAddress = ((sourceStartAddress | 0x30000000) & 0x3FFFFFFF);
9D00D6F0  3C033000   LUI V1, 12288
9D00D6F4  0B4035CE   J 0x9D00D738
9D00D6F8  00A31825   OR V1, A1, V1
129:                         }
130:                     } else if ((sourceStartAddress >> 29) == 0x7) {
9D00D6FC  24080007   ADDIU T0, ZERO, 7
9D00D700  5488000D   BNEL A0, T0, 0x9D00D738
9D00D704  7CA3E000   EXT V1, A1, 0, 29
131:                 	if ((sourceStartAddress >> 28)== 0xE) {
9D00D708  00052702   SRL A0, A1, 28
9D00D70C  2408000E   ADDIU T0, ZERO, 14
9D00D710  14880005   BNE A0, T0, SYS_DMA_ChannelTransferAdd::PLIB_DMA_ChannelXSourceStartAddressSet
9D00D714  2408000F   ADDIU T0, ZERO, 15
132:                 	    // EBI Address translation
133:                             sourceStartAddress = ((sourceStartAddress | 0x20000000) & 0x2FFFFFFF);
9D00D718  7CA5D800   EXT A1, A1, 0, 28
9D00D71C  3C032000   LUI V1, 8192
9D00D720  0B4035CE   J 0x9D00D738
9D00D724  00A31825   OR V1, A1, V1
134:                 	} else if ((sourceStartAddress >> 28)== 0xF) {
9D00D728  14880003   BNE A0, T0, 0x9D00D738
9D00D72C  7CA5D800   EXT A1, A1, 0, 28
135:                 	    //SQI Address translation
136:                             sourceStartAddress = ((sourceStartAddress | 0x30000000) & 0x3FFFFFFF);
9D00D730  3C033000   LUI V1, 12288
9D00D734  00A31825   OR V1, A1, V1
137:                         }
138:                     } else {
139:                         /*For KSEG0 and KSEG1, The translation is done by KVA_TO_PA */
140:                         sourceStartAddress = ConvertToPhysicalAddress(sourceStartAddress);
141:                     }
142:                 
143:                     regs->DCHxSSA = sourceStartAddress;
9D00D738  AC430030   SW V1, 48(V0)
144:                 }
145:                 
146:                 
147:                 #endif /*_DMA_CHANNELXSOURCESTARTADDRESS_DEFAULT_H*/
148:                 
149:                 /******************************************************************************
150:                  End of File
151:                 */
152:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/dma/templates/dma_ChannelXSourceSize_Default.h
1:                   /*******************************************************************************
2:                     DMA Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       dma_ChannelXSourceSize_Default.h
6:                   
7:                     Summary:
8:                       DMA PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ChannelXSourceSize
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_DMA_ExistsChannelXSourceSize
16:                          PLIB_DMA_ChannelXSourceSizeGet
17:                          PLIB_DMA_ChannelXSourceSizeSet
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _DMA_CHANNELXSOURCESIZE_DEFAULT_H
48:                  #define _DMA_CHANNELXSOURCESIZE_DEFAULT_H
49:                  
50:                  #include "dma_Registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  DMA_ExistsChannelXSourceSize_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_DMA_ExistsChannelXSourceSize
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_DMA_ExistsChannelXSourceSize function.
60:                  */
61:                  
62:                  #define PLIB_DMA_ExistsChannelXSourceSize PLIB_DMA_ExistsChannelXSourceSize
63:                  PLIB_TEMPLATE bool DMA_ExistsChannelXSourceSize_Default( DMA_MODULE_ID index )
64:                  {
65:                      return true;
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  DMA_ChannelXSourceSizeGet_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_DMA_ChannelXSourceSizeGet
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_DMA_ChannelXSourceSizeGet function.
77:                      Operation is atomic.
78:                  */
79:                  
80:                  PLIB_TEMPLATE uint16_t DMA_ChannelXSourceSizeGet_Default( DMA_MODULE_ID index , DMA_CHANNEL channel )
81:                  {
82:                      volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
83:                  
84:                      return (uint16_t)regs->DCHxSSIZ;
85:                  }
86:                  
87:                  
88:                  //******************************************************************************
89:                  /* Function :  DMA_ChannelXSourceSizeSet_Default
90:                  
91:                    Summary:
92:                      Implements Default variant of PLIB_DMA_ChannelXSourceSizeSet
93:                  
94:                    Description:
95:                      This template implements the Default variant of the PLIB_DMA_ChannelXSourceSizeSet function.
96:                      Operation is atomic.
97:                  */
98:                  
99:                  PLIB_TEMPLATE void DMA_ChannelXSourceSizeSet_Default( DMA_MODULE_ID index , DMA_CHANNEL channel , uint16_t sourceSize )
100:                 {
101:                     volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
102:                 
103:                     regs->DCHxSSIZ = sourceSize;
9D00D73C  30C6FFFF   ANDI A2, A2, -1
9D00D740  AC460050   SW A2, 80(V0)
104:                 }
105:                 
106:                 #endif /*_DMA_CHANNELXSOURCESIZE_DEFAULT_H*/
107:                 
108:                 /******************************************************************************
109:                  End of File
110:                 */
111:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/dma/templates/dma_ChannelXPriority_Default.h
1:                   /*******************************************************************************
2:                     DMA Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       dma_ChannelXPriority_Default.h
6:                   
7:                     Summary:
8:                       DMA PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ChannelXPriority
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_DMA_ExistsChannelXPriority
16:                          PLIB_DMA_ChannelXPrioritySelect
17:                          PLIB_DMA_ChannelXPriorityGet
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _DMA_CHANNELXPRIORITY_DEFAULT_H
48:                  #define _DMA_CHANNELXPRIORITY_DEFAULT_H
49:                  
50:                  #include "dma_Registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  DMA_ExistsChannelXPriority_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_DMA_ExistsChannelXPriority
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_DMA_ExistsChannelXPriority function.
60:                  */
61:                  
62:                  #define PLIB_DMA_ExistsChannelXPriority PLIB_DMA_ExistsChannelXPriority
63:                  PLIB_TEMPLATE bool DMA_ExistsChannelXPriority_Default( DMA_MODULE_ID index )
64:                  {
65:                      return true;
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  DMA_ChannelXPrioritySelect_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_DMA_ChannelXPrioritySelect
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_DMA_ChannelXPrioritySelect function.
77:                      Operation is not atomic.
78:                  */
79:                  
80:                  PLIB_TEMPLATE void DMA_ChannelXPrioritySelect_Default( DMA_MODULE_ID index , DMA_CHANNEL channel , DMA_CHANNEL_PRIORITY channelPriority )
81:                  {
82:                      volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
83:                  
84:                      regs->DCHxCON.CHPRI = channelPriority;
9D0134CC  94A70000   LHU A3, 0(A1)
9D0134D0  7CC70804   INS A3, A2, 0, 2
9D0134D4  A4A70000   SH A3, 0(A1)
9D0134D8  24C60001   ADDIU A2, A2, 1
9D0134DC  24A500C0   ADDIU A1, A1, 192
85:                  }
86:                  
87:                  
88:                  //******************************************************************************
89:                  /* Function :  DMA_ChannelXPriorityGet_Default
90:                  
91:                    Summary:
92:                      Implements Default variant of PLIB_DMA_ChannelXPriorityGet
93:                  
94:                    Description:
95:                      This template implements the Default variant of the PLIB_DMA_ChannelXPriorityGet function.
96:                      Operation is atomic.
97:                  */
98:                  
99:                  PLIB_TEMPLATE DMA_CHANNEL_PRIORITY DMA_ChannelXPriorityGet_Default( DMA_MODULE_ID index , DMA_CHANNEL channel )
100:                 {
101:                     volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
102:                 
103:                     return (DMA_CHANNEL_PRIORITY)regs->DCHxCON.CHPRI;
104:                 }
105:                 
106:                 
107:                 #endif /*_DMA_CHANNELXPRIORITY_DEFAULT_H*/
108:                 
109:                 /******************************************************************************
110:                  End of File
111:                 */
112:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/dma/templates/dma_ChannelXINTSource_Default.h
1:                   /*******************************************************************************
2:                     DMA Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       dma_ChannelXINTSource_Default.h
6:                   
7:                     Summary:
8:                       DMA PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ChannelXINTSource
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_DMA_ExistsChannelXINTSource
16:                          PLIB_DMA_ChannelXINTSourceEnable
17:                          PLIB_DMA_ChannelXINTSourceDisable
18:                          PLIB_DMA_ChannelXINTSourceIsEnabled
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _DMA_CHANNELXINTSOURCE_DEFAULT_H
49:                  #define _DMA_CHANNELXINTSOURCE_DEFAULT_H
50:                  
51:                  #include "dma_Registers.h"
52:                  
53:                  //******************************************************************************
54:                  /* Function :  DMA_ExistsChannelXINTSource_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_DMA_ExistsChannelXINTSource
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_DMA_ExistsChannelXINTSource function.
61:                  */
62:                  
63:                  #define PLIB_DMA_ExistsChannelXINTSource PLIB_DMA_ExistsChannelXINTSource
64:                  PLIB_TEMPLATE bool DMA_ExistsChannelXINTSource_Default( DMA_MODULE_ID index )
65:                  {
66:                      return true;
67:                  }
68:                  
69:                  
70:                  //******************************************************************************
71:                  /* Function :  DMA_ChannelXINTSourceEnable_Default
72:                  
73:                    Summary:
74:                      Implements Default variant of PLIB_DMA_ChannelXINTSourceEnable
75:                  
76:                    Description:
77:                      This template implements the Default variant of the PLIB_DMA_ChannelXINTSourceEnable function.
78:                      Operation is atomic.
79:                  */
80:                  
81:                  PLIB_TEMPLATE void DMA_ChannelXINTSourceEnable_Default( DMA_MODULE_ID index , DMA_CHANNEL channel , DMA_INT_TYPE dmaINTSource )
82:                  {
83:                      volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
9D00D094  00042200   SLL A0, A0, 8
9D00D098  00822023   SUBU A0, A0, V0
9D00D09C  3C02BF88   LUI V0, -16504
9D00D0A0  24423060   ADDIU V0, V0, 12384
9D00D0A4  00822021   ADDU A0, A0, V0
84:                  
85:                      switch (dmaINTSource) {
86:                      case DMA_INT_ADDRESS_ERROR:
87:                  	regs->DCHxINTSET = _DCH0INT_CHERIE_MASK;
9D00D0B0  3C020001   LUI V0, 1
9D00D0B4  AC820028   SW V0, 40(A0)
9D00D0B8  03E00008   JR RA
9D00D0BC  00000000   NOP
9D00D0EC  3C020001   LUI V0, 1
88:                  	break;
89:                  
90:                      case DMA_INT_TRANSFER_ABORT:
91:                  	regs->DCHxINTSET = _DCH0INT_CHTAIE_MASK;
92:                  	break;
93:                      case DMA_INT_CELL_TRANSFER_COMPLETE:
94:                  	regs->DCHxINTSET = _DCH0INT_CHCCIE_MASK;
95:                  	break;
96:                      case DMA_INT_BLOCK_TRANSFER_COMPLETE:
97:                  	regs->DCHxINTSET = _DCH0INT_CHBCIE_MASK;
9D00D0A8  3C020008   LUI V0, 8
9D00D0AC  AC820028   SW V0, 40(A0)
9D00D0E4  3C020008   LUI V0, 8
9D00D0E8  AC820028   SW V0, 40(A0)
98:                  	break;
99:                  
100:                     case DMA_INT_DESTINATION_HALF_FULL:
101:                 	regs->DCHxINTSET = _DCH0INT_CHDHIE_MASK;
102:                 	break;
103:                 
104:                     case DMA_INT_DESTINATION_DONE:
105:                 	regs->DCHxINTSET = _DCH0INT_CHDDIE_MASK;
106:                 	break;
107:                 
108:                     case DMA_INT_SOURCE_HALF_EMPTY:
109:                 	regs->DCHxINTSET = _DCH0INT_CHSHIE_MASK;
110:                 	break;
111:                 
112:                     case DMA_INT_SOURCE_DONE:
113:                 	regs->DCHxINTSET = _DCH0INT_CHSDIE_MASK;
114:                 	break;
115:                     }
116:                 }
117:                 
118:                 
119:                 //******************************************************************************
120:                 /* Function :  DMA_ChannelXINTSourceDisable_Default
121:                 
122:                   Summary:
123:                     Implements Default variant of PLIB_DMA_ChannelXINTSourceDisable
124:                 
125:                   Description:
126:                     This template implements the Default variant of the PLIB_DMA_ChannelXINTSourceDisable function.
127:                     Operation is atomic.
128:                 */
129:                 
130:                 PLIB_TEMPLATE void DMA_ChannelXINTSourceDisable_Default( DMA_MODULE_ID index , DMA_CHANNEL channel , DMA_INT_TYPE dmaINTSource )
131:                 {
132:                     volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
9D00CE4C  00041180   SLL V0, A0, 6
9D00CE50  00043A00   SLL A3, A0, 8
9D00CE54  00E23823   SUBU A3, A3, V0
9D00CE58  3C02BF88   LUI V0, -16504
9D00CE5C  24423060   ADDIU V0, V0, 12384
9D00CE60  00E23821   ADDU A3, A3, V0
9D00CE64  00001821   ADDU V1, ZERO, ZERO
133:                 
134:                     switch (dmaINTSource) {
9D00CE6C  24040008   ADDIU A0, ZERO, 8
9D00CE74  24080020   ADDIU T0, ZERO, 32
9D00CE7C  240B0040   ADDIU T3, ZERO, 64
9D00CE84  240D0080   ADDIU T5, ZERO, 128
9D00CE8C  240C0010   ADDIU T4, ZERO, 16
9D00CE94  24090002   ADDIU T1, ZERO, 2
9D00CE9C  240A0004   ADDIU T2, ZERO, 4
9D00CEAC  10440022   BEQ V0, A0, 0x9D00CF38
9D00CEB0  2C450009   SLTIU A1, V0, 9
9D00CEB4  10A00009   BEQ A1, ZERO, 0x9D00CEDC
9D00CEB8  00000000   NOP
9D00CEBC  10490018   BEQ V0, T1, 0x9D00CF20
9D00CEC0  00000000   NOP
9D00CEC4  104A0019   BEQ V0, T2, 0x9D00CF2C
9D00CEC8  00000000   NOP
9D00CECC  54460028   BNEL V0, A2, 0x9D00CF70
9D00CED0  24630001   ADDIU V1, V1, 1
9D00CED4  0B4033C5   J 0x9D00CF14
9D00CED8  00000000   NOP
9D00CEDC  1048001C   BEQ V0, T0, 0x9D00CF50
9D00CEE0  2C450021   SLTIU A1, V0, 33
9D00CEE4  10A00005   BEQ A1, ZERO, 0x9D00CEFC
9D00CEE8  00000000   NOP
9D00CEEC  104C0015   BEQ V0, T4, 0x9D00CF44
9D00CEF0  00000000   NOP
9D00CEF4  0B4033DC   J 0x9D00CF70
9D00CEF8  24630001   ADDIU V1, V1, 1
9D00CEFC  104B0017   BEQ V0, T3, 0x9D00CF5C
9D00CF00  00000000   NOP
9D00CF04  104D0018   BEQ V0, T5, 0x9D00CF68
9D00CF08  00000000   NOP
9D00CF0C  0B4033DC   J 0x9D00CF70
9D00CF10  24630001   ADDIU V1, V1, 1
135:                     case DMA_INT_ADDRESS_ERROR:
136:                 	regs->DCHxINTCLR = _DCH0INT_CHERIE_MASK;
9D00CEA4  3C0E0001   LUI T6, 1
9D00CF14  ACEE0024   SW T6, 36(A3)
9D00CF18  0B4033DC   J 0x9D00CF70
9D00CF1C  24630001   ADDIU V1, V1, 1
137:                 	break;
138:                 
139:                     case DMA_INT_TRANSFER_ABORT:
140:                 	regs->DCHxINTCLR = _DCH0INT_CHTAIE_MASK;
9D00CE98  3C180002   LUI T8, 2
9D00CF20  ACF80024   SW T8, 36(A3)
9D00CF24  0B4033DC   J 0x9D00CF70
9D00CF28  24630001   ADDIU V1, V1, 1
141:                 	break;
142:                     case DMA_INT_CELL_TRANSFER_COMPLETE:
143:                 	regs->DCHxINTCLR = _DCH0INT_CHCCIE_MASK;
9D00CEA0  3C0F0004   LUI T7, 4
9D00CF2C  ACEF0024   SW T7, 36(A3)
9D00CF30  0B4033DC   J 0x9D00CF70
9D00CF34  24630001   ADDIU V1, V1, 1
144:                 	break;
145:                     case DMA_INT_BLOCK_TRANSFER_COMPLETE:
146:                 	regs->DCHxINTCLR = _DCH0INT_CHBCIE_MASK;
9D00CE70  3C130008   LUI S3, 8
9D00CF38  ACF30024   SW S3, 36(A3)
9D00CF3C  0B4033DC   J 0x9D00CF70
9D00CF40  24630001   ADDIU V1, V1, 1
147:                 	break;
148:                 
149:                     case DMA_INT_DESTINATION_HALF_FULL:
150:                 	regs->DCHxINTCLR = _DCH0INT_CHDHIE_MASK;
9D00CE90  3C190010   LUI T9, 16
9D00CF44  ACF90024   SW T9, 36(A3)
9D00CF48  0B4033DC   J 0x9D00CF70
9D00CF4C  24630001   ADDIU V1, V1, 1
151:                 	break;
152:                 
153:                     case DMA_INT_DESTINATION_DONE:
154:                 	regs->DCHxINTCLR = _DCH0INT_CHDDIE_MASK;
9D00CE78  3C120020   LUI S2, 32
9D00CF50  ACF20024   SW S2, 36(A3)
9D00CF54  0B4033DC   J 0x9D00CF70
9D00CF58  24630001   ADDIU V1, V1, 1
155:                 	break;
156:                 
157:                     case DMA_INT_SOURCE_HALF_EMPTY:
158:                 	regs->DCHxINTCLR = _DCH0INT_CHSHIE_MASK;
9D00CE80  3C110040   LUI S1, 64
9D00CF5C  ACF10024   SW S1, 36(A3)
9D00CF60  0B4033DC   J 0x9D00CF70
9D00CF64  24630001   ADDIU V1, V1, 1
159:                 	break;
160:                 
161:                     case DMA_INT_SOURCE_DONE:
162:                 	regs->DCHxINTCLR = _DCH0INT_CHSDIE_MASK;
9D00CE88  3C100080   LUI S0, 128
9D00CF68  ACF00024   SW S0, 36(A3)
9D00CF6C  24630001   ADDIU V1, V1, 1
163:                 	break;
164:                     }
165:                 }
166:                 
167:                 
168:                 //******************************************************************************
169:                 /* Function :  DMA_ChannelXINTSourceIsEnabled_Default
170:                 
171:                   Summary:
172:                     Implements Default variant of PLIB_DMA_ChannelXINTSourceIsEnabled
173:                 
174:                   Description:
175:                     This template implements the Default variant of the PLIB_DMA_ChannelXINTSourceIsEnabled function.
176:                     Operation is atomic.
177:                 */
178:                 
179:                 PLIB_TEMPLATE bool DMA_ChannelXINTSourceIsEnabled_Default( DMA_MODULE_ID index , DMA_CHANNEL channel , DMA_INT_TYPE dmaINTSource )
180:                 {
181:                     volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
182:                 
183:                     switch (dmaINTSource) {
184:                     case DMA_INT_ADDRESS_ERROR:
185:                 	return (bool)regs->DCHxINT.CHERIE;
186:                 
187:                     case DMA_INT_TRANSFER_ABORT:
188:                 	return (bool)regs->DCHxINT.CHTAIE;
189:                 
190:                     case DMA_INT_CELL_TRANSFER_COMPLETE:
191:                 	return (bool)regs->DCHxINT.CHCCIE;
192:                 
193:                     case DMA_INT_BLOCK_TRANSFER_COMPLETE:
194:                 	return (bool)regs->DCHxINT.CHBCIE;
195:                 
196:                     case DMA_INT_DESTINATION_HALF_FULL:
197:                 	return (bool)regs->DCHxINT.CHDHIE;
198:                 
199:                     case DMA_INT_DESTINATION_DONE:
200:                 	return (bool)regs->DCHxINT.CHDDIE;
201:                 
202:                     case DMA_INT_SOURCE_HALF_EMPTY:
203:                 	return (bool)regs->DCHxINT.CHSHIE;
204:                 
205:                     case DMA_INT_SOURCE_DONE:
206:                 	return (bool)regs->DCHxINT.CHSDIE;
207:                     }
208:                 
209:                     return (bool)false;
210:                 }
211:                 
212:                 
213:                 #endif /*_DMA_CHANNELXINTSOURCE_DEFAULT_H*/
214:                 
215:                 /******************************************************************************
216:                  End of File
217:                 */
218:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/dma/templates/dma_ChannelXINTSourceFlag_Default.h
1:                   /*******************************************************************************
2:                     DMA Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       dma_ChannelXINTSourceFlag_Default.h
6:                   
7:                     Summary:
8:                       DMA PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ChannelXINTSourceFlag
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_DMA_ExistsChannelXINTSourceFlag
16:                          PLIB_DMA_ChannelXINTSourceFlagGet
17:                          PLIB_DMA_ChannelXINTSourceFlagSet
18:                          PLIB_DMA_ChannelXINTSourceFlagClear
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _DMA_CHANNELXINTSOURCEFLAG_DEFAULT_H
49:                  #define _DMA_CHANNELXINTSOURCEFLAG_DEFAULT_H
50:                  
51:                  #include "dma_Registers.h"
52:                  
53:                  //******************************************************************************
54:                  /* Function :  DMA_ExistsChannelXINTSourceFlag_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_DMA_ExistsChannelXINTSourceFlag
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_DMA_ExistsChannelXINTSourceFlag function.
61:                  */
62:                  
63:                  #define PLIB_DMA_ExistsChannelXINTSourceFlag PLIB_DMA_ExistsChannelXINTSourceFlag
64:                  PLIB_TEMPLATE bool DMA_ExistsChannelXINTSourceFlag_Default( DMA_MODULE_ID index )
65:                  {
66:                      return true;
67:                  }
68:                  
69:                  
70:                  //******************************************************************************
71:                  /* Function :  DMA_ChannelXINTSourceFlagGet_Default
72:                  
73:                    Summary:
74:                      Implements Default variant of PLIB_DMA_ChannelXINTSourceFlagGet
75:                  
76:                    Description:
77:                      This template implements the Default variant of the PLIB_DMA_ChannelXINTSourceFlagGet function.
78:                      Operation is atomic.
79:                  */
80:                  
81:                  PLIB_TEMPLATE bool DMA_ChannelXINTSourceFlagGet_Default( DMA_MODULE_ID index , DMA_CHANNEL channel , DMA_INT_TYPE dmaINTSource )
82:                  {
83:                      volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
9D00FD10  00051180   SLL V0, A1, 6
9D00FD14  00052200   SLL A0, A1, 8
9D00FD18  00821023   SUBU V0, A0, V0
9D00FD1C  3C04BF88   LUI A0, -16504
9D00FD20  24843060   ADDIU A0, A0, 12384
9D00FD24  00441021   ADDU V0, V0, A0
84:                      bool intSrcFlag = false;
85:                  
86:                      switch (dmaINTSource) {
87:                      case DMA_INT_ADDRESS_ERROR:
88:                  	intSrcFlag = regs->DCHxINT.CHERIF;
89:                  	break;
90:                  
91:                      case DMA_INT_TRANSFER_ABORT:
92:                  	intSrcFlag = regs->DCHxINT.CHTAIF;
9D00FD90  8C440020   LW A0, 32(V0)
9D00FD94  7C840040   EXT A0, A0, 1, 1
93:                  	break;
94:                  
95:                      case DMA_INT_CELL_TRANSFER_COMPLETE:
96:                  	intSrcFlag = regs->DCHxINT.CHCCIF;
97:                  	break;
98:                  
99:                      case DMA_INT_BLOCK_TRANSFER_COMPLETE:
100:                 	intSrcFlag = regs->DCHxINT.CHBCIF;
9D00FD28  8C440020   LW A0, 32(V0)
9D00FD2C  7C8400C0   EXT A0, A0, 3, 1
101:                 	break;
102:                 
103:                     case DMA_INT_DESTINATION_HALF_FULL:
104:                 	intSrcFlag = regs->DCHxINT.CHDHIF;
105:                 	break;
106:                 
107:                     case DMA_INT_DESTINATION_DONE:
108:                 	intSrcFlag = regs->DCHxINT.CHDDIF;
109:                 	break;
110:                 
111:                     case DMA_INT_SOURCE_HALF_EMPTY:
112:                 	intSrcFlag = regs->DCHxINT.CHSHIF;
113:                 	break;
114:                 
115:                     case DMA_INT_SOURCE_DONE:
116:                 	intSrcFlag = regs->DCHxINT.CHSDIF;
117:                 	break;
118:                     }
119:                 
120:                     return intSrcFlag;
121:                 }
122:                 
123:                 
124:                 //******************************************************************************
125:                 /* Function :  DMA_ChannelXINTSourceFlagSet_Default
126:                 
127:                   Summary:
128:                     Implements Default variant of PLIB_DMA_ChannelXINTSourceFlagSet
129:                 
130:                   Description:
131:                     This template implements the Default variant of the PLIB_DMA_ChannelXINTSourceFlagSet function.
132:                     Operation is atomic.
133:                 */
134:                 
135:                 PLIB_TEMPLATE void DMA_ChannelXINTSourceFlagSet_Default( DMA_MODULE_ID index , DMA_CHANNEL channel , DMA_INT_TYPE dmaINTSource )
136:                 {
137:                     volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
138:                 
139:                     switch (dmaINTSource) {
140:                     case DMA_INT_ADDRESS_ERROR:
141:                 	regs->DCHxINTSET = _DCH0INT_CHERIF_MASK;
142:                 	break;
143:                 
144:                     case DMA_INT_TRANSFER_ABORT:
145:                 	regs->DCHxINTSET = _DCH0INT_CHTAIF_MASK;
146:                 	break;
147:                 
148:                     case DMA_INT_CELL_TRANSFER_COMPLETE:
149:                 	regs->DCHxINTSET = _DCH0INT_CHCCIF_MASK;
150:                 	break;
151:                 
152:                     case DMA_INT_BLOCK_TRANSFER_COMPLETE:
153:                 	regs->DCHxINTSET = _DCH0INT_CHBCIF_MASK;
154:                 	break;
155:                 
156:                     case DMA_INT_DESTINATION_HALF_FULL:
157:                 	regs->DCHxINTSET = _DCH0INT_CHDHIF_MASK;
158:                 	break;
159:                 
160:                     case DMA_INT_DESTINATION_DONE:
161:                 	regs->DCHxINTSET = _DCH0INT_CHDDIF_MASK;
162:                 	break;
163:                 
164:                     case DMA_INT_SOURCE_HALF_EMPTY:
165:                 	regs->DCHxINTSET = _DCH0INT_CHSHIF_MASK;
166:                 	break;
167:                 
168:                     case DMA_INT_SOURCE_DONE:
169:                 	regs->DCHxINTSET = _DCH0INT_CHSDIF_MASK;
170:                 	break;
171:                     }
172:                 }
173:                 
174:                 //******************************************************************************
175:                 /* Function :  DMA_ChannelXINTSourceFlagClear_Default
176:                 
177:                   Summary:
178:                     Implements Default variant of PLIB_DMA_ChannelXINTSourceFlagClear
179:                 
180:                   Description:
181:                     This template implements the Default variant of the PLIB_DMA_ChannelXINTSourceFlagClear function.
182:                     Operation is atomic.
183:                 */
184:                 
185:                 PLIB_TEMPLATE void DMA_ChannelXINTSourceFlagClear_Default( DMA_MODULE_ID index , DMA_CHANNEL channel , DMA_INT_TYPE dmaINTSource )
186:                 {
187:                     volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
188:                 
189:                     switch (dmaINTSource) {
190:                     case DMA_INT_ADDRESS_ERROR:
191:                 	regs->DCHxINTCLR = _DCH0INT_CHERIF_MASK;
192:                 	break;
193:                 
194:                     case DMA_INT_TRANSFER_ABORT:
195:                 	regs->DCHxINTCLR = _DCH0INT_CHTAIF_MASK;
9D00FDA0  AC440024   SW A0, 36(V0)
196:                 	break;
197:                 
198:                     case DMA_INT_CELL_TRANSFER_COMPLETE:
199:                 	regs->DCHxINTCLR = _DCH0INT_CHCCIF_MASK;
200:                 	break;
201:                 
202:                     case DMA_INT_BLOCK_TRANSFER_COMPLETE:
203:                 	regs->DCHxINTCLR = _DCH0INT_CHBCIF_MASK;
9D00FD38  AC440024   SW A0, 36(V0)
204:                 	break;
205:                 
206:                     case DMA_INT_DESTINATION_HALF_FULL:
207:                 	regs->DCHxINTCLR = _DCH0INT_CHDHIF_MASK;
208:                 	break;
209:                 
210:                     case DMA_INT_DESTINATION_DONE:
211:                 	regs->DCHxINTCLR = _DCH0INT_CHDDIF_MASK;
212:                 	break;
213:                 
214:                     case DMA_INT_SOURCE_HALF_EMPTY:
215:                 	regs->DCHxINTCLR = _DCH0INT_CHSHIF_MASK;
216:                 	break;
217:                 
218:                     case DMA_INT_SOURCE_DONE:
219:                 	regs->DCHxINTCLR = _DCH0INT_CHSDIF_MASK;
220:                 	break;
221:                     }
222:                 }
223:                 
224:                 #endif /*_DMA_CHANNELXINTSOURCEFLAG_DEFAULT_H*/
225:                 
226:                 /******************************************************************************
227:                  End of File
228:                 */
229:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/dma/templates/dma_ChannelXDisabled_Default.h
1:                   /*******************************************************************************
2:                     DMA Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       dma_ChannelXDisabled_Default.h
6:                   
7:                     Summary:
8:                       DMA PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ChannelXDisabled
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_DMA_ExistsChannelXDisabled
16:                          PLIB_DMA_ChannelXDisabledEnablesEvents
17:                          PLIB_DMA_ChannelXDisabledDisablesEvents
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _DMA_CHANNELXDISABLED_DEFAULT_H
48:                  #define _DMA_CHANNELXDISABLED_DEFAULT_H
49:                  
50:                  #include "dma_Registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  DMA_ExistsChannelXDisabled_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_DMA_ExistsChannelXDisabled
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_DMA_ExistsChannelXDisabled function.
60:                  */
61:                  
62:                  #define PLIB_DMA_ExistsChannelXDisabled PLIB_DMA_ExistsChannelXDisabled
63:                  PLIB_TEMPLATE bool DMA_ExistsChannelXDisabled_Default( DMA_MODULE_ID index )
64:                  {
65:                      return true;
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  DMA_ChannelXDisabledEnablesEvents_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_DMA_ChannelXDisabledEnablesEvents
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_DMA_ChannelXDisabledEnablesEvents function.
77:                      Operation is atomic.
78:                  */
79:                  
80:                  PLIB_TEMPLATE void DMA_ChannelXDisabledEnablesEvents_Default( DMA_MODULE_ID index , DMA_CHANNEL channel )
81:                  {
82:                      volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
83:                  
84:                      regs->DCHxCONSET = _DCH0CON_CHAED_MASK;
9D00CFFC  24030040   ADDIU V1, ZERO, 64
9D00D000  AC430008   SW V1, 8(V0)
9D00D03C  24030040   ADDIU V1, ZERO, 64
9D00D040  AC430008   SW V1, 8(V0)
85:                  }
86:                  
87:                  
88:                  //******************************************************************************
89:                  /* Function :  DMA_ChannelXDisabledDisablesEvents_Default
90:                  
91:                    Summary:
92:                      Implements Default variant of PLIB_DMA_ChannelXDisabledDisablesEvents
93:                  
94:                    Description:
95:                      This template implements the Default variant of the PLIB_DMA_ChannelXDisabledDisablesEvents function.
96:                      Operation is atomic.
97:                  */
98:                  
99:                  PLIB_TEMPLATE void DMA_ChannelXDisabledDisablesEvents_Default( DMA_MODULE_ID index , DMA_CHANNEL channel )
100:                 {
101:                     volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
102:                 
103:                     regs->DCHxCONCLR = _DCH0CON_CHAED_MASK;
104:                 }
105:                 
106:                 
107:                 #endif /*_DMA_CHANNELXDISABLED_DEFAULT_H*/
108:                 
109:                 /******************************************************************************
110:                  End of File
111:                 */
112:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/dma/templates/dma_ChannelXDestinationStartAddress_Default.h
1:                   /*******************************************************************************
2:                     DMA Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       dma_ChannelXDestinationStartAddress_Default.h
6:                   
7:                     Summary:
8:                       DMA PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ChannelXDestinationStartAddress
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_DMA_ExistsChannelXDestinationStartAddress
16:                          PLIB_DMA_ChannelXDestinationStartAddressGet
17:                          PLIB_DMA_ChannelXDestinationStartAddressSet
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _DMA_CHANNELXDESTINATIONSTARTADDRESS_DEFAULT_H
48:                  #define _DMA_CHANNELXDESTINATIONSTARTADDRESS_DEFAULT_H
49:                  
50:                  #include <sys/kmem.h>
51:                  #include "dma_Registers.h"
52:                  
53:                  #define ConvertToPhysicalAddress(a) ((uint32_t)KVA_TO_PA(a))
54:                  #define ConvertToVirtualAddress(a)  PA_TO_KVA1(a)
55:                  
56:                  //******************************************************************************
57:                  /* Function :  DMA_ExistsChannelXDestinationStartAddress_Default
58:                  
59:                    Summary:
60:                      Implements Default variant of PLIB_DMA_ExistsChannelXDestinationStartAddress
61:                  
62:                    Description:
63:                      This template implements the Default variant of the PLIB_DMA_ExistsChannelXDestinationStartAddress function.
64:                  */
65:                  
66:                  #define PLIB_DMA_ExistsChannelXDestinationStartAddress PLIB_DMA_ExistsChannelXDestinationStartAddress
67:                  PLIB_TEMPLATE bool DMA_ExistsChannelXDestinationStartAddress_Default( DMA_MODULE_ID index )
68:                  {
69:                      return true;
70:                  }
71:                  
72:                  
73:                  //******************************************************************************
74:                  /* Function :  DMA_ChannelXDestinationStartAddressGet_Default
75:                  
76:                    Summary:
77:                      Implements Default variant of PLIB_DMA_ChannelXDestinationStartAddressGet
78:                  
79:                    Description:
80:                      This template implements the Default variant of the PLIB_DMA_ChannelXDestinationStartAddressGet function.
81:                      Operation is atomic.
82:                  */
83:                  
84:                  PLIB_TEMPLATE uint32_t DMA_ChannelXDestinationStartAddressGet_Default( DMA_MODULE_ID index , DMA_CHANNEL channel )
85:                  {
86:                      volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
87:                      uint32_t addr = regs->DCHxDSA;
88:                  
89:                      /* Check if the address lies in the KSEG2 for MZ devices */
90:                      if ((addr & 0x20000000) == 0x20000000) {
91:                  	if((addr >> 28)== 0x2) { // EBI Address translation
92:                  	    addr = (addr | 0xc0000000) & 0xcfffffff;
93:                  	} else if ((addr >> 28)== 0x3) { //SQI Address translation
94:                  	    addr = (addr | 0xd0000000) & 0xdfffffff;
95:                          }
96:                      } else {
97:                  	addr = (uint32_t)ConvertToVirtualAddress(addr);
98:                      }
99:                  
100:                     return addr;
101:                 }
102:                 
103:                 
104:                 //******************************************************************************
105:                 /* Function :  DMA_ChannelXDestinationStartAddressSet_Default
106:                 
107:                   Summary:
108:                     Implements Default variant of PLIB_DMA_ChannelXDestinationStartAddressSet
109:                 
110:                   Description:
111:                     This template implements the Default variant of the PLIB_DMA_ChannelXDestinationStartAddressSet function.
112:                     Operation is atomic.
113:                 */
114:                 
115:                 PLIB_TEMPLATE void DMA_ChannelXDestinationStartAddressSet_Default( DMA_MODULE_ID index , DMA_CHANNEL channel , uint32_t destinationStartAddress )
116:                 {
117:                     volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
118:                 
119:                     /* Check if the address lies in the KSEG2 for MZ devices */
120:                     if ((destinationStartAddress >> 29) == 0x6) {
9D00D744  00072742   SRL A0, A3, 29
9D00D748  24050006   ADDIU A1, ZERO, 6
9D00D74C  1485000E   BNE A0, A1, SYS_DMA_ChannelTransferAdd::PLIB_DMA_ChannelXDestinationStartAddressSet
9D00D750  00E01821   ADDU V1, A3, ZERO
121:                         // EBI Address translation
122:                 	if ((destinationStartAddress >> 28)== 0xc) {
9D00D754  00072702   SRL A0, A3, 28
9D00D758  2405000C   ADDIU A1, ZERO, 12
9D00D75C  14850005   BNE A0, A1, SYS_DMA_ChannelTransferAdd::PLIB_DMA_ChannelXDestinationStartAddressSet
9D00D760  2405000D   ADDIU A1, ZERO, 13
123:                             destinationStartAddress = ((destinationStartAddress | 0x20000000) & 0x2FFFFFFF);
9D00D764  7CE7D800   EXT A3, A3, 0, 28
9D00D768  3C032000   LUI V1, 8192
9D00D76C  0B4035F2   J 0x9D00D7C8
9D00D770  00E31825   OR V1, A3, V1
124:                         }
125:                 	//SQI Address translation
126:                 	else if ((destinationStartAddress >> 28)== 0xd) {
9D00D774  14850014   BNE A0, A1, 0x9D00D7C8
9D00D778  7CE7D800   EXT A3, A3, 0, 28
127:                             destinationStartAddress = ((destinationStartAddress | 0x30000000) & 0x3FFFFFFF);
9D00D77C  3C033000   LUI V1, 12288
9D00D780  0B4035F2   J 0x9D00D7C8
9D00D784  00E31825   OR V1, A3, V1
128:                         }
129:                     } else if ((destinationStartAddress >> 29) == 0x7) { /* Check if the address lies in the KSEG3 for MZ devices */
9D00D788  24050007   ADDIU A1, ZERO, 7
9D00D78C  5485000E   BNEL A0, A1, 0x9D00D7C8
9D00D790  7CE3E000   EXT V1, A3, 0, 29
130:                         // EBI Address translation
131:                 	if ((destinationStartAddress >> 28)== 0xe) {
9D00D794  00072702   SRL A0, A3, 28
9D00D798  2405000E   ADDIU A1, ZERO, 14
9D00D79C  14850005   BNE A0, A1, SYS_DMA_ChannelTransferAdd::PLIB_DMA_ChannelXDestinationStartAddressSet
9D00D7A0  2405000F   ADDIU A1, ZERO, 15
132:                             destinationStartAddress = ((destinationStartAddress | 0x20000000) & 0x2FFFFFFF);
9D00D7A4  7CE7D800   EXT A3, A3, 0, 28
9D00D7A8  3C032000   LUI V1, 8192
9D00D7AC  0B4035F2   J 0x9D00D7C8
9D00D7B0  00E31825   OR V1, A3, V1
133:                         }
134:                         //SQI Address translation
135:                 	else if ((destinationStartAddress >> 28)== 0xf) {
9D00D7B4  14850004   BNE A0, A1, 0x9D00D7C8
9D00D7B8  00000000   NOP
136:                             destinationStartAddress = ((destinationStartAddress | 0x30000000) & 0x3FFFFFFF);
9D00D7BC  7CE7D800   EXT A3, A3, 0, 28
9D00D7C0  3C033000   LUI V1, 12288
9D00D7C4  00E31825   OR V1, A3, V1
137:                         }
138:                     } else {
139:                         /*For KSEG0 and KSEG1, The translation is done by KVA_TO_PA */
140:                         destinationStartAddress = ConvertToPhysicalAddress(destinationStartAddress);
141:                     }
142:                 
143:                     regs->DCHxDSA = destinationStartAddress;
9D00D7C8  AC430040   SW V1, 64(V0)
144:                 }
145:                 
146:                 
147:                 #endif /*_DMA_CHANNELXDESTINATIONSTARTADDRESS_DEFAULT_H*/
148:                 
149:                 /******************************************************************************
150:                  End of File
151:                 */
152:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/dma/templates/dma_ChannelXDestinationSize_Default.h
1:                   /*******************************************************************************
2:                     DMA Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       dma_ChannelXDestinationSize_Default.h
6:                   
7:                     Summary:
8:                       DMA PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ChannelXDestinationSize
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_DMA_ExistsChannelXDestinationSize
16:                          PLIB_DMA_ChannelXDestinationSizeGet
17:                          PLIB_DMA_ChannelXDestinationSizeSet
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _DMA_CHANNELXDESTINATIONSIZE_DEFAULT_H
48:                  #define _DMA_CHANNELXDESTINATIONSIZE_DEFAULT_H
49:                  
50:                  #include "dma_Registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  DMA_ExistsChannelXDestinationSize_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_DMA_ExistsChannelXDestinationSize
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_DMA_ExistsChannelXDestinationSize function.
60:                  */
61:                  
62:                  #define PLIB_DMA_ExistsChannelXDestinationSize PLIB_DMA_ExistsChannelXDestinationSize
63:                  PLIB_TEMPLATE bool DMA_ExistsChannelXDestinationSize_Default( DMA_MODULE_ID index )
64:                  {
65:                      return true;
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  DMA_ChannelXDestinationSizeGet_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_DMA_ChannelXDestinationSizeGet
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_DMA_ChannelXDestinationSizeGet function.
77:                      Operation is atomic.
78:                  */
79:                  
80:                  PLIB_TEMPLATE uint16_t DMA_ChannelXDestinationSizeGet_Default( DMA_MODULE_ID index , DMA_CHANNEL channel )
81:                  {
82:                      volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
83:                  
84:                      return (uint16_t)regs->DCHxDSIZ;
85:                  }
86:                  
87:                  
88:                  //******************************************************************************
89:                  /* Function :  DMA_ChannelXDestinationSizeSet_Default
90:                  
91:                    Summary:
92:                      Implements Default variant of PLIB_DMA_ChannelXDestinationSizeSet
93:                  
94:                    Description:
95:                      This template implements the Default variant of the PLIB_DMA_ChannelXDestinationSizeSet function.
96:                      Operation is atomic.
97:                  */
98:                  
99:                  PLIB_TEMPLATE void DMA_ChannelXDestinationSizeSet_Default( DMA_MODULE_ID index , DMA_CHANNEL channel , uint16_t destinationSize )
100:                 {
101:                     volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
102:                 
103:                     regs->DCHxDSIZ = destinationSize;
9D00D7CC  97A30010   LHU V1, 16(SP)
9D00D7D0  AC430060   SW V1, 96(V0)
104:                 }
105:                 
106:                 
107:                 #endif /*_DMA_CHANNELXDESTINATIONSIZE_DEFAULT_H*/
108:                 
109:                 /******************************************************************************
110:                  End of File
111:                 */
112:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/dma/templates/dma_ChannelXChain_Default.h
1:                   /*******************************************************************************
2:                     DMA Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       dma_ChannelXChain_Default.h
6:                   
7:                     Summary:
8:                       DMA PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ChannelXChain
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_DMA_ExistsChannelXChain
16:                          PLIB_DMA_ChannelXChainToLower
17:                          PLIB_DMA_ChannelXChainToHigher
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _DMA_CHANNELXCHAIN_DEFAULT_H
48:                  #define _DMA_CHANNELXCHAIN_DEFAULT_H
49:                  
50:                  #include "dma_Registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  DMA_ExistsChannelXChain_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_DMA_ExistsChannelXChain
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_DMA_ExistsChannelXChain function.
60:                  */
61:                  
62:                  #define PLIB_DMA_ExistsChannelXChain PLIB_DMA_ExistsChannelXChain
63:                  PLIB_TEMPLATE bool DMA_ExistsChannelXChain_Default( DMA_MODULE_ID index )
64:                  {
65:                      return true;
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  DMA_ChannelXChainToLower_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_DMA_ChannelXChainToLower
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_DMA_ChannelXChainToLower function.
77:                      Operation is atomic.
78:                  */
79:                  
80:                  PLIB_TEMPLATE void DMA_ChannelXChainToLower_Default( DMA_MODULE_ID index , DMA_CHANNEL channel )
81:                  {
82:                      volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
83:                  
84:                      regs->DCHxCONSET = _DCH0CON_CHCHNS_MASK;
9D00D034  24030100   ADDIU V1, ZERO, 256
9D00D038  AC430008   SW V1, 8(V0)
85:                  }
86:                  
87:                  
88:                  //******************************************************************************
89:                  /* Function :  DMA_ChannelXChainToHigher_Default
90:                  
91:                    Summary:
92:                      Implements Default variant of PLIB_DMA_ChannelXChainToHigher
93:                  
94:                    Description:
95:                      This template implements the Default variant of the PLIB_DMA_ChannelXChainToHigher function.
96:                      Operation is atomic.
97:                  */
98:                  
99:                  PLIB_TEMPLATE void DMA_ChannelXChainToHigher_Default( DMA_MODULE_ID index , DMA_CHANNEL channel )
100:                 {
101:                     volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
102:                 
103:                     regs->DCHxCONCLR = _DCH0CON_CHCHNS_MASK;
9D00CFF4  24030100   ADDIU V1, ZERO, 256
9D00CFF8  AC430004   SW V1, 4(V0)
104:                 }
105:                 
106:                 
107:                 #endif /*_DMA_CHANNELXCHAIN_DEFAULT_H*/
108:                 
109:                 /******************************************************************************
110:                  End of File
111:                 */
112:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/dma/templates/dma_ChannelXChainEnbl_Default.h
1:                   /*******************************************************************************
2:                     DMA Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       dma_ChannelXChainEnbl_Default.h
6:                   
7:                     Summary:
8:                       DMA PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ChannelXChainEnbl
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_DMA_ExistsChannelXChainEnbl
16:                          PLIB_DMA_ChannelXChainEnable
17:                          PLIB_DMA_ChannelXChainDisable
18:                          PLIB_DMA_ChannelXChainIsEnabled
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _DMA_CHANNELXCHAINENBL_DEFAULT_H
49:                  #define _DMA_CHANNELXCHAINENBL_DEFAULT_H
50:                  
51:                  #include "dma_Registers.h"
52:                  
53:                  //******************************************************************************
54:                  /* Function :  DMA_ExistsChannelXChain_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_DMA_ExistsChannelXChainEnbl
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_DMA_ExistsChannelXChainEnbl function.
61:                  */
62:                  
63:                  #define PLIB_DMA_ExistsChannelXChainEnbl PLIB_DMA_ExistsChannelXChainEnbl
64:                  PLIB_TEMPLATE bool DMA_ExistsChannelXChainEnbl_Default( DMA_MODULE_ID index )
65:                  {
66:                      return true;
67:                  }
68:                  
69:                  
70:                  //******************************************************************************
71:                  /* Function :  DMA_ChannelXChainEnable_Default
72:                  
73:                    Summary:
74:                      Implements Default variant of PLIB_DMA_ChannelXChainEnable
75:                  
76:                    Description:
77:                      This template implements the Default variant of the PLIB_DMA_ChannelXChainEnable function.
78:                      Operation is atomic.
79:                  */
80:                  
81:                  PLIB_TEMPLATE void DMA_ChannelXChainEnable_Default( DMA_MODULE_ID index , DMA_CHANNEL channel )
82:                  {
83:                      volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
9D00CFD4  00041180   SLL V0, A0, 6
9D00CFD8  00041A00   SLL V1, A0, 8
9D00CFDC  00621023   SUBU V0, V1, V0
9D00CFE0  3C03BF88   LUI V1, -16504
9D00CFE4  24633060   ADDIU V1, V1, 12384
9D00CFE8  00431021   ADDU V0, V0, V1
9D00D014  00041180   SLL V0, A0, 6
9D00D018  00041A00   SLL V1, A0, 8
9D00D01C  00621023   SUBU V0, V1, V0
9D00D020  3C03BF88   LUI V1, -16504
9D00D024  24633060   ADDIU V1, V1, 12384
9D00D028  00431021   ADDU V0, V0, V1
84:                  
85:                      regs->DCHxCONSET = _DCH0CON_CHCHN_MASK;
9D00CFEC  24030020   ADDIU V1, ZERO, 32
9D00CFF0  AC430008   SW V1, 8(V0)
9D00D02C  24030020   ADDIU V1, ZERO, 32
9D00D030  AC430008   SW V1, 8(V0)
86:                  }
87:                  
88:                  
89:                  //******************************************************************************
90:                  /* Function :  DMA_ChannelXChainDisable_Default
91:                  
92:                    Summary:
93:                      Implements Default variant of PLIB_DMA_ChannelXChainDisable
94:                  
95:                    Description:
96:                      This template implements the Default variant of the PLIB_DMA_ChannelXChainDisable function.
97:                      Operation is atomic.
98:                  */
99:                  
100:                 PLIB_TEMPLATE void DMA_ChannelXChainDisable_Default( DMA_MODULE_ID index , DMA_CHANNEL channel )
101:                 {
102:                     volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
103:                 
104:                     regs->DCHxCONCLR = _DCH0CON_CHCHN_MASK;
105:                 }
106:                 
107:                 
108:                 //******************************************************************************
109:                 /* Function :  DMA_ChannelXChainIsEnabled_Default
110:                 
111:                   Summary:
112:                     Implements Default variant of PLIB_DMA_ChannelXChainIsEnabled
113:                 
114:                   Description:
115:                     This template implements the Default variant of the PLIB_DMA_ChannelXChainIsEnabled function.
116:                     Operation is atomic.
117:                 */
118:                 
119:                 PLIB_TEMPLATE bool DMA_ChannelXChainIsEnabled_Default( DMA_MODULE_ID index , DMA_CHANNEL channel )
120:                 {
121:                     volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
122:                 
123:                     return regs->DCHxCON.CHCHN;
124:                 }
125:                 
126:                 
127:                 #endif /*_DMA_CHANNELXCHAINENBL_DEFAULT_H*/
128:                 
129:                 /******************************************************************************
130:                  End of File
131:                 */
132:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/dma/templates/dma_ChannelXCellSize_Default.h
1:                   /*******************************************************************************
2:                     DMA Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       dma_ChannelXCellSize_Default.h
6:                   
7:                     Summary:
8:                       DMA PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ChannelXCellSize
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_DMA_ExistsChannelXCellSize
16:                          PLIB_DMA_ChannelXCellSizeGet
17:                          PLIB_DMA_ChannelXCellSizeSet
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _DMA_CHANNELXCELLSIZE_DEFAULT_H
48:                  #define _DMA_CHANNELXCELLSIZE_DEFAULT_H
49:                  
50:                  #include "dma_Registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  DMA_ExistsChannelXCellSize_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_DMA_ExistsChannelXCellSize
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_DMA_ExistsChannelXCellSize function.
60:                  */
61:                  
62:                  #define PLIB_DMA_ExistsChannelXCellSize PLIB_DMA_ExistsChannelXCellSize
63:                  PLIB_TEMPLATE bool DMA_ExistsChannelXCellSize_Default( DMA_MODULE_ID index )
64:                  {
65:                      return true;
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  DMA_ChannelXCellSizeGet_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_DMA_ChannelXCellSizeGet
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_DMA_ChannelXCellSizeGet function.
77:                      Operation is atomic.
78:                  */
79:                  
80:                  PLIB_TEMPLATE uint16_t DMA_ChannelXCellSizeGet_Default( DMA_MODULE_ID index , DMA_CHANNEL channel )
81:                  {
82:                      volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
83:                  
84:                      return (uint16_t)regs->DCHxCSIZ;
85:                  }
86:                  
87:                  
88:                  //******************************************************************************
89:                  /* Function :  DMA_ChannelXCellSizeSet_Default
90:                  
91:                    Summary:
92:                      Implements Default variant of PLIB_DMA_ChannelXCellSizeSet
93:                  
94:                    Description:
95:                      This template implements the Default variant of the PLIB_DMA_ChannelXCellSizeSet function.
96:                      Operation is atomic.
97:                  */
98:                  
99:                  PLIB_TEMPLATE void DMA_ChannelXCellSizeSet_Default( DMA_MODULE_ID index , DMA_CHANNEL channel , uint16_t CellSize )
100:                 {
101:                     volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
102:                 
103:                     regs->DCHxCSIZ = CellSize;
9D00D7D4  97A30014   LHU V1, 20(SP)
9D00D7D8  AC430090   SW V1, 144(V0)
104:                 }
105:                 
106:                 
107:                 #endif /*_DMA_CHANNELXCELLSIZE_DEFAULT_H*/
108:                 
109:                 /******************************************************************************
110:                  End of File
111:                 */
112:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/dma/templates/dma_ChannelXAuto_Default.h
1:                   /*******************************************************************************
2:                     DMA Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       dma_ChannelXAuto_Default.h
6:                   
7:                     Summary:
8:                       DMA PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ChannelXAuto
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_DMA_ExistsChannelXAuto
16:                          PLIB_DMA_ChannelXAutoEnable
17:                          PLIB_DMA_ChannelXAutoDisable
18:                          PLIB_DMA_ChannelXAutoIsEnabled
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _DMA_CHANNELXAUTO_DEFAULT_H
49:                  #define _DMA_CHANNELXAUTO_DEFAULT_H
50:                  
51:                  #include "dma_Registers.h"
52:                  
53:                  //******************************************************************************
54:                  /* Function :  DMA_ExistsChannelXAuto_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_DMA_ExistsChannelXAuto
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_DMA_ExistsChannelXAuto function.
61:                  */
62:                  
63:                  #define PLIB_DMA_ExistsChannelXAuto PLIB_DMA_ExistsChannelXAuto
64:                  PLIB_TEMPLATE bool DMA_ExistsChannelXAuto_Default( DMA_MODULE_ID index )
65:                  {
66:                      return true;
67:                  }
68:                  
69:                  
70:                  //******************************************************************************
71:                  /* Function :  DMA_ChannelXAutoEnable_Default
72:                  
73:                    Summary:
74:                      Implements Default variant of PLIB_DMA_ChannelXAutoEnable
75:                  
76:                    Description:
77:                      This template implements the Default variant of the PLIB_DMA_ChannelXAutoEnable function.
78:                      Operation is atomic.
79:                  */
80:                  
81:                  PLIB_TEMPLATE void DMA_ChannelXAutoEnable_Default( DMA_MODULE_ID index , DMA_CHANNEL channel )
82:                  {
83:                      volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
9D00D050  00041180   SLL V0, A0, 6
9D00D054  00041A00   SLL V1, A0, 8
9D00D058  00621023   SUBU V0, V1, V0
9D00D05C  3C03BF88   LUI V1, -16504
9D00D060  24633060   ADDIU V1, V1, 12384
9D00D064  00431021   ADDU V0, V0, V1
84:                  
85:                      regs->DCHxCONSET = _DCH0CON_CHAEN_MASK;
9D00D068  24030010   ADDIU V1, ZERO, 16
9D00D06C  AC430008   SW V1, 8(V0)
86:                  }
87:                  
88:                  
89:                  //******************************************************************************
90:                  /* Function :  DMA_ChannelXAutoDisable_Default
91:                  
92:                    Summary:
93:                      Implements Default variant of PLIB_DMA_ChannelXAutoDisable
94:                  
95:                    Description:
96:                      This template implements the Default variant of the PLIB_DMA_ChannelXAutoDisable function.
97:                      Operation is atomic.
98:                  */
99:                  
100:                 PLIB_TEMPLATE void DMA_ChannelXAutoDisable_Default( DMA_MODULE_ID index , DMA_CHANNEL channel )
101:                 {
102:                     volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
103:                 
104:                     regs->DCHxCONCLR = _DCH0CON_CHAEN_MASK;
105:                 }
106:                 
107:                 //******************************************************************************
108:                 /* Function :  DMA_ChannelXAutoIsEnabled_Default
109:                 
110:                   Summary:
111:                     Implements Default variant of PLIB_DMA_ChannelXAutoIsEnabled
112:                 
113:                   Description:
114:                     This template implements the Default variant of the PLIB_DMA_ChannelXAutoIsEnabled function.
115:                     Operation is atomic.
116:                 */
117:                 
118:                 PLIB_TEMPLATE bool DMA_ChannelXAutoIsEnabled_Default( DMA_MODULE_ID index , DMA_CHANNEL channel )
119:                 {
120:                     volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
121:                 
122:                     return (bool)regs->DCHxCON.CHAEN;
123:                 }
124:                 
125:                 
126:                 #endif /*_DMA_CHANNELXAUTO_DEFAULT_H*/
127:                 
128:                 /******************************************************************************
129:                  End of File
130:                 */
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/dma/templates/dma_AbortTransfer_Default.h
1:                   /*******************************************************************************
2:                     DMA Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       dma_AbortTransfer_Default.h
6:                   
7:                     Summary:
8:                       DMA PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : AbortTransfer
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_DMA_ExistsAbortTransfer
16:                          PLIB_DMA_AbortTransferSet
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _DMA_ABORTTRANSFER_DEFAULT_H
47:                  #define _DMA_ABORTTRANSFER_DEFAULT_H
48:                  
49:                  #include "dma_Registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  DMA_ExistsAbortTransfer_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_DMA_ExistsAbortTransfer
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_DMA_ExistsAbortTransfer function.
59:                  */
60:                  
61:                  #define PLIB_DMA_ExistsAbortTransfer PLIB_DMA_ExistsAbortTransfer
62:                  PLIB_TEMPLATE bool DMA_ExistsAbortTransfer_Default( DMA_MODULE_ID index )
63:                  {
64:                      return true;
65:                  }
66:                  
67:                  
68:                  //******************************************************************************
69:                  /* Function :  DMA_AbortTransferSet_Default
70:                  
71:                    Summary:
72:                      Implements Default variant of PLIB_DMA_AbortTransferSet
73:                  
74:                    Description:
75:                      This template implements the Default variant of the PLIB_DMA_AbortTransferSet function.
76:                      Operation is atomic.
77:                  */
78:                  
79:                  PLIB_TEMPLATE void DMA_AbortTransferSet_Default( DMA_MODULE_ID index , DMA_CHANNEL channel )
80:                  {
81:                      volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
9D014CF4  00041180   SLL V0, A0, 6
9D014CF8  00042200   SLL A0, A0, 8
9D014CFC  00822023   SUBU A0, A0, V0
9D014D00  3C02BF88   LUI V0, -16504
9D014D04  24423060   ADDIU V0, V0, 12384
9D014D08  00822021   ADDU A0, A0, V0
82:                  
83:                      regs->DCHxECONSET = _DCH0ECON_CABORT_MASK;
9D014D0C  24020040   ADDIU V0, ZERO, 64
84:                  }
85:                  
86:                  
87:                  #endif /*_DMA_ABORTTRANSFER_DEFAULT_H*/
88:                  
89:                  /******************************************************************************
90:                   End of File
91:                  */
92:                  
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/devcon/templates/devcon_SysLockUnlock_Default.h
1:                   /*******************************************************************************
2:                     DEVCON Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       devcon_SysLockUnlock_Default.h
6:                   
7:                     Summary:
8:                       DEVCON PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : SysLockUnlock
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_DEVCON_SystemUnlock
16:                          PLIB_DEVCON_SystemLock
17:                          PLIB_DEVCON_ExistsSystemLockUnlock
18:                          PLIB_DEVCON_ExistsDeviceVerAndId
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _DEVCON_SYSLOCKUNLOCK_DEFAULT_H
49:                  #define _DEVCON_SYSLOCKUNLOCK_DEFAULT_H
50:                  
51:                  //******************************************************************************
52:                  /* Function :  DEVCON_SystemUnlock_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_DEVCON_SystemUnlock 
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_DEVCON_SystemUnlock function.
59:                  */
60:                  
61:                  PLIB_TEMPLATE void DEVCON_SystemUnlock_Default( DEVCON_MODULE_ID index )
62:                  {	
63:                  	SYSKEY = 0x00000000;
9D00F4DC  3C02BF81   LUI V0, -16511
9D00F4E0  AC40F230   SW ZERO, -3536(V0)
9D01406C  3C02BF81   LUI V0, -16511
9D014070  AC40F230   SW ZERO, -3536(V0)
64:                  	SYSKEY = 0xAA996655;
9D00F4E4  3C03AA99   LUI V1, -21863
9D00F4E8  24636655   ADDIU V1, V1, 26197
9D00F4EC  AC43F230   SW V1, -3536(V0)
9D014074  3C04AA99   LUI A0, -21863
9D014078  24846655   ADDIU A0, A0, 26197
9D01407C  AC44F230   SW A0, -3536(V0)
65:                  	SYSKEY = 0x556699AA;
9D00F4F0  3C035566   LUI V1, 21862
9D00F4F4  346399AA   ORI V1, V1, -26198
9D00F4F8  AC43F230   SW V1, -3536(V0)
9D014080  3C045566   LUI A0, 21862
9D014084  348499AA   ORI A0, A0, -26198
9D014088  AC44F230   SW A0, -3536(V0)
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  DEVCON_SystemLock_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_DEVCON_SystemLock 
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_DEVCON_SystemLock function.
77:                  */
78:                  
79:                  PLIB_TEMPLATE void DEVCON_SystemLock_Default( DEVCON_MODULE_ID index )
80:                  {
81:                  	SYSKEY = 0x33333333;
9D0145F8  3C043333   LUI A0, 13107
9D0145FC  24843333   ADDIU A0, A0, 13107
9D014600  3C03BF81   LUI V1, -16511
9D014604  AC64F230   SW A0, -3536(V1)
82:                  }
83:                  
84:                  
85:                  //******************************************************************************
86:                  /* Function :  DEVCON_ExistsSystemLockUnlock_Default
87:                  
88:                    Summary:
89:                      Implements Default variant of PLIB_DEVCON_ExistsSystemLockUnlock
90:                  
91:                    Description:
92:                      This template implements the Default variant of the PLIB_DEVCON_ExistsSystemLockUnlock function.
93:                  */
94:                  
95:                  #define PLIB_DEVCON_ExistsSystemLockUnlock PLIB_DEVCON_ExistsSystemLockUnlock
96:                  PLIB_TEMPLATE bool DEVCON_ExistsSystemLockUnlock_Default( DEVCON_MODULE_ID index )
97:                  {
98:                      return true;
99:                  }
100:                 
101:                 #endif /*_DEVCON_SYSLOCKUNLOCK_DEFAULT_H*/
102:                 
103:                 /******************************************************************************
104:                  End of File
105:                 */
106:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/peripheral/bmx/templates/bmx_DataRamWaitState_Default.h
1:                   /*******************************************************************************
2:                     BMX Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       bmx_DataRamWaitState_Default.h
6:                   
7:                     Summary:
8:                       BMX PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : DataRamWaitState
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_BMX_ExistsDataRamWaitState
16:                          PLIB_BMX_DataRamWaitStateSet
17:                          PLIB_BMX_DataRamWaitStateGet
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _BMX_DATARAMWAITSTATE_DEFAULT_H
48:                  #define _BMX_DATARAMWAITSTATE_DEFAULT_H
49:                  
50:                  #include "bmx_registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  BMX_ExistsDataRamWaitState_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_BMX_ExistsDataRamWaitState
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_BMX_ExistsDataRamWaitState function.
60:                  */
61:                  
62:                  #define PLIB_BMX_ExistsDataRamWaitState PLIB_BMX_ExistsDataRamWaitState
63:                  PLIB_TEMPLATE bool BMX_ExistsDataRamWaitState_Default( BMX_MODULE_ID index )
64:                  {
65:                      return true;
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  BMX_DataRamWaitStateSet_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_BMX_DataRamWaitStateSet 
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_BMX_DataRamWaitStateSet function.
77:                  */
78:                  
79:                  PLIB_TEMPLATE void BMX_DataRamWaitStateSet_Default( BMX_MODULE_ID index , PLIB_BMX_DATA_RAM_WAIT_STATES wait )
80:                  {
81:                      volatile bmx_register_t *bmx = (bmx_register_t *)index;
82:                  
83:                      bmx->BMXCON.BMXWSDRM = wait;
9D0140D4  3C02BF88   LUI V0, -16504
9D0140D8  8C432000   LW V1, 8192(V0)
9D0140DC  7C033184   INS V1, ZERO, 6, 1
9D0140E0  AC432000   SW V1, 8192(V0)
84:                  }
85:                  
86:                  
87:                  //******************************************************************************
88:                  /* Function :  BMX_DataRamWaitStateGet_Default
89:                  
90:                    Summary:
91:                      Implements Default variant of PLIB_BMX_DataRamWaitStateGet 
92:                  
93:                    Description:
94:                      This template implements the Default variant of the PLIB_BMX_DataRamWaitStateGet function.
95:                  */
96:                  
97:                  PLIB_TEMPLATE PLIB_BMX_DATA_RAM_WAIT_STATES BMX_DataRamWaitStateGet_Default( BMX_MODULE_ID index )
98:                  {
99:                      volatile bmx_register_t *bmx = (bmx_register_t *)index;
100:                 
101:                     return (PLIB_BMX_DATA_RAM_WAIT_STATES)bmx->BMXCON.BMXWSDRM;
102:                 }
103:                 
104:                 
105:                 #endif /*_BMX_DATARAMWAITSTATE_DEFAULT_H*/
106:                 
107:                 /******************************************************************************
108:                  End of File
109:                 */
110:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/osal/src/osal_freertos.c  -----------------------
1:                   /*******************************************************************************
2:                     FreeRTOS OSAL compatibility layer
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       osal_freertos.c
9:                   
10:                    Summary:
11:                      Provide OSAL mappings for the FreeRTOS(tm) Real-time operating system
12:                  
13:                    Description:
14:                      This file contains functional implementations of the OSAL for FreeRTOS.
15:                  
16:                  *******************************************************************************/
17:                  
18:                  // DOM-IGNORE-BEGIN
19:                  /*******************************************************************************
20:                  Copyright (c) 2011-2013 released Microchip Technology Inc.  All rights reserved.
21:                  
22:                  Microchip licenses to you the right to use, modify, copy and distribute
23:                  Software only when embedded on a Microchip microcontroller or digital signal
24:                  controller that is integrated into your product or third party product
25:                  (pursuant to the sublicense terms in the accompanying license agreement).
26:                  
27:                  You should refer to the license agreement accompanying this Software for
28:                  additional information regarding your rights and obligations.
29:                  
30:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
31:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
32:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
33:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
34:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
35:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
36:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
37:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
38:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
39:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
40:                  *******************************************************************************/
41:                  // DOM-IGNORE-END
42:                  
43:                  
44:                  // *****************************************************************************
45:                  // *****************************************************************************
46:                  // Section: Included Files
47:                  // *****************************************************************************
48:                  // *****************************************************************************
49:                  /*  This section lists the other files that are included in this file.
50:                   */
51:                  
52:                  
53:                  #include "FreeRTOS.h"
54:                  #include "queue.h"
55:                  #include "semphr.h"
56:                  #include "task.h"
57:                  
58:                  #include "osal/osal_freertos.h"
59:                  
60:                  // *****************************************************************************
61:                  // *****************************************************************************
62:                  // Section: OSAL Routines
63:                  // *****************************************************************************
64:                  // *****************************************************************************
65:                  /* These routines implement the OSAL for the chosen RTOS.
66:                  */
67:                  
68:                  // Critical Section group
69:                  // *****************************************************************************
70:                  /* Function: void OSAL_CRIT_Enter(OSAL_CRIT_TYPE severity)
71:                  
72:                    Summary:
73:                      Enter a critical section with the specified severity level.
74:                  
75:                    Description:
76:                       The program is entering a critical section of code. It is assumed that the
77:                       sequence of operations bounded by the enter and leave critical section operations
78:                       is treated as one atomic sequence that will not be disturbed.
79:                  
80:                    Precondition:
81:                      None
82:                  
83:                    Parameters:
84:                      severity      - OSAL_CRIT_TYPE_LOW, The RTOS should disable all other running
85:                                      tasks effectively locking the scheduling mechanism.
86:                                    - OSAL_CRIT_TYPE_HIGH, The RTOS should disable all possible
87:                                      interrupts sources including the scheduler ensuring that the
88:                                      sequence of code operates without interruption.
89:                  
90:                    Returns:
91:                      None
92:                  
93:                    Example:
94:                      <code>
95:                       // prevent other tasks pre-empting this sequence of code
96:                       OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
97:                       // modify the peripheral
98:                       DRV_USART_Reinitialize( objUSART,  &initData);
99:                       OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW);
100:                     </code>
101:                 
102:                   Remarks:
103:                     The sequence of operations bounded by the OSAL_CRIT_Enter and OSAL_CRIT_Leave
104:                     form a critical section. The severity level defines whether the RTOS should
105:                     perform task locking or completely disable all interrupts.
106:                 
107:                    NOTE - 
108:                     In FreeRTOS only interrupts below configMAX_SYSCALL_INTERRUPT_PRIORITY are
109:                     disabled.  FreeRTOS will handle nesting of this function is scheduler is 
110:                     running.
111:                  */
112:                 OSAL_CRITSECT_DATA_TYPE OSAL_CRIT_Enter(OSAL_CRIT_TYPE severity)
113:                 {
114:                     switch (severity)
115:                     {
116:                         case OSAL_CRIT_TYPE_LOW:
117:                             /* LOW priority critical sections just disable the scheduler */
118:                             vTaskSuspendAll();
119:                             break;
120:                 
121:                         case OSAL_CRIT_TYPE_HIGH:
122:                             /* HIGH priority critical sections disable interrupts */
123:                             portENTER_CRITICAL();
124:                             break;
125:                     }
126:                     
127:                     return(0);
128:                 }
129:                 
130:                 // *****************************************************************************
131:                 /* Function: void OSAL_CRIT_Leave(OSAL_CRIT_TYPE severity,OSAL_CRITSECT_DATA_TYPE status)
132:                 
133:                   Summary:
134:                     Leave a critical section with the specified severity level.
135:                 
136:                   Description:
137:                      The program is leaving a critical section of code. It is assumed that the
138:                      sequence of operations bounded by the enter and leave critical section operations
139:                      is treated as one atomic sequence that will not be disturbed.
140:                     The severity should match the severity level used in the corresponding
141:                     OSAL_CRIT_Enter call to ensure that the RTOS carries out the correct action.
142:                 
143:                   Precondition:
144:                     None
145:                 
146:                   Parameters:
147:                     severity      - OSAL_CRIT_TYPE_LOW, The RTOS should disable all other running
148:                                     tasks effectively locking the scheduling mechanism.
149:                                   - OSAL_CRIT_TYPE_HIGH, The RTOS should disable all possible
150:                                     interrupts sources including the scheduler ensuring that the
151:                                     sequence of code operates without interruption.
152:                 
153:                   Returns:
154:                     None
155:                 
156:                   Example:
157:                     <code>
158:                      OSAL_CRITSECT_DATA_TYPE intStatus;
159:                      // prevent other tasks pre-empting this sequence of code
160:                      intStatus = OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
161:                      // modify the peripheral
162:                      DRV_USART_Reinitialize( objUSART,  &initData);
163:                      OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, intStatus);
164:                     </code>
165:                 
166:                   Remarks:
167:                     The sequence of operations bounded by the OSAL_CRIT_Enter and OSAL_CRIT_Leave
168:                     form a critical section. The severity level defines whether the RTOS should
169:                     perform task locking or completely disable all interrupts.
170:                 
171:                  */
172:                 void OSAL_CRIT_Leave(OSAL_CRIT_TYPE severity, OSAL_CRITSECT_DATA_TYPE status)
173:                 {
174:                     switch (severity)
175:                     {
176:                         case OSAL_CRIT_TYPE_LOW:
177:                             /* LOW priority resumes scheduler */
178:                             xTaskResumeAll();
179:                             break;
180:                 
181:                         case OSAL_CRIT_TYPE_HIGH:
182:                             /* HIGH priority renables interrupts */
183:                             portEXIT_CRITICAL();
184:                             break;
185:                     }
186:                 }
187:                 
188:                 // Semaphore group
189:                 // *****************************************************************************
190:                 /* Function: OSAL_RESULT OSAL_SEM_Create(OSAL_SEM_HANDLE_TYPE* semID, OSAL_SEM_TYPE type,
191:                                                 uint8_t maxCount, uint8_t initialCount)
192:                   Summary:
193:                     Create an OSAL Semaphore
194:                 
195:                   Description:
196:                     Create an OSAL binary or counting semaphore. If OSAL_SEM_TYPE_BINARY is specified then
197:                     the maxcount and initialCount values are ignored otherwise these must contain valid
198:                     values.
199:                 
200:                   Precondition:
201:                     Semaphore must have been declared.
202:                 
203:                   Parameters:
204:                     semID       - Pointer to the Semaphore ID
205:                 
206:                     type        - OSAL_SEM_TYPE_BINARY, create a binary semaphore
207:                                 - OSAL_SEM_TYPE_COUNTING, create a counting semaphore with the specified
208:                                   count values.
209:                 
210:                     maxCount    - Maximum value for a counting semaphore. Ignored for a BINARY semaphore.
211:                 
212:                     initialCount - Starting count value for the semaphore. Ignored for a BINARY semaphore
213:                 
214:                   Returns:
215:                     OSAL_RESULT_TRUE    - Semaphore created
216:                     OSAL_RESULT_FALSE   - Semaphore creation failed
217:                 
218:                   Example:
219:                     <code>
220:                     OSAL_SEM_Create(&mySemID, OSAL_SEM_TYPE_COUNTING, 10, 5);
221:                     </code>
222:                 
223:                   Remarks:
224:                  */
225:                 OSAL_RESULT OSAL_SEM_Create(OSAL_SEM_HANDLE_TYPE* semID, OSAL_SEM_TYPE type, uint8_t maxCount, uint8_t initialCount)
226:                 {
9D01272C  27BDFFE8   ADDIU SP, SP, -24
9D012730  AFBF0014   SW RA, 20(SP)
9D012734  AFB00010   SW S0, 16(SP)
227:                    switch (type) {
9D012738  10A00006   BEQ A1, ZERO, 0x9D012754
9D01273C  00808021   ADDU S0, A0, ZERO
9D012740  24020001   ADDIU V0, ZERO, 1
9D012744  50A20010   BEQL A1, V0, 0x9D012788
9D012748  00C02021   ADDU A0, A2, ZERO
228:                       case OSAL_SEM_TYPE_BINARY:
229:                          vSemaphoreCreateBinary(*(SemaphoreHandle_t*)semID);
9D012754  24040001   ADDIU A0, ZERO, 1
9D012758  00002821   ADDU A1, ZERO, ZERO
9D01275C  0F4048CD   JAL xQueueGenericCreate
9D012760  24060003   ADDIU A2, ZERO, 3
9D012764  1040000E   BEQ V0, ZERO, 0x9D0127A0
9D012768  AE020000   SW V0, 0(S0)
9D01276C  00402021   ADDU A0, V0, ZERO
9D012770  00002821   ADDU A1, ZERO, ZERO
9D012774  00003021   ADDU A2, ZERO, ZERO
9D012778  0F401FB3   JAL xQueueGenericSend
9D01277C  00003821   ADDU A3, ZERO, ZERO
230:                          break;
231:                 
232:                       case OSAL_SEM_TYPE_COUNTING:
233:                          *(SemaphoreHandle_t*)semID = xSemaphoreCreateCounting((UBaseType_t)maxCount, (UBaseType_t)initialCount);
9D012788  0F4053DB   JAL xQueueCreateCountingSemaphore
9D01278C  00E02821   ADDU A1, A3, ZERO
234:                          break;
9D012790  0B4049E8   J 0x9D0127A0
9D012794  AE020000   SW V0, 0(S0)
235:                 
236:                       default:
237:                          *(SemaphoreHandle_t*)semID = NULL;
9D01274C  0B4049E6   J 0x9D012798
9D012750  AC800000   SW ZERO, 0(A0)
238:                          return OSAL_RESULT_NOT_IMPLEMENTED;
9D012798  0B4049EA   J 0x9D0127A8
9D01279C  2402FFFF   ADDIU V0, ZERO, -1
239:                    }
240:                 
241:                    if (*(SemaphoreHandle_t*)semID == NULL)
9D012780  0B4049E9   J 0x9D0127A4
9D012784  8E020000   LW V0, 0(S0)
9D0127A0  8E020000   LW V0, 0(S0)
9D0127A4  0002102B   SLTU V0, ZERO, V0
242:                    {
243:                       return OSAL_RESULT_FALSE;
244:                    }
245:                 
246:                    return OSAL_RESULT_TRUE;
247:                 }
9D0127A8  8FBF0014   LW RA, 20(SP)
9D0127AC  8FB00010   LW S0, 16(SP)
9D0127B0  03E00008   JR RA
9D0127B4  27BD0018   ADDIU SP, SP, 24
248:                 
249:                 // *****************************************************************************
250:                 /* Function: OSAL_RESULT OSAL_SEM_Delete(OSAL_SEM_HANDLE_TYPE* semID)
251:                 
252:                   Summary:
253:                     Delete an OSAL Semaphore
254:                 
255:                   Description:
256:                     Delete an OSAL semaphore freeing up any allocated storage associated with it.
257:                 
258:                   Precondition:
259:                     Semaphore must have been created.
260:                 
261:                   Parameters:
262:                     semID       - Pointer to the semID
263:                 
264:                   Returns:
265:                     OSAL_RESULT_TRUE    - Semaphore deleted
266:                     OSAL_RESULT_FALSE   - Semaphore deletion failed
267:                 
268:                   Example:
269:                     <code>
270:                      OSAL_SEM_Delete(&mySemID);
271:                    </code>
272:                 
273:                   Remarks:
274:                  */
275:                 OSAL_RESULT OSAL_SEM_Delete(OSAL_SEM_HANDLE_TYPE* semID)
276:                 {
277:                    vSemaphoreDelete(*(SemaphoreHandle_t*)semID);
278:                    *(SemaphoreHandle_t*)semID = NULL;
279:                    return OSAL_RESULT_TRUE;
280:                 }
281:                 
282:                 // *****************************************************************************
283:                 /* Function: OSAL_RESULT OSAL_SEM_Pend(OSAL_SEM_HANDLE_TYPE* semID, uint16_t waitMS)
284:                 
285:                   Summary:
286:                      Pend on a semaphore. Returns true if semaphore obtained within time limit.
287:                 
288:                   Description:
289:                      Blocking function call that pends (waits) on a semaphore. The function will
290:                      return true is the semaphore has been obtained or false if it was not available
291:                      or the time limit was exceeded.
292:                 
293:                   Precondition:
294:                      Semaphore must have been created.
295:                 
296:                   Parameters:
297:                      semID       - The semID
298:                 
299:                     waitMS       - Time limit to wait in milliseconds.
300:                                    0 - do not wait
301:                                    OSAL_WAIT_FOREVER - return only when semaphore is obtained
302:                                    Other values - timeout delay
303:                 
304:                   Returns:
305:                     OSAL_RESULT_TRUE    - Semaphore obtained
306:                     OSAL_RESULT_FALSE   - Semaphore not obtained or timeout occurred
307:                 
308:                   Example:
309:                     <code>
310:                     if (OSAL_SEM_Pend(semUARTRX, 50) == OSAL_RESULT_TRUE)
311:                     {
312:                         // character available
313:                         c = DRV_USART_ReadByte(drvID);
314:                         ...
315:                     }
316:                     else
317:                     {
318:                         // character not available, resend prompt
319:                         ...
320:                     }
321:                    </code>
322:                 
323:                   Remarks:
324:                  */
325:                 OSAL_RESULT OSAL_SEM_Pend(OSAL_SEM_HANDLE_TYPE* semID, uint16_t waitMS)
326:                 {
9D01495C  27BDFFE8   ADDIU SP, SP, -24
9D014960  AFBF0014   SW RA, 20(SP)
327:                    TickType_t timeout = 0;
328:                 
329:                    if(waitMS == OSAL_WAIT_FOREVER)
330:                    {
331:                       timeout = portMAX_DELAY;
332:                    }
333:                    else
334:                    {
335:                       timeout = (TickType_t)(waitMS / portTICK_PERIOD_MS);
9D014964  00051882   SRL V1, A1, 2
9D014968  38A5FFFF   XORI A1, A1, -1
9D01496C  2402FFFF   ADDIU V0, ZERO, -1
9D014970  00403021   ADDU A2, V0, ZERO
9D014974  0065300B   MOVN A2, V1, A1
336:                    }
337:                    if (xSemaphoreTake(*(SemaphoreHandle_t*)semID, timeout) == pdTRUE)
9D014978  8C840000   LW A0, 0(A0)
9D01497C  00002821   ADDU A1, ZERO, ZERO
9D014980  0F401E81   JAL xQueueGenericReceive
9D014984  00003821   ADDU A3, ZERO, ZERO
9D014988  38420001   XORI V0, V0, 1
338:                       return OSAL_RESULT_TRUE;
339:                    else
340:                       return OSAL_RESULT_FALSE;
341:                 }
9D01498C  2C420001   SLTIU V0, V0, 1
9D014990  8FBF0014   LW RA, 20(SP)
9D014994  03E00008   JR RA
9D014998  27BD0018   ADDIU SP, SP, 24
342:                 
343:                 // *****************************************************************************
344:                 /* Function: OSAL_RESULT OSAL_SEM_Post(OSAL_SEM_HANDLE_TYPE* semID)
345:                 
346:                   Summary:
347:                      Post a semaphore or increment a counting semaphore.
348:                 
349:                   Description:
350:                      Post a binary semaphore or increment a counting semaphore. The highest
351:                      priority task currently blocked on the semaphore will be released and
352:                      made ready to run.
353:                 
354:                   Precondition:
355:                      Semaphore must have been created.
356:                 
357:                   Parameters:
358:                      semID       - The semID
359:                 
360:                   Returns:
361:                     OSAL_RESULT_TRUE    - Semaphore posted
362:                     OSAL_RESULT_FALSE   - Semaphore not posted
363:                 
364:                   Example:
365:                     <code>
366:                     OSAL_SEM_Post(semSignal);
367:                     </code>
368:                 
369:                   Remarks:
370:                  */
371:                 OSAL_RESULT OSAL_SEM_Post(OSAL_SEM_HANDLE_TYPE* semID)
372:                 {
373:                    if (xSemaphoreGive(*(SemaphoreHandle_t*)semID) == pdTRUE)
374:                    {
375:                       return OSAL_RESULT_TRUE;
376:                    }
377:                    return OSAL_RESULT_FALSE;
378:                 }
379:                 
380:                 // *****************************************************************************
381:                 /* Function: OSAL_RESULT OSAL_SEM_PostISR(OSAL_SEM_HANDLE_TYPE* semID)
382:                 
383:                   Summary:
384:                      Post a semaphore or increment a counting semaphore from within an ISR
385:                 
386:                   Description:
387:                      Post a binary semaphore or increment a counting semaphore. The highest
388:                      priority task currently blocked on the semaphore will be released and
389:                      made ready to run. This form of the post function should be used inside
390:                     an ISR.
391:                 
392:                   Precondition:
393:                      Semaphore must have been created.
394:                 
395:                   Parameters:
396:                      semID       - The semID
397:                 
398:                   Returns:
399:                     OSAL_RESULT_TRUE    - Semaphore posted
400:                     OSAL_RESULT_FALSE   - Semaphore not posted
401:                 
402:                   Example:
403:                     <code>
404:                      void __ISR(UART_2_VECTOR) _UART2RXHandler()
405:                      {
406:                         char c;
407:                         // read the character
408:                         c = U2RXREG;
409:                         // clear the interrupt flag
410:                         IFS1bits.U2IF = 0;
411:                         // post a semaphore indicating a character has been received
412:                         OSAL_SEM_PostISR(semSignal);
413:                      }
414:                     </code>
415:                 
416:                   Remarks:
417:                      This version of the OSAL_SEM_Post function should be used if the program
418:                      is, or may be, operating inside and ISR. The OSAL will take the necessary
419:                      steps to ensure correct operation possibly disabling interrupts or entering
420:                      a critical section. The exact requirements will depend upon the particular
421:                      RTOS being used.
422:                  */
423:                 OSAL_RESULT OSAL_SEM_PostISR(OSAL_SEM_HANDLE_TYPE* semID)
424:                 {
9D01439C  27BDFFE0   ADDIU SP, SP, -32
9D0143A0  AFBF001C   SW RA, 28(SP)
425:                    BaseType_t _taskWoken = pdFALSE;
9D0143A4  AFA00010   SW ZERO, 16(SP)
426:                    
427:                    if (xSemaphoreGiveFromISR(*(SemaphoreHandle_t*)semID, &_taskWoken))
9D0143A8  8C840000   LW A0, 0(A0)
9D0143AC  0F4040B2   JAL xQueueGiveFromISR
9D0143B0  27A50010   ADDIU A1, SP, 16
9D0143B4  10400008   BEQ V0, ZERO, 0x9D0143D8
9D0143B8  00001821   ADDU V1, ZERO, ZERO
428:                    {
429:                       portEND_SWITCHING_ISR(_taskWoken);
9D0143BC  8FA20010   LW V0, 16(SP)
9D0143C0  10400005   BEQ V0, ZERO, 0x9D0143D8
9D0143C4  24030001   ADDIU V1, ZERO, 1
9D0143C8  40026800   MFC0 V0, Cause
9D0143CC  34420100   ORI V0, V0, 256
9D0143D0  40826800   MTC0 V0, Cause
9D0143D4  000000C0   EHB
430:                       return OSAL_RESULT_TRUE;
431:                    }
432:                    return OSAL_RESULT_FALSE;
433:                 }
9D0143D8  00601021   ADDU V0, V1, ZERO
9D0143DC  8FBF001C   LW RA, 28(SP)
9D0143E0  03E00008   JR RA
9D0143E4  27BD0020   ADDIU SP, SP, 32
434:                 
435:                 // *****************************************************************************
436:                 /* Function: uint8_t OSAL_SEM_GetCount(OSAL_SEM_HANDLE_TYPE* semID)
437:                 
438:                   Summary:
439:                     Return the current value of a counting semaphore.
440:                 
441:                   Description:
442:                     Return the current value of a counting semaphore. The value returned is
443:                     assumed to be a single value ranging from 0-255.
444:                 
445:                   Precondition:
446:                      Semaphore must have been created.
447:                 
448:                   Parameters:
449:                      semID       - The semID
450:                 
451:                   Returns:
452:                     0           - Semaphore is unavailable
453:                     1-255       - Current value of the counting semaphore
454:                 
455:                   Example:
456:                     <code>
457:                      uint8_t semCount;
458:                 
459:                      semCount = OSAL_SEM_GetCount(semUART);
460:                 
461:                      if (semCount > 0)
462:                      {
463:                         // obtain the semaphore
464:                          if (OSAL_SEM_Pend(semUART) == OSAL_RESULT_TRUE)
465:                          {
466:                             // perform processing on the comm channel
467:                             ...
468:                          }
469:                      }
470:                      else
471:                      {
472:                         // no comm channels available
473:                         ...
474:                      }
475:                     </code>
476:                 
477:                   Remarks:
478:                      This version of the OSAL_SEM_Post function should be used if the program
479:                      is, or may be, operating inside and ISR. The OSAL will take the necessary
480:                      steps to ensure correct operation possibly disabling interrupts or entering
481:                      a critical section. The exact requirements will depend upon the particular
482:                      RTOS being used.
483:                  */
484:                 uint8_t OSAL_SEM_GetCount(OSAL_SEM_HANDLE_TYPE* semID)
485:                 {
486:                    UBaseType_t SemCount;
487:                    SemCount = uxQueueMessagesWaiting(*(SemaphoreHandle_t*)semID);
488:                    if(SemCount > 255)
489:                       SemCount = 255;
490:                    return SemCount;
491:                 }
492:                 
493:                 // *****************************************************************************
494:                 /* Function: OSAL_RESULT OSAL_MUTEX_Create(OSAL_MUTEX_HANDLE_TYPE* mutexID)
495:                 
496:                   Summary:
497:                     Create a mutex.
498:                 
499:                   Description:
500:                     This function creates a mutex, allocating storage if required and placing
501:                     the mutex handle into the passed parameter.
502:                 
503:                   Precondition:
504:                     None.
505:                 
506:                   Parameters:
507:                     mutexID      - Pointer to the mutex handle
508:                 
509:                   Returns:
510:                     OSAL_RESULT_TRUE    - Mutex successfully created
511:                 
512:                     OSAL_RESULT_FALSE   - Mutex failed to be created.
513:                 
514:                   Example:
515:                     <code>
516:                     OSAL_MUTEX_HANDLE_TYPE mutexData;
517:                 
518:                     OSAL_MUTEX_Create(&mutexData);
519:                     ...
520:                      if (OSAL_MUTEX_Lock(mutexData, 1000) == OSAL_RESULT_TRUE)
521:                      {
522:                         // manipulate the shared data
523:                         ...
524:                      }
525:                     </code>
526:                 
527:                   Remarks:
528:                 
529:                  */
530:                 OSAL_RESULT OSAL_MUTEX_Create(OSAL_MUTEX_HANDLE_TYPE* mutexID)
531:                 {
9D014AD4  27BDFFE8   ADDIU SP, SP, -24
9D014AD8  AFBF0014   SW RA, 20(SP)
9D014ADC  AFB00010   SW S0, 16(SP)
9D014AE0  00808021   ADDU S0, A0, ZERO
532:                     /* mutex may already have been created so test before creating it */
533:                     if (*(SemaphoreHandle_t*)mutexID != NULL)
9D014AE4  8C830000   LW V1, 0(A0)
9D014AE8  14600005   BNE V1, ZERO, 0x9D014B00
9D014AEC  00001021   ADDU V0, ZERO, ZERO
534:                     {
535:                         return OSAL_RESULT_FALSE;
536:                     }
537:                 
538:                     *(SemaphoreHandle_t*)mutexID = xSemaphoreCreateMutex();
9D014AF0  0F404FEB   JAL xQueueCreateMutex
9D014AF4  24040001   ADDIU A0, ZERO, 1
9D014AF8  AE020000   SW V0, 0(S0)
539:                     return OSAL_RESULT_TRUE;
9D014AFC  24020001   ADDIU V0, ZERO, 1
540:                 }
9D014B00  8FBF0014   LW RA, 20(SP)
9D014B04  8FB00010   LW S0, 16(SP)
9D014B08  03E00008   JR RA
9D014B0C  27BD0018   ADDIU SP, SP, 24
541:                 
542:                 // *****************************************************************************
543:                 /* Function: OSAL_RESULT OSAL_MUTEX_Delete(OSAL_MUTEX_HANDLE_TYPE* mutexID)
544:                 
545:                   Summary:
546:                     Delete a mutex.
547:                 
548:                   Description:
549:                     This function deletes a mutex and frees associated storage if required.
550:                 
551:                   Precondition:
552:                     None.
553:                 
554:                   Parameters:
555:                     mutexID      - Pointer to the mutex handle
556:                 
557:                   Returns:
558:                     OSAL_RESULT_TRUE    - Mutex successfully deleted.
559:                 
560:                     OSAL_RESULT_FALSE   - Mutex failed to be deleted.
561:                 
562:                   Example:
563:                     <code>
564:                     OSAL_MUTEX_Delete(mutexData);
565:                     </code>
566:                 
567:                   Remarks:
568:                 
569:                  */
570:                 OSAL_RESULT OSAL_MUTEX_Delete(OSAL_MUTEX_HANDLE_TYPE* mutexID)
571:                 {
572:                     if(*(SemaphoreHandle_t*)mutexID == NULL)
573:                     {
574:                        return OSAL_RESULT_FALSE;
575:                     }
576:                     vSemaphoreDelete(*(SemaphoreHandle_t*)mutexID);
577:                     *(SemaphoreHandle_t*)mutexID = NULL;
578:                     return OSAL_RESULT_TRUE;
579:                 }
580:                 
581:                 // *****************************************************************************
582:                 /* Function: OSAL_RESULT OSAL_MUTEX_Lock(OSAL_MUTEX_HANDLE_TYPE* mutexID, uint16_t waitMS)
583:                 
584:                   Summary:
585:                     Lock a mutex.
586:                 
587:                   Description:
588:                     This function locks a mutex, waiting for the specified timeout. If it cannot
589:                     be obtained or the timeout period elapses then false is returned;
590:                 
591:                   Precondition:
592:                     None.
593:                 
594:                   Parameters:
595:                     mutexID      - The mutex handle
596:                 
597:                     waitMS       - Timeout value in milliseconds,
598:                                    0 - do not wait, return immediately
599:                                    OSAL_WAIT_FOREVER - wait until mutex is obtained before returning
600:                                    Other values - Timeout delay
601:                 
602:                   Returns:
603:                     OSAL_RESULT_TRUE    - Mutex successfully obtained.
604:                 
605:                     OSAL_RESULT_FALSE   - Mutex failed to be obtained or timeout occurred.
606:                 
607:                   Example:
608:                     <code>
609:                     OSAL_MUTEX_HANDLE_TYPE* mutexData;
610:                 
611:                     OSAL_MUTEX_Create(&mutexData);
612:                     ...
613:                      if (OSAL_MUTEX_Lock(mutexData, 1000) == OSAL_RESULT_TRUE)
614:                      {
615:                         // manipulate the shared data
616:                         ...
617:                 
618:                         // unlock the mutex
619:                         OSAL_MUTEX_Unlock(mutexData);
620:                      }
621:                     </code>
622:                 
623:                   Remarks:
624:                 
625:                  */
626:                 OSAL_RESULT OSAL_MUTEX_Lock(OSAL_MUTEX_HANDLE_TYPE* mutexID, uint16_t waitMS)
627:                 {
9D01499C  27BDFFE8   ADDIU SP, SP, -24
9D0149A0  AFBF0014   SW RA, 20(SP)
628:                    TickType_t timeout = 0;
629:                    
630:                    if(waitMS == OSAL_WAIT_FOREVER)
631:                    {
632:                       timeout = portMAX_DELAY;
633:                    }
634:                    else
635:                    {
636:                       timeout = (TickType_t)(waitMS / portTICK_PERIOD_MS);
9D0149A4  00051882   SRL V1, A1, 2
9D0149A8  38A5FFFF   XORI A1, A1, -1
9D0149AC  2402FFFF   ADDIU V0, ZERO, -1
9D0149B0  00403021   ADDU A2, V0, ZERO
9D0149B4  0065300B   MOVN A2, V1, A1
637:                    }
638:                    if (xSemaphoreTake(*(SemaphoreHandle_t*)mutexID, timeout) == pdTRUE)
9D0149B8  8C840000   LW A0, 0(A0)
9D0149BC  00002821   ADDU A1, ZERO, ZERO
9D0149C0  0F401E81   JAL xQueueGenericReceive
9D0149C4  00003821   ADDU A3, ZERO, ZERO
9D0149C8  38420001   XORI V0, V0, 1
639:                       return OSAL_RESULT_TRUE;
640:                    else
641:                       return OSAL_RESULT_FALSE;
642:                 }
9D0149CC  2C420001   SLTIU V0, V0, 1
9D0149D0  8FBF0014   LW RA, 20(SP)
9D0149D4  03E00008   JR RA
9D0149D8  27BD0018   ADDIU SP, SP, 24
643:                 
644:                 // *****************************************************************************
645:                 /* Function: OSAL_RESULT OSAL_MUTEX_Unlock(OSAL_MUTEX_HANDLE_TYPE* mutexID)
646:                 
647:                   Summary:
648:                     Unlock a mutex.
649:                 
650:                   Description:
651:                     This function unlocks a previously obtained mutex.
652:                 
653:                   Precondition:
654:                     None.
655:                 
656:                   Parameters:
657:                     mutexID      - The mutex handle
658:                 
659:                   Returns:
660:                     OSAL_RESULT_TRUE    - Mutex released.
661:                 
662:                     OSAL_RESULT_FALSE   - Mutex failed to be released or error occurred.
663:                 
664:                   Example:
665:                     <code>
666:                     OSAL_MUTEX_HANDLE_TYPE* mutexData;
667:                 
668:                     OSAL_MUTEX_Create(&mutexData);
669:                     ...
670:                      if (OSAL_MUTEX_Lock(mutexData, 1000) == OSAL_RESULT_TRUE)
671:                      {
672:                         // manipulate the shared data
673:                         ...
674:                 
675:                         // unlock the mutex
676:                         OSAL_MUTEX_Unlock(mutexData);
677:                      }
678:                     </code>
679:                 
680:                   Remarks:
681:                 
682:                  */
683:                 OSAL_RESULT OSAL_MUTEX_Unlock(OSAL_MUTEX_HANDLE_TYPE* mutexID)
684:                 {
9D015068  27BDFFE8   ADDIU SP, SP, -24
9D01506C  AFBF0014   SW RA, 20(SP)
685:                 
686:                    if (xSemaphoreGive(*(SemaphoreHandle_t*)mutexID) == pdTRUE)
9D015070  8C840000   LW A0, 0(A0)
9D015074  00002821   ADDU A1, ZERO, ZERO
9D015078  00003021   ADDU A2, ZERO, ZERO
9D01507C  0F401FB3   JAL xQueueGenericSend
9D015080  00003821   ADDU A3, ZERO, ZERO
9D015084  38420001   XORI V0, V0, 1
687:                    {
688:                       return OSAL_RESULT_TRUE;
689:                    }
690:                 
691:                    return OSAL_RESULT_FALSE;
692:                 }
9D015088  2C420001   SLTIU V0, V0, 1
9D01508C  8FBF0014   LW RA, 20(SP)
9D015090  03E00008   JR RA
9D015094  27BD0018   ADDIU SP, SP, 24
693:                 
694:                 // *****************************************************************************
695:                 /* Function: const char* OSAL_Name()
696:                 
697:                   Summary:
698:                     Obtain the name of the underlying RTOS.
699:                 
700:                   Description:
701:                     This function returns a const char* to the textual name of the RTOS.
702:                     The name is a NULL terminated string.
703:                 
704:                   Precondition:
705:                     None
706:                 
707:                   Parameters:
708:                     None
709:                 
710:                   Returns:
711:                     const char* -   Name of the underlying RTOS or NULL
712:                 
713:                   Example:
714:                     <code>
715:                     // get the RTOS name
716:                     const char* sName;
717:                 
718:                     sName = OSAL_Name();
719:                     sprintf(buff, "RTOS: %s", sName);
720:                     </code>
721:                 
722:                   Remarks:
723:                 
724:                  */
725:                 __inline__ __attribute__ ((gnu_inline)) __attribute__((always_inline)) inline const char* OSAL_Name (void)
726:                 {
727:                     return "FreeRTOS";
728:                 }
729:                 
730:                 
731:                 // *****************************************************************************
732:                 /* Function: OSAL_RESULT OSAL_Initialize()
733:                 
734:                   Summary:
735:                     Perform OSAL initialization.
736:                 
737:                   Description:
738:                      This function should be called near the start of main in an application
739:                      that will use an underlying RTOS. This permits the RTOS to perform
740:                      any one time initialization before the application attempts to create
741:                      drivers or other items that may use the RTOS. Typical actions performed by
742:                      OSAL_Initialize would be to allocate and prepare any memory pools for
743:                      later use.
744:                 
745:                   Precondition:
746:                     None.
747:                 
748:                   Parameters:
749:                     None.
750:                 
751:                   Returns:
752:                     OSAL_RESULT_TRUE  - Initialization completed successfully.
753:                 
754:                   Example:
755:                     <code>
756:                      int main()
757:                      {
758:                          OSAL_Initialize();
759:                 
760:                          App_Init();
761:                          OSAL_Start();
762:                      }
763:                     </code>
764:                 
765:                   Remarks:
766:                  */
767:                 OSAL_RESULT OSAL_Initialize()
768:                 {
769:                     // nothing required
770:                     return OSAL_RESULT_TRUE;
771:                 }
772:                 
773:                 /*******************************************************************************
774:                  End of File
775:                 */
776:                 
777:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/driver/usb/usbfs/src/dynamic/drv_usbfs_device.c  
1:                   /*******************************************************************************
2:                     USB Device Driver Implementation of device mode operation routines
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       drv_usbfs_device.c
9:                   
10:                    Summary:
11:                      USB Device Driver Dynamic Implementation of device mode operation routines
12:                  
13:                    Description:
14:                      The USB device driver provides a simple interface to manage the USB modules
15:                      on Microchip microcontrollers.  This file implements the interface routines
16:                      for the USB driver when operating in device mode.
17:                  
18:                      While building the driver from source, ALWAYS use this file in the build if
19:                      device mode operation is required.
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip  Technology  Inc.   All  rights  reserved.
25:                  
26:                  Microchip licenses to  you  the  right  to  use,  modify,  copy  and  distribute
27:                  Software only when embedded on a Microchip  microcontroller  or  digital  signal
28:                  controller  that  is  integrated  into  your  product  or  third  party  product
29:                  (pursuant to the  sublicense  terms  in  the  accompanying  license  agreement).
30:                  
31:                  You should refer  to  the  license  agreement  accompanying  this  Software  for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS  WITHOUT  WARRANTY  OF  ANY  KIND,
35:                  EITHER EXPRESS  OR  IMPLIED,  INCLUDING  WITHOUT  LIMITATION,  ANY  WARRANTY  OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A  PARTICULAR  PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR  ITS  LICENSORS  BE  LIABLE  OR  OBLIGATED  UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION,  BREACH  OF  WARRANTY,  OR
39:                  OTHER LEGAL  EQUITABLE  THEORY  ANY  DIRECT  OR  INDIRECT  DAMAGES  OR  EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY  INCIDENTAL,  SPECIAL,  INDIRECT,  PUNITIVE  OR
41:                  CONSEQUENTIAL DAMAGES, LOST  PROFITS  OR  LOST  DATA,  COST  OF  PROCUREMENT  OF
42:                  SUBSTITUTE  GOODS,  TECHNOLOGY,  SERVICES,  OR  ANY  CLAIMS  BY  THIRD   PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE  THEREOF),  OR  OTHER  SIMILAR  COSTS.
44:                  *******************************************************************************/
45:                  //DOM-IGNORE-END
46:                  
47:                  #include "system_config.h"
48:                  #include "driver/usb/usbfs/drv_usbfs.h"
49:                  #include "driver/usb/usbfs/src/drv_usbfs_local.h"
50:                  
51:                  /*****************************************************
52:                   * This structure is a pointer to a set of USB Driver
53:                   * Device mode functions. This set is exported to the
54:                   * device layer when the device layer must use the
55:                   * PIC32MX USB Controller.
56:                   ******************************************************/
57:                  
58:                  DRV_USB_DEVICE_INTERFACE gDrvUSBFSDeviceInterface =
59:                  {
60:                      .open = DRV_USBFS_Open,
61:                      .close = DRV_USBFS_Close,
62:                      .eventHandlerSet = DRV_USBFS_ClientEventCallBackSet,
63:                      .deviceAddressSet = DRV_USBFS_DEVICE_AddressSet,
64:                      .deviceCurrentSpeedGet = DRV_USBFS_DEVICE_CurrentSpeedGet,
65:                      .deviceSOFNumberGet = DRV_USBFS_DEVICE_SOFNumberGet,
66:                      .deviceAttach = DRV_USBFS_DEVICE_Attach,
67:                      .deviceDetach = DRV_USBFS_DEVICE_Detach,
68:                      .deviceEndpointEnable = DRV_USBFS_DEVICE_EndpointEnable,
69:                      .deviceEndpointDisable = DRV_USBFS_DEVICE_EndpointDisable,
70:                      .deviceEndpointStall = DRV_USBFS_DEVICE_EndpointStall,
71:                      .deviceEndpointStallClear = DRV_USBFS_DEVICE_EndpointStallClear,
72:                      .deviceEndpointIsEnabled = DRV_USBFS_DEVICE_EndpointIsEnabled,
73:                      .deviceEndpointIsStalled = DRV_USBFS_DEVICE_EndpointIsStalled,
74:                      .deviceIRPSubmit = DRV_USBFS_DEVICE_IRPSubmit,
75:                      .deviceIRPCancel = DRV_USBFS_DEVICE_IRPCancel,
76:                      .deviceIRPCancelAll = DRV_USBFS_DEVICE_IRPCancelAll,
77:                      .deviceRemoteWakeupStop = DRV_USBFS_DEVICE_RemoteWakeupStop,
78:                      .deviceRemoteWakeupStart = DRV_USBFS_DEVICE_RemoteWakeupStart,
79:                      .deviceTestModeEnter = NULL
80:                                   
81:                              
82:                  };
83:                  
84:                  // *****************************************************************************
85:                  /* Function:
86:                        _DRV_USBFS_DEVICE_Initialize(DRV_USBFS_OBJ * drvObj, SYS_MODULE_INDEX index)
87:                  
88:                    Summary:
89:                      Dynamic impementation of _DRV_USBFS_DEVICE_Initialize system interface function.
90:                  
91:                    Description:
92:                      This is the dynamic impementation of _DRV_USBFS_DEVICE_Initialize system
93:                      interface initiaization function for USB device.  Function enables
94:                      USB_OTG_INT_SESSION_VALID interrupt to detect VBUS session valid\invalid
95:                      scenario. All the other interrupts will be enabled after the device has been
96:                      attached (DRV_USBFS_DEVICE_Attach() function will be called)
97:                  
98:                    Remarks:
99:                      See drv_usbfs.h for usage information.
100:                 */
101:                 
102:                 void _DRV_USBFS_DEVICE_Initialize(DRV_USBFS_OBJ * drvObj, SYS_MODULE_INDEX index)
103:                 {
104:                     /* Initialize device specific flags */
105:                     drvObj->vbusIsValid = false;
9D015158  A0800002   SB ZERO, 2(A0)
106:                     drvObj->isAttached = false;
9D01515C  A0800003   SB ZERO, 3(A0)
107:                     drvObj->isSuspended = false;
9D015160  A0800004   SB ZERO, 4(A0)
9D015164  8C820020   LW V0, 32(A0)
9D015168  2403FF00   ADDIU V1, ZERO, -256
9D01516C  AC4301D0   SW V1, 464(V0)
9D015170  AC4301F0   SW V1, 496(V0)
9D015174  2403FF02   ADDIU V1, ZERO, -254
9D015178  AC430010   SW V1, 16(V0)
9D01517C  03E00008   JR RA
9D015180  00000000   NOP
108:                 
109:                     /* Disable all interrupts */
110:                     PLIB_USB_AllInterruptEnable(drvObj->usbID, ~USB_INT_ALL, ~USB_ERR_INT_ALL, ~USB_OTG_INT_ALL);
111:                 
112:                 }/* end of _DRV_USBFS_DEVICE_Initialize() */
113:                 
114:                 // *****************************************************************************
115:                 /* Function:
116:                       void DRV_USBFS_DEVICE_AddressSet(DRV_HANDLE handle, uint8_t address)
117:                 
118:                   Summary:
119:                     Dynamic impementation of DRV_USBFS_DEVICE_AddressSet client interface function.
120:                 
121:                   Description:
122:                     This is the dynamic impementation of DRV_USBFS_DEVICE_AddressSet client
123:                     interface initiaization function for USB device.  Function checks the input
124:                     handle validity and on success updates the USB Address Register U1ADDR<6:0>
125:                     with the address value.
126:                 
127:                   Remarks:
128:                     See drv_usbfs.h for usage information.
129:                 */
130:                 
131:                 void DRV_USBFS_DEVICE_AddressSet(DRV_HANDLE handle, uint8_t address)
132:                 {
133:                     /* Check if the handle is valid */
134:                     if(DRV_HANDLE_INVALID == handle)
9D015398  2402FFFF   ADDIU V0, ZERO, -1
9D01539C  10820005   BEQ A0, V0, 0x9D0153B4
9D0153A0  00000000   NOP
9D0153A4  8C820020   LW V0, 32(A0)
9D0153A8  90430220   LBU V1, 544(V0)
9D0153AC  7CA33004   INS V1, A1, 0, 7
9D0153B0  A0430220   SB V1, 544(V0)
9D0153B4  03E00008   JR RA
9D0153B8  00000000   NOP
135:                     {
136:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "Driver Handle is invalid");
137:                         return;
138:                     }
139:                 
140:                     /* Set the address */
141:                     PLIB_USB_DeviceAddressSet( ((DRV_USBFS_OBJ *)handle)->usbID, address );
142:                 
143:                 }/* end of DRV_USBFS_DEVICE_AddressSet() */
144:                 
145:                 // *****************************************************************************
146:                 /* Function:
147:                       USB_SPEED DRV_USBFS_DEVICE_CurrentSpeedGet(DRV_HANDLE handle)
148:                 
149:                   Summary:
150:                     Dynamic impementation of DRV_USBFS_DEVICE_CurrentSpeedGet client interface
151:                     function.
152:                 
153:                   Description:
154:                     This is the dynamic impementation of DRV_USBFS_DEVICE_CurrentSpeedGet client
155:                     interface initiaization function for USB device.  Function checks the input
156:                     handle validity and on success returns value to indicate FULL speed
157:                     operation. The targetted PIC32 USB OTG module only supports FULL speed (NO
158:                     low speed support) as USB device.
159:                 
160:                   Remarks:
161:                     See drv_usbfs.h for usage information.
162:                 */
163:                 
164:                 USB_SPEED DRV_USBFS_DEVICE_CurrentSpeedGet(DRV_HANDLE handle)
165:                 {
166:                     /* Check if the handle is valid */
167:                     if(DRV_HANDLE_INVALID == handle)
168:                     {
169:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "Driver Handle is invalid");
170:                         return USB_SPEED_ERROR;
9D015924  00042027   NOR A0, ZERO, A0
171:                     }
172:                     
173:                     /* Return the speed */
174:                     return USB_SPEED_FULL;
175:                 
176:                 }/* end of DRV_USBFS_DEVICE_CurrentSpeedGet() */
9D015928  24020002   ADDIU V0, ZERO, 2
9D01592C  03E00008   JR RA
9D015930  0004100A   MOVZ V0, ZERO, A0
177:                 
178:                 // *****************************************************************************
179:                 /* Function:
180:                     void DRV_USBFS_DEVICE_RemoteWakeup_Start(DRV_HANDLE handle)
181:                 
182:                   Summary:
183:                     Dynamic impementation of DRV_USBFS_DEVICE_RemoteWakeupStart client interface
184:                     function.
185:                 
186:                   Description:
187:                     This is the dynamic impementation of DRV_USBFS_DEVICE_RemoteWakeup_Start
188:                     client interface function for USB device.  Function checks the input handle
189:                     validity and on success enables the USB device to drive resume signalling.
190:                     RESUME is enabled by programming USB Control register (U1CON<2>).  This
191:                     function should only be called if SUSPEND state has persisted for atleast 5
192:                     ms. The client should drive RESUME for 10ms and then
193:                     DRV_USBFS_DEVICE_RemoteWakeupStop() function should be called to clear
194:                     RESUME.
195:                 
196:                   Remarks:
197:                     See drv_usbfs.h for usage information.
198:                 */
199:                 
200:                 void DRV_USBFS_DEVICE_RemoteWakeupStart(DRV_HANDLE handle)
201:                 {
202:                     /* Check if the handle is valid */
203:                     if(DRV_HANDLE_INVALID == handle)
9D0153BC  2402FFFF   ADDIU V0, ZERO, -1
9D0153C0  10820005   BEQ A0, V0, 0x9D0153D8
9D0153C4  00000000   NOP
9D0153C8  8C820020   LW V0, 32(A0)
9D0153CC  8C430210   LW V1, 528(V0)
9D0153D0  34630004   ORI V1, V1, 4
9D0153D4  AC430210   SW V1, 528(V0)
9D0153D8  03E00008   JR RA
9D0153DC  00000000   NOP
204:                     {
205:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "Driver Handle is invalid");
206:                         return;
207:                     }
208:                 
209:                     /* Enable Resume signalling */
210:                     PLIB_USB_ResumeSignalingEnable(((DRV_USBFS_OBJ *)handle)->usbID);
211:                 
212:                 }/* end of DRV_USBFS_DEVICE_RemoteWakeupStart() */
213:                 
214:                 // *****************************************************************************
215:                 /* Function:
216:                     void DRV_USBFS_DEVICE_RemoteWakeupStop(DRV_HANDLE handle)
217:                 
218:                   Summary:
219:                     Dynamic impementation of DRV_USBFS_DEVICE_RemoteWakeupStop client interface
220:                     function.
221:                 
222:                   Description:
223:                     This is the dynamic impementation of DRV_USBFS_DEVICE_RemoteWakeupStop client
224:                     interface function for USB device.  Function checks the input handle
225:                     validity and on success disables the USB device to drive resume signalling.
226:                     RESUME is disabled by programming USB Control register (U1CON<2>).  This
227:                     function should only be called after 10ms of driving RESUME signal by USB
228:                     device.
229:                 
230:                   Remarks:
231:                     See drv_usbfs.h for usage information.
232:                 */
233:                 
234:                 void DRV_USBFS_DEVICE_RemoteWakeupStop(DRV_HANDLE handle)
235:                 {
236:                     /* Check if the handle is valid */
237:                     if(DRV_HANDLE_INVALID == handle)
9D0153E0  2402FFFF   ADDIU V0, ZERO, -1
9D0153E4  10820005   BEQ A0, V0, 0x9D0153FC
9D0153E8  00000000   NOP
9D0153EC  8C820020   LW V0, 32(A0)
9D0153F0  8C430210   LW V1, 528(V0)
9D0153F4  7C031084   INS V1, ZERO, 2, 1
9D0153F8  AC430210   SW V1, 528(V0)
9D0153FC  03E00008   JR RA
9D015400  00000000   NOP
238:                     {
239:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "Driver Handle is invalid");
240:                         return;
241:                     }
242:                 
243:                     /* Disable Resume signalling */
244:                     PLIB_USB_ResumeSignalingDisable(((DRV_USBFS_OBJ *)handle)->usbID);
245:                 
246:                 }/* end of DRV_USBFS_DEVICE_RemoteWakeupStop() */
247:                 
248:                 // *****************************************************************************
249:                 /* Function:
250:                       void DRV_USBFS_DEVICE_Attach(DRV_HANDLE handle)
251:                 
252:                   Summary:
253:                     Dynamic impementation of DRV_USBFS_DEVICE_Attach client interface
254:                     function.
255:                 
256:                   Description:
257:                     This is the dynamic impementation of DRV_USBFS_DEVICE_Attach client interface
258:                     function for USB device.  Function checks the input handle validity and on
259:                     success writes to USB CONTROL register <U1CON> to enable USB device mode of
260:                     operation.  It also enbales the necessaryy USB intrerupts except RESUMEIF
261:                     for USB device operation.  After this function gets called the D+/D- pull up
262:                     resistors are enabled and then only device enumeration can start.
263:                 
264:                   Remarks:
265:                     See drv_usbfs.h for usage information.
266:                 */
267:                 
268:                 void DRV_USBFS_DEVICE_Attach(DRV_HANDLE handle)
269:                 {
270:                     /* Check if the handle is valid */
271:                     if(DRV_HANDLE_INVALID == handle)
9D0134F8  2402FFFF   ADDIU V0, ZERO, -1
9D0134FC  10820017   BEQ A0, V0, 0x9D01355C
9D013500  24020001   ADDIU V0, ZERO, 1
272:                     {
273:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "Driver Handle is invalid");
274:                         return;
275:                     }
276:                 
277:                     /* Update the driver flag indicating attach */
278:                     ((DRV_USBFS_OBJ *)handle)->isAttached = true;
9D013504  A0820003   SB V0, 3(A0)
9D013508  8C820020   LW V0, 32(A0)
9D01350C  90430210   LBU V1, 528(V0)
9D013510  7C030004   INS V1, ZERO, 0, 1
9D013514  A0430210   SB V1, 528(V0)
9D013518  90430210   LBU V1, 528(V0)
9D01351C  7C0318C4   INS V1, ZERO, 3, 1
9D013520  A0430210   SB V1, 528(V0)
9D013524  90430030   LBU V1, 48(V0)
9D013528  7C031084   INS V1, ZERO, 2, 1
9D01352C  A0430030   SB V1, 48(V0)
9D013530  90430210   LBU V1, 528(V0)
9D013534  24050001   ADDIU A1, ZERO, 1
9D013538  7CA30004   INS V1, A1, 0, 1
9D01353C  A0430210   SB V1, 528(V0)
9D013540  8C820020   LW V0, 32(A0)
9D013544  240300DF   ADDIU V1, ZERO, 223
9D013548  AC4301D0   SW V1, 464(V0)
9D01354C  240300FF   ADDIU V1, ZERO, 255
9D013550  AC4301F0   SW V1, 496(V0)
9D013554  2403FF1A   ADDIU V1, ZERO, -230
9D013558  AC430010   SW V1, 16(V0)
9D01355C  03E00008   JR RA
9D013560  00000000   NOP
279:                 
280:                     /* Configure the peripheral for device mode operation. This function
281:                      * also enables the D+ pull up resistor.  */
282:                     PLIB_USB_OperatingModeSelect(((DRV_USBFS_OBJ *)handle)->usbID, USB_OPMODE_DEVICE);
283:                 
284:                     /* Enables all interrupts except RESUME. RESUMEIF will be enabled only on
285:                      * getting SUSPEND */
286:                     PLIB_USB_AllInterruptEnable(((DRV_USBFS_OBJ *)handle)->usbID,
287:                             (USB_INT_ALL & ~USB_INT_RESUME), USB_ERR_INT_ALL,
288:                             ((~USB_OTG_INT_ALL) | USB_OTG_INT_SESSION_VALID |
289:                             USB_OTG_INT_ACTIVITY_DETECT));
290:                 
291:                 }/* end of DRV_USBFS_DEVICE_Attach()*/
292:                 
293:                 // *****************************************************************************
294:                 /* Function:
295:                       void DRV_USBFS_DEVICE_Detach(DRV_HANDLE handle)
296:                 
297:                   Summary:
298:                     Dynamic impementation of DRV_USBFS_DEVICE_Detach client interface
299:                     function.
300:                 
301:                   Description:
302:                     This is the dynamic impementation of DRV_USBFS_DEVICE_Detach client interface
303:                     function for USB device.  Function checks the input handle validity and on
304:                     success clears all the interrupts and selects no mode of operation. This
305:                     will disable D+/D- pull-up registers and even if the USB device is connected
306:                     to USB physical bus, the device will not be enumerated after the USB device
307:                     detach is done.
308:                 
309:                   Remarks:
310:                     See drv_usbfs.h for usage information.
311:                 */
312:                 
313:                 void DRV_USBFS_DEVICE_Detach(DRV_HANDLE handle)
314:                 {
315:                     /* Check if the handle is valid */
316:                     if(DRV_HANDLE_INVALID == handle)
9D014480  2402FFFF   ADDIU V0, ZERO, -1
9D014484  1082000E   BEQ A0, V0, 0x9D0144C0
9D014488  240300FF   ADDIU V1, ZERO, 255
317:                     {
318:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "Driver Handle is invalid");
319:                         return;
320:                     }
321:                 
322:                     /* Update the driver flag indicating detach */
323:                     ((DRV_USBFS_OBJ *)handle)->isAttached = false;
9D01448C  A0800003   SB ZERO, 3(A0)
9D014490  8C820020   LW V0, 32(A0)
9D014494  AC4301C0   SW V1, 448(V0)
9D014498  8C820020   LW V0, 32(A0)
9D01449C  90430210   LBU V1, 528(V0)
9D0144A0  7C030004   INS V1, ZERO, 0, 1
9D0144A4  A0430210   SB V1, 528(V0)
9D0144A8  90430210   LBU V1, 528(V0)
9D0144AC  7C0318C4   INS V1, ZERO, 3, 1
9D0144B0  A0430210   SB V1, 528(V0)
9D0144B4  90430030   LBU V1, 48(V0)
9D0144B8  7C031084   INS V1, ZERO, 2, 1
9D0144BC  A0430030   SB V1, 48(V0)
9D0144C0  03E00008   JR RA
9D0144C4  00000000   NOP
324:                 
325:                     /* Clear all the interrupts */
326:                     PLIB_USB_InterruptFlagClear(((DRV_USBFS_OBJ *)handle)->usbID, USB_INT_ALL);
327:                 
328:                     /* Reset the operationg mode */
329:                     PLIB_USB_OperatingModeSelect(((DRV_USBFS_OBJ *)handle)->usbID, USB_OPMODE_NONE);
330:                 
331:                 }/* end of DRV_USBFS_DEVICE_Detach() */
332:                 
333:                 // *****************************************************************************
334:                 /* Function:
335:                     void _DRV_USBFS_DEVICE_EndpointObjectEnable
336:                     (
337:                         DRV_USBFS_DEVICE_ENDPOINT_OBJ * endpointObject,
338:                         uint16_t endpointSize,
339:                         USB_TRANSFER_TYPE endpointType,
340:                         USB_BUFFER_DATA01 dataToggle
341:                      )
342:                 
343:                   Summary:
344:                     Dynamic impementation of _DRV_USBFS_DEVICE_EndpointObjectEnable function.
345:                 
346:                   Description:
347:                     This is the dynamic impementation of _DRV_USBFS_DEVICE_EndpointObjectEnable
348:                     function for USB device.  Function populates the endpoint object data
349:                     structure and sets it to enabled state.
350:                 
351:                   Remarks:
352:                     This is a local function and should not be called directly by the
353:                     application.
354:                 */
355:                 
356:                 void _DRV_USBFS_DEVICE_EndpointObjectEnable
357:                 (
358:                     DRV_USBFS_DEVICE_ENDPOINT_OBJ * endpointObject,
359:                     uint16_t endpointSize,
360:                     USB_TRANSFER_TYPE endpointType,
361:                     USB_BUFFER_DATA01 dataToggle,
362:                     USB_PING_PONG_STATE nextPingPong
363:                 )
364:                 {
365:                     /* This is a helper function */
366:                     endpointObject->nextDataToggle  = USB_BUFFER_DATA0;
9D00DC48  AC60000C   SW ZERO, 12(V1)
9D00DC70  AC600024   SW ZERO, 36(V1)
9D00DCFC  AC60000C   SW ZERO, 12(V1)
367:                     endpointObject->irpQueue        = NULL;
9D00DC4C  AC600000   SW ZERO, 0(V1)
9D00DC74  AC600018   SW ZERO, 24(V1)
9D00DD00  AC600000   SW ZERO, 0(V1)
368:                     endpointObject->maxPacketSize   = endpointSize;
9D00DC50  A4670004   SH A3, 4(V1)
9D00DC78  A467001C   SH A3, 28(V1)
9D00DD04  A4670004   SH A3, 4(V1)
369:                     endpointObject->nextPingPong    = nextPingPong;
9D00DC54  AC620010   SW V0, 16(V1)
9D00DC7C  AC620028   SW V0, 40(V1)
9D00DD08  AC640010   SW A0, 16(V1)
370:                     endpointObject->endpointType    = endpointType;
9D00DC58  AC600008   SW ZERO, 8(V1)
9D00DC80  AC600020   SW ZERO, 32(V1)
9D00DD0C  AC660008   SW A2, 8(V1)
371:                     endpointObject->endpointState  |= DRV_USBFS_DEVICE_ENDPOINT_STATE_ENABLED;
9D00DC5C  8C620014   LW V0, 20(V1)
9D00DC84  8C62002C   LW V0, 44(V1)
9D00DD10  8C620014   LW V0, 20(V1)
9D00DD14  34420001   ORI V0, V0, 1
9D00DD18  AC620014   SW V0, 20(V1)
372:                     
373:                 }/* end of _DRV_USBFS_DEVICE_EndpointObjectEnable() */
374:                 
375:                 // *****************************************************************************
376:                 /* Function:
377:                     USB_ERROR DRV_USBFS_DEVICE_EndpointEnable
378:                     (
379:                         DRV_HANDLE handle,
380:                         USB_ENDPOINT endpointAndDirection,
381:                         USB_TRANSFER_TYPE endpointType,
382:                         uint16_t endpointSize
383:                     )
384:                 
385:                   Summary:
386:                     Dynamic impementation of DRV_USBFS_DEVICE_EndpointEnable client interface
387:                     function.
388:                 
389:                   Description:
390:                     This is the dynamic impementation of DRV_USBFS_DEVICE_EndpointEnable client
391:                     interface function for USB device.  Function enables the specified endpoint.
392:                 
393:                   Remarks:
394:                     See drv_usbfs.h for usage information.
395:                 */
396:                 
397:                 USB_ERROR DRV_USBFS_DEVICE_EndpointEnable
398:                 (
399:                     DRV_HANDLE handle, 
400:                     USB_ENDPOINT endpointAndDirection, 
401:                     USB_TRANSFER_TYPE endpointType,
402:                     uint16_t endpointSize
403:                 )
404:                 {
405:                     /* This function can be called from
406:                      * from the USB ISR. Because an endpoint
407:                      * can be owned by one client only, we
408:                      * dont need mutex protection in this 
409:                      * function */
410:                 
411:                     /* Start of local variables */
412:                     int      direction;
413:                     int      iEntry;
414:                     bool     handshake;
415:                     uint8_t  endpoint;
416:                     DRV_USBFS_OBJ    * hDriver;
417:                     USB_MODULE_ID    usbID;
418:                     DRV_USBFS_BDT_ENTRY * pBDT;
419:                     DRV_USBFS_DEVICE_ENDPOINT_OBJ * endpointObject;
420:                     USB_PING_PONG_STATE nextPingPong;
421:                     uint32_t            mask = 1;
422:                     /* end of local variables */
423:                 
424:                     /* Enable the endpoint */
425:                 
426:                     endpoint     = endpointAndDirection & 0xF;
427:                     direction    = ((endpointAndDirection & 0x80) != 0);
9D00DC98  000529C2   SRL A1, A1, 7
428:                     
429:                     if(endpoint >= DRV_USBFS_ENDPOINTS_NUMBER)
9D00DBE8  30A2000F   ANDI V0, A1, 15
9D00DBEC  1440004D   BNE V0, ZERO, 0x9D00DD24
9D00DBF0  00000000   NOP
430:                     {
431:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO,"Unsupported endpoint");
432:                         return USB_ERROR_DEVICE_ENDPOINT_INVALID;
9D00DD24  03E00008   JR RA
9D00DD28  2402FF84   ADDIU V0, ZERO, -124
433:                     }
434:                 
435:                     /* check if the handle is valid */
436:                     if(DRV_HANDLE_INVALID == handle)
9D00DBF4  2402FFFF   ADDIU V0, ZERO, -1
9D00DBF8  1082004C   BEQ A0, V0, 0x9D00DD2C
9D00DBFC  00000000   NOP
437:                     {
438:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "Driver Handle is invalid");
439:                         return USB_ERROR_PARAMETER_INVALID;
440:                     }
441:                 
442:                     usbID        = ((DRV_USBFS_OBJ *)handle)->usbID;
9D00DC00  8C890020   LW T1, 32(A0)
443:                     hDriver      = (DRV_USBFS_OBJ *)handle;
444:                 
445:                     /* The BDT table has four entries per endpoint
446:                      * The following statement points pBDT to the
447:                      * first endpoint specific entry */
448:                 
449:                     pBDT         = hDriver->pBDT + (endpoint * 4);
9D00DC04  8C88002C   LW T0, 44(A0)
450:                     
451:                     /* Get the pointer to the endpoint object */
452:                     
453:                     endpointObject = (hDriver->endpointTable + (2 * endpoint) + 0);
454:                 
455:                     if(endpointType == USB_TRANSFER_TYPE_CONTROL)
9D00DC08  14C00023   BNE A2, ZERO, 0x9D00DC98
9D00DC0C  8C830034   LW V1, 52(A0)
9D00DC10  00001021   ADDU V0, ZERO, ZERO
456:                     {
457:                         /* For a control endpoint enable both
458:                          * directions. Clear up the BDT entries. */
459:                 
460:                         uint32_t * pBDT32bit = (uint32_t *)pBDT;
461:                 
462:                         for(iEntry = 0; iEntry < 7; iEntry ++)
9D00DC14  2406001C   ADDIU A2, ZERO, 28
9D00DC18  01022821   ADDU A1, T0, V0
9D00DC1C  24420004   ADDIU V0, V0, 4
9D00DC20  1446FFFD   BNE V0, A2, 0x9D00DC18
9D00DC24  ACA00000   SW ZERO, 0(A1)
463:                         {
464:                             /* A full duplex endpoint has 4
465:                              * entries, 2 for each direction */
466:                 
467:                             *(pBDT32bit + iEntry) = 0;
468:                         }
469:                         
470:                         /* The following function enables both directions */
471:                            
472:                         PLIB_USB_EPnAttributesSet( usbID, endpoint, 0, true, 0 );
473:                              
474:                         /* The BDT even odd buffer descriptor entries to be used is
475:                 		 * is contained in the tx/rx endpoint next ping pong indicators.
476:                 		 * These indicators are updated when the hardware interrupts
477:                 		 * occur */
478:                 
479:                         mask = mask << endpoint ; 
480:                         if ( hDriver->rxEndpointsNextPingPong & mask  )
9D00DC40  8C820018   LW V0, 24(A0)
9D00DC44  30420001   ANDI V0, V0, 1
481:                         {
482:                             nextPingPong = USB_PING_PONG_ODD ;
483:                         }
484:                         else
485:                         {
486:                              nextPingPong = USB_PING_PONG_EVEN;
487:                         }
488:                 
489:                 		/* This is the RX endpoint */        
490:                         _DRV_USBFS_DEVICE_EndpointObjectEnable(endpointObject, endpointSize, endpointType, USB_BUFFER_DATA0,nextPingPong);
491:                 
492:                         /* This is when data moves from device to host. For
493:                          * control end points the Data toggle always starts
494:                          * with DATA1.
495:                          */
496:                    
497:                         endpointObject ++;
498:                         
499:                         if ( hDriver->txEndpointsNextPingPong & mask  )
9D00DC68  8C82001C   LW V0, 28(A0)
9D00DC6C  30420001   ANDI V0, V0, 1
500:                         {
501:                             nextPingPong = USB_PING_PONG_ODD; 
502:                         }
503:                         else
504:                         {
505:                              nextPingPong = USB_PING_PONG_EVEN;
506:                         }
507:                         _DRV_USBFS_DEVICE_EndpointObjectEnable(endpointObject, endpointSize, endpointType, USB_BUFFER_DATA1,nextPingPong);
508:                 
509:                     }
510:                     else
511:                     {
512:                         /* Clear up the even odd entries for this
513:                          * endpoint direction in the BDT. Each entry
514:                          * has 2 32 bit entries */
515:                 
516:                         pBDT += (2 * direction);
9D00DC9C  00051100   SLL V0, A1, 4
9D00DCA0  01024021   ADDU T0, T0, V0
517:                 
518:                         /* Clear up the even entry */
519:                         pBDT->word[0] = 0;
9D00DCA4  AD000000   SW ZERO, 0(T0)
520:                         pBDT->word[1] = 0;
9D00DCA8  AD000004   SW ZERO, 4(T0)
521:                         pBDT ++;
522:                 
523:                         /* Clear up the odd entry */
524:                         pBDT->word[0] = 0;
9D00DCAC  AD000008   SW ZERO, 8(T0)
525:                         pBDT->word[1] = 0;
9D00DCB0  AD00000C   SW ZERO, 12(T0)
526:                         
527:                         handshake = (endpointType == USB_TRANSFER_TYPE_ISOCHRONOUS) ? false : true;
9D00DCC0  38C20001   XORI V0, A2, 1
9D00DCC4  0002102B   SLTU V0, ZERO, V0
528:                                         
529:                         PLIB_USB_EPnAttributesSet(usbID, endpoint, direction, false, handshake);
530:                 
531:                          mask = mask << endpoint ;
532:                         /* Update the endpoint database */
533:                         if( direction == 0)
9D00DCD4  54A00004   BNEL A1, ZERO, 0x9D00DCE8
9D00DCD8  8C84001C   LW A0, 28(A0)
534:                         {
535:                             if ( hDriver->rxEndpointsNextPingPong & mask  )
9D00DCDC  8C840018   LW A0, 24(A0)
9D00DCE0  0B40373B   J 0x9D00DCEC
9D00DCE4  30840001   ANDI A0, A0, 1
536:                             {
537:                 				/* This means the next ping pong entry should be ODD */
538:                                 nextPingPong = USB_PING_PONG_ODD ;
539:                             }
540:                             else
541:                             {
542:                 				/* This means the next ping entry should be even */
543:                                 nextPingPong = USB_PING_PONG_EVEN;
544:                             }
545:                         }
546:                         else  
547:                         {
548:                             if ( hDriver->txEndpointsNextPingPong & mask  )
9D00DCE8  30840001   ANDI A0, A0, 1
549:                             {
550:                                 nextPingPong = USB_PING_PONG_ODD; 
551:                             }
552:                             else
553:                             {
554:                                 nextPingPong = USB_PING_PONG_EVEN;
555:                             }
556:                         }
557:                         endpointObject += direction;
9D00DCEC  000510C0   SLL V0, A1, 3
9D00DCF0  00052940   SLL A1, A1, 5
9D00DCF4  00A22823   SUBU A1, A1, V0
9D00DCF8  00651821   ADDU V1, V1, A1
558:                         _DRV_USBFS_DEVICE_EndpointObjectEnable(endpointObject, endpointSize, endpointType, USB_BUFFER_DATA0 ,nextPingPong);
559:                     }
560:                     
561:                     return(USB_ERROR_NONE);
9D00DC90  03E00008   JR RA
9D00DC94  00001021   ADDU V0, ZERO, ZERO
9D00DD1C  03E00008   JR RA
9D00DD20  00001021   ADDU V0, ZERO, ZERO
562:                 
563:                 }/* end of DRV_USBFS_DEVICE_EndpointEnable() */
9D00DD2C  03E00008   JR RA
9D00DD30  2402FF83   ADDIU V0, ZERO, -125
564:                 
565:                 // *****************************************************************************
566:                 /* Function:
567:                     USB_ERROR DRV_USBFS_DEVICE_EndpointDisable
568:                     (
569:                         DRV_HANDLE handle,
570:                         USB_ENDPOINT endpointAndDirection
571:                     )
572:                 
573:                   Summary:
574:                     Dynamic impementation of DRV_USBFS_DEVICE_EndpointDisable client interface
575:                     function.
576:                 
577:                   Description:
578:                     This is the dynamic impementation of DRV_USBFS_DEVICE_EndpointDisable client
579:                     interface function for USB device.  Function disables the specified
580:                     endpoint.
581:                 
582:                   Remarks:
583:                     See drv_usbfs.h for usage information.
584:                 */
585:                 
586:                 USB_ERROR DRV_USBFS_DEVICE_EndpointDisable
587:                 (
588:                     DRV_HANDLE handle, 
589:                     USB_ENDPOINT endpointAndDirection
590:                 )
591:                 {
592:                     /* This routine disables the specified endpoint.
593:                      * It does not check if there is any ongoing 
594:                      * communication on the bus through the endpoint
595:                      */
596:                 
597:                     /* Start of local variable */
598:                     uint8_t endpoint;
599:                     int     direction, iEntry;
600:                     DRV_USBFS_OBJ * hDriver;
601:                     DRV_USBFS_DEVICE_ENDPOINT_OBJ * endpointObject;
602:                     USB_MODULE_ID usbID;
603:                     /* end of local variable */
604:                 
605:                     /* Check if the handle is valid */
606:                     if(DRV_HANDLE_INVALID == handle)
9D0100E0  2402FFFF   ADDIU V0, ZERO, -1
9D0100E4  10820037   BEQ A0, V0, 0x9D0101C4
9D0100E8  24030010   ADDIU V1, ZERO, 16
607:                     {
608:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "Driver Handle is invalid");
609:                         return USB_ERROR_PARAMETER_INVALID;
9D0101C4  03E00008   JR RA
9D0101C8  2402FF83   ADDIU V0, ZERO, -125
610:                     }
611:                 
612:                     /* Get the pointer to associated endpoint object table */
613:                 
614:                     hDriver     = ((DRV_USBFS_OBJ *)handle);
615:                     usbID       = hDriver->usbID;
9D0100EC  8C820020   LW V0, 32(A0)
616:                     endpointObject = hDriver->endpointTable;
617:                 
618:                     /* If the endpointAndDirection is _DRV_USBFS_DEVICE_ENDPOINT_ALL
619:                      * then this means that the DRV_USBFS_DEVICE_EndpointDisableAll()
620:                      * function was called */
621:                 
622:                     if(endpointAndDirection == DRV_USBFS_DEVICE_ENDPOINT_ALL)
9D0100F0  14A30010   BNE A1, V1, 0x9D010134
9D0100F4  8C840034   LW A0, 52(A0)
623:                     {
624:                         
625:                         for(iEntry = 0; iEntry < DRV_USBFS_ENDPOINTS_NUMBER; iEntry ++)
626:                         {
627:                             PLIB_USB_EPnAttributesClear(usbID, iEntry);
628:                 
629:                             /* Update the endpoint database */
630:                 
631:                             endpointObject->endpointState  &= ~DRV_USBFS_DEVICE_ENDPOINT_STATE_ENABLED;
9D010114  8C820014   LW V0, 20(A0)
9D010118  7C020004   INS V0, ZERO, 0, 1
9D01011C  AC820014   SW V0, 20(A0)
632:                             endpointObject ++;
633:                             endpointObject->endpointState  &= ~DRV_USBFS_DEVICE_ENDPOINT_STATE_ENABLED;
9D010120  8C82002C   LW V0, 44(A0)
9D010124  7C020004   INS V0, ZERO, 0, 1
9D010128  AC82002C   SW V0, 44(A0)
9D01012C  03E00008   JR RA
9D010130  00001021   ADDU V0, ZERO, ZERO
634:                             endpointObject ++;
635:                 
636:                         }
637:                         
638:                         return (USB_ERROR_NONE);
639:                     }
640:                 
641:                     endpoint = endpointAndDirection & 0xF;
642:                     direction = ((endpointAndDirection & 0x80) != 0);
9D010134  000531C2   SRL A2, A1, 7
643:                 
644:                     if(endpoint >= DRV_USBFS_ENDPOINTS_NUMBER)
9D010138  30A5000F   ANDI A1, A1, 15
9D01013C  14A00023   BNE A1, ZERO, 0x9D0101CC
9D010140  000618C0   SLL V1, A2, 3
645:                     {
646:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO,"Unsupported endpoint");
647:                         return USB_ERROR_DEVICE_ENDPOINT_INVALID;
648:                     }
649:                 
650:                     /* Setup the endpointObj to point to the correct
651:                      * endpoint object */
652:                 
653:                     endpointObject += ((2 * endpoint) + direction);
9D010144  00062940   SLL A1, A2, 5
9D010148  00A31823   SUBU V1, A1, V1
9D01014C  00831821   ADDU V1, A0, V1
654:                 
655:                     if(endpointObject->endpointType == USB_TRANSFER_TYPE_CONTROL)
9D010150  8C640008   LW A0, 8(V1)
9D010154  14800010   BNE A0, ZERO, DRV_USBFS_DEVICE_EndpointDisable::PLIB_USB_EPnDirectionDisable
9D010158  00000000   NOP
656:                     {
657:                         /* Disable a control endpoint and update the
658:                          * endpoint database. */
659:                 
660:                         PLIB_USB_EPnAttributesClear(usbID, endpoint);
661:                         endpointObject->endpointState  &= ~DRV_USBFS_DEVICE_ENDPOINT_STATE_ENABLED;
9D010178  8C620014   LW V0, 20(V1)
9D01017C  7C020004   INS V0, ZERO, 0, 1
9D010180  AC620014   SW V0, 20(V1)
662:                         endpointObject += 1;
663:                         endpointObject->endpointState  &= ~DRV_USBFS_DEVICE_ENDPOINT_STATE_ENABLED;
9D010184  8C62002C   LW V0, 44(V1)
9D010188  7C020004   INS V0, ZERO, 0, 1
9D01018C  AC62002C   SW V0, 44(V1)
9D010190  03E00008   JR RA
9D010194  00001021   ADDU V0, ZERO, ZERO
664:                 
665:                     }
666:                     else
667:                     {
668:                         /* Disable a specific endpoint direction for non
669:                          * control endpoints */
670:                 	
671:                         PLIB_USB_EPnDirectionDisable(usbID, endpoint, direction);
672:                         endpoint += direction;
673:                         endpointObject->endpointState  &= ~DRV_USBFS_DEVICE_ENDPOINT_STATE_ENABLED;
9D0101B0  8C620014   LW V0, 20(V1)
9D0101B4  7C020004   INS V0, ZERO, 0, 1
9D0101B8  AC620014   SW V0, 20(V1)
674:                     }
675:                 
676:                     return(USB_ERROR_NONE);
9D0101BC  03E00008   JR RA
9D0101C0  00001021   ADDU V0, ZERO, ZERO
677:                     
678:                 }/* end of DRV_USBFS_DEVICE_EndpointDisable() */
9D0101CC  03E00008   JR RA
9D0101D0  2402FF84   ADDIU V0, ZERO, -124
679:                 
680:                 // *****************************************************************************
681:                 /* Function:
682:                     bool DRV_USBFS_DEVICE_EndpointIsEnabled
683:                     (
684:                         DRV_HANDLE client,
685:                         USB_ENDPOINT endpointAndDirection
686:                     )
687:                 
688:                   Summary:
689:                     Dynamic impementation of DRV_USBFS_DEVICE_EndpointIsEnabled client interface
690:                     function.
691:                 
692:                   Description:
693:                     This is the dynamic impementation of DRV_USBFS_DEVICE_EndpointIsEnabled client
694:                     interface function for USB device.  Function returns the state of specified
695:                     endpoint(true\false) signifying whether the endpoint is enabled or not.
696:                 
697:                   Remarks:
698:                     See drv_usbfs.h for usage information.
699:                 */
700:                 
701:                 bool DRV_USBFS_DEVICE_EndpointIsEnabled
702:                 (
703:                     DRV_HANDLE client, 
704:                     USB_ENDPOINT endpointAndDirection
705:                 )
706:                 {
707:                     /* Start of local variables */
708:                     DRV_USBFS_OBJ * hDriver;
709:                     DRV_USBFS_DEVICE_ENDPOINT_OBJ * endpointObj;
710:                     /* end of local variables */
711:                 
712:                     uint8_t endpoint = endpointAndDirection & 0xF;
9D0149DC  30A3000F   ANDI V1, A1, 15
713:                     int direction = ((endpointAndDirection & 0x80) != 0);
714:                 
715:                     /* Check if the handle is valid */
716:                     if(DRV_HANDLE_INVALID == client)
9D0149E0  2402FFFF   ADDIU V0, ZERO, -1
9D0149E4  1082000B   BEQ A0, V0, 0x9D014A14
9D0149E8  000529C2   SRL A1, A1, 7
717:                     {
718:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "Driver Handle is invalid");
719:                         return false;
720:                     }
721:                 
722:                     hDriver = ((DRV_USBFS_OBJ *)client);
723:                     endpointObj = hDriver->endpointTable + (2 * endpoint) + direction;
9D0149EC  00031840   SLL V1, V1, 1
9D0149F0  00652821   ADDU A1, V1, A1
724:                  
725:                     if((endpointObj->endpointState & DRV_USBFS_DEVICE_ENDPOINT_STATE_ENABLED) != 0)
9D0149F4  8C820034   LW V0, 52(A0)
9D0149F8  000518C0   SLL V1, A1, 3
9D0149FC  00052940   SLL A1, A1, 5
9D014A00  00A32823   SUBU A1, A1, V1
9D014A04  00452821   ADDU A1, V0, A1
9D014A08  8CA20014   LW V0, 20(A1)
9D014A0C  03E00008   JR RA
9D014A10  30420001   ANDI V0, V0, 1
726:                     {
727:                         return true;
728:                     }
729:                     else
730:                     {
731:                         return false;
732:                     }
733:                 
734:                 }/* end of DRV_USBFS_DEVICE_EndpointIsEnabled() */
9D014A14  03E00008   JR RA
9D014A18  00001021   ADDU V0, ZERO, ZERO
735:                 
736:                 // *****************************************************************************
737:                 /* Function:
738:                     bool DRV_USBFS_DEVICE_EndpointIsStalled
739:                     (
740:                         DRV_HANDLE client,
741:                         USB_ENDPOINT endpointAndDirection
742:                     )
743:                 
744:                   Summary:
745:                     Dynamic impementation of DRV_USBFS_DEVICE_EndpointIsStalled client interface
746:                     function.
747:                 
748:                   Description:
749:                     This is the dynamic impementation of DRV_USBFS_DEVICE_EndpointIsStalled client
750:                     interface function for USB device.  Function returns the state of specified
751:                     endpoint(true\false) signifying whether the endpoint is STALLed or not.
752:                 
753:                   Remarks:
754:                     See drv_usbfs.h for usage information.
755:                 */
756:                 
757:                 bool DRV_USBFS_DEVICE_EndpointIsStalled
758:                 (
759:                     DRV_HANDLE client, 
760:                     USB_ENDPOINT endpointAndDirection
761:                 )
762:                 {
763:                     /* Start of local variables */
764:                     DRV_USBFS_OBJ * hDriver;
765:                     DRV_USBFS_DEVICE_ENDPOINT_OBJ * endpointObj;
766:                     uint8_t endpoint = endpointAndDirection & 0xF;
9D014A1C  30A3000F   ANDI V1, A1, 15
767:                     int direction = ((endpointAndDirection & 0x80) != 0);
768:                     /* end of local variable */
769:                 
770:                     /* Check if the handle is valid */
771:                     if(DRV_HANDLE_INVALID == client)
9D014A20  2402FFFF   ADDIU V0, ZERO, -1
9D014A24  1082000B   BEQ A0, V0, 0x9D014A54
9D014A28  000529C2   SRL A1, A1, 7
772:                     {
773:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "Driver Handle is invalid");
774:                         return false;
775:                     }
776:                 
777:                     hDriver = ((DRV_USBFS_OBJ *)client);
778:                     endpointObj = hDriver->endpointTable + (2 * endpoint) + direction;
9D014A2C  00031840   SLL V1, V1, 1
9D014A30  00652821   ADDU A1, V1, A1
779:                     
780:                     if((endpointObj->endpointState & DRV_USBFS_DEVICE_ENDPOINT_STATE_STALLED) != 0)
9D014A34  8C820034   LW V0, 52(A0)
9D014A38  000518C0   SLL V1, A1, 3
9D014A3C  00052940   SLL A1, A1, 5
9D014A40  00A32823   SUBU A1, A1, V1
9D014A44  00452821   ADDU A1, V0, A1
9D014A48  8CA20014   LW V0, 20(A1)
9D014A4C  03E00008   JR RA
9D014A50  7C420040   EXT V0, V0, 1, 1
781:                     {
782:                         return true;
783:                     }
784:                     else
785:                     {
786:                         return false;
787:                     }
788:                 
789:                 }/* end of DRV_USBFS_DEVICE_EndpointIsStalled() */
9D014A54  03E00008   JR RA
9D014A58  00001021   ADDU V0, ZERO, ZERO
790:                 
791:                 // *****************************************************************************
792:                 /* Function:
793:                     void _DRV_USBFS_DEVICE_EndpointBDTEntryArm
794:                     (
795:                         DRV_USBFS_BDT_ENTRY * pBDT,
796:                         DRV_USBFS_DEVICE_ENDPOINT_OBJ * endpointObj,
797:                         USB_DEVICE_IRP_LOCAL * irp,
798:                         int direction
799:                     )
800:                 
801:                   Summary:
802:                     Dynamic impementation of _DRV_USBFS_DEVICE_EndpointBDTEntryArm client interface
803:                     function.
804:                 
805:                   Description:
806:                     This is the dynamic impementation of _DRV_USBFS_DEVICE_EndpointBDTEntryArm
807:                     client interface function for USB device.  Function arms a BDT entry slot
808:                     for the endpoint object
809:                 
810:                   Remarks:
811:                     This is a local function and should not be called directly by the
812:                     application.
813:                 */
814:                 
815:                 void _DRV_USBFS_DEVICE_EndpointBDTEntryArm
816:                 (
817:                     DRV_USBFS_BDT_ENTRY * pBDT, 
818:                     DRV_USBFS_DEVICE_ENDPOINT_OBJ * endpointObj, 
819:                     USB_DEVICE_IRP_LOCAL * irp,
820:                     int direction
821:                 )
822:                 {
823:                     /* pBDT is the pointer to the ping pong BDT entries
824:                      * for the endpoint and direction  In this driver we
825:                      * dont check for the data toggle while receiving data from
826:                      * the host. The assumption here is that the host is correct */
827:                 
828:                     /* If the endpoint is stalled, the stall will be cleared */
829:                 
830:                     /* Start of local variable */
831:                     uint16_t size;
832:                     DRV_USBFS_BDT_ENTRY * currentBDTEntry;
833:                     /* end of local variable */
834:                 
835:                     currentBDTEntry = pBDT + endpointObj->nextPingPong;
9D010BD4  8CA20010   LW V0, 16(A1)
9D010BD8  000210C0   SLL V0, V0, 3
9D010BDC  00822021   ADDU A0, A0, V0
836:                 
837:                     /* Calculate the size of the transaction */
838:                     if(USB_DATA_DIRECTION_DEVICE_TO_HOST == direction)
9D010BE0  24020001   ADDIU V0, ZERO, 1
9D010BE4  54E20014   BNEL A3, V0, 0x9D010C38
9D010BE8  A0800000   SB ZERO, 0(A0)
839:                     {
840:                         /* If data is moving from device to host
841:                          * then enable data toggle syncronization */
842:                 
843:                         currentBDTEntry->byte[0] = 0x08;
9D010BEC  24020008   ADDIU V0, ZERO, 8
9D010BF0  A0820000   SB V0, 0(A0)
844:                 
845:                         /* Adjust buffer address for the number of
846:                          * bytes sent */
847:                         currentBDTEntry->word[1] = (uint32_t) (KVA_TO_PA ((uint8_t *)irp->data + irp->size - irp->nPendingBytes));
9D010BF4  8CC30004   LW V1, 4(A2)
9D010BF8  8CC20020   LW V0, 32(A2)
9D010BFC  00621023   SUBU V0, V1, V0
9D010C00  8CC30000   LW V1, 0(A2)
9D010C04  00621021   ADDU V0, V1, V0
9D010C08  7C42E000   EXT V0, V0, 0, 29
9D010C0C  AC820004   SW V0, 4(A0)
848:                 
849:                         if(irp->nPendingBytes == 0)  
9D010C10  8CC20020   LW V0, 32(A2)
9D010C14  10400005   BEQ V0, ZERO, 0x9D010C2C
9D010C18  00001821   ADDU V1, ZERO, ZERO
850:                         {
851:                             /* This applies when we need to send a ZLP */
852:                             size = 0;
853:                         }
854:                         else
855:                         {
856:                             size = (irp->nPendingBytes > endpointObj->maxPacketSize)
9D010C28  3063FFFF   ANDI V1, V1, -1
857:                                 ? endpointObj->maxPacketSize: irp->nPendingBytes;
9D010C1C  94A30004   LHU V1, 4(A1)
9D010C20  0043382B   SLTU A3, V0, V1
9D010C24  0047180B   MOVN V1, V0, A3
858:                         }
859:                 
860:                         /* Update the pending bytes only if the 
861:                          * data direction is from device to host. The
862:                          * pending bytes for the other direction is 
863:                          * updated in the ISR */
864:                 
865:                         irp->nPendingBytes -= size;
9D010C2C  00431023   SUBU V0, V0, V1
9D010C30  0B40431A   J 0x9D010C68
9D010C34  ACC20020   SW V0, 32(A2)
866:                     }
867:                     else
868:                     {
869:                         /* Data is moving from host to device */
870:                         currentBDTEntry->byte[0] = 0x0;
871:                 
872:                         /* Adjust the buffer address for the number of bytes
873:                          * received so far */
874:                 
875:                         currentBDTEntry->word[1] = (uint32_t) (KVA_TO_PA ((uint8_t *)irp->data + irp->nPendingBytes));
9D010C38  8CC30000   LW V1, 0(A2)
9D010C3C  8CC20020   LW V0, 32(A2)
9D010C40  00621021   ADDU V0, V1, V0
9D010C44  7C42E000   EXT V0, V0, 0, 29
9D010C48  AC820004   SW V0, 4(A0)
876:                         
877:                         size = (irp->size - irp->nPendingBytes > 
9D010C64  3043FFFF   ANDI V1, V0, -1
878:                                     endpointObj->maxPacketSize) ? endpointObj->maxPacketSize :
9D010C4C  94A70004   LHU A3, 4(A1)
9D010C5C  0047182B   SLTU V1, V0, A3
9D010C60  00E3100A   MOVZ V0, A3, V1
879:                                     irp->size - irp->nPendingBytes;
9D010C50  8CC30004   LW V1, 4(A2)
9D010C54  8CC20020   LW V0, 32(A2)
9D010C58  00621023   SUBU V0, V1, V0
880:                 
881:                     }
882:                 
883:                     /* We set up the data toggle. This will be active
884:                      * only if DTS is active. Clear the DATA0/1 and 
885:                      * then set it according to the next data toggle
886:                      * to be used.*/
887:                 
888:                     currentBDTEntry->byte[0] &= 0xBF;
9D010C68  90820000   LBU V0, 0(A0)
9D010C6C  304200BF   ANDI V0, V0, 191
9D010C70  A0820000   SB V0, 0(A0)
889:                     currentBDTEntry->byte[0] |= (endpointObj->nextDataToggle << 6);
9D010C74  8CA6000C   LW A2, 12(A1)
9D010C78  00063180   SLL A2, A2, 6
9D010C80  2403FF80   ADDIU V1, ZERO, -128
9D010C84  00431025   OR V0, V0, V1
890:                     
891:                     /* Set the size */
892:                     currentBDTEntry->shortWord[1] = size;
9D010C7C  A4830002   SH V1, 2(A0)
893:                     
894:                     /* Set the UOWN bit */
895:                 
896:                     currentBDTEntry->byte[0] |= 0x80;
9D010C88  00C21025   OR V0, A2, V0
9D010C8C  A0820000   SB V0, 0(A0)
897:                 
898:                     endpointObj->nextPingPong ^= 0x1;
9D010C90  8CA20010   LW V0, 16(A1)
9D010C94  38420001   XORI V0, V0, 1
9D010C98  ACA20010   SW V0, 16(A1)
899:                     endpointObj->nextDataToggle ^= 0x1;
9D010C9C  8CA2000C   LW V0, 12(A1)
9D010CA0  38420001   XORI V0, V0, 1
9D010CA4  03E00008   JR RA
9D010CA8  ACA2000C   SW V0, 12(A1)
900:                 
901:                 }/* end of _DRV_USBFS_DEVICE_EndpointBDTEntryArm() */
902:                 
903:                 // *****************************************************************************
904:                 /* Function:
905:                     USB_ERROR DRV_USBFS_DEVICE_IRPSubmit
906:                     (
907:                         DRV_HANDLE client,
908:                         USB_ENDPOINT endpointAndDirection,
909:                         USB_DEVICE_IRP * inputIRP
910:                     )
911:                 
912:                   Summary:
913:                     Dynamic impementation of DRV_USBFS_DEVICE_IRPSubmit client interface
914:                     function.
915:                 
916:                   Description:
917:                     This is the dynamic impementation of DRV_USBFS_DEVICE_IRPSubmit client
918:                     interface function for USB device.  Function checks the validity of the
919:                     input arguments and on success adds the IRP to endpoint object queue linked
920:                     list.
921:                 
922:                   Remarks:
923:                     See drv_usbfs.h for usage information.
924:                 */
925:                 
926:                 USB_ERROR DRV_USBFS_DEVICE_IRPSubmit
927:                 (
928:                     DRV_HANDLE client,
929:                     USB_ENDPOINT endpointAndDirection, 
930:                     USB_DEVICE_IRP * inputIRP
931:                 )
932:                 {
9D0095FC  27BDFFD0   ADDIU SP, SP, -48
9D009600  AFBF002C   SW RA, 44(SP)
9D009604  AFB60028   SW S6, 40(SP)
9D009608  AFB50024   SW S5, 36(SP)
9D00960C  AFB40020   SW S4, 32(SP)
9D009610  AFB3001C   SW S3, 28(SP)
9D009614  AFB20018   SW S2, 24(SP)
9D009618  AFB10014   SW S1, 20(SP)
9D00961C  AFB00010   SW S0, 16(SP)
933:                     /* Start of local variables */
934:                     uint8_t                       endpoint;
935:                     bool                          interruptWasEnabled = false;
936:                     int                           direction;
937:                     int                           remainder;
938:                     DRV_USBFS_OBJ                 * hDriver;
939:                     USB_DEVICE_IRP_LOCAL        * irp = (USB_DEVICE_IRP_LOCAL *)inputIRP;
940:                     DRV_USBFS_BDT_ENTRY           * pBDT;
941:                     DRV_USBFS_DEVICE_ENDPOINT_OBJ * endpointObj;
942:                     /* end of local variables */
943:                 
944:                     /* Check for a valid client */
945:                     if(DRV_HANDLE_INVALID == client)
9D009620  2402FFFF   ADDIU V0, ZERO, -1
9D009624  10820062   BEQ A0, V0, 0x9D0097B0
9D009628  00808821   ADDU S1, A0, ZERO
946:                     {
947:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "Invalid handle");
948:                         return USB_ERROR_PARAMETER_INVALID;
9D0097B0  0B4025F3   J 0x9D0097CC
9D0097B4  2402FF83   ADDIU V0, ZERO, -125
949:                     }
950:                 
951:                     if(irp->status > USB_DEVICE_IRP_STATUS_SETUP)
9D00962C  8CC20008   LW V0, 8(A2)
9D009630  28420003   SLTI V0, V0, 3
9D009634  10400060   BEQ V0, ZERO, 0x9D0097B8
9D009638  00C08021   ADDU S0, A2, ZERO
952:                     {
953:                         /* This means that the IRP is in use */
954:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "Device IRP is already in use");
955:                         return(USB_ERROR_DEVICE_IRP_IN_USE);
9D0097B8  0B4025F3   J 0x9D0097CC
9D0097BC  2402FF85   ADDIU V0, ZERO, -123
956:                     }
957:                    
958:                     /* Check for a valid endpoint */
959:                     endpoint = endpointAndDirection & 0xF;
960:                     direction = ((endpointAndDirection & 0x80) != 0);
9D00963C  000591C2   SRL S2, A1, 7
961:                 
962:                     if(endpoint >= DRV_USBFS_ENDPOINTS_NUMBER)
9D009640  30A5000F   ANDI A1, A1, 15
9D009644  14A0005E   BNE A1, ZERO, 0x9D0097C0
9D009648  0240A021   ADDU S4, S2, ZERO
963:                     {
964:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "Endpoint is not provisioned for");
965:                         return USB_ERROR_DEVICE_ENDPOINT_INVALID;
9D0097C0  0B4025F3   J 0x9D0097CC
9D0097C4  2402FF84   ADDIU V0, ZERO, -124
9D0097C8  2402FF8A   ADDIU V0, ZERO, -118
966:                     }
967:                 
968:                     /* Get the driver object, the module ID and the endpoint and direction
969:                      * specific BDT entry and the endpoint object. */
970:                 
971:                     hDriver     = ((DRV_USBFS_OBJ *)client);
972:                     pBDT        = hDriver->pBDT + (endpoint * 4) + (2 * direction);
9D00972C  00122100   SLL A0, S2, 4
973:                     endpointObj = hDriver->endpointTable + (2 * endpoint) + direction;
9D00964C  001298C0   SLL S3, S2, 3
9D009650  00121140   SLL V0, S2, 5
9D009654  00539823   SUBU S3, V0, S3
9D009658  8C820034   LW V0, 52(A0)
9D00965C  00539821   ADDU S3, V0, S3
974:                 
975:                     if((endpointObj->endpointState & DRV_USBFS_DEVICE_ENDPOINT_STATE_ENABLED) == 0)
9D009660  8E620014   LW V0, 20(S3)
9D009664  30420001   ANDI V0, V0, 1
9D009668  10400057   BEQ V0, ZERO, 0x9D0097C8
9D00966C  8C95002C   LW S5, 44(A0)
976:                     {
977:                         /* This means the endpoint is disabled */        
978:                         return(USB_ERROR_ENDPOINT_NOT_CONFIGURED);        
979:                     }
980:                 
981:                     /* Check the size of the IRP. If the endpoint receives data from the host,
982:                      * then IRP size must be multiple of maxPacketSize. If the send ZLP flag is
983:                      * set, then size must be multiple of endpoint size. */
984:                 
985:                     remainder = irp->size % endpointObj->maxPacketSize;
9D009670  8CC20004   LW V0, 4(A2)
9D009674  96630004   LHU V1, 4(S3)
9D009678  0043001B   DIVU V0, V1
9D00967C  006001F4   TEQ V1, ZERO
9D009680  00002010   MFHI A0
986:                 
987:                     if(remainder == 0)
9D009684  1480000C   BNE A0, ZERO, 0x9D0096B8
9D009688  00000000   NOP
988:                     {
989:                         /* The IRP size is either 0 or a exact multiple of maxPacketSize */
990:                 
991:                         if(USB_DATA_DIRECTION_DEVICE_TO_HOST == direction)
9D00968C  5240000D   BEQL S2, ZERO, 0x9D0096C4
9D009690  92220001   LBU V0, 1(S1)
992:                         {
993:                             if(((irp->flags & USB_DEVICE_IRP_FLAG_DATA_COMPLETE) 
9D009694  8CC30010   LW V1, 16(A2)
9D009698  30640001   ANDI A0, V1, 1
9D00969C  50800009   BEQL A0, ZERO, 0x9D0096C4
9D0096A0  92220001   LBU V0, 1(S1)
994:                                     == USB_DEVICE_IRP_FLAG_DATA_COMPLETE) &&
9D0096A4  50400007   BEQL V0, ZERO, 0x9D0096C4
9D0096A8  92220001   LBU V0, 1(S1)
995:                                 (irp->size != 0))
996:                             {
997:                                 /* This means a ZLP should be sent after the data is sent. We
998:                                  * will OR this flag as this flag is temporary and must co-exist
999:                                  * by the driver client defined flag. */
1000:                
1001:                                irp->flags |= USB_DEVICE_IRP_FLAG_SEND_ZLP;
9D0096AC  34630080   ORI V1, V1, 128
9D0096B0  0B4025B0   J 0x9D0096C0
9D0096B4  ACC30010   SW V1, 16(A2)
1002:                            }
1003:                        }
1004:                    }
1005:                    else
1006:                    {
1007:                        /* Not exact multiple of maxPacketSize */
1008:                        if(USB_DATA_DIRECTION_HOST_TO_DEVICE == direction)
9D0096B8  12400044   BEQ S2, ZERO, 0x9D0097CC
9D0096BC  2402FF83   ADDIU V0, ZERO, -125
1009:                        {
1010:                            /* For receive IRP it needs to exact multiple of maxPacketSize.
1011:                             * Hence this is an error condition. */
1012:                            return USB_ERROR_PARAMETER_INVALID;
1013:                        }
1014:                    }
1015:                
1016:                    /* Now we check if the interrupt context is active. If so the we dont need
1017:                     * to get a mutex or disable interrupts.  If this were being done in non
1018:                     * interrupt context, we, then we would disable the interrupt. In which case
1019:                     * we would get the mutex and then disable the interrupt */
1020:                
1021:                    if(!(hDriver->inInterruptContext))
9D0096C0  92220001   LBU V0, 1(S1)
9D0096C4  1440000A   BNE V0, ZERO, 0x9D0096F0
9D0096C8  0000B021   ADDU S6, ZERO, ZERO
1022:                    {
1023:                        if(OSAL_MUTEX_Lock(&hDriver->mutexID, OSAL_WAIT_FOREVER) != OSAL_RESULT_TRUE)
9D0096CC  26240030   ADDIU A0, S1, 48
9D0096D0  0F405267   JAL OSAL_MUTEX_Lock
9D0096D4  3405FFFF   ORI A1, ZERO, -1
9D0096D8  24030001   ADDIU V1, ZERO, 1
9D0096DC  1443003B   BNE V0, V1, 0x9D0097CC
9D0096E0  2402FF81   ADDIU V0, ZERO, -127
1024:                        {
1025:                            SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "mutex lock failed");
1026:                            return USB_ERROR_OSAL_FUNCTION;
1027:                        }
1028:                
1029:                        interruptWasEnabled = _DRV_USBFS_InterruptSourceDisable(hDriver->interruptSource);
9D0096E4  0F405058   JAL SYS_INT_SourceDisable
9D0096E8  8E240028   LW A0, 40(S1)
9D0096EC  0040B021   ADDU S6, V0, ZERO
1030:                    }
1031:                
1032:                    irp->next = NULL;
1033:                
1034:                    /* If the data is moving from device to host then pending bytes is data
1035:                     * remaining to be sent to the host. If the data is moving from host to
1036:                     * device, nPendingBytes tracks the amount of data received so far */
1037:                
1038:                    if(USB_DATA_DIRECTION_DEVICE_TO_HOST == direction)
9D0096F0  12800004   BEQ S4, ZERO, 0x9D009704
9D0096F4  AE000018   SW ZERO, 24(S0)
1039:                    {
1040:                        irp->nPendingBytes = irp->size;
9D0096F8  8E020004   LW V0, 4(S0)
9D0096FC  0B4025C2   J 0x9D009708
9D009700  AE020020   SW V0, 32(S0)
1041:                    }
1042:                    else
1043:                    {
1044:                        irp->nPendingBytes = 0;
9D009704  AE000020   SW ZERO, 32(S0)
1045:                    }
1046:                
1047:                    /* Mark the IRP status as pending */
1048:                    irp->status = USB_DEVICE_IRP_STATUS_PENDING;
9D009708  24020003   ADDIU V0, ZERO, 3
9D00970C  AE020008   SW V0, 8(S0)
1049:                
1050:                    /* Get the last object in the endpoint object IRP Queue */
1051:                    if(endpointObj->irpQueue == NULL)
9D009710  8E680000   LW T0, 0(S3)
9D009714  5500000E   BNEL T0, ZERO, 0x9D009750
9D009718  8D030018   LW V1, 24(T0)
1052:                    {
1053:                        /* Queue is empty */
1054:                        endpointObj->irpQueue = irp;
9D00971C  AE700000   SW S0, 0(S3)
1055:                        irp->previous = NULL;
9D009720  AE00001C   SW ZERO, 28(S0)
1056:                
1057:                        /* Because this is the first IRP in the queue then we we must arm the
1058:                         * endpoint entry in the BDT. */
1059:                
1060:                        irp->status = USB_DEVICE_IRP_STATUS_IN_PROGRESS;
9D009724  24020004   ADDIU V0, ZERO, 4
9D009728  AE020008   SW V0, 8(S0)
1061:                        _DRV_USBFS_DEVICE_EndpointBDTEntryArm(pBDT,endpointObj, irp, direction);
9D009730  02A42021   ADDU A0, S5, A0
9D009734  02602821   ADDU A1, S3, ZERO
9D009738  02003021   ADDU A2, S0, ZERO
9D00973C  0F4042F5   JAL _DRV_USBFS_DEVICE_EndpointBDTEntryArm
9D009740  02403821   ADDU A3, S2, ZERO
9D009744  0B4025DC   J 0x9D009770
9D009748  92230001   LBU V1, 1(S1)
1062:                    }
1063:                    else
1064:                    {
1065:                        /* This means we should surf the linked list to get to the last entry .
1066:                         * */
1067:                        USB_DEVICE_IRP_LOCAL * iterator;
1068:                        iterator = endpointObj->irpQueue;
1069:                        while(iterator->next != NULL)
9D00974C  8D030018   LW V1, 24(T0)
9D009750  50600003   BEQL V1, ZERO, 0x9D009760
9D009754  AD100018   SW S0, 24(T0)
1070:                        {
1071:                            iterator = iterator->next;
9D009758  0B4025D3   J 0x9D00974C
9D00975C  00604021   ADDU T0, V1, ZERO
1072:                        }
1073:                        iterator->next = irp;
1074:                        irp->previous = iterator;
9D009760  AE08001C   SW T0, 28(S0)
1075:                        irp->status = USB_DEVICE_IRP_STATUS_PENDING;
9D009764  24020003   ADDIU V0, ZERO, 3
9D009768  AE020008   SW V0, 8(S0)
1076:                    }
1077:                
1078:                    if(!(hDriver->inInterruptContext))
9D00976C  92230001   LBU V1, 1(S1)
9D009770  14600016   BNE V1, ZERO, 0x9D0097CC
9D009774  00001021   ADDU V0, ZERO, ZERO
1079:                    {
1080:                        if(interruptWasEnabled)
9D009778  12C00009   BEQ S6, ZERO, 0x9D0097A0
9D00977C  3C03BF88   LUI V1, -16504
1081:                        {
1082:                            /* Enable the interrupt only if it was enabled */
1083:                            _DRV_USBFS_InterruptSourceEnable(hDriver->interruptSource);
9D009780  8E220028   LW V0, 40(S1)
1084:                        }
1085:                        /* Unlock the mutex */
1086:                        if(OSAL_MUTEX_Unlock(&hDriver->mutexID) != OSAL_RESULT_TRUE)
9D0097A0  0F40541A   JAL OSAL_MUTEX_Unlock
9D0097A4  26240030   ADDIU A0, S1, 48
9D0097A8  0B4025F3   J 0x9D0097CC
9D0097AC  00001021   ADDU V0, ZERO, ZERO
1087:                        {
1088:                	    SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "Mutex unlock failed");
1089:                        }
1090:                    }
1091:                
1092:                    return(USB_ERROR_NONE);
1093:                
1094:                }/* end of DRV_USBFS_DEVICE_IRPSubmit() */
9D0097CC  8FBF002C   LW RA, 44(SP)
9D0097D0  8FB60028   LW S6, 40(SP)
9D0097D4  8FB50024   LW S5, 36(SP)
9D0097D8  8FB40020   LW S4, 32(SP)
9D0097DC  8FB3001C   LW S3, 28(SP)
9D0097E0  8FB20018   LW S2, 24(SP)
9D0097E4  8FB10014   LW S1, 20(SP)
9D0097E8  8FB00010   LW S0, 16(SP)
9D0097EC  03E00008   JR RA
9D0097F0  27BD0030   ADDIU SP, SP, 48
1095:                
1096:                // *****************************************************************************
1097:                /* Function:
1098:                    void _DRV_USBFS_DEVICE_IRPQueueFlush
1099:                    (
1100:                        DRV_USBFS_DEVICE_ENDPOINT_OBJ * endpointObject
1101:                        USB_DEVICE_IRP_STATUS status
1102:                    )
1103:                
1104:                  Summary:
1105:                    Dynamic impementation of _DRV_USBFS_DEVICE_IRPQueueFlush function.
1106:                
1107:                  Description:
1108:                    This is the dynamic impementation of _DRV_USBFS_DEVICE_IRPQueueFlush
1109:                    function for USB device.  Function scans for all the IRPs on the endpoint
1110:                    queue and cancels them all. status indicate the abort status to be returned
1111:                    when the IRP callback is invoked.
1112:                
1113:                  Remarks:
1114:                    This is a local function and should not be called directly by the
1115:                    application.
1116:                */
1117:                
1118:                void _DRV_USBFS_DEVICE_IRPQueueFlush
1119:                (
1120:                    DRV_USBFS_DEVICE_ENDPOINT_OBJ * endpointObject,
1121:                    USB_DEVICE_IRP_STATUS status
1122:                )
1123:                {
9D0137E4  27BDFFE0   ADDIU SP, SP, -32
9D0137E8  AFBF001C   SW RA, 28(SP)
9D0137EC  AFB20018   SW S2, 24(SP)
9D0137F0  AFB10014   SW S1, 20(SP)
9D0137F4  AFB00010   SW S0, 16(SP)
1124:                    /* Start of local variable */
1125:                    USB_DEVICE_IRP_LOCAL * iterator = NULL;
1126:                    /* End of local variable */
1127:                    
1128:                    if(endpointObject != NULL)
9D0137F8  1080000E   BEQ A0, ZERO, 0x9D013834
9D0137FC  00809021   ADDU S2, A0, ZERO
1129:                    {
1130:                        /* Check if any IRPs are assigned on this endpoint and
1131:                         * abort them */
1132:                        if(endpointObject->irpQueue != NULL)
9D013800  8C900000   LW S0, 0(A0)
9D013804  1200000A   BEQ S0, ZERO, 0x9D013830
9D013808  00A08821   ADDU S1, A1, ZERO
1133:                        {
1134:                            /* Scan for all the IRPs on this endpoint
1135:                             * Cancel the IRP and deallocate driver IRP
1136:                             * objects */
1137:                            iterator = endpointObject->irpQueue;
1138:                            while(iterator != NULL)
9D013828  5600FFF9   BNEL S0, ZERO, 0x9D013810
9D01382C  AE110008   SW S1, 8(S0)
1139:                            {
1140:                                iterator->status = status;
9D01380C  AE110008   SW S1, 8(S0)
1141:                                if(iterator->callback != NULL)
9D013810  8E02000C   LW V0, 12(S0)
9D013814  50400004   BEQL V0, ZERO, 0x9D013828
9D013818  8E100018   LW S0, 24(S0)
1142:                                {
1143:                                    iterator->callback((USB_DEVICE_IRP *)iterator);
9D01381C  0040F809   JALR V0
9D013820  02002021   ADDU A0, S0, ZERO
1144:                                }
1145:                                iterator = iterator->next;
9D013824  8E100018   LW S0, 24(S0)
1146:                            }/* end of while(IRP != NULL) */
1147:                        }
1148:                        /* Set the head pointer to NULL */
1149:                        endpointObject->irpQueue = NULL;
9D013830  AE400000   SW ZERO, 0(S2)
1150:                    }
1151:                }/* end of _DRV_USBFS_DEVICE_IRPQueueFlush() */
9D013834  8FBF001C   LW RA, 28(SP)
9D013838  8FB20018   LW S2, 24(SP)
9D01383C  8FB10014   LW S1, 20(SP)
9D013840  8FB00010   LW S0, 16(SP)
9D013844  03E00008   JR RA
9D013848  27BD0020   ADDIU SP, SP, 32
1152:                
1153:                // *****************************************************************************
1154:                /* Function:
1155:                    USB_ERROR DRV_USBFS_DEVICE_IRPCancel
1156:                    (
1157:                        DRV_HANDLE client, 
1158:                        USB_DEVICE_IRP * irp
1159:                    )
1160:                
1161:                  Summary:
1162:                    Dynamic implementation of DRV_USBFS_DEVICE_IRPCancel client interface
1163:                    function.
1164:                
1165:                  Description:
1166:                    This is the dynamic implementation of DRV_USBFS_DEVICE_IRPCancel client
1167:                    interface function for USB device.  Function checks the validity of the
1168:                    input arguments and on success cancels  the specific IRP.
1169:                    An IRP that was in the queue but that has been processed yet will be
1170:                    cancelled successfully and the IRP callback function will be called from
1171:                    this function with USB_DEVICE_IRP_STATUS_ABORTED status. The application can
1172:                    release the data buffer memory used by the IRP when this callback occurs.
1173:                    If the IRP was in progress (a transaction in on the bus) when the cancel
1174:                    function was called, the IRP will be cancelled only when an ongoing or the
1175:                    next transaction has completed. The IRP callback function will then be
1176:                    called in an interrupt context. The application should not release the
1177:                    related data buffer unless the IRP callback has occurred.
1178:                
1179:                  Remarks:
1180:                    See drv_usbfs.h for usage information.
1181:                */
1182:                
1183:                USB_ERROR DRV_USBFS_DEVICE_IRPCancel
1184:                (
1185:                    DRV_HANDLE client, 
1186:                    USB_DEVICE_IRP * irp
1187:                )
1188:                {
9D00DD34  27BDFFD8   ADDIU SP, SP, -40
9D00DD38  AFBF0024   SW RA, 36(SP)
9D00DD3C  AFB30020   SW S3, 32(SP)
9D00DD40  AFB2001C   SW S2, 28(SP)
9D00DD44  AFB10018   SW S1, 24(SP)
9D00DD48  AFB00014   SW S0, 20(SP)
1189:                    /* Start of local variables */
1190:                    USB_ERROR returnValue = USB_ERROR_NONE;
1191:                    DRV_USBFS_OBJ * hDriver = NULL;
1192:                    USB_DEVICE_IRP_LOCAL * irpToCancel = (USB_DEVICE_IRP_LOCAL *)irp;
1193:                    bool interruptWasEnabled = false;
1194:                    /* End of local variables */
1195:                    
1196:                    /* Check if the handle is valid */
1197:                    if(DRV_HANDLE_INVALID == client)
9D00DD4C  2402FFFF   ADDIU V0, ZERO, -1
9D00DD50  10820033   BEQ A0, V0, 0x9D00DE20
9D00DD54  00808821   ADDU S1, A0, ZERO
1198:                    {
1199:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "Driver Handle is invalid");
1200:                        returnValue = USB_ERROR_PARAMETER_INVALID;
9D00DE20  0B403797   J 0x9D00DE5C
9D00DE24  2412FF83   ADDIU S2, ZERO, -125
1201:                    }
1202:                    /* Check if the IRP is NULL */
1203:                    else if(irpToCancel == NULL)
9D00DD58  10A00033   BEQ A1, ZERO, 0x9D00DE28
9D00DD5C  00A08021   ADDU S0, A1, ZERO
1204:                    {
1205:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "IRP is invalid");
1206:                        returnValue = USB_ERROR_PARAMETER_INVALID;
9D00DE28  0B403797   J 0x9D00DE5C
9D00DE2C  2412FF83   ADDIU S2, ZERO, -125
1207:                    }
1208:                    else
1209:                    {
1210:                        hDriver = ((DRV_USBFS_OBJ *)client);
1211:                    
1212:                        if(!(hDriver->inInterruptContext))
9D00DD60  90830001   LBU V1, 1(A0)
9D00DD64  14600032   BNE V1, ZERO, 0x9D00DE30
9D00DD68  00009821   ADDU S3, ZERO, ZERO
1213:                        {
1214:                            if(OSAL_MUTEX_Lock(&hDriver->mutexID, OSAL_WAIT_FOREVER) != OSAL_RESULT_TRUE)
9D00DD6C  24840030   ADDIU A0, A0, 48
9D00DD70  0F405267   JAL OSAL_MUTEX_Lock
9D00DD74  3405FFFF   ORI A1, ZERO, -1
9D00DD78  24030001   ADDIU V1, ZERO, 1
9D00DD7C  14430037   BNE V0, V1, 0x9D00DE5C
9D00DD80  2412FF81   ADDIU S2, ZERO, -127
1215:                            {
1216:                                SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "mutex lock failed");
1217:                                returnValue = USB_ERROR_OSAL_FUNCTION;
1218:                            }
1219:                            else
1220:                            {
1221:                                /* Disable the interrupt */
1222:                                 interruptWasEnabled =
9D00DD84  0F405058   JAL SYS_INT_SourceDisable
9D00DD88  8E240028   LW A0, 40(S1)
9D00DD8C  0B40378C   J 0x9D00DE30
9D00DD90  00409821   ADDU S3, V0, ZERO
1223:                                         _DRV_USBFS_InterruptSourceDisable(hDriver->interruptSource);
1224:                            }
1225:                        }
1226:                        
1227:                        if(returnValue == USB_ERROR_NONE)
1228:                        {
1229:                            if(irpToCancel->status <= USB_DEVICE_IRP_STATUS_COMPLETED_SHORT)
9D00DE30  8E030008   LW V1, 8(S0)
9D00DE34  28630002   SLTI V1, V1, 2
9D00DE38  1060FFD6   BEQ V1, ZERO, 0x9D00DD94
9D00DE3C  2402FFFE   ADDIU V0, ZERO, -2
1230:                            {
1231:                                /* This IRP has either completed or has been aborted.*/
1232:                                returnValue = USB_ERROR_PARAMETER_INVALID;
1233:                            }
1234:                            else
1235:                            {
1236:                                /* The code will come here both when the IRP is NOT the 1st
1237:                                 * in queue as well as when it is at the HEAD. We will change
1238:                                 * the IRP status for either scenario but will give the callback
1239:                                 * only if it is NOT at the HEAD of the queue.
1240:                                 * 
1241:                                 * What it means for HEAD IRP case is it will be caught in USB
1242:                                 * ISR and will be further processed in ISR. This is done to
1243:                                 * make sure that the user cannot release the IRP buffer before
1244:                                 * ABORT callback*/
1245:                                
1246:                                /* Mark the IRP status as aborted */
1247:                                irpToCancel->status = USB_DEVICE_IRP_STATUS_ABORTED;
9D00DD94  AE020008   SW V0, 8(S0)
1248:                                
1249:                                /* No data for this IRP was sent or received */
1250:                                irpToCancel->size = 0;
9D00DD98  AE000004   SW ZERO, 4(S0)
1251:                                
1252:                                if(irpToCancel->previous != NULL)
9D00DD9C  8E02001C   LW V0, 28(S0)
9D00DDA0  5040002C   BEQL V0, ZERO, 0x9D00DE54
9D00DDA4  92220001   LBU V0, 1(S1)
1253:                                {
1254:                                    /* This means this is not the HEAD IRP in the IRP queue.
1255:                                     Can be removed from the endpoint object queue safely.*/
1256:                                    irpToCancel->previous->next = irpToCancel->next;
9D00DDA8  8E030018   LW V1, 24(S0)
9D00DDAC  AC430018   SW V1, 24(V0)
1257:                
1258:                                    if(irpToCancel->next != NULL)
9D00DDB0  8E020018   LW V0, 24(S0)
9D00DDB4  50400004   BEQL V0, ZERO, 0x9D00DDC8
9D00DDB8  AE00001C   SW ZERO, 28(S0)
1259:                                    {
1260:                                        /* If this is not the last IRP in the queue then update
1261:                                         the previous link connection for the next IRP */
1262:                                        irpToCancel->next->previous = irpToCancel->previous;
9D00DDBC  8E03001C   LW V1, 28(S0)
9D00DDC0  AC43001C   SW V1, 28(V0)
1263:                                    }
1264:                
1265:                                    irpToCancel->previous = NULL;
9D00DDC4  AE00001C   SW ZERO, 28(S0)
1266:                                    irpToCancel->next = NULL;
9D00DDC8  AE000018   SW ZERO, 24(S0)
1267:                                    
1268:                                    if(irpToCancel->callback != NULL)
9D00DDCC  8E02000C   LW V0, 12(S0)
9D00DDD0  50400020   BEQL V0, ZERO, 0x9D00DE54
9D00DDD4  92220001   LBU V0, 1(S1)
1269:                                    {
1270:                                        irpToCancel->callback((USB_DEVICE_IRP *)irpToCancel);
9D00DDD8  0040F809   JALR V0
9D00DDDC  02002021   ADDU A0, S0, ZERO
1271:                                    }
1272:                                }
1273:                            }
1274:                        }
1275:                
1276:                        if( (!(hDriver->inInterruptContext)) && 
9D00DDE0  0B403795   J 0x9D00DE54
9D00DDE4  92220001   LBU V0, 1(S1)
9D00DE40  92220001   LBU V0, 1(S1)
9D00DE44  14400005   BNE V0, ZERO, 0x9D00DE5C
9D00DE48  2412FF83   ADDIU S2, ZERO, -125
9D00DE4C  0B40377A   J 0x9D00DDE8
9D00DE50  00000000   NOP
9D00DE54  1040FFE4   BEQ V0, ZERO, 0x9D00DDE8
9D00DE58  00009021   ADDU S2, ZERO, ZERO
1277:                                ( (returnValue == USB_ERROR_NONE) || 
1278:                                (returnValue == USB_ERROR_PARAMETER_INVALID) ) )
1279:                        {
1280:                            if(interruptWasEnabled)
9D00DDE8  12600009   BEQ S3, ZERO, 0x9D00DE10
9D00DDEC  3C03BF88   LUI V1, -16504
1281:                            {
1282:                                _DRV_USBFS_InterruptSourceEnable(hDriver->interruptSource);
9D00DDF0  8E220028   LW V0, 40(S1)
1283:                            }
1284:                
1285:                            if(OSAL_MUTEX_Unlock(&hDriver->mutexID) != OSAL_RESULT_TRUE)
9D00DE10  0F40541A   JAL OSAL_MUTEX_Unlock
9D00DE14  26240030   ADDIU A0, S1, 48
9D00DE18  0B403798   J 0x9D00DE60
9D00DE1C  02401021   ADDU V0, S2, ZERO
1286:                            {
1287:                                SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "Mutex unlock failed");
1288:                            }
1289:                        }
1290:                    }
1291:                    
1292:                    return returnValue;
1293:                    
1294:                }/* End of DRV_USBFS_DEVICE_IRPCancel() */
9D00DE5C  02401021   ADDU V0, S2, ZERO
9D00DE60  8FBF0024   LW RA, 36(SP)
9D00DE64  8FB30020   LW S3, 32(SP)
9D00DE68  8FB2001C   LW S2, 28(SP)
9D00DE6C  8FB10018   LW S1, 24(SP)
9D00DE70  8FB00014   LW S0, 20(SP)
9D00DE74  03E00008   JR RA
9D00DE78  27BD0028   ADDIU SP, SP, 40
1295:                
1296:                // *****************************************************************************
1297:                /* Function:
1298:                    USB_ERROR DRV_USBFS_DEVICE_IRPCancelAll
1299:                    (
1300:                        DRV_HANDLE client,
1301:                        USB_ENDPOINT endpointAndDirection
1302:                    )
1303:                
1304:                  Summary:
1305:                    Dynamic impementation of DRV_USBFS_DEVICE_IRPCancelAll client interface
1306:                    function.
1307:                
1308:                  Description:
1309:                    This is the dynamic impementation of DRV_USBFS_DEVICE_IRPCancelAll client
1310:                    interface function for USB device.  Function checks the validity of the
1311:                    input arguments and on success cancels all the IRPs on the specific endpoint
1312:                    object queue.
1313:                
1314:                  Remarks:
1315:                    See drv_usbfs.h for usage information.
1316:                */
1317:                
1318:                USB_ERROR DRV_USBFS_DEVICE_IRPCancelAll
1319:                (
1320:                    DRV_HANDLE client,
1321:                    USB_ENDPOINT endpointAndDirection
1322:                )
1323:                {
9D00F190  27BDFFD8   ADDIU SP, SP, -40
9D00F194  AFBF0024   SW RA, 36(SP)
9D00F198  AFB30020   SW S3, 32(SP)
9D00F19C  AFB2001C   SW S2, 28(SP)
9D00F1A0  AFB10018   SW S1, 24(SP)
9D00F1A4  AFB00014   SW S0, 20(SP)
1324:                    /* Start of local variable */
1325:                    uint8_t                       endpoint;
1326:                    bool                          interruptWasEnabled = false;
1327:                    int                           direction;
1328:                    DRV_USBFS_OBJ                 * hDriver;
1329:                    DRV_USBFS_BDT_ENTRY           * pBDT;
1330:                    DRV_USBFS_DEVICE_ENDPOINT_OBJ * endpointObject;
1331:                    /* end of local variable */
1332:                
1333:                    endpoint = endpointAndDirection & 0xF;
1334:                    direction = ((endpointAndDirection & 0x80) != 0);
9D00F180  000511C2   SRL V0, A1, 7
1335:                
1336:                    /* Check if the endpoint number is within limit */
1337:                    if(endpoint >= DRV_USBFS_ENDPOINTS_NUMBER)
9D00F184  30A5000F   ANDI A1, A1, 15
9D00F188  14A00033   BNE A1, ZERO, 0x9D00F258
9D00F18C  2403FFFF   ADDIU V1, ZERO, -1
1338:                    {
1339:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO,"Unsupported endpoint");
1340:                        return USB_ERROR_DEVICE_ENDPOINT_INVALID;
1341:                    }
1342:                
1343:                    /* Check if the handle is valid */
1344:                    if(DRV_HANDLE_INVALID == client)
9D00F1A8  1083002D   BEQ A0, V1, 0x9D00F260
9D00F1AC  00808021   ADDU S0, A0, ZERO
1345:                    {
1346:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "Driver Handle is invalid");
1347:                        return USB_ERROR_PARAMETER_INVALID;
9D00F260  0B403CA1   J 0x9D00F284
9D00F264  2402FF83   ADDIU V0, ZERO, -125
1348:                    }
1349:                    
1350:                    hDriver      = ((DRV_USBFS_OBJ *)client);
1351:                
1352:                    /* Get the endpoint object */
1353:                    endpointObject = hDriver->endpointTable + (2 * endpoint) + direction;
9D00F1B0  000218C0   SLL V1, V0, 3
9D00F1B4  00022140   SLL A0, V0, 5
9D00F1B8  00831823   SUBU V1, A0, V1
9D00F1BC  8E040034   LW A0, 52(S0)
9D00F1C0  00839021   ADDU S2, A0, V1
1354:                
1355:                    /* Get the BDT entry for this endpoint */
1356:                    pBDT = hDriver->pBDT + (4 * endpoint) + (2 * direction);
9D00F1C4  00021100   SLL V0, V0, 4
9D00F1C8  8E03002C   LW V1, 44(S0)
9D00F1CC  00628821   ADDU S1, V1, V0
1357:                
1358:                    if(!(hDriver->inInterruptContext))
9D00F1D0  92030001   LBU V1, 1(S0)
9D00F1D4  54600024   BNEL V1, ZERO, 0x9D00F268
9D00F1D8  A2200000   SB ZERO, 0(S1)
1359:                    {
1360:                        if(OSAL_MUTEX_Lock(&hDriver->mutexID, OSAL_WAIT_FOREVER) != OSAL_RESULT_TRUE)
9D00F1DC  26040030   ADDIU A0, S0, 48
9D00F1E0  0F405267   JAL OSAL_MUTEX_Lock
9D00F1E4  3405FFFF   ORI A1, ZERO, -1
9D00F1E8  24030001   ADDIU V1, ZERO, 1
9D00F1EC  54430025   BNEL V0, V1, 0x9D00F284
9D00F1F0  2402FF81   ADDIU V0, ZERO, -127
1361:                        {
1362:                            SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "mutex lock failed");
1363:                            return USB_ERROR_OSAL_FUNCTION;
1364:                        }
1365:                
1366:                        /* Disable the interrupt */
1367:                         interruptWasEnabled = _DRV_USBFS_InterruptSourceDisable(hDriver->interruptSource);
9D00F1F4  0F405058   JAL SYS_INT_SourceDisable
9D00F1F8  8E040028   LW A0, 40(S0)
9D00F1FC  00409821   ADDU S3, V0, ZERO
1368:                    }
1369:                
1370:                    /* Get the odd and even endpoint BDT back */
1371:                    pBDT->byte[0] = 0x0;
9D00F200  A2200000   SB ZERO, 0(S1)
1372:                    (pBDT + 1)->byte[0] = 0x0;
9D00F204  A2200008   SB ZERO, 8(S1)
9D00F268  A2200008   SB ZERO, 8(S1)
1373:                
1374:                    /* Flush the endpoint */
1375:                    _DRV_USBFS_DEVICE_IRPQueueFlush(endpointObject, USB_DEVICE_IRP_STATUS_ABORTED);
9D00F208  02402021   ADDU A0, S2, ZERO
9D00F20C  0F404DF9   JAL _DRV_USBFS_DEVICE_IRPQueueFlush
9D00F210  2405FFFE   ADDIU A1, ZERO, -2
9D00F26C  02402021   ADDU A0, S2, ZERO
9D00F270  0F404DF9   JAL _DRV_USBFS_DEVICE_IRPQueueFlush
9D00F274  2405FFFE   ADDIU A1, ZERO, -2
1376:                
1377:                    if(!(hDriver->inInterruptContext))
9D00F214  92030001   LBU V1, 1(S0)
9D00F218  1460001A   BNE V1, ZERO, 0x9D00F284
9D00F21C  00001021   ADDU V0, ZERO, ZERO
9D00F278  92030001   LBU V1, 1(S0)
9D00F27C  1060FFF2   BEQ V1, ZERO, 0x9D00F248
9D00F280  00001021   ADDU V0, ZERO, ZERO
1378:                    {
1379:                        if(interruptWasEnabled)
9D00F220  12600009   BEQ S3, ZERO, 0x9D00F248
9D00F224  3C03BF88   LUI V1, -16504
1380:                        {
1381:                            _DRV_USBFS_InterruptSourceEnable(hDriver->interruptSource);
9D00F228  8E020028   LW V0, 40(S0)
1382:                        }
1383:                
1384:                        if(OSAL_MUTEX_Unlock(&hDriver->mutexID) != OSAL_RESULT_TRUE)
9D00F248  0F40541A   JAL OSAL_MUTEX_Unlock
9D00F24C  26040030   ADDIU A0, S0, 48
9D00F250  0B403CA1   J 0x9D00F284
9D00F254  00001021   ADDU V0, ZERO, ZERO
1385:                        {
1386:                            SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "Mutex unlock failed");
1387:                        }
1388:                    }
1389:                
1390:                    return(USB_ERROR_NONE);
1391:                
1392:                }/* end of DRV_USBFS_DEVICE_IRPCancelAll() */
9D00F258  03E00008   JR RA
9D00F25C  2402FF84   ADDIU V0, ZERO, -124
9D00F284  8FBF0024   LW RA, 36(SP)
9D00F288  8FB30020   LW S3, 32(SP)
9D00F28C  8FB2001C   LW S2, 28(SP)
9D00F290  8FB10018   LW S1, 24(SP)
9D00F294  8FB00014   LW S0, 20(SP)
9D00F298  03E00008   JR RA
9D00F29C  27BD0028   ADDIU SP, SP, 40
1393:                
1394:                // *****************************************************************************
1395:                /* Function:
1396:                    USB_ERROR DRV_USBFS_DEVICE_EndpointStall
1397:                    (
1398:                        DRV_HANDLE client,
1399:                        USB_ENDPOINT endpointAndDirection
1400:                    )
1401:                
1402:                  Summary:
1403:                    Dynamic impementation of DRV_USBFS_DEVICE_EndpointStall client interface
1404:                    function.
1405:                
1406:                  Description:
1407:                    This is the dynamic impementation of DRV_USBFS_DEVICE_EndpointStall client
1408:                    interface function for USB device.  Function sets the STALL state of the
1409:                    specified endpoint.
1410:                
1411:                  Remarks:
1412:                    See drv_usbfs.h for usage information.
1413:                */
1414:                
1415:                USB_ERROR DRV_USBFS_DEVICE_EndpointStall
1416:                (
1417:                    DRV_HANDLE client,
1418:                    USB_ENDPOINT endpointAndDirection
1419:                )
1420:                {
9D00E114  27BDFFD8   ADDIU SP, SP, -40
9D00E118  AFBF0024   SW RA, 36(SP)
9D00E11C  AFB30020   SW S3, 32(SP)
9D00E120  AFB2001C   SW S2, 28(SP)
9D00E124  AFB10018   SW S1, 24(SP)
9D00E128  AFB00014   SW S0, 20(SP)
1421:                    /* start of local variables */
1422:                    int     direction;
1423:                    bool    interruptWasEnabled = false;
1424:                    uint8_t endpoint;
1425:                    DRV_USBFS_OBJ     * hDriver;
1426:                    DRV_USBFS_BDT_ENTRY * pBDT;
1427:                    DRV_USBFS_DEVICE_ENDPOINT_OBJ * endpointObject;
1428:                    /* end of local variables */
1429:                
1430:                    endpoint = endpointAndDirection & 0xF;
1431:                    direction = ((endpointAndDirection & 0x80) != 0);
1432:                
1433:                    if(endpoint >= DRV_USBFS_ENDPOINTS_NUMBER)
9D00E108  30A5000F   ANDI A1, A1, 15
9D00E10C  14A00025   BNE A1, ZERO, 0x9D00E1A4
9D00E110  00000000   NOP
1434:                    {
1435:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO,"Unsupported endpoint");
1436:                        return USB_ERROR_DEVICE_ENDPOINT_INVALID;
1437:                    }
1438:                
1439:                    if(DRV_HANDLE_INVALID == client)
9D00E12C  2402FFFF   ADDIU V0, ZERO, -1
9D00E130  1082001E   BEQ A0, V0, 0x9D00E1AC
9D00E134  00808021   ADDU S0, A0, ZERO
1440:                    {
1441:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "Driver Handle is invalid");
1442:                        return USB_ERROR_PARAMETER_INVALID;
9D00E1AC  0B40388A   J 0x9D00E228
9D00E1B0  2402FF83   ADDIU V0, ZERO, -125
1443:                    }
1444:                
1445:                    hDriver      = ((DRV_USBFS_OBJ *)client);
1446:                
1447:                    if(!(hDriver->inInterruptContext))
9D00E138  90830001   LBU V1, 1(A0)
9D00E13C  1460001D   BNE V1, ZERO, 0x9D00E1B4
9D00E140  00009821   ADDU S3, ZERO, ZERO
1448:                    {
1449:                        //OSAL: Get Mutex
1450:                        if(OSAL_MUTEX_Lock(&hDriver->mutexID, OSAL_WAIT_FOREVER) !=
9D00E144  24840030   ADDIU A0, A0, 48
9D00E148  0F405267   JAL OSAL_MUTEX_Lock
9D00E14C  3405FFFF   ORI A1, ZERO, -1
9D00E150  24030001   ADDIU V1, ZERO, 1
9D00E154  54430034   BNEL V0, V1, 0x9D00E228
9D00E158  2402FF81   ADDIU V0, ZERO, -127
1451:                                OSAL_RESULT_TRUE)
1452:                        {
1453:                            SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "mutex lock failed");
1454:                            return USB_ERROR_OSAL_FUNCTION;
1455:                        }
1456:                
1457:                        /* Disable the interrupt */
1458:                        interruptWasEnabled = _DRV_USBFS_InterruptSourceDisable(hDriver->interruptSource);
9D00E15C  0F405058   JAL SYS_INT_SourceDisable
9D00E160  8E040028   LW A0, 40(S0)
9D00E164  0B40386D   J 0x9D00E1B4
9D00E168  00409821   ADDU S3, V0, ZERO
1459:                    }
1460:                   
1461:                    if(endpoint == 0)
1462:                    {
1463:                        /* For zero endpoint we stall both directions */
1464:                
1465:                        endpointObject = hDriver->endpointTable;
9D00E1B4  8E110034   LW S1, 52(S0)
1466:                        pBDT = hDriver->pBDT + (endpointObject->nextPingPong);
9D00E1B8  8E220010   LW V0, 16(S1)
1467:                        
1468:                        /* This is the RX direction for EP0. Get the
1469:                         * BDT back, stall it, flush all IRPs and then
1470:                         * set the endpoint state */
1471:                        
1472:                        pBDT->byte[0] = 0x0;
1473:                        pBDT->byte[0] |= 0x84;
9D00E1BC  8E03002C   LW V1, 44(S0)
9D00E1C0  000210C0   SLL V0, V0, 3
9D00E1C4  00621021   ADDU V0, V1, V0
9D00E1C8  2412FF84   ADDIU S2, ZERO, -124
9D00E1CC  A0520000   SB S2, 0(V0)
1474:                        _DRV_USBFS_DEVICE_IRPQueueFlush(endpointObject, USB_DEVICE_IRP_STATUS_ABORTED_ENDPOINT_HALT);
9D00E1D0  02202021   ADDU A0, S1, ZERO
9D00E1D4  0F404DF9   JAL _DRV_USBFS_DEVICE_IRPQueueFlush
9D00E1D8  2405FFFD   ADDIU A1, ZERO, -3
1475:                        endpointObject->endpointState |= DRV_USBFS_DEVICE_ENDPOINT_STATE_STALLED;
9D00E1DC  8E220014   LW V0, 20(S1)
9D00E1E0  34420002   ORI V0, V0, 2
9D00E1E4  AE220014   SW V0, 20(S1)
1476:                
1477:                        /* Now do the same for the TX direction */
1478:                
1479:                        endpointObject = hDriver->endpointTable + 1;
9D00E1E8  8E110034   LW S1, 52(S0)
1480:                        pBDT = hDriver->pBDT + 2 + (endpointObject->nextPingPong);
9D00E1EC  8E220028   LW V0, 40(S1)
9D00E1F0  24420002   ADDIU V0, V0, 2
1481:                        
1482:                        /* This is the TX direction for EP0. Get the
1483:                         * BDT back, stall it, flush all IRPs and then
1484:                         * set the endpoint state */
1485:                        
1486:                        pBDT->byte[0] = 0x0;
1487:                        pBDT->byte[0] |= 0x84;
9D00E1F4  8E03002C   LW V1, 44(S0)
9D00E1F8  000210C0   SLL V0, V0, 3
9D00E1FC  00621021   ADDU V0, V1, V0
9D00E200  A0520000   SB S2, 0(V0)
1488:                        _DRV_USBFS_DEVICE_IRPQueueFlush(endpointObject, USB_DEVICE_IRP_STATUS_ABORTED_ENDPOINT_HALT );
9D00E204  26240018   ADDIU A0, S1, 24
9D00E208  0F404DF9   JAL _DRV_USBFS_DEVICE_IRPQueueFlush
9D00E20C  2405FFFD   ADDIU A1, ZERO, -3
1489:                        endpointObject->endpointState |= DRV_USBFS_DEVICE_ENDPOINT_STATE_STALLED;
9D00E210  8E23002C   LW V1, 44(S1)
9D00E214  34630002   ORI V1, V1, 2
9D00E218  AE23002C   SW V1, 44(S1)
1490:                
1491:                    } 
1492:                    else
1493:                    {
1494:                        /* For non zero endpoints we stall the specified direction */
1495:                
1496:                        /* Get the endpoint object */
1497:                        endpointObject = hDriver->endpointTable + (2 * endpoint)
1498:                            + direction;
1499:                
1500:                        /* Get the BDT entry for this endpoint */
1501:                        pBDT = hDriver->pBDT + (4 * endpoint) + (2 * direction) ;
1502:                    
1503:                        /* Get the endpoint BDT back. Stall the entry.
1504:                         * Flush the endpoint and set the object state. */
1505:                        pBDT->byte[0] = 0x0;
1506:                        pBDT->byte[0] |= 0x84;
1507:                
1508:                        pBDT = hDriver->pBDT + (4 * endpoint) + (2 * direction) + 1;
1509:                
1510:                        /* Get the endpoint BDT back. Stall the entry.
1511:                         * Flush the endpoint and set the object state. */
1512:                        pBDT->byte[0] = 0x0;
1513:                        pBDT->byte[0] |= 0x84;
1514:                
1515:                
1516:                        _DRV_USBFS_DEVICE_IRPQueueFlush(endpointObject, USB_DEVICE_IRP_STATUS_ABORTED_ENDPOINT_HALT);
1517:                        endpointObject->endpointState |= DRV_USBFS_DEVICE_ENDPOINT_STATE_STALLED;
1518:                
1519:                    }
1520:                    
1521:                    if(!(hDriver->inInterruptContext))
9D00E21C  92030001   LBU V1, 1(S0)
9D00E220  1060FFD2   BEQ V1, ZERO, 0x9D00E16C
9D00E224  00001021   ADDU V0, ZERO, ZERO
1522:                    {
1523:                        if(interruptWasEnabled)
9D00E16C  12600009   BEQ S3, ZERO, 0x9D00E194
9D00E170  3C03BF88   LUI V1, -16504
1524:                        {
1525:                            /* Enable the interrupt */
1526:                            _DRV_USBFS_InterruptSourceEnable(hDriver->interruptSource);
9D00E174  8E020028   LW V0, 40(S0)
1527:                        }
1528:                
1529:                        if(OSAL_MUTEX_Unlock(&hDriver->mutexID) != OSAL_RESULT_TRUE)
9D00E194  0F40541A   JAL OSAL_MUTEX_Unlock
9D00E198  26040030   ADDIU A0, S0, 48
9D00E19C  0B40388A   J 0x9D00E228
9D00E1A0  00001021   ADDU V0, ZERO, ZERO
1530:                        {
1531:                            SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "Mutex unlock failed");
1532:                        }
1533:                    }
1534:                    
1535:                    return(USB_ERROR_NONE);
1536:                
1537:                }/* end of DRV_USBFS_DEVICE_EndpointStall() */
9D00E1A4  03E00008   JR RA
9D00E1A8  2402FF84   ADDIU V0, ZERO, -124
9D00E228  8FBF0024   LW RA, 36(SP)
9D00E22C  8FB30020   LW S3, 32(SP)
9D00E230  8FB2001C   LW S2, 28(SP)
9D00E234  8FB10018   LW S1, 24(SP)
9D00E238  8FB00014   LW S0, 20(SP)
9D00E23C  03E00008   JR RA
9D00E240  27BD0028   ADDIU SP, SP, 40
1538:                
1539:                // *****************************************************************************
1540:                /* Function:
1541:                    USB_ERROR DRV_USBFS_DEVICE_EndpointStallClear
1542:                    (
1543:                        DRV_HANDLE client,
1544:                        USB_ENDPOINT endpointAndDirection
1545:                    )
1546:                
1547:                  Summary:
1548:                    Dynamic impementation of DRV_USBFS_DEVICE_EndpointStallClear client interface
1549:                    function.
1550:                
1551:                  Description:
1552:                    This is the dynamic impementation of DRV_USBFS_DEVICE_EndpointStallClear
1553:                    client interface function for USB device.  Function clears the STALL state
1554:                    of the specified endpoint and resets the data toggle value.
1555:                
1556:                  Remarks:
1557:                    See drv_usbfs.h for usage information.
1558:                */
1559:                
1560:                USB_ERROR DRV_USBFS_DEVICE_EndpointStallClear
1561:                (
1562:                    DRV_HANDLE client,
1563:                    USB_ENDPOINT endpointAndDirection
1564:                )
1565:                {
9D00E718  27BDFFD8   ADDIU SP, SP, -40
9D00E71C  AFBF0024   SW RA, 36(SP)
9D00E720  AFB30020   SW S3, 32(SP)
9D00E724  AFB2001C   SW S2, 28(SP)
9D00E728  AFB10018   SW S1, 24(SP)
1566:                    /* Start of local variables */
1567:                    int                           direction;
1568:                    uint8_t                       endpoint;
1569:                    DRV_USBFS_OBJ                 * hDriver;
1570:                    DRV_USBFS_BDT_ENTRY           * pBDT;
1571:                    DRV_USBFS_DEVICE_ENDPOINT_OBJ * endpointObject;
1572:                    bool interruptWasEnabled = false;
1573:                    USB_MODULE_ID usbID; 
1574:                    /* End of local variables */
1575:                
1576:                    endpoint = endpointAndDirection & 0xF;
1577:                    direction = ((endpointAndDirection & 0x80) != 0);
9D00E72C  000589C2   SRL S1, A1, 7
1578:                
1579:                    if(endpoint >= DRV_USBFS_ENDPOINTS_NUMBER)
9D00E730  30A5000F   ANDI A1, A1, 15
9D00E734  14A00028   BNE A1, ZERO, 0x9D00E7D8
9D00E738  AFB00014   SW S0, 20(SP)
1580:                    {
1581:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO,"Unsupported endpoint");
1582:                        return USB_ERROR_DEVICE_ENDPOINT_INVALID;
9D00E7D8  0B403A0A   J 0x9D00E828
9D00E7DC  2402FF84   ADDIU V0, ZERO, -124
1583:                    }
1584:                
1585:                    /* Check if the handle is valid */
1586:                    if(DRV_HANDLE_INVALID == client)
9D00E73C  2402FFFF   ADDIU V0, ZERO, -1
9D00E740  10820027   BEQ A0, V0, 0x9D00E7E0
9D00E744  00808021   ADDU S0, A0, ZERO
9D00E748  02209821   ADDU S3, S1, ZERO
1587:                    {
1588:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "Driver Handle is invalid");
1589:                        return USB_ERROR_PARAMETER_INVALID;
9D00E7E0  0B403A0A   J 0x9D00E828
9D00E7E4  2402FF83   ADDIU V0, ZERO, -125
1590:                    }
1591:                
1592:                    hDriver      = ((DRV_USBFS_OBJ *)client);
1593:                    usbID = hDriver->usbID;
1594:                    /* Get the endpoint object */
1595:                    endpointObject = hDriver->endpointTable + (2 * endpoint) + direction;
9D00E74C  001190C0   SLL S2, S1, 3
9D00E750  00111140   SLL V0, S1, 5
9D00E754  00529023   SUBU S2, V0, S2
9D00E758  8C820034   LW V0, 52(A0)
1596:                   
1597:                    /* Disable the driver interrupt */
1598:                    if(!(hDriver->inInterruptContext))
9D00E75C  90830001   LBU V1, 1(A0)
9D00E760  14600021   BNE V1, ZERO, 0x9D00E7E8
9D00E764  00529021   ADDU S2, V0, S2
1599:                    {
1600:                        //OSAL: Get Mutex
1601:                        if(OSAL_MUTEX_Lock(&hDriver->mutexID, OSAL_WAIT_FOREVER) !=
9D00E768  24840030   ADDIU A0, A0, 48
9D00E76C  0F405267   JAL OSAL_MUTEX_Lock
9D00E770  3405FFFF   ORI A1, ZERO, -1
9D00E774  24030001   ADDIU V1, ZERO, 1
9D00E778  1443002B   BNE V0, V1, 0x9D00E828
9D00E77C  2402FF81   ADDIU V0, ZERO, -127
1602:                                OSAL_RESULT_TRUE)
1603:                        {
1604:                            SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "mutex lock failed");
1605:                            return USB_ERROR_OSAL_FUNCTION;
1606:                        }
1607:                
1608:                        /* Disable the interrupt */
1609:                        interruptWasEnabled = _DRV_USBFS_InterruptSourceDisable(hDriver->interruptSource);
9D00E780  0F405058   JAL SYS_INT_SourceDisable
9D00E784  8E040028   LW A0, 40(S0)
9D00E788  0B4039FA   J 0x9D00E7E8
9D00E78C  00402821   ADDU A1, V0, ZERO
1610:                    }
1611:                
1612:                    if(endpoint == 0)
1613:                    {
1614:                        /* Get the BDT entry for this endpoint */
1615:                        pBDT = hDriver->pBDT + (4 * endpoint) + (2 * direction) + endpointObject->nextPingPong;
9D00E7E8  8E440010   LW A0, 16(S2)
1616:                
1617:                        /* Clear the stall and data toggle on the endpoint */
1618:                        pBDT->byte[0] = 0x0;
9D00E7EC  8E03002C   LW V1, 44(S0)
9D00E7F0  00118900   SLL S1, S1, 4
9D00E7F4  000420C0   SLL A0, A0, 3
9D00E7F8  02248821   ADDU S1, S1, A0
9D00E7FC  00718821   ADDU S1, V1, S1
1619:                
1620:                    }
1621:                    else
1622:                    {
1623:                        /* Get the BDT entry for this endpoint */
1624:                        pBDT = hDriver->pBDT + (4 * endpoint) + (2 * direction);
1625:                
1626:                        /* Clear the stall and data toggle on the endpoint */
1627:                        pBDT->byte[0] = 0x0;
1628:                
1629:                        /* Get the BDT entry for this endpoint */
1630:                        pBDT = hDriver->pBDT + (4 * endpoint) + (2 * direction) + 1;
1631:                
1632:                        /* Clear the stall and data toggle on the endpoint */
1633:                        pBDT->byte[0] = 0x0;
1634:                		
1635:                		/* Clear Endpoint Stall status bit */ 
1636:                        PLIB_USB_EPnStallClear(usbID,endpoint);
1637:                
1638:                    }
1639:                    
1640:                    if((endpoint == 0) && (direction == USB_DATA_DIRECTION_DEVICE_TO_HOST))
9D00E800  1260FFE5   BEQ S3, ZERO, 0x9D00E798
9D00E804  A2200000   SB ZERO, 0(S1)
9D00E808  0B4039E4   J 0x9D00E790
9D00E80C  24020001   ADDIU V0, ZERO, 1
1641:                    {
1642:                        /* All endpoint 0 transmit must start with data toggle DATA1 */
1643:                        endpointObject->nextDataToggle = USB_BUFFER_DATA1;
9D00E790  0B403A04   J 0x9D00E810
9D00E794  AE42000C   SW V0, 12(S2)
1644:                    }
1645:                    else
1646:                    {
1647:                       endpointObject->nextDataToggle = USB_BUFFER_DATA0;
9D00E798  0B403A04   J 0x9D00E810
9D00E79C  AE40000C   SW ZERO, 12(S2)
1648:                    }
1649:                
1650:                    endpointObject->endpointState &= ~DRV_USBFS_DEVICE_ENDPOINT_STATE_STALLED;
9D00E810  8E430014   LW V1, 20(S2)
9D00E814  7C030844   INS V1, ZERO, 1, 1
9D00E818  AE430014   SW V1, 20(S2)
1651:                
1652:                    if(endpoint != 0)
1653:                    {
1654:                
1655:                        /* Clear up all the IRPs on this endpoint */
1656:                        _DRV_USBFS_DEVICE_IRPQueueFlush(endpointObject, USB_DEVICE_IRP_STATUS_TERMINATED_BY_HOST);
1657:                    }
1658:                    
1659:                    /* Enable the interrupt if it was previously enabled */
1660:                    if(!(hDriver->inInterruptContext))
9D00E81C  92030001   LBU V1, 1(S0)
9D00E820  1060FFDF   BEQ V1, ZERO, 0x9D00E7A0
9D00E824  00001021   ADDU V0, ZERO, ZERO
1661:                    {
1662:                        if(interruptWasEnabled)
9D00E7A0  10A00009   BEQ A1, ZERO, 0x9D00E7C8
9D00E7A4  3C03BF88   LUI V1, -16504
1663:                        {
1664:                            /* Enable the interrupt */
1665:                            _DRV_USBFS_InterruptSourceEnable(hDriver->interruptSource);
9D00E7A8  8E020028   LW V0, 40(S0)
1666:                        }
1667:                
1668:                        if(OSAL_MUTEX_Unlock(&hDriver->mutexID) != OSAL_RESULT_TRUE)
9D00E7C8  0F40541A   JAL OSAL_MUTEX_Unlock
9D00E7CC  26040030   ADDIU A0, S0, 48
9D00E7D0  0B403A0A   J 0x9D00E828
9D00E7D4  00001021   ADDU V0, ZERO, ZERO
1669:                        {
1670:                            SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "Mutex unlock failed");
1671:                        }
1672:                    }
1673:                
1674:                    return(USB_ERROR_NONE);
1675:                    
1676:                }/* end of DRV_USBFS_DEVICE_EndpointStallClear() */
9D00E828  8FBF0024   LW RA, 36(SP)
9D00E82C  8FB30020   LW S3, 32(SP)
9D00E830  8FB2001C   LW S2, 28(SP)
9D00E834  8FB10018   LW S1, 24(SP)
9D00E838  8FB00014   LW S0, 20(SP)
9D00E83C  03E00008   JR RA
9D00E840  27BD0028   ADDIU SP, SP, 40
1677:                
1678:                // *****************************************************************************
1679:                /* Function:
1680:                      uint16_t DRV_USBFS_DEVICE_SOFNumberGet(DRV_HANDLE client)
1681:                
1682:                  Summary:
1683:                    Dynamic impementation of DRV_USBFS_DEVICE_SOFNumberGet client interface
1684:                    function.
1685:                
1686:                  Description:
1687:                    This is the dynamic impementation of DRV_USBFS_DEVICE_SOFNumberGet client
1688:                    interface function for USB device.  Function checks the validity of the
1689:                    input arguments and on success returns the Frame count value. Frame count
1690:                    value is obtained from USB Frame registers (High and Low).
1691:                
1692:                  Remarks:
1693:                    See drv_usbfs.h for usage information.
1694:                */
1695:                
1696:                uint16_t DRV_USBFS_DEVICE_SOFNumberGet(DRV_HANDLE client)
1697:                {
1698:                    /* Start of local variable */
1699:                    uint16_t sofNumber = 0;
1700:                    USB_MODULE_ID usbID;
1701:                    /* end of local variable */
1702:                
1703:                    /* Check if the handle is valid */
1704:                    if(DRV_HANDLE_INVALID == client)
9D014F38  2402FFFF   ADDIU V0, ZERO, -1
9D014F3C  10820009   BEQ A0, V0, 0x9D014F64
9D014F40  00000000   NOP
1705:                    {
1706:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "Driver Handle is invalid");
1707:                    }
1708:                    else
1709:                    {
1710:                        /* Get the Frame count */
1711:                        usbID = ((DRV_USBFS_OBJ *)client)->usbID;
1712:                        sofNumber = PLIB_USB_FrameNumberGet(usbID);
1713:                    }
1714:                
1715:                    return sofNumber;
1716:                
1717:                }/* end of DRV_USBFS_DEVICE_SOFNumberGet() */
9D014F64  03E00008   JR RA
9D014F68  00001021   ADDU V0, ZERO, ZERO
1718:                
1719:                // *****************************************************************************
1720:                /* Function:
1721:                      void _DRV_USBFS_DEVICE_Tasks_ISR(DRV_USBFS_OBJ * hDriver)
1722:                
1723:                  Summary:
1724:                    Dynamic impementation of _DRV_USBFS_DEVICE_Tasks_ISR ISR handler function.
1725:                
1726:                  Description:
1727:                    This is the dynamic impementation of _DRV_USBFS_DEVICE_Tasks_ISR ISR handler
1728:                    function for USB device.  Function will get called automatically due to USB
1729:                    interrupts in interrupt mode.  In polling mode this function will be
1730:                    routinely called from USB driver DRV_USBFS_Tasks() function.  This function
1731:                    performs necessary action based on the interrupt and clears the interrupt
1732:                    after that. The USB device layer callback is called with the interrupt event
1733:                    details, if callback function is registered.
1734:                
1735:                  Remarks:
1736:                    This is a local function and should not be called directly by the
1737:                    application.
1738:                */
1739:                
1740:                void _DRV_USBFS_DEVICE_Tasks_ISR(DRV_USBFS_OBJ * hDriver)
1741:                {
9D00406C  27BDFFB8   ADDIU SP, SP, -72
9D004070  AFBF0044   SW RA, 68(SP)
9D004074  AFBE0040   SW S8, 64(SP)
9D004078  AFB7003C   SW S7, 60(SP)
9D00407C  AFB60038   SW S6, 56(SP)
9D004080  AFB50034   SW S5, 52(SP)
9D004084  AFB40030   SW S4, 48(SP)
9D004088  AFB3002C   SW S3, 44(SP)
9D00408C  AFB20028   SW S2, 40(SP)
9D004090  AFB10024   SW S1, 36(SP)
9D004094  AFB00020   SW S0, 32(SP)
9D004098  00808821   ADDU S1, A0, ZERO
1742:                    /* Start of local variables */
1743:                
1744:                    bool                          queueWasEmpty = false;
1745:                    bool                          processNextIRP;
1746:                    uint8_t                       lastEndpoint = 0;
1747:                    int                           iEntry;
1748:                    unsigned int                  errorType;
1749:                    USB_MODULE_ID                 usbID;
1750:                    DRV_USBFS_EVENT                 eventType = 0;
1751:                    USB_DEVICE_IRP_LOCAL        * irp;
1752:                    DRV_USBFS_BDT_ENTRY           * currentBDTEntry;
1753:                    DRV_USBFS_BDT_ENTRY           * lastBDTEntry;
1754:                    DRV_USBFS_BDT_ENTRY           * ep0TransmitBDTEntry;
1755:                    USB_PING_PONG_STATE           lastPingPong = 0;
1756:                    USB_PING_PONG_STATE           nextPingPong = 0;
1757:                    USB_BUFFER_DIRECTION          lastDirection = 0;
1758:                    DRV_USBFS_DEVICE_ENDPOINT_OBJ * lastEndpointObj;
1759:                    uint32_t                      mask;
1760:                    /* end of local variables */
1761:                
1762:                    usbID = hDriver->usbID;
1763:                
1764:                    /* Check is there was a change in VBUS voltage level */
1765:                    if(PLIB_USB_OTG_InterruptFlagGet(usbID, USB_OTG_INT_SESSION_VALID)
9D0040A8  50400017   BEQL V0, ZERO, 0x9D004108
9D0040AC  92220002   LBU V0, 2(S1)
1766:                            && PLIB_USB_OTG_InterruptIsEnabled(usbID, USB_OTG_INT_SESSION_VALID))
9D0040B8  50400013   BEQL V0, ZERO, 0x9D004108
9D0040BC  92220002   LBU V0, 2(S1)
1767:                    {
1768:                        /* This means there was a change in the VBUS voltage detected level. We
1769:                         * can find out if the VBUS is valid */
1770:                
1771:                        if(PLIB_USB_OTG_SessionValid(usbID))
9D0040C8  50400005   BEQL V0, ZERO, 0x9D0040E0
9D0040CC  A0800002   SB ZERO, 2(A0)
1772:                        {
1773:                            /* This means we detected a valid VBUS voltage. */
1774:                            hDriver->vbusIsValid = true;
9D0040D0  24020001   ADDIU V0, ZERO, 1
9D0040D4  A0820002   SB V0, 2(A0)
9D0040D8  0B401039   J 0x9D0040E4
9D0040DC  24050008   ADDIU A1, ZERO, 8
1775:                            eventType = DRV_USBFS_EVENT_DEVICE_SESSION_VALID; 
1776:                        }
1777:                        else
1778:                        {
1779:                            /* This means the VBUS is not valid anymore */
1780:                            hDriver->vbusIsValid = false;
1781:                            eventType = DRV_USBFS_EVENT_DEVICE_SESSION_INVALID;
9D0040E0  24050009   ADDIU A1, ZERO, 9
1782:                        }
1783:                
1784:                        if(hDriver->pEventCallBack != NULL)
9D0040E4  8E220010   LW V0, 16(S1)
9D0040E8  50400005   BEQL V0, ZERO, 0x9D004100
9D0040EC  24020008   ADDIU V0, ZERO, 8
1785:                        {
1786:                            /* Send this event to the client */
1787:                            hDriver->pEventCallBack(hDriver->hClientArg, eventType,  (void *)NULL);
9D0040F0  8E24000C   LW A0, 12(S1)
9D0040F4  0040F809   JALR V0
9D0040F8  00003021   ADDU A2, ZERO, ZERO
1788:                        }
1789:                
1790:                        /* Clear the interrupt */
1791:                        PLIB_USB_OTG_InterruptFlagClear(usbID, USB_OTG_INT_SESSION_VALID);
1792:                    }
1793:                
1794:                    /* If there is no VBUS or if the device pull up is not enabled yet, then
1795:                     * clear all the interrupt flags except VBUS session interrupt. Clear all
1796:                     * error, OTG and general interrupts. We cannot clear the session valid
1797:                     * interrupt because this may have change already by the time we have
1798:                     * reached here. After clearing the interrup we exit as we have nothing more
1799:                     * to be done in the ISR. */
1800:                
1801:                    if((!(hDriver->vbusIsValid)) || (!(hDriver->isAttached)))
9D004104  92220002   LBU V0, 2(S1)
9D004108  10400004   BEQ V0, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_ErrorInterruptFlagClear
9D00410C  240200FF   ADDIU V0, ZERO, 255
9D004110  92220003   LBU V0, 3(S1)
9D004114  14400007   BNE V0, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_OTG_InterruptFlagGet
9D004118  240200FF   ADDIU V0, ZERO, 255
1802:                    {
1803:                        PLIB_USB_ErrorInterruptFlagClear(usbID, USB_ERR_INT_ALL);
1804:                        PLIB_USB_InterruptFlagClear(usbID, USB_INT_ALL);
1805:                        PLIB_USB_OTG_InterruptFlagClear(usbID, (USB_OTG_INT_ALL & (~ USB_OTG_INT_SESSION_VALID))); 
1806:                        return;
1807:                    }
1808:                
1809:                    /* Check if there was activity on the bus. This interrupt is enabled before
1810:                     * entering suspend mode. This interrupt must be enabled to wake up the 
1811:                     * microcontroller from sleep due to USB activity. The driver wraps this
1812:                     * interrupt as resume detection. */
1813:                
1814:                    if(PLIB_USB_OTG_InterruptFlagGet(usbID, USB_OTG_INT_ACTIVITY_DETECT)
9D00413C  10400010   BEQ V0, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagGet
9D004140  00000000   NOP
1815:                            && PLIB_USB_OTG_InterruptIsEnabled(usbID, USB_OTG_INT_ACTIVITY_DETECT ))
9D00414C  1040000C   BEQ V0, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagGet
9D004150  24020010   ADDIU V0, ZERO, 16
1816:                    {
1817:                        /* Clear the interrupt */
1818:                        PLIB_USB_OTG_InterruptFlagClear(usbID, USB_OTG_INT_ACTIVITY_DETECT);
1819:                
1820:                        /* Disable the interrupt */
1821:                        PLIB_USB_OTG_InterruptDisable(usbID, USB_OTG_INT_ACTIVITY_DETECT);
1822:                
1823:                        /* Device is not suspended any more */
1824:                        hDriver->isSuspended = false;
9D004164  A2200004   SB ZERO, 4(S1)
1825:                
1826:                        if(hDriver->pEventCallBack != NULL)
9D004168  8E220010   LW V0, 16(S1)
9D00416C  10400004   BEQ V0, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagGet
9D004170  24050003   ADDIU A1, ZERO, 3
1827:                        {
1828:                            /* Send this event to the client */
1829:                            hDriver->pEventCallBack(hDriver->hClientArg, DRV_USBFS_EVENT_RESUME_DETECT,  (void *)NULL);
9D004174  8E24000C   LW A0, 12(S1)
9D004178  0040F809   JALR V0
9D00417C  00003021   ADDU A2, ZERO, ZERO
1830:                        }
1831:                    }
1832:                
1833:                    /* The RESUME event can only occur after the device has been suspended. */
1834:                    if (PLIB_USB_InterruptFlagGet(usbID, USB_INT_RESUME)
9D004188  10400011   BEQ V0, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagGet
9D00418C  00000000   NOP
1835:                            && PLIB_USB_InterruptIsEnabled(usbID, USB_INT_RESUME))
9D004198  1040000D   BEQ V0, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagGet
9D00419C  00000000   NOP
1836:                    {
1837:                        /* Device is not suspended any more */
1838:                        hDriver->isSuspended = false;
9D0041A0  A2200004   SB ZERO, 4(S1)
1839:                        
1840:                        if(hDriver->pEventCallBack != NULL)
9D0041A4  8E220010   LW V0, 16(S1)
9D0041A8  10400004   BEQ V0, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagClear
9D0041AC  24050003   ADDIU A1, ZERO, 3
1841:                        {
1842:                            /* Send this event to the client */
1843:                            hDriver->pEventCallBack(hDriver->hClientArg, DRV_USBFS_EVENT_RESUME_DETECT,  (void *)NULL);
9D0041B0  8E24000C   LW A0, 12(S1)
9D0041B4  0040F809   JALR V0
9D0041B8  00003021   ADDU A2, ZERO, ZERO
1844:                        }
1845:                
1846:                        /* Clear the interrupt flag and disable it. This event will be enabled
1847:                         * the next time we enter suspend mode. */
1848:                        PLIB_USB_InterruptFlagClear(usbID, USB_INT_RESUME);
1849:                        PLIB_USB_InterruptDisable(usbID, USB_INT_RESUME);
1850:                    }
1851:                
1852:                    /* Check if RESET signalling was received */
1853:                    if ( PLIB_USB_InterruptFlagGet(usbID, USB_INT_DEVICE_RESET)
9D0041D8  10400021   BEQ V0, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagGet
9D0041DC  00000000   NOP
1854:                            && PLIB_USB_InterruptIsEnabled(usbID, USB_INT_DEVICE_RESET))
9D0041E8  1040001D   BEQ V0, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagGet
9D0041EC  24020020   ADDIU V0, ZERO, 32
1855:                    {
1856:                        /* Device is not suspended any more */
1857:                        hDriver->isSuspended = false;
9D0041F0  A2200004   SB ZERO, 4(S1)
1858:                
1859:                        /* The host may have suspended the device before reset.
1860:                         * Clear the suspend flag and the resume flag */
1861:                        PLIB_USB_InterruptFlagClear( usbID, USB_INT_RESUME );
1862:                        PLIB_USB_InterruptFlagClear( usbID, USB_INT_IDLE_DETECT );
1863:                
1864:                        /* Make sure that all BDs are returned
1865:                         * back to the application */
1866:                
1867:                        for(iEntry = 0; iEntry < DRV_USBFS_ENDPOINTS_NUMBER; iEntry++)
1868:                        {
1869:                            currentBDTEntry = hDriver->pBDT + (4 * iEntry);
9D004200  8E22002C   LW V0, 44(S1)
1870:                            (currentBDTEntry + 0)->word[0] = 0x0;
9D004204  AC400000   SW ZERO, 0(V0)
1871:                            (currentBDTEntry + 1)->word[0] = 0x0;
9D004208  AC400008   SW ZERO, 8(V0)
1872:                            (currentBDTEntry + 2)->word[0] = 0x0;
9D00420C  AC400010   SW ZERO, 16(V0)
1873:                            (currentBDTEntry + 3)->word[0] = 0x0;
9D004210  AC400018   SW ZERO, 24(V0)
1874:                        }
1875:                
1876:                        /* Reset all ping pong buffers to even */
1877:                        PLIB_USB_PingPongReset(usbID);
1878:                        
1879:                		/* Because we have reset the ping pong, the rx and tx
1880:                		 * ping pong indicators need to set to set to all even */
1881:                        hDriver->rxEndpointsNextPingPong = 0 ;
9D00422C  AE200018   SW ZERO, 24(S1)
1882:                        hDriver->txEndpointsNextPingPong = 0 ;
9D004230  AE20001C   SW ZERO, 28(S1)
1883:                
1884:                        /* Reset address to default value (0) */
1885:                        PLIB_USB_DeviceAddressSet( usbID, 0 );
1886:                
1887:                        if(hDriver->pEventCallBack != NULL)
9D004240  8E220010   LW V0, 16(S1)
9D004244  10400004   BEQ V0, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagClear
9D004248  24050002   ADDIU A1, ZERO, 2
1888:                        {
1889:                            /* Send this event to the client */
1890:                            hDriver->pEventCallBack(hDriver->hClientArg, DRV_USBFS_EVENT_RESET_DETECT,  (void *)NULL);
9D00424C  8E24000C   LW A0, 12(S1)
9D004250  0040F809   JALR V0
9D004254  00003021   ADDU A2, ZERO, ZERO
1891:                        }
1892:                
1893:                        /* Clear the interrupt flag */
1894:                        PLIB_USB_InterruptFlagClear(usbID, USB_INT_DEVICE_RESET);
1895:                
1896:                    }
1897:                
1898:                    /* Check if the host has suspended the bus. */
1899:                    if (PLIB_USB_InterruptFlagGet(usbID, USB_INT_IDLE_DETECT)
9D004268  10400015   BEQ V0, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagGet
9D00426C  00000000   NOP
1900:                            && PLIB_USB_InterruptIsEnabled(usbID, USB_INT_IDLE_DETECT))
9D004278  10400011   BEQ V0, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagGet
9D00427C  00000000   NOP
1901:                    {
1902:                        /* The bus is IDLE and is suspended. Send the event to the client. */
1903:                        if(hDriver->pEventCallBack != NULL)
9D004280  8E220010   LW V0, 16(S1)
9D004284  10400004   BEQ V0, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagClear
9D004288  24050004   ADDIU A1, ZERO, 4
1904:                        {
1905:                            /* Send this event to the client */
1906:                            hDriver->pEventCallBack(hDriver->hClientArg, DRV_USBFS_EVENT_IDLE_DETECT,  (void *)NULL);
9D00428C  8E24000C   LW A0, 12(S1)
9D004290  0040F809   JALR V0
9D004294  00003021   ADDU A2, ZERO, ZERO
1907:                        }
1908:                
1909:                        /* Clear the interrupt flag and disable it. This event will be enabled
1910:                         * the next time we enter suspend mode. */
1911:                        PLIB_USB_InterruptFlagClear(usbID, USB_INT_IDLE_DETECT);
1912:                
1913:                        /* Enable the actvity interrupt */
1914:                        PLIB_USB_InterruptEnable(usbID, USB_OTG_INT_ACTIVITY_DETECT);
1915:                
1916:                        /* Enable the resume interrupt */
1917:                        PLIB_USB_InterruptEnable(usbID, USB_INT_RESUME);
1918:                
1919:                        /* Set the suspended flag */
1920:                        hDriver->isSuspended = true;
9D0042B8  24020001   ADDIU V0, ZERO, 1
9D0042BC  A2220004   SB V0, 4(S1)
1921:                    }
1922:                
1923:                    /* Check if an SOF was received */
1924:                
1925:                    if (PLIB_USB_InterruptFlagGet(usbID,USB_INT_SOF)
9D0042C8  1040000D   BEQ V0, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagGet
9D0042CC  00000000   NOP
1926:                            && PLIB_USB_InterruptIsEnabled(usbID, USB_INT_SOF))
9D0042D8  10400009   BEQ V0, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagGet
9D0042DC  00000000   NOP
1927:                    {
1928:                        /* SOF received by Device or SOF threshold reached by Host
1929:                         * no event data to send. */
1930:                
1931:                        if(hDriver->pEventCallBack != NULL)
9D0042E0  8E220010   LW V0, 16(S1)
9D0042E4  10400004   BEQ V0, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagClear
9D0042E8  24050007   ADDIU A1, ZERO, 7
1932:                        {
1933:                            /* Send this event to the client */
1934:                            hDriver->pEventCallBack(hDriver->hClientArg, DRV_USBFS_EVENT_SOF_DETECT,  (void *)NULL);
9D0042EC  8E24000C   LW A0, 12(S1)
9D0042F0  0040F809   JALR V0
9D0042F4  00003021   ADDU A2, ZERO, ZERO
1935:                        }
1936:                
1937:                        /* Clear the interrupt flag */
1938:                        PLIB_USB_InterruptFlagClear(usbID, USB_INT_SOF);
1939:                    }
1940:                
1941:                    /* The following event occurs when and endpoint has sent stall to the host.
1942:                     * If the stall was sent from endpoint 0, the device layer would know about
1943:                     * it. If it was sent from an non-zero endpoint, the host would send a clear
1944:                     * feature control request. This event therefore does not send any event
1945:                     * data to the client. */
1946:                    if (PLIB_USB_InterruptFlagGet(usbID, USB_INT_STALL)
9D004308  10400014   BEQ V0, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagGet
9D00430C  00000000   NOP
1947:                            && PLIB_USB_InterruptIsEnabled(usbID, USB_INT_STALL))
9D004318  10400010   BEQ V0, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagGet
9D00431C  00000000   NOP
1948:                    {
1949:                        unsigned int iEndpoint;
1950:                        for ( iEndpoint = 0; iEndpoint < DRV_USBFS_ENDPOINTS_NUMBER; iEndpoint++ )
1951:                        {
1952:                            if ( PLIB_USB_EPnIsStalled(usbID,iEndpoint) )
9D004328  50400005   BEQL V0, ZERO, 0x9D004340
9D00432C  8E220010   LW V0, 16(S1)
1953:                            {
1954:                                PLIB_USB_EPnStallClear(usbID,iEndpoint);
1955:                            }
1956:                        }
1957:                
1958:                        if(hDriver->pEventCallBack != NULL)
9D00433C  8E220010   LW V0, 16(S1)
9D004340  10400004   BEQ V0, ZERO, PLIB_USB_InterruptFlagClear
9D004344  24050006   ADDIU A1, ZERO, 6
1959:                        {
1960:                            /* Send this event to the client */
1961:                            hDriver->pEventCallBack(hDriver->hClientArg, DRV_USBFS_EVENT_STALL,  (void *)NULL);
9D004348  8E24000C   LW A0, 12(S1)
9D00434C  0040F809   JALR V0
9D004350  00003021   ADDU A2, ZERO, ZERO
1962:                        }
1963:                
1964:                        /* Clear the interrupt flag */
1965:                        PLIB_USB_InterruptFlagClear(usbID, USB_INT_STALL);
1966:                
1967:                    }
1968:                
1969:                    /* Check if an error has occurred */
1970:                    if ( PLIB_USB_InterruptFlagGet( usbID, USB_INT_ERROR ) &&
9D004364  50400011   BEQL V0, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagClear
9D004368  AFA00018   SW ZERO, 24(SP)
9D004374  5040000D   BEQL V0, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagClear
9D004378  AFA00018   SW ZERO, 24(SP)
1971:                            PLIB_USB_InterruptIsEnabled(usbID, USB_INT_ERROR))
1972:                    {
1973:                
1974:                        /* Get the error type to send to the client */
1975:                        errorType = PLIB_USB_ErrorInterruptFlagAllGet(usbID);
9D004380  AFA20010   SW V0, 16(SP)
1976:                
1977:                        /* Clear the base error flags and the interrupt flag */
1978:                        PLIB_USB_ErrorInterruptFlagClear( usbID, errorType );
1979:                        PLIB_USB_InterruptFlagClear( usbID, USB_INT_ERROR );
1980:                
1981:                        if(hDriver->pEventCallBack != NULL)
9D004390  8E220010   LW V0, 16(S1)
9D004394  10400004   BEQ V0, ZERO, 0x9D0043A8
9D004398  24050001   ADDIU A1, ZERO, 1
1982:                        {
1983:                            /* Send this event to the client */
1984:                            hDriver->pEventCallBack(hDriver->hClientArg, DRV_USBFS_EVENT_ERROR,  (void *)&errorType);
9D00439C  8E24000C   LW A0, 12(S1)
9D0043A0  0040F809   JALR V0
9D0043A4  27A60010   ADDIU A2, SP, 16
1985:                        }
1986:                    }
1987:                
1988:                    /* This while loop will empty the token received FIFO. This while will not
1989:                     * run forever because there are only that many tokens that can be received
1990:                     * in a period of 1 millisecond. */
1991:                    while(PLIB_USB_InterruptFlagGet(usbID, USB_INT_TOKEN_DONE))
9D004638  1440FF5F   BNE V0, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_LastTransactionDetailsGet
9D00463C  8FBF0044   LW RA, 68(SP)
9D004640  0B40119E   J 0x9D004678
9D004644  8FBE0040   LW S8, 64(SP)
1992:                    {
1993:                        /* Get the details of the last transaction */
1994:                        PLIB_USB_LastTransactionDetailsGet(usbID, &lastDirection, &lastPingPong, &lastEndpoint); 
1995:                
1996:                        /* Now that the details of the last transaction have been obtained, we
1997:                         * need to clear the TOKEN interrupt immediately. This will give enough
1998:                         * time for the TRNIF flag to clear. This way we avoid situations where
1999:                         * the flag was cleared but the code still enters TRNIF was still set.
2000:                         * */
2001:                
2002:                        PLIB_USB_InterruptFlagClear(usbID,USB_INT_TOKEN_DONE);
2003:                
2004:                        /* Set up the next ping pong buffer descriptor. This will tell the IRP
2005:                         * processing code which buffer descriptors to use. When the host does a
2006:                         * set configuration 0, the Device Layer will disable and enable all
2007:                         * endpoints. A set configuration 0 is not the same a bus reset in which
2008:                         * case the ping pong indicators would have been reset. So the endpoint
2009:                         * enable function will ready the soft ping pong trackers to find out
2010:                         * which ping pong to use.
2011:                         * */
2012:                        
2013:                        if ( lastPingPong == USB_PING_PONG_EVEN )
9D0043D8  2EE30001   SLTIU V1, S7, 1
2014:                        {
2015:                            nextPingPong = USB_PING_PONG_ODD;
2016:                        }
2017:                        else
2018:                        {
2019:                            nextPingPong = USB_PING_PONG_EVEN;
2020:                        }
2021:                
2022:                        mask = 1 << lastEndpoint ;
9D0043B0  0B40118C   J _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagGet
9D0043B4  24140001   ADDIU S4, ZERO, 1
9D0043DC  00403021   ADDU A2, V0, ZERO
2023:                
2024:                        /* Update the next ping pong indicator for this endpoint. Each bit in
2025:                         * the rxEndpointsNextPingPong and txEndpointsNextPingPong track the
2026:                         * ping pong value for the endpoint. */
2027:                        
2028:                        if( lastDirection == USB_BUFFER_RX ) 
9D0043E0  1640000B   BNE S2, ZERO, 0x9D004410
9D0043E4  00542004   SLLV A0, S4, V0
2029:                        {
2030:                            /* This is for the RX direction */
2031:                            if (nextPingPong == USB_PING_PONG_ODD )
9D0043E8  54740005   BNEL V1, S4, 0x9D004400
9D0043EC  00042027   NOR A0, ZERO, A0
2032:                            {
2033:                                hDriver->rxEndpointsNextPingPong =   hDriver->rxEndpointsNextPingPong | mask ;
9D0043F0  8E230018   LW V1, 24(S1)
9D0043F4  00642025   OR A0, V1, A0
9D0043F8  0B40110D   J 0x9D004434
9D0043FC  AE240018   SW A0, 24(S1)
2034:                            }
2035:                            else
2036:                            {
2037:                                hDriver->rxEndpointsNextPingPong =  ( hDriver->rxEndpointsNextPingPong & (~mask ) ) ;
9D004400  8E230018   LW V1, 24(S1)
9D004404  00642024   AND A0, V1, A0
9D004408  0B40110D   J 0x9D004434
9D00440C  AE240018   SW A0, 24(S1)
2038:                            }
2039:                        }
2040:                        else    
2041:                        {
2042:                            /* This is for the TX direction */
2043:                            if (nextPingPong == USB_PING_PONG_ODD )
9D004410  54740005   BNEL V1, S4, 0x9D004428
9D004414  00042027   NOR A0, ZERO, A0
2044:                            {
2045:                                hDriver->txEndpointsNextPingPong =   hDriver->txEndpointsNextPingPong | mask ;
9D004418  8E23001C   LW V1, 28(S1)
9D00441C  00642025   OR A0, V1, A0
9D004420  0B40110D   J 0x9D004434
9D004424  AE24001C   SW A0, 28(S1)
2046:                            }
2047:                            else
2048:                            {
2049:                                hDriver->txEndpointsNextPingPong =  ( hDriver->txEndpointsNextPingPong & (~mask ) ) ;
9D004428  8E23001C   LW V1, 28(S1)
9D00442C  00642024   AND A0, V1, A0
9D004430  AE24001C   SW A0, 28(S1)
2050:                            }
2051:                        }
2052:                
2053:                        /* Get the associated endpoint object */
2054:                        lastEndpointObj = hDriver->endpointTable + (lastEndpoint * 2) + lastDirection;
9D004434  00021040   SLL V0, V0, 1
9D004438  00521021   ADDU V0, V0, S2
9D00443C  000218C0   SLL V1, V0, 3
9D004440  00021140   SLL V0, V0, 5
9D004444  00431023   SUBU V0, V0, V1
9D004448  8E350034   LW S5, 52(S1)
9D00444C  02A2A821   ADDU S5, S5, V0
2055:                
2056:                        /* Get the first IRP in the queue */
2057:                        irp = lastEndpointObj->irpQueue; 
9D004450  8EB30000   LW S3, 0(S5)
9D004548  02601821   ADDU V1, S3, ZERO
2058:                
2059:                        /* Get the BDT entry for this direction. currentBDTEntry points to the
2060:                         * ping pong set. lastBDTEntry points to the specific ping or pong
2061:                         * entry. */
2062:                
2063:                        currentBDTEntry = hDriver->pBDT + (4 * lastEndpoint) + (2 * lastDirection); 
9D00445C  0006F140   SLL S8, A2, 5
9D004460  00052900   SLL A1, A1, 4
9D004464  03C5F021   ADDU S8, S8, A1
9D004468  005EF021   ADDU S8, V0, S8
2064:                        lastBDTEntry = currentBDTEntry + lastPingPong;
9D00446C  0017B8C0   SLL S7, S7, 3
9D004470  03D7B821   ADDU S7, S8, S7
2065:                
2066:                        if(irp != NULL)
9D004454  12600076   BEQ S3, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagGet
9D004458  8E22002C   LW V0, 44(S1)
2067:                        {
2068:                            /* This flag lets us know if the current IRP is done and that the next
2069:                             * IRP should be processed */
2070:                
2071:                            processNextIRP = false;
2072:                            switch(lastBDTEntry->byte[0] & 0x3C)
9D004474  92E20000   LBU V0, 0(S7)
9D004478  3042003C   ANDI V0, V0, 60
9D00447C  24030024   ADDIU V1, ZERO, 36
9D004480  1043003A   BEQ V0, V1, 0x9D00456C
9D004484  24040034   ADDIU A0, ZERO, 52
9D004488  10440005   BEQ V0, A0, 0x9D0044A0
9D00448C  24030004   ADDIU V1, ZERO, 4
9D004490  54430067   BNEL V0, V1, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagGet
9D004494  A2E00000   SB ZERO, 0(S7)
2073:                            {
2074:                                case 0x34 :
2075:                
2076:                                    /* This means a setup packet has been received */
2077:                
2078:                                    irp->status = USB_DEVICE_IRP_STATUS_SETUP;
9D0044A0  24020002   ADDIU V0, ZERO, 2
9D0044A4  AE620008   SW V0, 8(S3)
2079:                                    irp->size   = lastBDTEntry->word[1];
9D0044A8  8EE20004   LW V0, 4(S7)
9D0044AC  AE620004   SW V0, 4(S3)
2080:                
2081:                                    /* currentBDTEntry at this point will point to enpoint 0 BDT
2082:                                     * entry. We should get the transmit BDT entries and clear
2083:                                     * the stall conditions */
2084:                
2085:                                    ep0TransmitBDTEntry = currentBDTEntry + 2;
2086:                
2087:                                    /* ep0TranmitBDTEntry at this point should point to the EP0
2088:                                     * transmit even BDT entry. Clearing byte 0 will clear clear
2089:                                     * the stall */
2090:                                    ep0TransmitBDTEntry->byte[0] = 0;
9D0044B0  A3C00010   SB ZERO, 16(S8)
2091:                
2092:                                    /* Now get the transmit BDT odd entry and do the same */
2093:                
2094:                                    ep0TransmitBDTEntry ++;
2095:                                    ep0TransmitBDTEntry->byte[0] = 0;
9D0044B4  A3C00018   SB ZERO, 24(S8)
2096:                
2097:                                    /* Reset the data toggle on the TX endpoint to DATA1 because
2098:                                     * we received a setup packet. Any packet that the device
2099:                                     * transmit on this endpoint must start with DATA1 toggle.
2100:                                     * */
2101:                
2102:                                    (lastEndpointObj + USB_DATA_DIRECTION_DEVICE_TO_HOST)->nextDataToggle = USB_BUFFER_DATA1;
9D0044B8  AEB40024   SW S4, 36(S5)
2103:                
2104:                                    PLIB_USB_PacketTransferEnable(usbID);
2105:                
2106:                                    /* We should get the next IRP in the queue . */
2107:                
2108:                                    processNextIRP = true;
2109:                                    break;
9D0044C8  0B401193   J 0x9D00464C
9D0044CC  A2E00000   SB ZERO, 0(S7)
2110:                
2111:                                case 0x4:
2112:                
2113:                                    /* We received an OUT token. Check if the size is less than
2114:                                     * maxPacketSize. This means the end of the transfer. If the
2115:                                     * pending size is 0 then again we end the transfer */
2116:                
2117:                                    irp->nPendingBytes += lastBDTEntry->shortWord[1];
9D004498  0B401134   J 0x9D0044D0
9D00449C  96E30002   LHU V1, 2(S7)
9D0044D0  8E620020   LW V0, 32(S3)
9D0044D4  00621021   ADDU V0, V1, V0
9D0044D8  AE620020   SW V0, 32(S3)
2118:                
2119:                                    if(irp->status == USB_DEVICE_IRP_STATUS_ABORTED)
9D0044DC  8E630008   LW V1, 8(S3)
9D0044E0  2404FFFE   ADDIU A0, ZERO, -2
9D0044E4  54640008   BNEL V1, A0, 0x9D004508
9D0044E8  96E40002   LHU A0, 2(S7)
2120:                                    {
2121:                                        /* No need to process this aborted IRP. Enable the
2122:                                         * driver to move to the next IRP in the queue. */
2123:                                        if(irp->callback != NULL)
9D0044EC  8E62000C   LW V0, 12(S3)
9D0044F0  50400056   BEQL V0, ZERO, 0x9D00464C
9D0044F4  A2E00000   SB ZERO, 0(S7)
2124:                                        {
2125:                                            irp->callback((USB_DEVICE_IRP *)irp);
9D0044F8  0040F809   JALR V0
9D0044FC  02602021   ADDU A0, S3, ZERO
2126:                                        }
2127:                                        processNextIRP = true;
2128:                                    }
2129:                
2130:                                    else if((lastBDTEntry->shortWord[1] < lastEndpointObj->maxPacketSize) || (irp->nPendingBytes >= irp->size))
9D004508  96A30004   LHU V1, 4(S5)
9D00450C  0083182B   SLTU V1, A0, V1
9D004510  14600006   BNE V1, ZERO, 0x9D00452C
9D004514  8E630004   LW V1, 4(S3)
9D004518  0043182B   SLTU V1, V0, V1
9D00451C  10600007   BEQ V1, ZERO, 0x9D00453C
9D004520  02601821   ADDU V1, S3, ZERO
9D004524  0B401155   J 0x9D004554
9D004528  03C02021   ADDU A0, S8, ZERO
2131:                                    {
2132:                                        /* We end the transfer because we either got the amount
2133:                                         * of data that we were expecting or we got the a short
2134:                                         * packet. */
2135:                
2136:                                        /* If we got less data than we were expecting, then set
2137:                                         * the IRP status to short else say it is completed */
2138:                
2139:                                        if(irp->nPendingBytes >= irp->size)
9D00452C  0043182B   SLTU V1, V0, V1
9D004530  54600005   BNEL V1, ZERO, 0x9D004548
9D004534  AE740008   SW S4, 8(S3)
9D004538  02601821   ADDU V1, S3, ZERO
2140:                                        {
2141:                                            irp->status = USB_DEVICE_IRP_STATUS_COMPLETED;
9D00453C  AC600008   SW ZERO, 8(V1)
9D004540  0B401153   J 0x9D00454C
9D004544  02601821   ADDU V1, S3, ZERO
2142:                                        }
2143:                                        else
2144:                                        {
2145:                                            irp->status = USB_DEVICE_IRP_STATUS_COMPLETED_SHORT;
2146:                                        }
2147:                
2148:                                        /* Update the irp size with received data */
2149:                                        irp->size = irp->nPendingBytes;
2150:                
2151:                                        processNextIRP = true;
9D00454C  0B401192   J 0x9D004648
9D004550  AC620004   SW V0, 4(V1)
2152:                
2153:                                    }
2154:                                    else
2155:                                    {
2156:                                        /* We must continue this transfer */
2157:                                        _DRV_USBFS_DEVICE_EndpointBDTEntryArm(currentBDTEntry, lastEndpointObj, irp, lastDirection);
9D004554  02A02821   ADDU A1, S5, ZERO
9D004558  02603021   ADDU A2, S3, ZERO
9D00455C  0F4042F5   JAL _DRV_USBFS_DEVICE_EndpointBDTEntryArm
9D004560  02403821   ADDU A3, S2, ZERO
2158:                                    }
2159:                                    break;
2160:                
2161:                                case 0x24:
2162:                
2163:                                    /* This means that a IN token was received from the host */
2164:                
2165:                                    if(irp->status == USB_DEVICE_IRP_STATUS_ABORTED)
9D00456C  8E620008   LW V0, 8(S3)
9D004570  2403FFFE   ADDIU V1, ZERO, -2
9D004574  54430008   BNEL V0, V1, 0x9D004598
9D004578  8E620020   LW V0, 32(S3)
2166:                                    {
2167:                                        /* No need to process this aborted IRP. Enable the
2168:                                         * driver to move to the next IRP in the queue. */
2169:                
2170:                                        if(irp->callback != NULL)
9D00457C  8E62000C   LW V0, 12(S3)
9D004580  50400032   BEQL V0, ZERO, 0x9D00464C
9D004584  A2E00000   SB ZERO, 0(S7)
2171:                                        {
2172:                                            irp->callback((USB_DEVICE_IRP *)irp);
9D004588  0040F809   JALR V0
9D00458C  02602021   ADDU A0, S3, ZERO
2173:                                        }
2174:                                        processNextIRP = true;
2175:                                    }
2176:                
2177:                                    else if(irp->nPendingBytes == 0)
9D004598  1440000F   BNE V0, ZERO, 0x9D0045D8
9D00459C  03C02021   ADDU A0, S8, ZERO
2178:                                    {
2179:                                        if((irp->flags & USB_DEVICE_IRP_FLAG_SEND_ZLP) != 0)
9D0045A0  8E620010   LW V0, 16(S3)
9D0045A4  30430080   ANDI V1, V0, 128
9D0045A8  10600009   BEQ V1, ZERO, 0x9D0045D0
9D0045AC  7C0239C4   INS V0, ZERO, 7, 1
2180:                                        {
2181:                                            /* This means a ZLP must be sent */
2182:                                            irp->flags &= ~USB_DEVICE_IRP_FLAG_SEND_ZLP;
9D0045B0  AE620010   SW V0, 16(S3)
2183:                                            _DRV_USBFS_DEVICE_EndpointBDTEntryArm(currentBDTEntry, lastEndpointObj, irp, lastDirection);
9D0045B4  03C02021   ADDU A0, S8, ZERO
9D0045B8  02A02821   ADDU A1, S5, ZERO
9D0045BC  02603021   ADDU A2, S3, ZERO
9D0045C0  0F4042F5   JAL _DRV_USBFS_DEVICE_EndpointBDTEntryArm
9D0045C4  02403821   ADDU A3, S2, ZERO
9D0045C8  0B40118C   J _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagGet
9D0045CC  A2E00000   SB ZERO, 0(S7)
2184:                                        }
2185:                                        else
2186:                                        {
2187:                                            irp->status = USB_DEVICE_IRP_STATUS_COMPLETED;
9D0045D0  0B401192   J 0x9D004648
9D0045D4  AE600008   SW ZERO, 8(S3)
2188:                                            processNextIRP = true;
2189:                                        }
2190:                                    }
2191:                                    else
2192:                                    {
2193:                                        /* We must continue this transfer */
2194:                                        _DRV_USBFS_DEVICE_EndpointBDTEntryArm(currentBDTEntry, lastEndpointObj, irp, lastDirection);
9D0045D8  02A02821   ADDU A1, S5, ZERO
9D0045DC  02603021   ADDU A2, S3, ZERO
9D0045E0  0F4042F5   JAL _DRV_USBFS_DEVICE_EndpointBDTEntryArm
9D0045E4  02403821   ADDU A3, S2, ZERO
2195:                                    }
2196:                
2197:                                    break;
2198:                
2199:                                default:
2200:                                    SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "Unknown TOKEN received from host");
2201:                                    break;
2202:                            }
2203:                
2204:                            /* Reset the BDT status */
2205:                            lastBDTEntry->byte[0] = 0;
9D004500  0B401193   J 0x9D00464C
9D004504  A2E00000   SB ZERO, 0(S7)
9D004564  0B40118C   J _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagGet
9D004568  A2E00000   SB ZERO, 0(S7)
9D004590  0B401193   J 0x9D00464C
9D004594  A2E00000   SB ZERO, 0(S7)
9D0045E8  0B40118C   J _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagGet
9D0045EC  A2E00000   SB ZERO, 0(S7)
9D004648  A2E00000   SB ZERO, 0(S7)
2206:                
2207:                            if(processNextIRP)
2208:                            {
2209:                                /* Check the queue and get the next IRP */
2210:                
2211:                                lastEndpointObj->irpQueue = irp->next;
9D00464C  8E620018   LW V0, 24(S3)
9D004650  AEA20000   SW V0, 0(S5)
2212:                
2213:                                /* Check if the queue is empty. This will then allow us to track
2214:                                 * if a IRP was submitted after the  IRP callback. If so, then
2215:                                 * we should not call the
2216:                                 * _DRV_USBFS_DEVICE_EndpointBDTEntryArm(). For an IRP added in
2217:                                 * the IRP callback, the _DRV_USBFS_DEVICE_EndpointBDTEntryArm
2218:                                 * would have already been done in the IRP Submit function */
2219:                
2220:                                if(lastEndpointObj->irpQueue == NULL)
2221:                                {
2222:                                    /* Queue was empty before the call back */
2223:                                    queueWasEmpty = true;
9D0043A8  AFA00018   SW ZERO, 24(SP)
9D004654  8FA40018   LW A0, 24(SP)
9D004658  0282200A   MOVZ A0, S4, V0
9D00465C  AFA40018   SW A0, 24(SP)
2224:                                }
2225:                
2226:                                /* Now do the IRP callback*/
2227:                
2228:                                if(irp->callback != NULL && irp->status != USB_DEVICE_IRP_STATUS_ABORTED)
9D0045F0  2404FFFE   ADDIU A0, ZERO, -2
9D0045F4  50640004   BEQL V1, A0, 0x9D004608
9D0045F8  8EA20000   LW V0, 0(S5)
9D004660  8E62000C   LW V0, 12(S3)
9D004664  5440FFE2   BNEL V0, ZERO, 0x9D0045F0
9D004668  8E630008   LW V1, 8(S3)
9D00466C  0B401182   J 0x9D004608
9D004670  8EA20000   LW V0, 0(S5)
2229:                                {
2230:                                    /* Invoke the callback */
2231:                                    irp->callback((USB_DEVICE_IRP *)irp);
9D0045FC  0040F809   JALR V0
9D004600  02602021   ADDU A0, S3, ZERO
2232:                                }
2233:                
2234:                                if((lastEndpointObj->irpQueue != NULL) && (!(queueWasEmpty)))
9D004604  8EA20000   LW V0, 0(S5)
9D004608  10400009   BEQ V0, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagGet
9D00460C  8FA30018   LW V1, 24(SP)
9D004610  14600007   BNE V1, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagGet
9D004614  24030004   ADDIU V1, ZERO, 4
2235:                                {
2236:                                    /* This means we have something in the queue and this was not
2237:                                     * added in the IRP callback. We can arm the endpoint. */
2238:                
2239:                                    lastEndpointObj->irpQueue->status = USB_DEVICE_IRP_STATUS_IN_PROGRESS;
9D004618  AC430008   SW V1, 8(V0)
2240:                                    _DRV_USBFS_DEVICE_EndpointBDTEntryArm( currentBDTEntry, lastEndpointObj, lastEndpointObj->irpQueue, lastDirection);
9D00461C  03C02021   ADDU A0, S8, ZERO
9D004620  02A02821   ADDU A1, S5, ZERO
9D004624  8EA60000   LW A2, 0(S5)
9D004628  0F4042F5   JAL _DRV_USBFS_DEVICE_EndpointBDTEntryArm
9D00462C  02403821   ADDU A3, S2, ZERO
2241:                                }
2242:                            }
2243:                        }
2244:                        else
2245:                        {
2246:                            /* The IRP is null. This can happen if the IRP was aborted. In which
2247:                             * case we have nothing to do. */
2248:                        }
2249:                    }
2250:                }
9D00412C  0B40119D   J 0x9D004674
9D004130  8FBF0044   LW RA, 68(SP)
9D004674  8FBE0040   LW S8, 64(SP)
9D004678  8FB7003C   LW S7, 60(SP)
9D00467C  8FB60038   LW S6, 56(SP)
9D004680  8FB50034   LW S5, 52(SP)
9D004684  8FB40030   LW S4, 48(SP)
9D004688  8FB3002C   LW S3, 44(SP)
9D00468C  8FB20028   LW S2, 40(SP)
9D004690  8FB10024   LW S1, 36(SP)
9D004694  8FB00020   LW S0, 32(SP)
9D004698  03E00008   JR RA
9D00469C  27BD0048   ADDIU SP, SP, 72
2251:                
2252:                
---  /home/whatisthis/microchip/harmony/v2_04/framework/driver/usb/usbfs/src/dynamic/drv_usbfs.c  -------
1:                   /*******************************************************************************
2:                     USB Controller Driver Core Routines.
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       drv_usbfs.c
9:                   
10:                    Summary:
11:                      USB Controller Driver Core Routines intended for Dynamic implementation.
12:                  
13:                    Description:
14:                      The USB Controller driver provides a simple interface to manage the USB
15:                      modules on Microchip microcontrollers.  This file Implements the core
16:                      interface routines to be used both by the client(USB Host or Device layer)
17:                      and the system for communicating with USB Contoller driver.  While building
18:                      the driver from source, ALWAYS use this file in the build.
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute Software
26:                  only when embedded on a Microchip microcontroller or digital  signal  controller
27:                  that is integrated into your product or third party  product  (pursuant  to  the
28:                  sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS  WITHOUT  WARRANTY  OF  ANY  KIND,
34:                  EITHER EXPRESS  OR  IMPLIED,  INCLUDING  WITHOUT  LIMITATION,  ANY  WARRANTY  OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A  PARTICULAR  PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR  ITS  LICENSORS  BE  LIABLE  OR  OBLIGATED  UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION,  BREACH  OF  WARRANTY,  OR
38:                  OTHER LEGAL  EQUITABLE  THEORY  ANY  DIRECT  OR  INDIRECT  DAMAGES  OR  EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY  INCIDENTAL,  SPECIAL,  INDIRECT,  PUNITIVE  OR
40:                  CONSEQUENTIAL DAMAGES, LOST  PROFITS  OR  LOST  DATA,  COST  OF  PROCUREMENT  OF
41:                  SUBSTITUTE  GOODS,  TECHNOLOGY,  SERVICES,  OR  ANY  CLAIMS  BY  THIRD   PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE  THEREOF),  OR  OTHER  SIMILAR  COSTS.
43:                  *******************************************************************************/
44:                  //DOM-IGNORE-END
45:                  
46:                  // *****************************************************************************
47:                  // *****************************************************************************
48:                  // Section: Include Files
49:                  // *****************************************************************************
50:                  // *****************************************************************************
51:                  
52:                  #include "system_config.h"
53:                  #include "driver/usb/usbfs/src/drv_usbfs_local.h"
54:                  
55:                  // *****************************************************************************
56:                  // *****************************************************************************
57:                  // Section: Global Data
58:                  // *****************************************************************************
59:                  // *****************************************************************************
60:                  
61:                  /******************************************************
62:                   * Hardware instance, endpoint table and client object
63:                   * lumped together as group to save memory.
64:                   ******************************************************/
65:                  DRV_USBFS_GROUP gDrvUSBGroup[DRV_USBFS_INSTANCES_NUMBER];
66:                  
67:                  // *****************************************************************************
68:                  // *****************************************************************************
69:                  // Section: USB Controller Driver Interface Implementations
70:                  // *****************************************************************************
71:                  // *****************************************************************************
72:                  
73:                  // *****************************************************************************
74:                  /* Function:
75:                      SYS_MODULE_OBJ DRV_USBFS_Initialize
76:                      ( 
77:                          const SYS_MODULE_INDEX index,
78:                          const SYS_MODULE_INIT * const init
79:                      )
80:                  
81:                    Summary:
82:                      Dynamic impementation of DRV_USBFS_Initialize system interface function.
83:                  
84:                    Description:
85:                      This is the dynamic impementation of DRV_USBFS_Initialize system interface
86:                      function. Function performs the following task:
87:                      - Initializes the neccessary USB module as per the instance init data
88:                      - Updates internal data structure for the particular USB instance
89:                      - Returns the USB instance value as a handle to the system
90:                    
91:                    Remarks:
92:                      See drv_usbfs.h for usage information.
93:                  */
94:                  
95:                  SYS_MODULE_OBJ DRV_USBFS_Initialize 
96:                  (
97:                      const SYS_MODULE_INDEX  drvIndex,
98:                      const SYS_MODULE_INIT * const init
99:                  )
100:                 {
9D00D804  27BDFFE0   ADDIU SP, SP, -32
9D00D808  AFBF001C   SW RA, 28(SP)
9D00D80C  AFB20018   SW S2, 24(SP)
9D00D810  AFB10014   SW S1, 20(SP)
9D00D814  AFB00010   SW S0, 16(SP)
9D00D818  00A08021   ADDU S0, A1, ZERO
101:                     /* Start of local variable */
102:                     DRV_USBFS_OBJ * pUSBDrvObj    = (DRV_USBFS_OBJ *)NULL;
103:                     USB_MODULE_ID  usbID        = USB_NUMBER_OF_MODULES;
104:                     DRV_USBFS_INIT * pusbInit     = (DRV_USBFS_INIT *)NULL;
105:                     SYS_MODULE_OBJ returnValue  = SYS_MODULE_OBJ_INVALID;
106:                     /* End of local variable */
107:                 
108:                     /* Check if the specified driver index is in valid range */
109:                     if(drvIndex >= DRV_USBFS_INSTANCES_NUMBER)
9D00D7EC  14800053   BNE A0, ZERO, 0x9D00D93C
9D00D7F0  2402FFFF   ADDIU V0, ZERO, -1
110:                     {
111:                         SYS_DEBUG(SYS_ERROR_INFO, "\r\nUSBFS Driver: Invalid driver index");
112:                         returnValue = SYS_MODULE_OBJ_INVALID;
113:                     }
114:                 
115:                     /* Check if this hardware instance was already initialized */
116:                     else if(gDrvUSBGroup[drvIndex].gDrvUSBObj.inUse == true)
9D00D7F4  3C02A000   LUI V0, -24576
9D00D7F8  90430CDC   LBU V1, 3292(V0)
9D00D7FC  1460004F   BNE V1, ZERO, 0x9D00D93C
9D00D800  2402FFFF   ADDIU V0, ZERO, -1
117:                     {
118:                         /* Cannot initialize an object that is
119:                          * already in use. */
120:                         SYS_DEBUG(SYS_ERROR_INFO, "\r\nUSBFS Driver: Hardware Instance already in use");
121:                         returnValue = SYS_MODULE_OBJ_INVALID;
122:                     }
123:                     else
124:                     {
125:                         /* Grab the particular USB instance object*/
126:                         gDrvUSBGroup[drvIndex].gDrvUSBObj.inUse = true;
9D00D81C  3C12A000   LUI S2, -24576
9D00D820  24020001   ADDIU V0, ZERO, 1
9D00D824  A2420CDC   SB V0, 3292(S2)
127:                 
128:                         /* Assign to the local pointer the init data passed */
129:                         pusbInit   = (DRV_USBFS_INIT *) init;
130:                         usbID      = pusbInit->usbID;
9D00D828  8CB10004   LW S1, 4(A1)
131:                         pUSBDrvObj = &gDrvUSBGroup[drvIndex].gDrvUSBObj;
132:                 
133:                         /* If this being built in an OS application, then create a mutex */
134:                         OSAL_ASSERT(if(OSAL_MUTEX_Create(&pUSBDrvObj->mutexID) == OSAL_RESULT_TRUE), "\r\nUSBFS Driver: Mutex create failed");
9D00D82C  3C04A000   LUI A0, -24576
9D00D830  0F4052B5   JAL OSAL_MUTEX_Create
9D00D834  24840D0C   ADDIU A0, A0, 3340
135:                 
136:                         /* Populate the driver instance object with required data */
137:                         pUSBDrvObj->status  = SYS_STATUS_BUSY;
9D00D838  26420CDC   ADDIU V0, S2, 3292
9D00D83C  24030001   ADDIU V1, ZERO, 1
9D00D840  AC430014   SW V1, 20(V0)
138:                         pUSBDrvObj->usbID   = usbID;
9D00D844  AC510020   SW S1, 32(V0)
139:                         pUSBDrvObj->operationMode  = pusbInit->operationMode;
9D00D848  8E040014   LW A0, 20(S0)
9D00D84C  AC440024   SW A0, 36(V0)
140:                         pUSBDrvObj->pBDT    = (DRV_USBFS_BDT_ENTRY *)(pusbInit->endpointTable);
9D00D850  8E040018   LW A0, 24(S0)
9D00D854  AC44002C   SW A0, 44(V0)
141:                         pUSBDrvObj->isOpened = false;
9D00D858  A0400005   SB ZERO, 5(V0)
142:                         pUSBDrvObj->pEventCallBack = NULL;
9D00D85C  AC400010   SW ZERO, 16(V0)
143:                 
144:                         /* Assign the endpoint table */
145:                         pUSBDrvObj->endpointTable = &gDrvUSBGroup[drvIndex].gDrvUSBEndpoints[0];
9D00D860  3C04A000   LUI A0, -24576
9D00D864  24840D14   ADDIU A0, A0, 3348
9D00D868  AC440034   SW A0, 52(V0)
146:                 
147:                         pUSBDrvObj->interruptSource  = pusbInit->interruptSource;
9D00D86C  8E04000C   LW A0, 12(S0)
9D00D870  AC440028   SW A0, 40(V0)
148:                 
149:                         /* Enable USB module(U1PWRC<0>). This internally does the following:
150:                          * - Start the USB clock
151:                          * - Allow the USB interrupt to be activated
152:                          * - Select USB as the owner of the necessary I/O pins
153:                          * - Enable the USB transceiver
154:                          * - Enable the USB comparators */
155:                 
156:                         PLIB_USB_Enable(usbID);
157:                 
158:                         /* Setup the Hardware */
159:                         if(pusbInit->stopInIdle)
9D00D880  92020008   LBU V0, 8(S0)
9D00D884  10400006   BEQ V0, ZERO, DRV_USBFS_Initialize::PLIB_USB_StopInIdleDisable
9D00D888  00000000   NOP
160:                         {
161:                             PLIB_USB_StopInIdleEnable( usbID );
162:                         }
163:                         else
164:                         {
165:                             PLIB_USB_StopInIdleDisable( usbID );
166:                         }
167:                 #ifdef PLIB_USB_ExistsAutomaticSuspend
168:                         if(PLIB_USB_ExistsAutomaticSuspend(usbID))
169:                         {
170:                             if(pusbInit->suspendInSleep)
9D00D898  0B40362D   J 0x9D00D8B4
9D00D89C  92020009   LBU V0, 9(S0)
9D00D8B0  92020009   LBU V0, 9(S0)
9D00D8B4  10400004   BEQ V0, ZERO, DRV_USBFS_Initialize::PLIB_USB_AutoSuspendDisable
9D00D8B8  24020001   ADDIU V0, ZERO, 1
171:                             {
172:                                 PLIB_USB_AutoSuspendEnable( usbID );
173:                             }
174:                             else
175:                             {
176:                                 PLIB_USB_AutoSuspendDisable( usbID );
177:                             }
178:                         }
179:                 #endif
180:                         /* Setup the USB Module as per selected mode */
181:                         switch(pusbInit->operationMode)
9D00D8C0  0B403634   J 0x9D00D8D0
9D00D8C4  8E030014   LW V1, 20(S0)
9D00D8CC  8E030014   LW V1, 20(S0)
9D00D8D0  24020001   ADDIU V0, ZERO, 1
9D00D8D4  14620006   BNE V1, V0, 0x9D00D8F0
9D00D8D8  3C03A000   LUI V1, -24576
182:                         {
183:                             case DRV_USBFS_OPMODE_DEVICE:
184:                                 
185:                                 /* Initialize USB Controller for Device mode */
186:                                 _DRV_USBFS_DEVICE_INIT(pUSBDrvObj, drvIndex);
9D00D8DC  3C04A000   LUI A0, -24576
9D00D8E0  24840CDC   ADDIU A0, A0, 3292
9D00D8E4  0F405456   JAL _DRV_USBFS_DEVICE_Initialize
9D00D8E8  00002821   ADDU A1, ZERO, ZERO
187:                                 break;
188:                 
189:                             case DRV_USBFS_OPMODE_HOST:
190:                                 
191:                                 /* Initialize USB Controller for Host mode */
192:                                 _DRV_USBFS_HOST_INIT(pUSBDrvObj, drvIndex, pusbInit);
193:                                 break;
194:                 
195:                             case DRV_USBFS_OPMODE_OTG:
196:                                 /* Not implemented at this point of time*/
197:                                 break;
198:                             default:
199:                                 SYS_DEBUG(SYS_ERROR_INFO, "\r\nUSBFS Driver: What mode are you trying?");
200:                                 break;
201:                         }
202:                 
203:                         /* Assign the BDT table base address */
204:                         PLIB_USB_BDTBaseAddressSet(usbID , (void *)((uint32_t)KVA_TO_PA(pUSBDrvObj->pBDT)));    
9D00D8EC  3C03A000   LUI V1, -24576
9D00D8F0  24630CDC   ADDIU V1, V1, 3292
9D00D8F4  8C62002C   LW V0, 44(V1)
9D00D8F8  7C42E000   EXT V0, V0, 0, 29
205:                 
206:                         /* Indicate that the object is ready and in use
207:                          * and return the driver handle */
208:                 
209:                         pUSBDrvObj->status = SYS_STATUS_READY;
9D00D91C  24020002   ADDIU V0, ZERO, 2
9D00D920  AC620014   SW V0, 20(V1)
210:                         returnValue = drvIndex;
9D00D924  00001021   ADDU V0, ZERO, ZERO
211:                     }
212:                 
213:                     return (returnValue);
214:                 
215:                 }/* end of DRV_USBFS_Initialize() */
9D00D928  8FBF001C   LW RA, 28(SP)
9D00D92C  8FB20018   LW S2, 24(SP)
9D00D930  8FB10014   LW S1, 20(SP)
9D00D934  8FB00010   LW S0, 16(SP)
9D00D938  27BD0020   ADDIU SP, SP, 32
9D00D93C  03E00008   JR RA
9D00D940  00000000   NOP
216:                 
217:                 // *****************************************************************************
218:                 /* Function:
219:                     void DRV_USBFS_Deinitialize( const SYS_MODULE_OBJ object )
220:                 
221:                   Summary:
222:                     Dynamic impementation of DRV_USBFS_Deinitialize system interface function.
223:                 
224:                   Description:
225:                     This is the dynamic impementation of DRV_USBFS_Deinitialize system interface
226:                     function.
227:                 
228:                   Remarks:
229:                     See drv_usbfs.h for usage information.
230:                 */
231:                 
232:                 void DRV_USBFS_Deinitialize
233:                 ( 
234:                     const SYS_MODULE_OBJ  object
235:                 )
236:                 {
237:                     DRV_USBFS_OBJ * pUSBDrvObj = NULL;
238:                     bool returnValue = false;
239:                 
240:                     /* Check if USB instance object is valid */
241:                     if((object == SYS_MODULE_OBJ_INVALID) || (object >= DRV_USBFS_INSTANCES_NUMBER))
242:                     {
243:                         /* Invalid object */
244:                         SYS_DEBUG(SYS_ERROR_INFO, "\r\nUSBFS Driver: Invalid System Module Object");
245:                     }
246:                     else if(gDrvUSBGroup[object].gDrvUSBObj.inUse == false)
247:                     {
248:                         /* Cannot deinitialize an object that is 
249:                          * not in use. */
250:                         SYS_DEBUG(SYS_ERROR_INFO, "\r\nUSBFS Driver: Instance not in use");
251:                     }
252:                     else
253:                     {
254:                         pUSBDrvObj = &gDrvUSBGroup[object].gDrvUSBObj;
255:                 
256:                         /* Release the USB instance object */
257:                         pUSBDrvObj->inUse = false;
258:                 
259:                         /* Reset the open flag */
260:                         pUSBDrvObj->isOpened = false;
261:                 
262:                         /* Delete the mutex */
263:                         OSAL_ASSERT(if(OSAL_MUTEX_Delete(&pUSBDrvObj->mutexID) == OSAL_RESULT_TRUE), "\r\nUSBFS Driver: Mutex delete failed");
264:                         
265:                         /* Uninitialize the status*/
266:                         pUSBDrvObj->status = SYS_STATUS_UNINITIALIZED;
267:                 
268:                         pUSBDrvObj->pEventCallBack = NULL;
269:                 
270:                         /* Clear and disable the interrupts */
271:                         returnValue = _DRV_USBFS_InterruptSourceDisable(pUSBDrvObj->interruptSource);
272:                         if(returnValue == false)
273:                         {
274:                             SYS_DEBUG(SYS_ERROR_INFO, "\r\nUSBFS Driver: Interrupt Source Disable failed");
275:                         }
276:                         _DRV_USBFS_InterruptSourceClear(pUSBDrvObj->interruptSource);
277:                 
278:                         /* Turn off USB module */
279:                         PLIB_USB_Disable(pUSBDrvObj->usbID);
280:                 
281:                     }
282:                 
283:                     return;
284:                 
285:                 } /* end of DRV_USBFS_Deinitialize() */
286:                 
287:                 // *****************************************************************************
288:                 /* Function:
289:                     SYS_STATUS DRV_USBFS_Status( const SYS_MODULE_OBJ object )
290:                 
291:                   Summary:
292:                     Dynamic impementation of DRV_USBFS_Status system interface function.
293:                 
294:                   Description:
295:                     This is the dynamic impementation of DRV_USBFS_Status system interface
296:                     function.
297:                 
298:                   Remarks:
299:                     See drv_usbfs.h for usage information.
300:                 */
301:                 
302:                 SYS_STATUS DRV_USBFS_Status
303:                 (
304:                     const SYS_MODULE_OBJ object
305:                 )
306:                 {
307:                     /* Start of local variables */
308:                     SYS_STATUS returnValue = SYS_STATUS_UNINITIALIZED;
309:                     /* End of local variables */
310:                 
311:                     /* Check if USB instance object is valid */
312:                     if((object == SYS_MODULE_OBJ_INVALID) || (object >= DRV_USBFS_INSTANCES_NUMBER))
313:                     {
314:                         /* Invalid object */
315:                         SYS_DEBUG(SYS_ERROR_INFO, "\r\nUSBFS Driver: Invalid object");
316:                     }
317:                     else
318:                     {
319:                         returnValue = gDrvUSBGroup[object].gDrvUSBObj.status;
320:                     }
321:                 
322:                     /* Return the status of the driver object */
323:                     return returnValue;
324:                     
325:                 }/* end of DRV_USBFS_Status() */
326:                 
327:                 // *****************************************************************************
328:                 /* Function:
329:                     DRV_HANDLE DRV_USBFS_Open
330:                     (
331:                         const SYS_MODULE_INDEX drvIndex,
332:                         const DRV_IO_INTENT    ioIntent 
333:                     )
334:                 
335:                   Summary:
336:                     Dynamic impementation of DRV_USBFS_Open client interface function.
337:                 
338:                   Description:
339:                     This is the dynamic impementation of DRV_USBFS_Open client interface function.
340:                 
341:                   Remarks:
342:                     See drv_usbfs.h for usage information.
343:                 */
344:                 
345:                 DRV_HANDLE DRV_USBFS_Open
346:                 (
347:                     const SYS_MODULE_INDEX drvIndex,
348:                     const DRV_IO_INTENT    ioIntent 
349:                 )
350:                 {
351:                     /* Check if the specified driver index is in valid range */
352:                     if(drvIndex >= DRV_USBFS_INSTANCES_NUMBER)
9D0142AC  14800011   BNE A0, ZERO, 0x9D0142F4
9D0142B0  2402FFFF   ADDIU V0, ZERO, -1
353:                     {
354:                         SYS_DEBUG(SYS_ERROR_INFO, "\r\nUSBFS Driver: Bad Driver Index");
355:                     }
356:                     /* Check if USB instance object is ready*/
357:                     else if(gDrvUSBGroup[drvIndex].gDrvUSBObj.status != SYS_STATUS_READY)
9D0142B4  3C02A000   LUI V0, -24576
9D0142B8  8C440CF0   LW A0, 3312(V0)
9D0142BC  24030002   ADDIU V1, ZERO, 2
9D0142C0  1483000C   BNE A0, V1, 0x9D0142F4
9D0142C4  2402FFFF   ADDIU V0, ZERO, -1
358:                     {
359:                         /* The USB module should be ready */
360:                         SYS_DEBUG(SYS_ERROR_INFO, "\r\nUSBFS Driver: Was the driver initialized?");
361:                     }
362:                     else if(ioIntent != (DRV_IO_INTENT_EXCLUSIVE|DRV_IO_INTENT_NONBLOCKING |DRV_IO_INTENT_READWRITE))
9D0142C8  2403000F   ADDIU V1, ZERO, 15
9D0142CC  14A30009   BNE A1, V1, 0x9D0142F4
9D0142D0  00000000   NOP
363:                     {
364:                         /* The driver only supports this mode */
365:                         SYS_DEBUG(SYS_ERROR_INFO, "\r\nUSBFS Driver: IO intent mode not supported");
366:                     }
367:                     else if(gDrvUSBGroup[drvIndex].gDrvUSBObj.isOpened)
9D0142D4  3C02A000   LUI V0, -24576
9D0142D8  90430CE1   LBU V1, 3297(V0)
9D0142DC  14600005   BNE V1, ZERO, 0x9D0142F4
9D0142E0  2402FFFF   ADDIU V0, ZERO, -1
368:                     {
369:                         /* Driver supports exclusive open only */
370:                         SYS_DEBUG(SYS_ERROR_INFO, "\r\nUSBFS Driver: Driver already opened once. Cannot open again");
371:                     }
372:                     else
373:                     {
374:                         gDrvUSBGroup[drvIndex].gDrvUSBObj.isOpened = true;
9D0142E4  3C02A000   LUI V0, -24576
9D0142E8  24420CDC   ADDIU V0, V0, 3292
9D0142EC  24030001   ADDIU V1, ZERO, 1
9D0142F0  A0430005   SB V1, 5(V0)
375:                         
376:                         /* Return the client object address */
377:                         return ((DRV_HANDLE)&(gDrvUSBGroup[drvIndex].gDrvUSBObj));
378:                     }
379:                 
380:                     /* Return invalid handle */
381:                     return DRV_HANDLE_INVALID;
382:                 
383:                 }/* end of DRV_USBFS_Open()*/
9D0142F4  03E00008   JR RA
9D0142F8  00000000   NOP
384:                 
385:                 // *****************************************************************************
386:                 /* Function:
387:                     bool DRV_USBFS_HOST_Resume(DRV_HANDLE handle)
388:                 
389:                   Summary:
390:                     Dynamic implementation of DRV_USBFS_HOST_Resume
391:                     client interface function.
392:                 
393:                   Description:
394:                     This is the dynamic implementation of DRV_USBFS_HOST_Resume client interface
395:                     function. Function resumes a suspended BUS.
396:                 
397:                   Remarks:
398:                     See drv_usbfs.h for usage information.
399:                 */
400:                 
401:                 bool DRV_USBFS_HOST_Resume
402:                 (
403:                     DRV_HANDLE handle
404:                 )
405:                 {
406:                     /* Start of local variable */
407:                     DRV_USBFS_OBJ * pUSBDrvObj = (DRV_USBFS_OBJ *)handle;
408:                     bool returnValue = false;
409:                     /* End of local variable */
410:                     
411:                     /* Check if the handle is valid */
412:                     if((handle == DRV_HANDLE_INVALID) || (!(pUSBDrvObj->isOpened)))
413:                     {
414:                         SYS_DEBUG(SYS_ERROR_INFO, "\r\nUSBFS Driver: Bad Client or client closed");
415:                     }
416:                     else
417:                     {
418:                         /* Enable the SOF */
419:                         PLIB_USB_SOFEnable(pUSBDrvObj->usbID);
420:                         PLIB_USB_InterruptEnable(pUSBDrvObj->usbID, USB_INT_SOF);
421:                         returnValue = true;
422:                     }
423:                 
424:                     return returnValue;
425:                 
426:                 }/* end of DRV_USBFS_HOST_Resume() */
427:                 
428:                 // *****************************************************************************
429:                 /* Function:
430:                     bool DRV_USBFS_HOST_Suspend(DRV_HANDLE handle)
431:                 
432:                   Summary:
433:                     Dynamic implementation of DRV_USBFS_HOST_Suspend
434:                     client interface function.
435:                 
436:                   Description:
437:                     This is the dynamic implementation of DRV_USBFS_HOST_Suspend client
438:                     interface function. Function suspends USB BUS.
439:                 
440:                   Remarks:
441:                     See drv_usbfs.h for usage information.
442:                 */
443:                 
444:                 bool DRV_USBFS_HOST_Suspend
445:                 (
446:                     DRV_HANDLE handle
447:                 )
448:                 {
449:                     /* Start of local variable */
450:                     DRV_USBFS_OBJ * pUSBDrvObj = (DRV_USBFS_OBJ *)handle;
451:                     bool returnValue = false;
452:                     /* End of local variable */
453:                 
454:                     /* Check if the handle is valid */
455:                     if((handle == DRV_HANDLE_INVALID) || (!(pUSBDrvObj->isOpened)))
456:                     {
457:                         SYS_DEBUG(SYS_ERROR_INFO, "\r\nUSBFS Driver: Bad Client or client closed");
458:                     }
459:                     else
460:                     {
461:                         /* Disable the SOF */
462:                         PLIB_USB_SOFDisable(pUSBDrvObj->usbID);
463:                         PLIB_USB_InterruptDisable(pUSBDrvObj->usbID, USB_INT_SOF);
464:                         returnValue = true;
465:                     }
466:                 
467:                     return returnValue;
468:                 
469:                 }/* end of DRV_USBFS_HOST_Suspend() */
470:                 
471:                 // *****************************************************************************
472:                 /* Function:
473:                     void DRV_USBFS_Close( DRV_HANDLE client )
474:                 
475:                   Summary:
476:                     Dynamic impementation of DRV_USBFS_Close client interface function.
477:                 
478:                   Description:
479:                     This is the dynamic impementation of DRV_USBFS_Close client interface
480:                     function.
481:                 
482:                   Remarks:
483:                     See drv_usbfs.h for usage information.
484:                 */
485:                 
486:                 void DRV_USBFS_Close
487:                 (
488:                     DRV_HANDLE handle
489:                 )
490:                 {
491:                     /* Start of local variable */
492:                     DRV_USBFS_OBJ * pUSBDrvObj = (DRV_USBFS_OBJ *)NULL;
493:                     /* End of local variable */
494:                 
495:                     /* Check if the handle is valid */
496:                     if(handle == DRV_HANDLE_INVALID)
9D015284  2402FFFF   ADDIU V0, ZERO, -1
9D015288  10820006   BEQ A0, V0, 0x9D0152A4
9D01528C  00000000   NOP
497:                     {
498:                         SYS_DEBUG(SYS_ERROR_INFO, "\r\nUSBFS Driver: Bad Client Handle");
499:                     }
500:                     else
501:                     {
502:                         /* Reset the relevant parameters */
503:                         pUSBDrvObj = (DRV_USBFS_OBJ *)handle;
504:                         if(pUSBDrvObj->isOpened)
9D015290  90820005   LBU V0, 5(A0)
9D015294  10400003   BEQ V0, ZERO, 0x9D0152A4
9D015298  00000000   NOP
505:                         {
506:                             pUSBDrvObj->isOpened = false;
9D01529C  A0800005   SB ZERO, 5(A0)
507:                             pUSBDrvObj->pEventCallBack = NULL;
9D0152A0  AC800010   SW ZERO, 16(A0)
9D0152A4  03E00008   JR RA
9D0152A8  00000000   NOP
508:                         }
509:                         else
510:                         {
511:                             SYS_DEBUG(SYS_ERROR_INFO, "\r\nUSBFS Driver: Client Handle already closed");
512:                         }
513:                 
514:                     }
515:                 
516:                     return;
517:                     
518:                 }/* end of DRV_USBFS_Close() */
519:                 
520:                 // *****************************************************************************
521:                 /* Function:
522:                     DRV_HANDLE DRV_USBFS_Tasks_ISR( SYS_MODULE_OBJ object )
523:                 
524:                   Summary:
525:                     Dynamic impementation of DRV_USBFS_Tasks_ISR system interface function.
526:                 
527:                   Description:
528:                     This is the dynamic impementation of DRV_USBFS_Tasks_ISR system interface
529:                     function.
530:                 
531:                   Remarks:
532:                     See drv_usbfs.h for usage information.
533:                 */
534:                 
535:                 void DRV_USBFS_Tasks_ISR
536:                 (
537:                     SYS_MODULE_OBJ object
538:                 )
539:                 {
9D012D8C  27BDFFE8   ADDIU SP, SP, -24
9D012D90  AFBF0014   SW RA, 20(SP)
9D012D94  AFB00010   SW S0, 16(SP)
540:                     /* Start of local variable */
541:                     DRV_USBFS_OBJ * pUSBDriver = (DRV_USBFS_OBJ *)NULL;
542:                     /* End of local varibale */
543:                 
544:                     pUSBDriver = &gDrvUSBGroup[object].gDrvUSBObj;
9D012D98  00041080   SLL V0, A0, 2
9D012D9C  00048100   SLL S0, A0, 4
9D012DA0  02028023   SUBU S0, S0, V0
9D012DA4  02042021   ADDU A0, S0, A0
9D012DA8  000420C0   SLL A0, A0, 3
9D012DAC  3C10A000   LUI S0, -24576
9D012DB0  26100CDC   ADDIU S0, S0, 3292
9D012DB4  02048021   ADDU S0, S0, A0
545:                 
546:                     /* We are entering an interrupt context */
547:                     pUSBDriver->inInterruptContext = true;
9D012DB8  24020001   ADDIU V0, ZERO, 1
9D012DBC  A2020001   SB V0, 1(S0)
548:                 
549:                     /* Clear the interrupt */
550:                     _DRV_USBFS_InterruptSourceClear(pUSBDriver->interruptSource);
9D012DC0  8E030028   LW V1, 40(S0)
551:                 	
552:                     switch(pUSBDriver->operationMode)
9D012DE4  8E030024   LW V1, 36(S0)
9D012DE8  54620004   BNEL V1, V0, 0x9D012DFC
9D012DEC  A2000001   SB ZERO, 1(S0)
553:                     {
554:                         case DRV_USBFS_OPMODE_DEVICE:
555:                             
556:                             /* Driver is running in Device Mode */
557:                             _DRV_USBFS_DEVICE_TASKS_ISR(pUSBDriver);
9D012DF0  0F40101B   JAL _DRV_USBFS_DEVICE_Tasks_ISR
9D012DF4  02002021   ADDU A0, S0, ZERO
558:                             break;
559:                         
560:                         case DRV_USBFS_OPMODE_HOST:
561:                 
562:                             /* Driver is running in Host Mode */
563:                             _DRV_USBFS_HOST_TASKS_ISR(pUSBDriver);
564:                             break;
565:                 
566:                         case DRV_USBFS_OPMODE_OTG:
567:                             /* OTG mode is not supported yet */
568:                             break;
569:                 
570:                         default:
571:                             SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: What mode are you trying?");
572:                             break;
573:                     }
574:                   
575:                     pUSBDriver->inInterruptContext = false;
9D012DF8  A2000001   SB ZERO, 1(S0)
576:                     
577:                 }/* end of DRV_USBFS_Tasks_ISR()*/
9D012DFC  8FBF0014   LW RA, 20(SP)
9D012E00  8FB00010   LW S0, 16(SP)
9D012E04  03E00008   JR RA
9D012E08  27BD0018   ADDIU SP, SP, 24
578:                 
579:                 // *****************************************************************************
580:                 /* Function:
581:                     void DRV_USBFS_ClientEventCallBackSet
582:                     (
583:                         DRV_HANDLE   handle,
584:                         uintptr_t    hReferenceData,
585:                         DRV_USBFS_EVENT_CALLBACK eventCallBack
586:                     )
587:                 
588:                   Summary:
589:                     Dynamic impementation of DRV_USBFS_ClientEventCallBackSet client interface
590:                     function.
591:                 
592:                   Description:
593:                     This is the dynamic impementation of DRV_USBFS_ClientEventCallBackSet client
594:                     interface function.
595:                 
596:                   Remarks:
597:                     See drv_usbfs.h for usage information.
598:                 */
599:                 
600:                 void DRV_USBFS_ClientEventCallBackSet
601:                 ( 
602:                     DRV_HANDLE   handle,
603:                     uintptr_t    hReferenceData,
604:                     DRV_USB_EVENT_CALLBACK eventCallBack 
605:                 )
606:                 {
607:                     /* Start of local variables */
608:                     DRV_USBFS_OBJ * pUSBDrvObj = (DRV_USBFS_OBJ *)handle;
609:                     /* End of local variables */
610:                     
611:                     /* Check if the handle is valid or opened */
612:                     if((handle == DRV_HANDLE_INVALID) || (!(pUSBDrvObj->isOpened)))
9D01377C  2402FFFF   ADDIU V0, ZERO, -1
9D013780  10820016   BEQ A0, V0, 0x9D0137DC
9D013784  00000000   NOP
9D013788  90820005   LBU V0, 5(A0)
9D01378C  10400013   BEQ V0, ZERO, 0x9D0137DC
9D013790  24020001   ADDIU V0, ZERO, 1
613:                     {
614:                         SYS_DEBUG(SYS_ERROR_INFO, "\r\nUSBFS Driver: Bad Client or client closed");
615:                     }
616:                     else
617:                     {
618:                         /* Assign event call back and reference data */
619:                         pUSBDrvObj->hClientArg = hReferenceData;
9D013794  AC85000C   SW A1, 12(A0)
620:                         pUSBDrvObj->pEventCallBack = eventCallBack;
9D013798  AC860010   SW A2, 16(A0)
621:                 
622:                         /* If the driver is operating in device mode, this is the time
623:                          * we enable the USB interrupt */
624:                 
625:                         if(pUSBDrvObj->operationMode == USB_OPMODE_DEVICE)
9D01379C  8C830024   LW V1, 36(A0)
9D0137A0  1462000E   BNE V1, V0, 0x9D0137DC
9D0137A4  00000000   NOP
626:                         {
627:                             /* Enable the session valid interrupt */
628:                             PLIB_USB_OTG_InterruptEnable(pUSBDrvObj->usbID, USB_OTG_INT_SESSION_VALID);
629:                             
630:                             /* Enable the interrupt */
631:                             _DRV_USBFS_InterruptSourceEnable(pUSBDrvObj->interruptSource);
9D0137B8  8C820028   LW V0, 40(A0)
9D0137BC  00022142   SRL A0, V0, 5
9D0137C0  00042100   SLL A0, A0, 4
9D0137C4  3C03BF88   LUI V1, -16504
9D0137C8  24631060   ADDIU V1, V1, 4192
9D0137CC  00641821   ADDU V1, V1, A0
9D0137D0  24040001   ADDIU A0, ZERO, 1
9D0137D4  00441004   SLLV V0, A0, V0
9D0137D8  AC620008   SW V0, 8(V1)
9D0137DC  03E00008   JR RA
9D0137E0  00000000   NOP
632:                 
633:                         }
634:                     }
635:                    
636:                     return;
637:                     
638:                 } /* end of DRV_USBFS_ClientEventCallBackSet() */
639:                 
640:                 // *****************************************************************************
641:                 /* Function:
642:                     void DRV_USBFS_Tasks( SYS_MODULE_OBJ object )
643:                 
644:                   Summary:
645:                     Maintains the driver's state machine when the driver is configured for 
646:                     polled mode.
647:                 
648:                   Description:
649:                     Maintains the driver's state machine when the driver is configured for 
650:                     polled mode. This function should be called from the system tasks routine.
651:                 
652:                   Remarks:
653:                     Refer to drv_usbfs.h for usage information.
654:                 */
655:                 
656:                 void DRV_USBFS_Tasks(SYS_MODULE_OBJ object)
657:                 {
9D015A10  03E00008   JR RA
9D015A14  00000000   NOP
658:                     /* This driver does not have any non interrupt tasks. When the driver
659:                      * is configured for polled mode operation, the _DRV_USBFS_Tasks_ISR function
660:                      * will map to DRV_USBFS_Tasks_ISR function. In interrupt mode, this function
661:                      * will be mapped to nothing and hence this function will not have any
662:                      * effect. */
663:                 
664:                     _DRV_USBFS_Tasks_ISR(object);
665:                 }
666:                 
667:                 void DRV_USBFS_Tasks_ISR_USBDMA( SYS_MODULE_OBJ object )
668:                 {
669:                     /* This function is implemented to only maintain compatibility with the
670:                      * PIC32MZ High Speed USB Driver. This function does not do anything on the
671:                      * PIC32MX USB driver and is not required to be called in a PIC32MX USB
672:                      * applicaiton */
673:                 }
---  /home/whatisthis/microchip/harmony/v2_04/framework/driver/usart/src/dynamic/drv_usart_read_write.c  
1:                   /*******************************************************************************
2:                     USART Driver Dynamic implementation.
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       drv_usart_file_io_model.c
9:                   
10:                    Summary:
11:                      Source code for the USART driver dynamic implementation of File IO data
12:                      transfer model.
13:                  
14:                    Description:
15:                      This file contains the source code for the dynamic implementation of the
16:                      USART driver File IO data transfer model.
17:                  *******************************************************************************/
18:                  
19:                  //DOM-IGNORE-BEGIN
20:                  /*******************************************************************************
21:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
22:                  
23:                  Microchip licenses to you the right to use, modify, copy and distribute Software
24:                  only when embedded on a Microchip microcontroller or digital  signal  controller
25:                  that is integrated into your product or third party  product  (pursuant  to  the
26:                  sublicense terms in the accompanying license agreement).
27:                  
28:                  You should refer to the license agreement accompanying this Software for
29:                  additional information regarding your rights and obligations.
30:                  
31:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS  WITHOUT  WARRANTY  OF  ANY  KIND,
32:                  EITHER EXPRESS  OR  IMPLIED,  INCLUDING  WITHOUT  LIMITATION,  ANY  WARRANTY  OF
33:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A  PARTICULAR  PURPOSE.
34:                  IN NO EVENT SHALL MICROCHIP OR  ITS  LICENSORS  BE  LIABLE  OR  OBLIGATED  UNDER
35:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION,  BREACH  OF  WARRANTY,  OR
36:                  OTHER LEGAL  EQUITABLE  THEORY  ANY  DIRECT  OR  INDIRECT  DAMAGES  OR  EXPENSES
37:                  INCLUDING BUT NOT LIMITED TO ANY  INCIDENTAL,  SPECIAL,  INDIRECT,  PUNITIVE  OR
38:                  CONSEQUENTIAL DAMAGES, LOST  PROFITS  OR  LOST  DATA,  COST  OF  PROCUREMENT  OF
39:                  SUBSTITUTE  GOODS,  TECHNOLOGY,  SERVICES,  OR  ANY  CLAIMS  BY  THIRD   PARTIES
40:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE  THEREOF),  OR  OTHER  SIMILAR  COSTS.
41:                  *******************************************************************************/
42:                  //DOM-IGNORE-END
43:                  #include "../drv_usart_local.h"
44:                  
45:                  // *****************************************************************************
46:                  /* Function:
47:                      size_t DRV_USART_Read
48:                      (
49:                          DRV_HANDLE hClient, 
50:                          void * destination,
51:                          size_t nBytes
52:                      )
53:                  
54:                    Summary:
55:                      Dynamic implementation of DRV_USART_Read client interface function.
56:                  
57:                    Description:
58:                      This is the dynamic implementation of DRV_USART_Read client interface
59:                      function.
60:                  
61:                    Remarks:
62:                      See drv_usart.h for usage information.
63:                  */
64:                  
65:                  size_t DRV_USART_Read(const DRV_HANDLE hClient, void * destination, size_t nBytes)
66:                  {
9D00810C  27BDFFD0   ADDIU SP, SP, -48
9D008110  AFBF002C   SW RA, 44(SP)
9D008114  AFB50028   SW S5, 40(SP)
9D008118  AFB40024   SW S4, 36(SP)
9D00811C  AFB30020   SW S3, 32(SP)
9D008120  AFB2001C   SW S2, 28(SP)
9D008124  AFB10018   SW S1, 24(SP)
9D008128  AFB00014   SW S0, 20(SP)
9D00812C  00A09021   ADDU S2, A1, ZERO
67:                      DRV_USART_CLIENT_OBJ * clientObj;
68:                      DRV_USART_OBJ * hDriver;
69:                      USART_MODULE_ID plibID;
70:                      DRV_USART_BUFFER_OBJ * iterator, * bufferObj;
71:                      size_t count = 0;
72:                      uint8_t * data;
73:                  
74:                      /* Validate the driver handle */
75:                  
76:                      clientObj = _DRV_USART_DriverHandleValidate(hClient);
9D008130  0F40548D   JAL _DRV_USART_DriverHandleValidate
9D008134  00C09821   ADDU S3, A2, ZERO
77:                      if(clientObj == NULL)
9D008138  10400077   BEQ V0, ZERO, 0x9D008318
9D00813C  00408021   ADDU S0, V0, ZERO
78:                      {
79:                          SYS_DEBUG(0, "Invalid driver handle");
80:                          return 0;
9D008318  0B4020C8   J 0x9D008320
9D00831C  00001821   ADDU V1, ZERO, ZERO
81:                      }
82:                  
83:                      hDriver = (DRV_USART_OBJ *)clientObj->hDriver;
9D008140  8C510000   LW S1, 0(V0)
84:                      plibID = hDriver->moduleId;
9D008144  8E340000   LW S4, 0(S1)
85:                  
86:                      if(!(clientObj->ioIntent & DRV_IO_INTENT_READ))
9D008148  8C420004   LW V0, 4(V0)
9D00814C  30420001   ANDI V0, V0, 1
9D008150  10400073   BEQ V0, ZERO, 0x9D008320
9D008154  00001821   ADDU V1, ZERO, ZERO
87:                      {
88:                          /* This client did not open the driver for
89:                             reading */
90:                          SYS_DEBUG(0, "Driver not opened for read");
91:                          return 0;
92:                      }
93:                  
94:                      if((destination == NULL) || (nBytes == 0))
9D008158  12400072   BEQ S2, ZERO, 0x9D008324
9D00815C  00601021   ADDU V0, V1, ZERO
9D008160  12600071   BEQ S3, ZERO, 0x9D008328
9D008164  8FBF002C   LW RA, 44(SP)
95:                      {
96:                          /* We have a NULL pointer or don't have
97:                             any data to write. */
98:                  
99:                          SYS_DEBUG(0, "NULL data pointer or no data to write");
100:                         return 0;
101:                     }
102:                 
103:                     data = (uint8_t *)destination;
104:                 
105:                     /* Grab he hardware instance mutex */
106:                 
107:                     if(OSAL_MUTEX_Lock(&(hDriver->mutexDriverInstance), OSAL_WAIT_FOREVER) == OSAL_RESULT_TRUE)
9D008168  26350030   ADDIU S5, S1, 48
9D00816C  02A02021   ADDU A0, S5, ZERO
9D008170  0F405267   JAL OSAL_MUTEX_Lock
9D008174  3405FFFF   ORI A1, ZERO, -1
9D008178  24040001   ADDIU A0, ZERO, 1
9D00817C  14440068   BNE V0, A0, 0x9D008320
9D008180  00001821   ADDU V1, ZERO, ZERO
108:                     {
109:                         if(!(clientObj->ioIntent & DRV_IO_INTENT_NONBLOCKING))
9D008184  8E020004   LW V0, 4(S0)
9D008188  30420004   ANDI V0, V0, 4
9D00818C  5440003C   BNEL V0, ZERO, 0x9D008280
9D008190  8E220008   LW V0, 8(S1)
110:                         {
111:                             /* This is a blocking implementation. We populate the client buffer
112:                                object and add it to the queue. We then wait till the buffer is
113:                                completely processed. */
114:                 
115:                             /* Because we are modifying the queue, we should disable the
116:                                interrupt */
117:                             _DRV_USART_InterruptSourceDisable(hDriver->rxInterruptSource);
9D008194  0F405058   JAL SYS_INT_SourceDisable
9D008198  8E240028   LW A0, 40(S1)
118:                             _DRV_USART_InterruptSourceDisable(hDriver->errorInterruptSource);
9D00819C  0F405058   JAL SYS_INT_SourceDisable
9D0081A0  8E24002C   LW A0, 44(S1)
119:                 
120:                             /* Get the queue head */
121:                 
122:                             iterator = hDriver->queueRead;
9D0081A4  8E230008   LW V1, 8(S1)
123:                 
124:                             /* If the queue is not empty, get to the end of the queue */
125:                 
126:                             if(iterator != NULL)
9D0081A8  10600006   BEQ V1, ZERO, 0x9D0081C4
9D0081AC  2602000C   ADDIU V0, S0, 12
127:                             {
128:                                 while(iterator->next != NULL)
9D0081B0  8C620018   LW V0, 24(V1)
9D0081B4  50400003   BEQL V0, ZERO, 0x9D0081C4
9D0081B8  2602000C   ADDIU V0, S0, 12
129:                                 {
130:                                     iterator = iterator->next;
9D0081BC  0B40206C   J 0x9D0081B0
9D0081C0  00401821   ADDU V1, V0, ZERO
131:                                 }
132:                             }
133:                 
134:                             /* We should be at the end of the queue now. Populate the client
135:                                buffer object */
136:                 
137:                             bufferObj = &clientObj->bufferObject;
138:                             bufferObj->buffer = destination;
9D0081C4  AE120010   SW S2, 16(S0)
139:                             bufferObj->nCurrentBytes = 0;
9D0081C8  AE000018   SW ZERO, 24(S0)
140:                             bufferObj->size = nBytes;
9D0081CC  AE13001C   SW S3, 28(S0)
141:                             bufferObj->inUse = true;
9D0081D0  24040001   ADDIU A0, ZERO, 1
9D0081D4  A204000C   SB A0, 12(S0)
142:                             bufferObj->hClient = clientObj;
9D0081D8  AE100020   SW S0, 32(S0)
143:                             bufferObj->flags = (0 | DRV_USART_BUFFER_OBJ_FLAG_READ_WRITE);
9D0081DC  24040001   ADDIU A0, ZERO, 1
9D0081E0  AE04002C   SW A0, 44(S0)
144:                 
145:                             /* Add this object to the queue and enable the RX interrupt */
146:                 
147:                             bufferObj->previous = iterator;
9D0081E4  AE030028   SW V1, 40(S0)
148:                             bufferObj->next = NULL;
9D0081E8  AE000024   SW ZERO, 36(S0)
149:                 
150:                             /* If we are not at the start of the queue, then update the next
151:                                pointer of the last object else set the queue head to point to
152:                                this object */
153:                 
154:                             if(hDriver->queueRead == NULL)
9D0081EC  8E240008   LW A0, 8(S1)
9D0081F0  54800003   BNEL A0, ZERO, 0x9D008200
9D0081F4  AC620018   SW V0, 24(V1)
9D0081F8  0B402081   J 0x9D008204
9D0081FC  AE220008   SW V0, 8(S1)
155:                             {
156:                                 hDriver->queueRead = bufferObj;
157:                             }
158:                             else
159:                             {
160:                                 iterator->next = bufferObj;
161:                                 bufferObj->previous = iterator;
9D008200  AE030028   SW V1, 40(S0)
162:                             }
163:                 
164:                             /* Update the queue size as we have added a buffer to the queue */
165:                             hDriver->queueSizeCurrentRead ++;
9D008204  8E22003C   LW V0, 60(S1)
9D008208  24420001   ADDIU V0, V0, 1
9D00820C  AE22003C   SW V0, 60(S1)
166:                 
167:                             /* Now enable the interrupt and release the mutex so that the system
168:                                can proceed */
169:                 
170:                             _DRV_USART_InterruptSourceEnable(hDriver->rxInterruptSource);
9D008210  8E220028   LW V0, 40(S1)
171:                             _DRV_USART_InterruptSourceEnable(hDriver->errorInterruptSource);
9D008234  8E22002C   LW V0, 44(S1)
172:                             
173:                             OSAL_MUTEX_Unlock(&(hDriver->mutexDriverInstance));
9D00824C  0F40541A   JAL OSAL_MUTEX_Unlock
9D008250  02A02021   ADDU A0, S5, ZERO
174:                 
175:                             /* If we are in a bare metal configuration, then wait till the
176:                                buffer is processed. If we are in RTOS configuration then pend on
177:                                the client semaphore. */
178:                 
179:                                 OSAL_SEM_Pend(&(clientObj->semReadDone), OSAL_WAIT_FOREVER);
9D008254  26040048   ADDIU A0, S0, 72
9D008258  0F405257   JAL OSAL_SEM_Pend
9D00825C  3405FFFF   ORI A1, ZERO, -1
180:                                 /* This is the implementation of the blocking behavior. In a
181:                                    RTOS configuration, if the code reaches here, it means then
182:                                    that buffer has been processed. */
183:                 
184:                                 while(bufferObj->inUse);
9D008260  9202000C   LBU V0, 12(S0)
9D008264  304200FF   ANDI V0, V0, 255
9D008268  1440FFFD   BNE V0, ZERO, 0x9D008260
9D00826C  2403FFFF   ADDIU V1, ZERO, -1
185:                                 if(bufferObj->nCurrentBytes != nBytes)
9D008270  8E020018   LW V0, 24(S0)
186:                                 {
187:                                     /* This means this buffer was terminated because of an
188:                                        error. */
189:                 
190:                                     return(DRV_USART_READ_ERROR);
9D008274  00539826   XOR S3, V0, S3
9D008278  0B4020C8   J 0x9D008320
9D00827C  0053180A   MOVZ V1, V0, S3
191:                                 }
192:                 
193:                                 count = nBytes;
194:                             
195:                         }
196:                         else if(clientObj->ioIntent & DRV_IO_INTENT_NONBLOCKING)
197:                         {
198:                             /* This is a non blocking implementation*/
199:                 
200:                             if(hDriver->queueRead != NULL)
9D008280  14400027   BNE V0, ZERO, 0x9D008320
9D008284  00001821   ADDU V1, ZERO, ZERO
201:                             {
202:                                 /* This means queue is not empty. We cannot read
203:                                    data now. */
204:                                 count = 0;
205:                             }
206:                             else
207:                             {
208:                 
209:                                 while((PLIB_USART_ReceiverDataIsAvailable(plibID)) &&
9D008294  5060001C   BEQL V1, ZERO, 0x9D008308
9D008298  0000A021   ADDU S4, ZERO, ZERO
9D0082F8  10600003   BEQ V1, ZERO, 0x9D008308
9D0082FC  00000000   NOP
9D008300  1693FFED   BNE S4, S3, DRV_USART_Read::PLIB_USART_ErrorsGet
9D008304  00000000   NOP
210:                                         (count < nBytes))
211:                                 {
212:                 
213:                                     /* We need to check for errors. Store the error
214:                                        in the client error field. */
215:                 
216:                                     clientObj->error = PLIB_USART_ErrorsGet(plibID);
9D0082A4  AE03003C   SW V1, 60(S0)
217:                 
218:                                     if(clientObj->error != DRV_USART_ERROR_NONE)
9D0082A8  1060000D   BEQ V1, ZERO, DRV_USART_Read::PLIB_USART_ReceiverByteReceive
9D0082AC  0000A021   ADDU S4, ZERO, ZERO
9D0082B0  0B4020B2   J 0x9D0082C8
9D0082B4  00000000   NOP
9D0082C0  10600007   BEQ V1, ZERO, DRV_USART_Read::PLIB_USART_ReceiverByteReceive
9D0082C4  AE03003C   SW V1, 60(S0)
219:                                     {
220:                                         /* This means we have an error. Release the mutex and
221:                                            exit */
222:                                            
223:                                         /* Clear error condition before exiting */
224:                                         _DRV_USART_ErrorConditionClear(hDriver);
9D0082C8  0F4047E7   JAL _DRV_USART_ErrorConditionClear
9D0082CC  02202021   ADDU A0, S1, ZERO
225:                                         
226:                                         OSAL_MUTEX_Unlock(&(hDriver->mutexDriverInstance));
9D0082D0  0F40541A   JAL OSAL_MUTEX_Unlock
9D0082D4  02A02021   ADDU A0, S5, ZERO
227:                                         return(DRV_USART_READ_ERROR);
9D0082D8  0B4020C8   J 0x9D008320
9D0082DC  2403FFFF   ADDIU V1, ZERO, -1
228:                                     }
229:                                     
230:                                     /* This is not a blocking implementation. We read
231:                                        the hardware till the FIFO is empty. */
232:                 
233:                                     data[count] = PLIB_USART_ReceiverByteReceive(plibID);
9D0082E8  A0640000   SB A0, 0(V1)
234:                                     count ++;
9D0082EC  26940001   ADDIU S4, S4, 1
235:                                 }
236:                 
237:                                 /* Unlock the mutex */
238:                                 OSAL_MUTEX_Unlock(&(hDriver->mutexDriverInstance));
9D008308  0F40541A   JAL OSAL_MUTEX_Unlock
9D00830C  02A02021   ADDU A0, S5, ZERO
9D008310  0B4020C8   J 0x9D008320
9D008314  02801821   ADDU V1, S4, ZERO
239:                             }
240:                         }
241:                     }
242:                     else
243:                     {
244:                         /* Timed out while waiting for read mutex.
245:                          * We simply return 0 */
246:                         count = 0;
247:                     }
248:                 
249:                     return(count);
250:                 }
9D008320  00601021   ADDU V0, V1, ZERO
9D008324  8FBF002C   LW RA, 44(SP)
9D008328  8FB50028   LW S5, 40(SP)
9D00832C  8FB40024   LW S4, 36(SP)
9D008330  8FB30020   LW S3, 32(SP)
9D008334  8FB2001C   LW S2, 28(SP)
9D008338  8FB10018   LW S1, 24(SP)
9D00833C  8FB00014   LW S0, 20(SP)
9D008340  03E00008   JR RA
9D008344  27BD0030   ADDIU SP, SP, 48
251:                 
252:                 // *****************************************************************************
253:                 /* Function:
254:                     size_t DRIVER DRV_USART_Write
255:                     (
256:                         DRV_HANDLE hClient, 
257:                         void * source, 
258:                         size_t nBytes
259:                     )
260:                 
261:                   Summary:
262:                     Dynamic implementation of DRV_USART_Write client interface function.
263:                 
264:                   Description:
265:                     This is the dynamic implementation of DRV_USART_Write client interface function.
266:                 
267:                   Remarks:
268:                     See drv_usart.h for usage information.
269:                 */
270:                 
271:                 size_t DRV_USART_Write(DRV_HANDLE hClient, void * source, size_t nBytes)
272:                 {
9D008BE4  27BDFFD0   ADDIU SP, SP, -48
9D008BE8  AFBF002C   SW RA, 44(SP)
9D008BEC  AFB50028   SW S5, 40(SP)
9D008BF0  AFB40024   SW S4, 36(SP)
9D008BF4  AFB30020   SW S3, 32(SP)
9D008BF8  AFB2001C   SW S2, 28(SP)
9D008BFC  AFB10018   SW S1, 24(SP)
9D008C00  AFB00014   SW S0, 20(SP)
9D008C04  00A09821   ADDU S3, A1, ZERO
273:                     DRV_USART_CLIENT_OBJ * clientObj;
274:                     DRV_USART_OBJ * hDriver;
275:                     DRV_USART_BUFFER_OBJ * iterator, * bufferObj;
276:                     USART_MODULE_ID plibID;
277:                     size_t count = 0;
278:                     uint8_t * data;
279:                     /* Validate the driver handle */
280:                 
281:                     clientObj = _DRV_USART_DriverHandleValidate(hClient);
9D008C08  0F40548D   JAL _DRV_USART_DriverHandleValidate
9D008C0C  00C09021   ADDU S2, A2, ZERO
282:                     if(clientObj == NULL)
9D008C10  1040006C   BEQ V0, ZERO, 0x9D008DC4
9D008C14  00408021   ADDU S0, V0, ZERO
283:                     {
284:                         SYS_DEBUG(0, "Invalid driver handle");
285:                         return 0;
9D008DC4  0B402373   J 0x9D008DCC
9D008DC8  00001821   ADDU V1, ZERO, ZERO
286:                     }
287:                 
288:                     hDriver = (DRV_USART_OBJ *)clientObj->hDriver;
9D008C18  8C510000   LW S1, 0(V0)
289:                     plibID = hDriver->moduleId;
9D008C1C  8E340000   LW S4, 0(S1)
290:                 
291:                     if(!(clientObj->ioIntent & DRV_IO_INTENT_WRITE))
9D008C20  8C420004   LW V0, 4(V0)
9D008C24  30420002   ANDI V0, V0, 2
9D008C28  10400068   BEQ V0, ZERO, 0x9D008DCC
9D008C2C  00001821   ADDU V1, ZERO, ZERO
292:                     {
293:                         /* This client did not open the driver for
294:                            writing */
295:                         SYS_DEBUG(0, "Driver not opened for write");
296:                         return 0;
297:                     }
298:                 
299:                     if((source == NULL) || (nBytes == 0))
9D008C30  12600067   BEQ S3, ZERO, 0x9D008DD0
9D008C34  00601021   ADDU V0, V1, ZERO
9D008C38  12400066   BEQ S2, ZERO, 0x9D008DD4
9D008C3C  8FBF002C   LW RA, 44(SP)
300:                     {
301:                         /* We have a NULL pointer or don't have
302:                            any data to write. */
303:                 
304:                         SYS_DEBUG(0, "NULL data pointer or no data to write");
305:                         return 0;
306:                     }
307:                 
308:                     data = (uint8_t *)source;
309:                 
310:                     /* Grab the write mutex */
311:                     if(OSAL_MUTEX_Lock(&(hDriver->mutexDriverInstance), OSAL_WAIT_FOREVER) == OSAL_RESULT_TRUE)
9D008C40  26350030   ADDIU S5, S1, 48
9D008C44  02A02021   ADDU A0, S5, ZERO
9D008C48  0F405267   JAL OSAL_MUTEX_Lock
9D008C4C  3405FFFF   ORI A1, ZERO, -1
9D008C50  24040001   ADDIU A0, ZERO, 1
9D008C54  1444005D   BNE V0, A0, 0x9D008DCC
9D008C58  00001821   ADDU V1, ZERO, ZERO
312:                     {
313:                         if(!(clientObj->ioIntent & DRV_IO_INTENT_NONBLOCKING))
9D008C5C  8E020004   LW V0, 4(S0)
9D008C60  30420004   ANDI V0, V0, 4
9D008C64  5440003D   BNEL V0, ZERO, 0x9D008D5C
9D008C68  8E220004   LW V0, 4(S1)
314:                         {
315:                             /* This is a blocking implementation. We populate the client buffer
316:                                object and add it to the queue. We then wait till the buffer is
317:                                completely processed. */
318:                 
319:                             /* Because we are modifying the queue, we should disable the
320:                                interrupt */
321:                 
322:                             _DRV_USART_InterruptSourceDisable(hDriver->txInterruptSource);
9D008C6C  0F405058   JAL SYS_INT_SourceDisable
9D008C70  8E240024   LW A0, 36(S1)
323:                 
324:                             /* Get the queue head */
325:                 
326:                             iterator = hDriver->queueWrite;
9D008C74  8E230004   LW V1, 4(S1)
327:                 
328:                             /* If the queue is not empty, then get to the
329:                                end of the queue */
330:                 
331:                             if(iterator != NULL)
9D008C78  10600006   BEQ V1, ZERO, 0x9D008C94
9D008C7C  2602000C   ADDIU V0, S0, 12
332:                             {
333:                                 while(iterator->next != NULL)
9D008C80  8C620018   LW V0, 24(V1)
9D008C84  50400003   BEQL V0, ZERO, 0x9D008C94
9D008C88  2602000C   ADDIU V0, S0, 12
334:                                 {
335:                                     iterator = iterator->next;
9D008C8C  0B402320   J 0x9D008C80
9D008C90  00401821   ADDU V1, V0, ZERO
336:                                 }
337:                             }
338:                 
339:                             /* We should be at the end of the queue now. Populate the client
340:                                buffer object */
341:                 
342:                             bufferObj = &clientObj->bufferObject;
343:                             bufferObj->buffer = source;
9D008C94  AE130010   SW S3, 16(S0)
344:                             bufferObj->nCurrentBytes = 0;
9D008C98  AE000018   SW ZERO, 24(S0)
345:                             bufferObj->size = nBytes;
9D008C9C  AE12001C   SW S2, 28(S0)
346:                             bufferObj->inUse = true;
9D008CA0  24040001   ADDIU A0, ZERO, 1
9D008CA4  A204000C   SB A0, 12(S0)
347:                             bufferObj->hClient = clientObj;
9D008CA8  AE100020   SW S0, 32(S0)
348:                             bufferObj->flags = (0 | DRV_USART_BUFFER_OBJ_FLAG_READ_WRITE);
9D008CAC  24040001   ADDIU A0, ZERO, 1
9D008CB0  AE04002C   SW A0, 44(S0)
349:                 
350:                             /* Add this object to the queue and enable the RX interrupt */
351:                 
352:                             bufferObj->previous = iterator;
9D008CB4  AE030028   SW V1, 40(S0)
353:                             bufferObj->next = NULL;
9D008CB8  AE000024   SW ZERO, 36(S0)
354:                 
355:                             /* If we are not at the start of the queue, then update the next
356:                                pointer of the last object else set the queue head to point to
357:                                this object */
358:                 
359:                             if(hDriver->queueWrite == NULL)
9D008CBC  8E240004   LW A0, 4(S1)
9D008CC0  5480000B   BNEL A0, ZERO, 0x9D008CF0
9D008CC4  AC620018   SW V0, 24(V1)
360:                             {
361:                                 hDriver->queueWrite = bufferObj;
9D008CC8  AE220004   SW V0, 4(S1)
362:                                 bufferObj->nCurrentBytes = 1;
9D008CCC  24020001   ADDIU V0, ZERO, 1
9D008CD0  AE020018   SW V0, 24(S0)
363:                                 hDriver->queueSizeCurrentWrite ++;
9D008CD4  8E220040   LW V0, 64(S1)
9D008CD8  24420001   ADDIU V0, V0, 1
9D008CDC  AE220040   SW V0, 64(S1)
364:                                 PLIB_USART_TransmitterByteSend(plibID, data[0]);
365:                             }
366:                             else
367:                             {
368:                                 iterator->next = bufferObj;
369:                                 bufferObj->previous = iterator;
9D008CF0  AE030028   SW V1, 40(S0)
370:                                 hDriver->queueSizeCurrentWrite ++;
9D008CF4  8E220040   LW V0, 64(S1)
9D008CF8  24420001   ADDIU V0, V0, 1
9D008CFC  AE220040   SW V0, 64(S1)
371:                             }
372:                 
373:                             /* Now enable the interrupt and release the mutex so that the system
374:                                can proceed */
375:                 
376:                             _DRV_USART_InterruptSourceEnable(hDriver->txInterruptSource);
9D008CE8  0B402341   J DRV_USART_Write::PLIB_INT_SourceEnable
9D008CEC  8E220024   LW V0, 36(S1)
9D008D00  8E220024   LW V0, 36(S1)
377:                             OSAL_MUTEX_Unlock(&(hDriver->mutexDriverInstance));
9D008D24  0F40541A   JAL OSAL_MUTEX_Unlock
9D008D28  02A02021   ADDU A0, S5, ZERO
378:                 
379:                             /* If we are in a bare metal configuration, then wait till the
380:                                buffer is processed. If we are in RTOS configuration then pend on
381:                                the client semaphore. */
382:                 
383:                             OSAL_SEM_Pend(&(clientObj->semWriteDone), OSAL_WAIT_FOREVER);
9D008D2C  2604004C   ADDIU A0, S0, 76
9D008D30  0F405257   JAL OSAL_SEM_Pend
9D008D34  3405FFFF   ORI A1, ZERO, -1
384:                 
385:                             /* This is the implementation of the blocking behavior. In a
386:                                RTOS configuration, if the code reaches here, it means then
387:                                that buffer has been processed. */
388:                 
389:                             while(bufferObj->inUse);
9D008D38  9202000C   LBU V0, 12(S0)
9D008D3C  304200FF   ANDI V0, V0, 255
9D008D40  1440FFFD   BNE V0, ZERO, 0x9D008D38
9D008D44  00000000   NOP
390:                             if(bufferObj->nCurrentBytes != nBytes)
9D008D48  8E020018   LW V0, 24(S0)
9D008D4C  1452001F   BNE V0, S2, 0x9D008DCC
9D008D50  2403FFFF   ADDIU V1, ZERO, -1
9D008D54  0B40236D   J 0x9D008DB4
9D008D58  00000000   NOP
391:                             {
392:                                 /* This means this buffer was terminated because of an
393:                                    error. */
394:                 
395:                                 return(DRV_USART_WRITE_ERROR);
396:                             }
397:                 
398:                             count = nBytes;
399:                 
400:                         }
401:                         else if(clientObj->ioIntent & DRV_IO_INTENT_NONBLOCKING)
402:                         {
403:                             /* This is a non blocking implementation*/
404:                 
405:                             if(hDriver->queueWrite != NULL)
9D008D5C  54400015   BNEL V0, ZERO, 0x9D008DB4
9D008D60  00009021   ADDU S2, ZERO, ZERO
9D008D64  0B402366   J DRV_USART_Write::PLIB_USART_TransmitterBufferIsFull
9D008D68  00001021   ADDU V0, ZERO, ZERO
406:                             {
407:                                 /* This means queue is not empty. We cannot send
408:                                    data now. */
409:                                 count = 0;
410:                             }
411:                             else
412:                             {
413:                                 while((!PLIB_USART_TransmitterBufferIsFull(plibID)) &&
9D008DA0  54600004   BNEL V1, ZERO, 0x9D008DB4
9D008DA4  00409021   ADDU S2, V0, ZERO
9D008DA8  5452FFF0   BNEL V0, S2, DRV_USART_Write::PLIB_USART_TransmitterByteSend
9D008DAC  02621821   ADDU V1, S3, V0
9D008DB0  00409021   ADDU S2, V0, ZERO
414:                                         (count < nBytes))
415:                                 {
416:                                     /* This is not a blocking implementation. We write
417:                                        to the hardware till the FIFO is full. */
418:                 
419:                                     PLIB_USART_TransmitterByteSend(plibID, data[count]);
420:                                     count ++;
9D008D74  24420001   ADDIU V0, V0, 1
421:                 
422:                                     /* We need to check for errors. Store the error
423:                                        in the client error field. */
424:                 
425:                                     clientObj->error = PLIB_USART_ErrorsGet(plibID);
426:                 
427:                                     if(clientObj->error != DRV_USART_ERROR_NONE)
9D008D80  10600005   BEQ V1, ZERO, DRV_USART_Write::PLIB_USART_TransmitterBufferIsFull
9D008D84  AE03003C   SW V1, 60(S0)
428:                                     {
429:                                         /* This means we have an error. Release the mutex and exit */
430:                 
431:                                         OSAL_MUTEX_Unlock(&(hDriver->mutexDriverInstance));
9D008D88  0F40541A   JAL OSAL_MUTEX_Unlock
9D008D8C  02A02021   ADDU A0, S5, ZERO
432:                                         return(DRV_USART_WRITE_ERROR);
9D008D90  0B402373   J 0x9D008DCC
9D008D94  2403FFFF   ADDIU V1, ZERO, -1
433:                                     }
434:                                 }
435:                             }
436:                         }
437:                 
438:                         /* Release mutex */
439:                         OSAL_MUTEX_Unlock(&(hDriver->mutexDriverInstance));
9D008DB4  0F40541A   JAL OSAL_MUTEX_Unlock
9D008DB8  02A02021   ADDU A0, S5, ZERO
9D008DBC  0B402373   J 0x9D008DCC
9D008DC0  02401821   ADDU V1, S2, ZERO
440:                     }
441:                     else
442:                     {
443:                         /* Write mutex timed out. Set the return count to zero. */
444:                         count = 0;
445:                     }
446:                 
447:                     return(count);
448:                 }
9D008DCC  00601021   ADDU V0, V1, ZERO
9D008DD0  8FBF002C   LW RA, 44(SP)
9D008DD4  8FB50028   LW S5, 40(SP)
9D008DD8  8FB40024   LW S4, 36(SP)
9D008DDC  8FB30020   LW S3, 32(SP)
9D008DE0  8FB2001C   LW S2, 28(SP)
9D008DE4  8FB10018   LW S1, 24(SP)
9D008DE8  8FB00014   LW S0, 20(SP)
9D008DEC  03E00008   JR RA
9D008DF0  27BD0030   ADDIU SP, SP, 48
449:                 
450:                 
---  /home/whatisthis/microchip/harmony/v2_04/framework/driver/usart/src/dynamic/drv_usart.c  -----------
1:                   /********************************************************************************
2:                     USART Driver Dynamic implementation.
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       drv_usart.c
9:                   
10:                    Summary:
11:                      Source code for the USART driver dynamic implementation.
12:                  
13:                    Description:
14:                      This file contains the source code for the dynamic implementation of the
15:                      USART driver.
16:                  *******************************************************************************/
17:                  
18:                  //DOM-IGNORE-BEGIN
19:                  /*******************************************************************************
20:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
21:                  
22:                  Microchip licenses to you the right to use, modify, copy and distribute Software
23:                  only when embedded on a Microchip microcontroller or digital  signal  controller
24:                  that is integrated into your product or third party  product  (pursuant  to  the
25:                  sublicense terms in the accompanying license agreement).
26:                  
27:                  You should refer to the license agreement accompanying this Software for
28:                  additional information regarding your rights and obligations.
29:                  
30:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS  WITHOUT  WARRANTY  OF  ANY  KIND,
31:                  EITHER EXPRESS  OR  IMPLIED,  INCLUDING  WITHOUT  LIMITATION,  ANY  WARRANTY  OF
32:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A  PARTICULAR  PURPOSE.
33:                  IN NO EVENT SHALL MICROCHIP OR  ITS  LICENSORS  BE  LIABLE  OR  OBLIGATED  UNDER
34:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION,  BREACH  OF  WARRANTY,  OR
35:                  OTHER LEGAL  EQUITABLE  THEORY  ANY  DIRECT  OR  INDIRECT  DAMAGES  OR  EXPENSES
36:                  INCLUDING BUT NOT LIMITED TO ANY  INCIDENTAL,  SPECIAL,  INDIRECT,  PUNITIVE  OR
37:                  CONSEQUENTIAL DAMAGES, LOST  PROFITS  OR  LOST  DATA,  COST  OF  PROCUREMENT  OF
38:                  SUBSTITUTE  GOODS,  TECHNOLOGY,  SERVICES,  OR  ANY  CLAIMS  BY  THIRD   PARTIES
39:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE  THEREOF),  OR  OTHER  SIMILAR  COSTS.
40:                  *******************************************************************************/
41:                  //DOM-IGNORE-END
42:                  
43:                  // *****************************************************************************
44:                  // *****************************************************************************
45:                  // Section: Included Files
46:                  // *****************************************************************************
47:                  // *****************************************************************************
48:                  #include "../drv_usart_local.h"
49:                  
50:                  
51:                  
52:                  // *****************************************************************************
53:                  // *****************************************************************************
54:                  // Section: Global Data
55:                  // *****************************************************************************
56:                  // *****************************************************************************
57:                  
58:                  /* This is the driver instance object array. */
59:                  DRV_USART_OBJ gDrvUSARTObj[DRV_USART_INSTANCES_NUMBER] ;
60:                  
61:                  /* This is the client object array. */
62:                  DRV_USART_CLIENT_OBJ gDrvUSARTClientObj[DRV_USART_CLIENTS_NUMBER];
63:                  
64:                  /* This object maintains data that is required by all USART
65:                     driver instances. */
66:                  DRV_USART_COMMON_DATA_OBJ gDrvUSARTCommonDataObj;
67:                  
68:                  // *****************************************************************************
69:                  // *****************************************************************************
70:                  // Section: USART Driver Interface Implementations
71:                  // *****************************************************************************
72:                  // *****************************************************************************
73:                  
74:                  // *****************************************************************************
75:                  /* Function:
76:                      SYS_MODULE_OBJ DRV_USART_Initialize
77:                      (
78:                          const SYS_MODULE_INDEX drvIndex,
79:                          const SYS_MODULE_INIT * const init
80:                      )
81:                  
82:                    Summary:
83:                      Dynamic implementation of DRV_USART_Initialize system interface function.
84:                  
85:                    Description:
86:                      This is the dynamic implementation of DRV_USART_Initialize system interface
87:                      function.
88:                  
89:                    Remarks:
90:                      See drv_usart.h for usage information.
91:                  */
92:                  
93:                  SYS_MODULE_OBJ DRV_USART_Initialize
94:                  (
95:                      const SYS_MODULE_INDEX drvIndex,
96:                      const SYS_MODULE_INIT * const init
97:                  )
98:                  {
9D009FC8  27BDFFE0   ADDIU SP, SP, -32
9D009FCC  AFBF001C   SW RA, 28(SP)
9D009FD0  AFB20018   SW S2, 24(SP)
9D009FD4  AFB10014   SW S1, 20(SP)
9D009FD8  AFB00010   SW S0, 16(SP)
9D009FDC  00A08021   ADDU S0, A1, ZERO
99:                      DRV_USART_OBJ *dObj = (DRV_USART_OBJ*)NULL;
100:                     DRV_USART_INIT *usartInit = NULL ;
101:                 
102:                     /* Check if the specified driver index is in valid range */
103:                     if(drvIndex >= DRV_USART_INSTANCES_NUMBER)
9D009FB0  14800075   BNE A0, ZERO, 0x9D00A188
9D009FB4  2403FFFF   ADDIU V1, ZERO, -1
104:                     {
105:                         SYS_DEBUG(0, "Invalid driver index");
106:                         return SYS_MODULE_OBJ_INVALID;
107:                     }
108:                 
109:                     /* Check if this hardware instance was already initialized */
110:                     if(gDrvUSARTObj[drvIndex].inUse != false)
9D009FB8  3C02A000   LUI V0, -24576
9D009FBC  90420C50   LBU V0, 3152(V0)
9D009FC0  14400071   BNE V0, ZERO, 0x9D00A188
9D009FC4  00000000   NOP
111:                     {
112:                         SYS_DEBUG(0, "Instance already in use");
113:                         return SYS_MODULE_OBJ_INVALID;
114:                     }
115:                 
116:                     /* Assign to the local pointer the init data passed */
117:                     usartInit = ( DRV_USART_INIT * ) init ;
118:                 
119:                     /* Disable the USART module */
120:                     PLIB_USART_Disable (usartInit->usartID) ;
121:                 
122:                     /* Allocate the driver object and set the operation flag to be in use */
123:                     dObj = &gDrvUSARTObj[drvIndex];
124:                     dObj->inUse = true;
9D009FEC  3C02A000   LUI V0, -24576
9D009FF0  24510C3C   ADDIU S1, V0, 3132
9D009FF4  24030001   ADDIU V1, ZERO, 1
9D009FF8  A2230014   SB V1, 20(S1)
125:                 
126:                     /* Update the USART PLIB Id and other parameters. */
127:                 
128:                     dObj->nClients              = 0;
9D009FFC  AE200018   SW ZERO, 24(S1)
129:                     dObj->moduleId              = usartInit->usartID;
9D00A000  8CA30004   LW V1, 4(A1)
9D00A004  AC430C3C   SW V1, 3132(V0)
130:                     dObj->brgClock              = usartInit->brgClock;
9D00A008  8CA20014   LW V0, 20(A1)
9D00A00C  AE22001C   SW V0, 28(S1)
131:                     dObj->isExclusive           = false;
9D00A010  A2200015   SB ZERO, 21(S1)
132:                     dObj->queueSizeRead         = usartInit->queueSizeReceive;
9D00A014  8CA20030   LW V0, 48(A1)
9D00A018  AE220034   SW V0, 52(S1)
133:                     dObj->queueSizeWrite        = usartInit->queueSizeTransmit;
9D00A01C  8CA20034   LW V0, 52(A1)
9D00A020  AE220038   SW V0, 56(S1)
134:                     dObj->dmaChannelRead        = usartInit->dmaChannelReceive;
9D00A024  8CA2003C   LW V0, 60(A1)
9D00A028  AE220044   SW V0, 68(S1)
135:                     dObj->dmaChannelWrite       = usartInit->dmaChannelTransmit;
9D00A02C  8CA20038   LW V0, 56(A1)
9D00A030  AE220048   SW V0, 72(S1)
136:                     dObj->txInterruptSource     = usartInit->interruptTransmit;
9D00A034  8CA20024   LW V0, 36(A1)
9D00A038  AE220024   SW V0, 36(S1)
137:                     dObj->rxInterruptSource     = usartInit->interruptReceive;
9D00A03C  8CA20028   LW V0, 40(A1)
9D00A040  AE220028   SW V0, 40(S1)
138:                     dObj->errorInterruptSource  = usartInit->interruptError;
9D00A044  8CA2002C   LW V0, 44(A1)
9D00A048  AE22002C   SW V0, 44(S1)
139:                     dObj->dmaInterruptTransmit  = usartInit->dmaInterruptTransmit;
9D00A04C  8CA20040   LW V0, 64(A1)
9D00A050  AE22004C   SW V0, 76(S1)
140:                     dObj->dmaInterruptReceive   = usartInit->dmaInterruptReceive;
9D00A054  8CA20044   LW V0, 68(A1)
9D00A058  AE220050   SW V0, 80(S1)
141:                     dObj->interruptNestingCount = 0;
9D00A05C  AE200020   SW ZERO, 32(S1)
142:                     dObj->queueSizeCurrentRead  = 0;
9D00A060  AE20003C   SW ZERO, 60(S1)
143:                     dObj->queueSizeCurrentWrite = 0;
9D00A064  AE200040   SW ZERO, 64(S1)
144:                     dObj->queueRead             = NULL;
9D00A068  AE200008   SW ZERO, 8(S1)
145:                     dObj->queueWrite            = NULL;
9D00A06C  AE200004   SW ZERO, 4(S1)
146:                     dObj->transmitCallback      = NULL;
9D00A070  AE200054   SW ZERO, 84(S1)
147:                     dObj->receiveCallback       = NULL;
9D00A074  AE200058   SW ZERO, 88(S1)
148:                     dObj->errorCallback         = NULL;
9D00A078  AE20005C   SW ZERO, 92(S1)
149:                     dObj->operationMode         = usartInit->mode;
9D00A07C  8CA20008   LW V0, 8(A1)
9D00A080  AE220010   SW V0, 16(S1)
150:                 
151:                     /* Setup the Hardware */
152:                     _DRV_USART_HardwareSetup(usartInit->usartID, usartInit ) ;
9D00A084  0F402950   JAL _DRV_USART_HardwareSetup
9D00A088  8CA40004   LW A0, 4(A1)
153:                 
154:                     /* Clear the interrupts */
155:                     SYS_INT_SourceStatusClear(dObj->txInterruptSource);
9D00A08C  8E230024   LW V1, 36(S1)
156:                     SYS_INT_SourceStatusClear(dObj->rxInterruptSource);
9D00A0B0  8E230028   LW V1, 40(S1)
157:                     SYS_INT_SourceStatusClear(dObj->errorInterruptSource);
9D00A0C8  8E23002C   LW V1, 44(S1)
158:                 
159:                     /* Enable the interrupt source in case of interrupt mode */
160:                     _DRV_USART_InterruptSourceEnable(dObj->errorInterruptSource);
161:                 
162:                     _DRV_USART_ByteModelInterruptSourceEnable(dObj->rxInterruptSource);
163:                 
164:                     /* TODO: Enable DMA interrupts if the DMA channel is selected */
165:                 
166:                     /* Create the hardware instance mutex. */
167:                      if(OSAL_MUTEX_Create(&(dObj->mutexDriverInstance)) != OSAL_RESULT_TRUE)
9D00A0F0  3C04A000   LUI A0, -24576
9D00A0F4  0F4052B5   JAL OSAL_MUTEX_Create
9D00A0F8  24840C6C   ADDIU A0, A0, 3180
9D00A0FC  1452001B   BNE V0, S2, 0x9D00A16C
9D00A100  2403FFFF   ADDIU V1, ZERO, -1
168:                      {
169:                                  return SYS_MODULE_OBJ_INVALID;
170:                      }
171:                 
172:                     /* Check if the global mutexes have been created. If not
173:                        then create these. */
174:                 
175:                      if(!gDrvUSARTCommonDataObj.membersAreInitialized)
9D00A104  3C02A000   LUI V0, -24576
9D00A108  90420B90   LBU V0, 2960(V0)
9D00A10C  54400011   BNEL V0, ZERO, 0x9D00A154
9D00A110  8E020004   LW V0, 4(S0)
176:                      {
177:                          /* This means that mutexes where not created. Create them. */
178:                         if(OSAL_MUTEX_Create(&(gDrvUSARTCommonDataObj.mutexClientObjects)) != OSAL_RESULT_TRUE)
9D00A114  3C04A000   LUI A0, -24576
9D00A118  0F4052B5   JAL OSAL_MUTEX_Create
9D00A11C  24840B94   ADDIU A0, A0, 2964
9D00A120  24040001   ADDIU A0, ZERO, 1
9D00A124  14440011   BNE V0, A0, 0x9D00A16C
9D00A128  2403FFFF   ADDIU V1, ZERO, -1
179:                         {
180:                                  return SYS_MODULE_OBJ_INVALID;
181:                         }
182:                         if(OSAL_MUTEX_Create(&(gDrvUSARTCommonDataObj.mutexBufferQueueObjects)) != OSAL_RESULT_TRUE)
9D00A12C  3C04A000   LUI A0, -24576
9D00A130  0F4052B5   JAL OSAL_MUTEX_Create
9D00A134  24840B98   ADDIU A0, A0, 2968
9D00A138  24040001   ADDIU A0, ZERO, 1
9D00A13C  1444000B   BNE V0, A0, 0x9D00A16C
9D00A140  2403FFFF   ADDIU V1, ZERO, -1
183:                         {
184:                                  return SYS_MODULE_OBJ_INVALID;
185:                         }
186:                          /* Set this flag so that global mutexes get allocated only once */
187:                          gDrvUSARTCommonDataObj.membersAreInitialized = true;
9D00A144  24030001   ADDIU V1, ZERO, 1
9D00A148  3C02A000   LUI V0, -24576
9D00A14C  A0430B90   SB V1, 2960(V0)
188:                      }
189:                 
190:                     /* Enable the USART module */
191:                     PLIB_USART_Enable(usartInit->usartID) ;
192:                 
193:                     /* Update the status */
194:                     dObj->status = SYS_STATUS_READY;
9D00A15C  24030002   ADDIU V1, ZERO, 2
9D00A160  3C02A000   LUI V0, -24576
9D00A164  AC430C48   SW V1, 3144(V0)
195:                 
196:                     /* Return the object structure */
197:                     return ( (SYS_MODULE_OBJ)drvIndex );
9D00A168  00001821   ADDU V1, ZERO, ZERO
198:                 }
9D00A16C  00601021   ADDU V0, V1, ZERO
9D00A170  8FBF001C   LW RA, 28(SP)
9D00A174  8FB20018   LW S2, 24(SP)
9D00A178  8FB10014   LW S1, 20(SP)
9D00A17C  8FB00010   LW S0, 16(SP)
9D00A180  03E00008   JR RA
9D00A184  27BD0020   ADDIU SP, SP, 32
9D00A188  03E00008   JR RA
9D00A18C  00601021   ADDU V0, V1, ZERO
199:                 
200:                 // *****************************************************************************
201:                 /* Function:
202:                     void DRV_USART_Deinitialize( SYS_MODULE_OBJ object )
203:                 
204:                   Summary:
205:                     Dynamic implementation of DRV_USART_Deinitialize system interface function.
206:                 
207:                   Description:
208:                     This is the dynamic implementation of DRV_USART_Deinitialize system interface
209:                     function.
210:                 
211:                   Remarks:
212:                     See drv_usart.h for usage information.
213:                 */
214:                 
215:                 void  DRV_USART_Deinitialize(SYS_MODULE_OBJ object)
216:                 {
217:                     DRV_USART_OBJ * dObj;
218:                     DRV_USART_BUFFER_OBJ * iterator;
219:                 
220:                     bool status;
221:                 
222:                     /* Check that the object is valid */
223:                 
224:                     if(object == SYS_MODULE_OBJ_INVALID)
225:                     {
226:                         SYS_DEBUG(0, "Invalid system object handle" );
227:                         return;
228:                     }
229:                 
230:                     if(object >= DRV_USART_INSTANCES_NUMBER)
231:                     {
232:                         SYS_DEBUG(0, "Invalid system object handle" );
233:                         return;
234:                     }
235:                 
236:                     dObj = (DRV_USART_OBJ*) &gDrvUSARTObj[object];
237:                 
238:                     if(!dObj->inUse)
239:                     {
240:                         SYS_DEBUG(0, "Invalid system object handle");
241:                         return;
242:                     }
243:                 
244:                     /* The driver will not have clients when it is
245:                        being deinitialized. So the order in which
246:                        we do the following steps is not that important */
247:                 
248:                     /* Indicate that this object is not is use */
249:                     dObj->inUse = false;
250:                 
251:                     /* Deinitialize the USART status */
252:                     dObj->status =  SYS_STATUS_UNINITIALIZED ;
253:                 
254:                     /* Disable the interrupt */
255:                     status = _DRV_USART_InterruptSourceDisable(dObj->txInterruptSource) ;
256:                     status = _DRV_USART_InterruptSourceDisable(dObj->rxInterruptSource) ;
257:                     status = _DRV_USART_InterruptSourceDisable(dObj->errorInterruptSource);
258:                 
259:                     /* Ignore the warning */
260:                     (void)status;
261:                 
262:                     /* Disable USART module */
263:                     PLIB_USART_Disable (dObj->moduleId);
264:                 
265:                     /* Deallocate all mutexes */
266:                     if(OSAL_MUTEX_Delete(&(dObj->mutexDriverInstance)) != OSAL_RESULT_TRUE)
267:                     {
268:                         SYS_DEBUG(0, "Mutex Delete Failed");
269:                         return;
270:                     }
271:                 
272:                     /* TODO: Disable all DMA interrupts */
273:                 
274:                     /* Remove all objects from the read and write queue */
275:                 
276:                     iterator = dObj->queueWrite;
277:                     while(iterator != NULL)
278:                     {
279:                         /* Return the buffer object to the pool */
280:                         iterator->inUse = false;
281:                         iterator = iterator->next;
282:                     }
283:                 
284:                     iterator = dObj->queueRead;
285:                     while(iterator != NULL)
286:                     {
287:                         /* Return the buffer object to the pool */
288:                         iterator->inUse = false;
289:                         iterator = iterator->next;
290:                     }
291:                 }
292:                 
293:                 // *****************************************************************************
294:                 /* Function:
295:                     SYS_STATUS DRV_USART_Status( SYS_MODULE_OBJ object )
296:                 
297:                   Summary:
298:                     Dynamic implementation of DRV_USART_Status system interface function.
299:                 
300:                   Description:
301:                     This is the dynamic implementation of DRV_USART_Status system interface
302:                     function.
303:                 
304:                   Remarks:
305:                     See drv_usart.h for usage information.
306:                 */
307:                 
308:                 SYS_STATUS DRV_USART_Status( SYS_MODULE_OBJ object)
309:                 {
310:                     /* Check if we have a valid object */
311:                     if(object == SYS_MODULE_OBJ_INVALID)
312:                     {
313:                         SYS_DEBUG(0, "Invalid system object handle");
314:                         return(SYS_STATUS_UNINITIALIZED);
315:                     }
316:                 
317:                     if(object > DRV_USART_INSTANCES_NUMBER)
318:                     {
319:                         SYS_DEBUG(0, "Invalid system object handle");
320:                         return(SYS_STATUS_UNINITIALIZED);
321:                     }
322:                 
323:                     /* Return the system status of the hardware instance object */
324:                     return (gDrvUSARTObj[object].status);
325:                 }
326:                 
327:                 // *****************************************************************************
328:                 /* Function:
329:                     DRV_HANDLE DRV_USART_Open( const SYS_MODULE_INDEX index,
330:                                                const DRV_IO_INTENT    ioIntent )
331:                 
332:                   Summary:
333:                     Dynamic implementation of DRV_USART_Open client interface function.
334:                 
335:                   Description:
336:                     This is the dynamic implementation of DRV_USART_Open client interface
337:                     function.
338:                 
339:                   Remarks:
340:                     See drv_usart.h for usage information.
341:                 */
342:                 
343:                 DRV_HANDLE DRV_USART_Open
344:                 (
345:                     const SYS_MODULE_INDEX drvIndex,
346:                     const DRV_IO_INTENT ioIntent
347:                 )
348:                 {
9D00C3F0  27BDFFE0   ADDIU SP, SP, -32
9D00C3F4  AFBF001C   SW RA, 28(SP)
9D00C3F8  AFB10018   SW S1, 24(SP)
9D00C3FC  AFB00014   SW S0, 20(SP)
349:                     DRV_USART_CLIENT_OBJ *clientObj;
350:                     DRV_USART_OBJ *dObj;
351:                     unsigned int iClient;
352:                 
353:                     if (drvIndex >= DRV_USART_INSTANCES_NUMBER)
9D00C3B4  14800062   BNE A0, ZERO, 0x9D00C540
9D00C3B8  2403FFFF   ADDIU V1, ZERO, -1
354:                     {
355:                         /* Invalid driver index */
356:                         SYS_DEBUG(0, "Invalid Driver Instance");
357:                         return (DRV_HANDLE_INVALID);
358:                     }
359:                 
360:                     dObj = &gDrvUSARTObj[drvIndex];
361:                 
362:                     if((dObj->status != SYS_STATUS_READY) || (dObj->inUse == false))
9D00C3BC  3C02A000   LUI V0, -24576
9D00C3C0  8C440C48   LW A0, 3144(V0)
9D00C3C4  24020002   ADDIU V0, ZERO, 2
9D00C3C8  1482005D   BNE A0, V0, 0x9D00C540
9D00C3CC  00000000   NOP
9D00C3D0  3C02A000   LUI V0, -24576
9D00C3D4  90420C50   LBU V0, 3152(V0)
9D00C3D8  10400059   BEQ V0, ZERO, 0x9D00C540
9D00C3DC  00000000   NOP
363:                     {
364:                         /* The USART module should be ready */
365:                 
366:                         SYS_DEBUG(0, "Was the driver initialized?");
367:                         return DRV_HANDLE_INVALID;
368:                     }
369:                 
370:                     if(dObj->isExclusive)
9D00C3E0  3C02A000   LUI V0, -24576
9D00C3E4  90420C51   LBU V0, 3153(V0)
9D00C3E8  14400055   BNE V0, ZERO, 0x9D00C540
9D00C3EC  00000000   NOP
371:                     {
372:                         /* This means the another client has opened the driver in exclusive
373:                            mode. The driver cannot be opened again */
374:                 
375:                         SYS_DEBUG(0, "Driver already opened exclusively");
376:                         return ( DRV_HANDLE_INVALID ) ;
377:                     }
378:                 
379:                     if((dObj->nClients > 0) && (ioIntent & DRV_IO_INTENT_EXCLUSIVE))
9D00C400  3C02A000   LUI V0, -24576
9D00C404  8C420C54   LW V0, 3156(V0)
9D00C408  10400004   BEQ V0, ZERO, 0x9D00C41C
9D00C40C  00A08021   ADDU S0, A1, ZERO
9D00C410  30A20008   ANDI V0, A1, 8
9D00C414  14400045   BNE V0, ZERO, 0x9D00C52C
9D00C418  00601021   ADDU V0, V1, ZERO
380:                     {
381:                         /* This means the driver was already opened and another driver was
382:                            trying to open it exclusively.  We cannot give exclusive access in
383:                            this case */
384:                 
385:                         SYS_DEBUG(0, "Driver already opened. Cannot be opened exclusively");
386:                         return(DRV_HANDLE_INVALID);
387:                     }
388:                 
389:                     /* Grab client object mutex here */
390:                 
391:                     if(OSAL_MUTEX_Lock(&(gDrvUSARTCommonDataObj.mutexClientObjects), OSAL_WAIT_FOREVER) == OSAL_RESULT_TRUE)
9D00C41C  3C04A000   LUI A0, -24576
9D00C420  24840B94   ADDIU A0, A0, 2964
9D00C424  0F405267   JAL OSAL_MUTEX_Lock
9D00C428  3405FFFF   ORI A1, ZERO, -1
9D00C42C  24040001   ADDIU A0, ZERO, 1
9D00C430  1444003D   BNE V0, A0, 0x9D00C528
9D00C434  2403FFFF   ADDIU V1, ZERO, -1
392:                     {
393:                         /* Enter here only if the lock was obtained (applicable in
394:                            RTOS only). If the mutex lock fails due to time out then
395:                            this code does not get executed */
396:                 
397:                         for(iClient = 0; iClient != DRV_USART_CLIENTS_NUMBER; iClient ++)
398:                         {
399:                             if(!gDrvUSARTClientObj[iClient].inUse)
9D00C438  3C02A000   LUI V0, -24576
9D00C43C  90420BA4   LBU V0, 2980(V0)
9D00C440  10400006   BEQ V0, ZERO, 0x9D00C45C
9D00C444  3C02A000   LUI V0, -24576
9D00C448  90420BF4   LBU V0, 3060(V0)
9D00C44C  54400033   BNEL V0, ZERO, 0x9D00C51C
9D00C450  3C04A000   LUI A0, -24576
9D00C454  0B403118   J 0x9D00C460
9D00C458  24020001   ADDIU V0, ZERO, 1
9D00C45C  00001021   ADDU V0, ZERO, ZERO
400:                             {
401:                                 /* This means we have a free client object to use */
402:                                 clientObj = &gDrvUSARTClientObj[iClient];
9D00C460  3C03A000   LUI V1, -24576
9D00C464  24710B9C   ADDIU S1, V1, 2972
9D00C468  24030050   ADDIU V1, ZERO, 80
9D00C46C  70432002   MUL A0, V0, V1
9D00C470  00918821   ADDU S1, A0, S1
403:                                 clientObj->inUse        = true;
9D00C474  24020001   ADDIU V0, ZERO, 1
9D00C478  A2220008   SB V0, 8(S1)
404:                 
405:                                 /* We have found a client object. Release the mutex */
406:                 
407:                                 OSAL_MUTEX_Unlock(&(gDrvUSARTCommonDataObj.mutexClientObjects));
9D00C47C  3C04A000   LUI A0, -24576
9D00C480  0F40541A   JAL OSAL_MUTEX_Unlock
9D00C484  24840B94   ADDIU A0, A0, 2964
408:                 
409:                                 clientObj->hDriver      = dObj;
9D00C488  3C02A000   LUI V0, -24576
9D00C48C  24420C3C   ADDIU V0, V0, 3132
9D00C490  AE220000   SW V0, 0(S1)
410:                 
411:                                 /* In a case where the driver is configured for polled
412:                                    and bare metal operation, it will not support blocking operation */
413:                 
414:                                 clientObj->ioIntent     = (ioIntent | _DRV_USART_ALWAYS_NON_BLOCKING);
9D00C494  AE300004   SW S0, 4(S1)
415:                                 clientObj->eventHandler = NULL;
9D00C498  AE200038   SW ZERO, 56(S1)
416:                                 clientObj->context      = (uintptr_t)NULL;
9D00C49C  AE200044   SW ZERO, 68(S1)
417:                                 clientObj->error        = DRV_USART_ERROR_NONE;
418:                 
419:                                 if(ioIntent & DRV_IO_INTENT_EXCLUSIVE)
9D00C4A0  32100008   ANDI S0, S0, 8
9D00C4A4  12000004   BEQ S0, ZERO, 0x9D00C4B8
9D00C4A8  AE20003C   SW ZERO, 60(S1)
420:                                 {
421:                                     /* Set the driver exclusive flag */
422:                                     dObj->isExclusive = true;
9D00C4AC  24030001   ADDIU V1, ZERO, 1
9D00C4B0  3C02A000   LUI V0, -24576
9D00C4B4  A0430C51   SB V1, 3153(V0)
423:                                 }
424:                 
425:                                 dObj->nClients ++;
9D00C4B8  3C02A000   LUI V0, -24576
9D00C4BC  24420C3C   ADDIU V0, V0, 3132
9D00C4C0  8C430018   LW V1, 24(V0)
9D00C4C4  24630001   ADDIU V1, V1, 1
9D00C4C8  AC430018   SW V1, 24(V0)
426:                 
427:                                 /* Create the semaphores */
428:                                 if(OSAL_SEM_Create(&(clientObj->semReadDone), OSAL_SEM_TYPE_COUNTING, 1, 0) != OSAL_RESULT_TRUE)
9D00C4CC  26240048   ADDIU A0, S1, 72
9D00C4D0  24050001   ADDIU A1, ZERO, 1
9D00C4D4  24060001   ADDIU A2, ZERO, 1
9D00C4D8  0F4049CB   JAL OSAL_SEM_Create
9D00C4DC  00003821   ADDU A3, ZERO, ZERO
9D00C4E0  24040001   ADDIU A0, ZERO, 1
9D00C4E4  14440010   BNE V0, A0, 0x9D00C528
9D00C4E8  2403FFFF   ADDIU V1, ZERO, -1
429:                                 {
430:                                         SYS_DEBUG(0, "Semaphore creation failed");
431:                                         return(DRV_HANDLE_INVALID);
432:                                 }
433:                                 if(OSAL_SEM_Create(&(clientObj->semWriteDone), OSAL_SEM_TYPE_COUNTING, 1, 0) != OSAL_RESULT_TRUE)
9D00C4EC  2624004C   ADDIU A0, S1, 76
9D00C4F0  24050001   ADDIU A1, ZERO, 1
9D00C4F4  24060001   ADDIU A2, ZERO, 1
9D00C4F8  0F4049CB   JAL OSAL_SEM_Create
9D00C4FC  00003821   ADDU A3, ZERO, ZERO
9D00C500  24040001   ADDIU A0, ZERO, 1
9D00C504  14440008   BNE V0, A0, 0x9D00C528
9D00C508  2403FFFF   ADDIU V1, ZERO, -1
434:                                 {
435:                                         SYS_DEBUG(0, "Semaphore creation failed");
436:                                         return(DRV_HANDLE_INVALID);
437:                                 }
438:                                 /* Update the client status */
439:                                 clientObj->status = DRV_USART_CLIENT_STATUS_READY;
9D00C50C  24020002   ADDIU V0, ZERO, 2
9D00C510  AE220040   SW V0, 64(S1)
440:                                 return ((DRV_HANDLE) clientObj );
9D00C514  0B40314A   J 0x9D00C528
9D00C518  02201821   ADDU V1, S1, ZERO
441:                             }
442:                         }
443:                 
444:                         /* Could not find a client object. Release the mutex and
445:                            return with an invalid handle. */
446:                         OSAL_MUTEX_Unlock(&(gDrvUSARTCommonDataObj.mutexClientObjects));
9D00C51C  0F40541A   JAL OSAL_MUTEX_Unlock
9D00C520  24840B94   ADDIU A0, A0, 2964
447:                     }
448:                 
449:                     /* If we have reached here, it means either we could not find a spare
450:                        client object or the mutex timed out in a RTOS environment. */
451:                 
452:                     return DRV_HANDLE_INVALID;
9D00C524  2403FFFF   ADDIU V1, ZERO, -1
453:                 }
9D00C528  00601021   ADDU V0, V1, ZERO
9D00C52C  8FBF001C   LW RA, 28(SP)
9D00C530  8FB10018   LW S1, 24(SP)
9D00C534  8FB00014   LW S0, 20(SP)
9D00C538  03E00008   JR RA
9D00C53C  27BD0020   ADDIU SP, SP, 32
9D00C540  03E00008   JR RA
9D00C544  00601021   ADDU V0, V1, ZERO
454:                 
455:                 // *****************************************************************************
456:                 /* Function:
457:                     DRV_CLIENT_STATUS DRV_USART_Close ( DRV_HANDLE handle)
458:                 
459:                   Summary:
460:                     Dynamic implementation of DRV_USART_Close client interface function.
461:                 
462:                   Description:
463:                     This is the dynamic implementation of DRV_USART_Close client interface
464:                     function.
465:                 
466:                   Remarks:
467:                     See drv_usart.h for usage information.
468:                 */
469:                 
470:                 void DRV_USART_Close ( DRV_HANDLE handle)
471:                 {
472:                     /* This function closes the client, The client
473:                        object is deallocated and returned to the
474:                        pool. */
475:                 
476:                     DRV_USART_CLIENT_OBJ * clientObj;
477:                     DRV_USART_OBJ * dObj;
478:                 
479:                     /* Validate the handle */
480:                     clientObj = _DRV_USART_DriverHandleValidate(handle);
481:                 
482:                     if(clientObj == NULL)
483:                     {
484:                         /* Driver handle is not valid */
485:                         SYS_DEBUG(0, "Invalid Driver Handle");
486:                         return;
487:                     }
488:                 
489:                     dObj = (DRV_USART_OBJ *)clientObj->hDriver;
490:                 
491:                     /* Remove all buffers that this client owns from the driver queue. This
492:                        function will map to _DRV_USART_ClientBufferQueueObjectsRemove() if the
493:                        driver was built for buffer queue support. Else this condition always
494:                        maps to true. */
495:                 
496:                     if(!_DRV_USART_CLIENT_BUFFER_QUEUE_OBJECTS_REMOVE(clientObj))
497:                     {
498:                         /* The function could fail if the mutex time out occurred */
499:                         SYS_DEBUG(0, "Could not remove client buffer objects");
500:                         clientObj->status = DRV_USART_CLIENT_STATUS_ERROR;
501:                         return;
502:                     }
503:                 
504:                     /* Deallocate all semaphores */
505:                     if(OSAL_SEM_Delete(&(clientObj->semWriteDone)) != OSAL_RESULT_TRUE)
506:                     {
507:                         SYS_DEBUG(0, "Unable to delete client write done semaphore");
508:                         clientObj->status = DRV_USART_CLIENT_STATUS_ERROR;
509:                         return;
510:                     }
511:                     if(OSAL_SEM_Delete(&(clientObj->semReadDone)) != OSAL_RESULT_TRUE)
512:                     {
513:                         SYS_DEBUG(0, "Unable to delete client read done semaphore");
514:                         clientObj->status = DRV_USART_CLIENT_STATUS_ERROR;
515:                         return;
516:                     }
517:                     /* Reduce the number of clients */
518:                     dObj->nClients --;
519:                 
520:                     /* Reset the exclusive flag */
521:                     dObj->isExclusive = false;
522:                 
523:                     /* De-allocate the object */
524:                     clientObj->status = DRV_USART_CLIENT_STATUS_CLOSED;
525:                     clientObj->inUse = false;
526:                 
527:                     return;
528:                 }
529:                 
530:                 // *****************************************************************************
531:                 /* Function:
532:                     void DRV_USART_ByteTransmitCallbackSet
533:                     (
534:                         const SYS_MODULE_INDEX index,
535:                         const DRV_USART_BYTE_EVENT_HANDLER eventHandler
536:                     )
537:                 
538:                   Summary:
539:                     Registers transmit callback function.
540:                 
541:                   Description:
542:                     This function is used to register the callback function to be invoked
543:                     upon transmission of a byte.
544:                 
545:                   Remarks:
546:                     See drv_usart.h for usage information.
547:                 */
548:                 
549:                 void DRV_USART_ByteTransmitCallbackSet
550:                 (
551:                     const SYS_MODULE_INDEX index,
552:                     const DRV_USART_BYTE_EVENT_HANDLER eventHandler
553:                 )
554:                 {
555:                     if (index >= DRV_USART_INSTANCES_NUMBER)
556:                     {
557:                         /* Invalid driver index */
558:                         SYS_DEBUG(0, "\r\nUSART Driver: Invalid Driver Instance");
559:                     }
560:                     else
561:                     {
562:                         gDrvUSARTObj[index].transmitCallback = eventHandler;
563:                     }
564:                 }
565:                 
566:                 // *****************************************************************************
567:                 /* Function:
568:                     void DRV_USART_ByteReceiveCallbackSet
569:                     (
570:                         const SYS_MODULE_INDEX index,
571:                         const DRV_USART_BYTE_EVENT_HANDLER eventHandler
572:                     )
573:                 
574:                   Summary:
575:                     Registers receive callback function.
576:                 
577:                   Description:
578:                     This function is used to register the callback function to be invoked
579:                     upon reception of a byte.
580:                 
581:                   Remarks:
582:                     See drv_usart.h for usage information.
583:                 */
584:                 
585:                 void DRV_USART_ByteReceiveCallbackSet
586:                 (
587:                     const SYS_MODULE_INDEX index,
588:                     const DRV_USART_BYTE_EVENT_HANDLER eventHandler
589:                 )
590:                 {
591:                     if (index >= DRV_USART_INSTANCES_NUMBER)
592:                     {
593:                         /* Invalid driver index */
594:                         SYS_DEBUG(0, "\r\nUSART Driver: Invalid Driver Instance");
595:                     }
596:                     else
597:                     {
598:                         gDrvUSARTObj[index].receiveCallback = eventHandler;
599:                     }
600:                 }
601:                 
602:                 // *****************************************************************************
603:                 /* Function:
604:                     void DRV_USART_ByteErrorCallbackSet
605:                     (
606:                         const SYS_MODULE_INDEX index,
607:                         const DRV_USART_BYTE_EVENT_HANDLER eventHandler
608:                     )
609:                 
610:                   Summary:
611:                     Registers error notification callback function.
612:                 
613:                   Description:
614:                     This function is used to register the callback function to be invoked
615:                     to notify error on the tx or the rx path in byte model of operation.
616:                 
617:                   Remarks:
618:                     See drv_usart.h for usage information.
619:                 */
620:                 
621:                 void DRV_USART_ByteErrorCallbackSet
622:                 (
623:                     const SYS_MODULE_INDEX index,
624:                     const DRV_USART_BYTE_EVENT_HANDLER eventHandler
625:                 )
626:                 {
627:                     if (index >= DRV_USART_INSTANCES_NUMBER)
628:                     {
629:                         /* Invalid driver index */
630:                         SYS_DEBUG(0, "\r\nUSART Driver: Invalid Driver Instance");
631:                     }
632:                     else
633:                     {
634:                         gDrvUSARTObj[index].errorCallback = eventHandler;
635:                     }
636:                 }
637:                 
638:                 
639:                 // *****************************************************************************
640:                 /* Function:
641:                     DRV_USART_ERROR DRV_USART_ErrorGet( DRV_HANDLE hClient )
642:                 
643:                   Summary:
644:                     Dynamic implementation of DRV_USART_ErrorGet client interface function.
645:                 
646:                   Description:
647:                     This is the dynamic implementation of DRV_USART_ErrorGet client interface
648:                     function.
649:                 
650:                   Remarks:
651:                     See drv_usart.h for usage information.
652:                 */
653:                 
654:                 DRV_USART_ERROR DRV_USART_ErrorGet(DRV_HANDLE hClient)
655:                 {
656:                     DRV_USART_CLIENT_OBJ * clientObj;
657:                     DRV_USART_ERROR error;
658:                 
659:                     /* Validate the handle */
660:                     clientObj = _DRV_USART_DriverHandleValidate(hClient);
661:                 
662:                     if(clientObj == NULL)
663:                     {
664:                         /* Driver handle is not valid. Return error */
665:                         SYS_DEBUG(0, "Invalid client handle");
666:                         return DRV_USART_BAUD_SET_ERROR;
667:                     }
668:                 
669:                     /* Return the error. Clear the error before
670:                        returning. */
671:                 
672:                     error = clientObj->error;
673:                     clientObj->error = DRV_USART_ERROR_NONE;
674:                     return(error);
675:                 }
676:                 
677:                 // *****************************************************************************
678:                 /* Function:
679:                     DRV_USART_BAUD_SET_RESULT DRV_USART_BaudSet(DRV_HANDLE handle, uint32_t baud)
680:                 
681:                   Summary:
682:                     Dynamic implementation of DRV_USART_BaudSet client interface function.
683:                 
684:                   Description:
685:                     This is the dynamic implementation of DRV_USART_BaudSet client interface
686:                     function.
687:                 
688:                   Remarks:
689:                     See drv_usart.h for usage information.
690:                 */
691:                 
692:                 DRV_USART_BAUD_SET_RESULT DRV_USART_BaudSet(DRV_HANDLE handle, uint32_t baud)
693:                 {
694:                     DRV_USART_OBJ * hDriver;
695:                     DRV_USART_CLIENT_OBJ * client;
696:                     USART_MODULE_ID plibID;
697:                     DRV_USART_BAUD_SET_RESULT retVal = DRV_USART_BAUD_SET_SUCCESS;
698:                 #if defined (PLIB_USART_ExistsModuleBusyStatus)
699:                     bool isEnabled = false;
700:                 #endif
701:                 
702:                     /* Validate the handle */
703:                     client = _DRV_USART_DriverHandleValidate(handle);
704:                 
705:                     if(client == NULL)
706:                     {
707:                         /* Driver handle is not valid. Return error */
708:                         SYS_DEBUG(0, "Invalid client handle");
709:                         return DRV_USART_BAUD_SET_ERROR;
710:                     }
711:                 
712:                     hDriver = (DRV_USART_OBJ*)client->hDriver;
713:                     plibID = hDriver->moduleId;
714:                 
715:                     if(OSAL_MUTEX_Lock(&(hDriver->mutexDriverInstance), OSAL_WAIT_FOREVER) == OSAL_RESULT_TRUE)
716:                     {
717:                         int32_t brgValueLow=0;
718:                         int32_t brgValueHigh=0;
719:                 
720:                         brgValueLow  = ( (hDriver->brgClock/baud) >> 4 ) - 1;
721:                         brgValueHigh = ( (hDriver->brgClock/baud) >> 2 ) - 1;
722:                 
723:                 #if defined (PLIB_USART_ExistsModuleBusyStatus)
724:                         isEnabled = PLIB_USART_ModuleIsBusy (plibID);
725:                         if (isEnabled)
726:                         {
727:                             PLIB_USART_Disable (plibID);
728:                             while (PLIB_USART_ModuleIsBusy (plibID));
729:                         }
730:                 #endif
731:                         /* Check if the baud value can be set with high baud settings */
732:                         if ((brgValueHigh >= 0) && (brgValueHigh <= UINT16_MAX))
733:                         {
734:                             PLIB_USART_BaudRateHighEnable(plibID);
735:                             PLIB_USART_BaudRateHighSet(plibID, hDriver->brgClock, baud);
736:                         }
737:                         /* Check if the baud value can be set with low baud settings */
738:                         else if ((brgValueLow >= 0) && (brgValueLow <= UINT16_MAX))
739:                         {
740:                             PLIB_USART_BaudRateHighDisable(plibID);
741:                             PLIB_USART_BaudRateSet(plibID, hDriver->brgClock, baud);
742:                         }
743:                         else
744:                         {
745:                             retVal = DRV_USART_BAUD_SET_ERROR;
746:                         }
747:                 
748:                 #if defined (PLIB_USART_ExistsModuleBusyStatus)
749:                         if (isEnabled)
750:                         {
751:                             PLIB_USART_Enable (plibID);
752:                         }
753:                 #endif
754:                         OSAL_MUTEX_Unlock(&(hDriver->mutexDriverInstance));
755:                     }
756:                     else
757:                     {
758:                         /* The mutex timed out */
759:                         SYS_DEBUG(0, "Hardware instance mutex time out in DRV_USART_BaudSet() function");
760:                         retVal = DRV_USART_BAUD_SET_ERROR;
761:                     }
762:                 
763:                     return retVal;
764:                 }
765:                 
766:                 // *****************************************************************************
767:                 /* Function:
768:                     DRV_USART_LINE_CONTROL_SET_RESULT DRV_USART_LineControlSet
769:                     (
770:                         DRV_HANDLE handle,
771:                         DRV_USART_LINE_CONTROL lineControlMode
772:                     )
773:                 
774:                   Summary:
775:                     Dynamic implementation of DRV_USART_LineControlSet client interface function.
776:                 
777:                   Description:
778:                     This is the dynamic implementation of DRV_USART_LineControlSet client
779:                     interface function.
780:                 
781:                   Remarks:
782:                     See drv_usart.h for usage information.
783:                 */
784:                 
785:                 DRV_USART_LINE_CONTROL_SET_RESULT DRV_USART_LineControlSet
786:                 (
787:                     DRV_HANDLE handle,
788:                     DRV_USART_LINE_CONTROL lineControlMode
789:                 )
790:                 {
791:                     DRV_USART_OBJ * hDriver;
792:                     DRV_USART_CLIENT_OBJ * client;
793:                     USART_MODULE_ID plibID;
794:                 #if defined (PLIB_USART_ExistsModuleBusyStatus)
795:                     bool isEnabled = false;
796:                 #endif
797:                 
798:                     /* Validate the driver handle */
799:                     client = _DRV_USART_DriverHandleValidate(handle);
800:                 
801:                     if(client == NULL)
802:                     {
803:                         /* Driver handle is not valid. Return error */
804:                 
805:                         SYS_DEBUG(0, "Invalid driver handle");
806:                         return DRV_USART_LINE_CONTROL_SET_ERROR;
807:                     }
808:                 
809:                     hDriver = (DRV_USART_OBJ*)client->hDriver;
810:                     plibID = hDriver->moduleId;
811:                 
812:                     if(OSAL_MUTEX_Lock(&(hDriver->mutexDriverInstance), OSAL_WAIT_FOREVER) == OSAL_RESULT_TRUE)
813:                     {
814:                 #if defined (PLIB_USART_ExistsModuleBusyStatus)
815:                         isEnabled = PLIB_USART_ModuleIsBusy (plibID);
816:                         if (isEnabled)
817:                         {
818:                             PLIB_USART_Disable (plibID);
819:                             while (PLIB_USART_ModuleIsBusy (plibID));
820:                         }
821:                 #endif
822:                         /* Set the Line Control Mode */
823:                         PLIB_USART_LineControlModeSelect(plibID, lineControlMode);
824:                 #if defined (PLIB_USART_ExistsModuleBusyStatus)
825:                         if (isEnabled)
826:                         {
827:                             PLIB_USART_Enable (plibID);
828:                         }
829:                 #endif
830:                         OSAL_MUTEX_Unlock(&(hDriver->mutexDriverInstance));
831:                     }
832:                     else
833:                     {
834:                         SYS_DEBUG(0, "Hardware Instance Mutex time out in DRV_USART_LineControlSet() function");
835:                         return DRV_USART_LINE_CONTROL_SET_ERROR;
836:                     }
837:                 
838:                     /* Return success */
839:                     return(DRV_USART_LINE_CONTROL_SET_SUCCESS);
840:                 }
841:                 
842:                 // *****************************************************************************
843:                 /* Function:
844:                     void DRV_USART_TasksTransmit (SYS_MODULE_OBJ object )
845:                 
846:                   Summary:
847:                     Dynamic implementation of DRV_USART_TasksTransmit system interface function.
848:                 
849:                   Description:
850:                     This is the dynamic implementation of DRV_USART_TasksTransmit system interface
851:                     function.
852:                 
853:                   Remarks:
854:                     See drv_usart.h for usage information.
855:                 */
856:                 
857:                 void DRV_USART_TasksTransmit(SYS_MODULE_OBJ object)
858:                 {
9D011BD4  27BDFFE8   ADDIU SP, SP, -24
9D011BD8  AFBF0014   SW RA, 20(SP)
9D011BDC  AFB00010   SW S0, 16(SP)
859:                     /* This is the USART Driver Transmit tasks routine.
860:                        In this function, the driver checks if a transmit
861:                        interrupt is active and if there are any buffers in
862:                        queue. If so the buffer is serviced. A buffer that
863:                        is serviced completely is removed from the queue.
864:                      */
865:                 
866:                     DRV_USART_OBJ * hDriver = &gDrvUSARTObj[object];
9D011BE0  00041140   SLL V0, A0, 5
9D011BE4  000481C0   SLL S0, A0, 7
9D011BE8  02021023   SUBU V0, S0, V0
9D011BEC  3C10A000   LUI S0, -24576
9D011BF0  26100C3C   ADDIU S0, S0, 3132
9D011BF4  02028021   ADDU S0, S0, V0
867:                 
868:                     if((!hDriver->inUse) || (hDriver->status != SYS_STATUS_READY))
9D011BF8  92020014   LBU V0, 20(S0)
9D011BFC  1040001A   BEQ V0, ZERO, 0x9D011C68
9D011C00  24020002   ADDIU V0, ZERO, 2
9D011C04  8E03000C   LW V1, 12(S0)
9D011C08  14620018   BNE V1, V0, 0x9D011C6C
9D011C0C  8FBF0014   LW RA, 20(SP)
869:                     {
870:                         /* This instance of the driver is not initialized. Don't
871:                          * do anything */
872:                         return;
873:                     }
874:                 
875:                     if(SYS_INT_SourceStatusGet(hDriver->txInterruptSource))
9D011C10  8E020024   LW V0, 36(S0)
9D011C34  5040000E   BEQL V0, ZERO, 0x9D011C70
9D011C38  8FB00010   LW S0, 16(SP)
876:                     {
877:                         /* The USART driver is configured to generate an
878:                            interrupt when the FIFO is empty. Additionally
879:                            the queue is not empty. Which means there is
880:                            work to done in this routine. */
881:                 
882:                         _DRV_USART_TRANSMIT_BUFFER_QUEUE_TASKS(object);
9D011C3C  0F40237D   JAL _DRV_USART_BufferQueueTxTasks
9D011C40  00000000   NOP
883:                 
884:                         /* Clear up the interrupt flag */
885:                         SYS_INT_SourceStatusClear(hDriver->txInterruptSource);
9D011C44  8E020024   LW V0, 36(S0)
886:                     }
887:                 }
9D011C68  8FBF0014   LW RA, 20(SP)
888:                 
889:                 
890:                 // *****************************************************************************
891:                 /* Function:
892:                     void DRV_USART_TasksError (SYS_MODULE_OBJ object );
893:                 
894:                   Summary:
895:                     Maintains the driver's error state machine and implements its ISR
896:                 
897:                   Description:
898:                     This routine is used to maintain the driver's internal error state machine
899:                     and implement its error ISR for interrupt-driven implementations.  In
900:                     polling mode, this function should be called from the SYS_Tasks function.
901:                     In interrupt mode, this function should be called in the error interrupt
902:                     service routine of the USART that is associated with this USART driver
903:                     hardware instance.
904:                 
905:                   Remarks:
906:                     Refer to drv_usart.h for usage information.
907:                 */
908:                 
909:                 void DRV_USART_TasksError(SYS_MODULE_OBJ object)
910:                 {
9D011C78  27BDFFE8   ADDIU SP, SP, -24
9D011C7C  AFBF0014   SW RA, 20(SP)
9D011C80  AFB00010   SW S0, 16(SP)
911:                     /* This is the USART Driver Error tasks routine. In this function, the
912:                      * driver checks if an error interrupt has occurred. If so the error
913:                      * condition is cleared.  */
914:                 
915:                     DRV_USART_OBJ * hDriver = &gDrvUSARTObj[object];
9D011C84  00041140   SLL V0, A0, 5
9D011C88  000481C0   SLL S0, A0, 7
9D011C8C  02021023   SUBU V0, S0, V0
9D011C90  3C10A000   LUI S0, -24576
9D011C94  26100C3C   ADDIU S0, S0, 3132
9D011C98  02028021   ADDU S0, S0, V0
916:                 
917:                     if((!hDriver->inUse) || (hDriver->status != SYS_STATUS_READY))
9D011C9C  92020014   LBU V0, 20(S0)
9D011CA0  1040001A   BEQ V0, ZERO, 0x9D011D0C
9D011CA4  24020002   ADDIU V0, ZERO, 2
9D011CA8  8E03000C   LW V1, 12(S0)
9D011CAC  14620018   BNE V1, V0, 0x9D011D10
9D011CB0  8FBF0014   LW RA, 20(SP)
918:                     {
919:                         /* This instance of the driver is not initialized. Don't
920:                          * do anything */
921:                         return;
922:                     }
923:                 
924:                     if(SYS_INT_SourceStatusGet(hDriver->errorInterruptSource))
9D011CB4  8E02002C   LW V0, 44(S0)
9D011CD8  5040000E   BEQL V0, ZERO, 0x9D011D14
9D011CDC  8FB00010   LW S0, 16(SP)
925:                     {
926:                         /* This means an error has occurred */
927:                         _DRV_USART_ERROR_TASKS(object);
9D011CE0  0F404214   JAL _DRV_USART_BufferQueueErrorTasks
9D011CE4  00000000   NOP
928:                 
929:                         /* Clear up the error interrupt flag */
930:                         SYS_INT_SourceStatusClear(hDriver->errorInterruptSource);
9D011CE8  8E02002C   LW V0, 44(S0)
931:                     }
932:                 }
9D011D0C  8FBF0014   LW RA, 20(SP)
9D011D10  8FB00010   LW S0, 16(SP)
9D011D14  03E00008   JR RA
9D011D18  27BD0018   ADDIU SP, SP, 24
933:                 
934:                 // *****************************************************************************
935:                 /* Function:
936:                     DRV_USART_CLIENT_STATUS DRV_USART_ClientStatus (DRV_HANDLE handle )
937:                 
938:                   Summary:
939:                     Dynamic implementation of DRV_USART_ClientStatus client interface function.
940:                 
941:                   Description:
942:                     This is the dynamic implementation of DRV_USART_ClientStatus client interface
943:                     function.
944:                 
945:                   Remarks:
946:                     See drv_usart.h for usage information.
947:                 */
948:                 
949:                 DRV_USART_CLIENT_STATUS DRV_USART_ClientStatus(DRV_HANDLE handle)
950:                 {
951:                     DRV_USART_CLIENT_OBJ * client;
952:                 
953:                     /* Validate the driver handle */
954:                     client = _DRV_USART_DriverHandleValidate(handle);
955:                 
956:                     if(client == NULL)
957:                     {
958:                         /* Driver handle is not valid */
959:                 
960:                         SYS_DEBUG(0, "Invalid driver handle");
961:                         return DRV_USART_CLIENT_STATUS_CLOSED;
962:                     }
963:                 
964:                     /* Return the client status */
965:                     return(client->status);
966:                 }
967:                 
968:                 // *****************************************************************************
969:                 /* Function:
970:                     void DRV_USART_TasksReceive (SYS_MODULE_OBJ object )
971:                 
972:                   Summary:
973:                     Dynamic implementation of DRV_USART_Initialize system interface function.
974:                 
975:                   Description:
976:                     This is the dynamic implementation of DRV_USART_Initialize system interface
977:                     function.
978:                 
979:                   Remarks:
980:                     See drv_usart.h for usage information.
981:                 */
982:                 
983:                 void DRV_USART_TasksReceive(SYS_MODULE_OBJ object)
984:                 {
9D011B30  27BDFFE8   ADDIU SP, SP, -24
9D011B34  AFBF0014   SW RA, 20(SP)
9D011B38  AFB00010   SW S0, 16(SP)
985:                     /* This is the USART Driver Receive tasks routine. If the receive
986:                        interrupt flag is set, the tasks routines are executed.
987:                      */
988:                 
989:                     DRV_USART_OBJ * hDriver = &gDrvUSARTObj[object];
9D011B3C  00041140   SLL V0, A0, 5
9D011B40  000481C0   SLL S0, A0, 7
9D011B44  02021023   SUBU V0, S0, V0
9D011B48  3C10A000   LUI S0, -24576
9D011B4C  26100C3C   ADDIU S0, S0, 3132
9D011B50  02028021   ADDU S0, S0, V0
990:                 
991:                     if((!hDriver->inUse) || (hDriver->status != SYS_STATUS_READY))
9D011B54  92020014   LBU V0, 20(S0)
9D011B58  1040001A   BEQ V0, ZERO, 0x9D011BC4
9D011B5C  24020002   ADDIU V0, ZERO, 2
9D011B60  8E03000C   LW V1, 12(S0)
9D011B64  14620018   BNE V1, V0, 0x9D011BC8
9D011B68  8FBF0014   LW RA, 20(SP)
992:                     {
993:                         /* This instance of the driver is not initialized. Dont
994:                            do anything */
995:                 
996:                         return;
997:                     }
998:                 
999:                     if(SYS_INT_SourceStatusGet(hDriver->rxInterruptSource))
9D011B6C  8E020028   LW V0, 40(S0)
9D011B90  5040000E   BEQL V0, ZERO, 0x9D011BCC
9D011B94  8FB00010   LW S0, 16(SP)
1000:                    {
1001:                        _DRV_USART_RECEIVE_BUFFER_QUEUE_TASKS(object);
9D011B98  0F4032D1   JAL _DRV_USART_BufferQueueRxTasks
9D011B9C  00000000   NOP
1002:                
1003:                        /* Clear up the interrupt flag */
1004:                        SYS_INT_SourceStatusClear(hDriver->rxInterruptSource);
9D011BA0  8E020028   LW V0, 40(S0)
1005:                    }
1006:                }
9D011BC4  8FBF0014   LW RA, 20(SP)
9D011BC8  8FB00010   LW S0, 16(SP)
9D011BCC  03E00008   JR RA
9D011BD0  27BD0018   ADDIU SP, SP, 24
1007:                
1008:                // *****************************************************************************
1009:                /* Function:
1010:                    DRV_USART_TRANSFER_STATUS DRV_USART_TransferStatus(const DRV_HANDLE handle)
1011:                
1012:                  Summary:
1013:                    Dynamic implementation of DRV_USART_TransferStatus client interface function.
1014:                
1015:                  Description:
1016:                    This is the dynamic implementation of DRV_USART_TransferStatus client
1017:                    interface function.
1018:                
1019:                  Remarks:
1020:                    See drv_usart.h for usage information.
1021:                */
1022:                
1023:                DRV_USART_TRANSFER_STATUS DRV_USART_TransferStatus(const DRV_HANDLE handle)
1024:                {
1025:                    DRV_USART_CLIENT_OBJ * client;
1026:                    DRV_USART_OBJ * hDriver;
1027:                    DRV_USART_TRANSFER_STATUS result = 0;
1028:                
1029:                    client = _DRV_USART_DriverHandleValidate(handle);
1030:                
1031:                    /* Validate the handle */
1032:                    if(client == NULL)
1033:                    {
1034:                        SYS_DEBUG(0, "Invalid Driver handle");
1035:                        return 0;
1036:                    }
1037:                
1038:                    hDriver = client->hDriver;
1039:                
1040:                    /* If the Rx interrupt flag is set then there is data available
1041:                       else there isn't */
1042:                    result |= (PLIB_USART_ReceiverDataIsAvailable(hDriver->moduleId)) ?
1043:                        DRV_USART_TRANSFER_STATUS_RECEIVER_DATA_PRESENT : DRV_USART_TRANSFER_STATUS_RECEIVER_EMPTY;
1044:                
1045:                    /* If the TX interrupt flag is set, then the Tx Buffer is empty */
1046:                    result |= (PLIB_USART_TransmitterIsEmpty(hDriver->moduleId)) ? DRV_USART_TRANSFER_STATUS_TRANSMIT_EMPTY : 0;
1047:                
1048:                    /* Check if the TX buffer is full */
1049:                    result |= (PLIB_USART_TransmitterBufferIsFull(hDriver->moduleId)) ? DRV_USART_TRANSFER_STATUS_TRANSMIT_FULL : 0;
1050:                
1051:                    return(result);
1052:                }
1053:                
1054:                // *****************************************************************************
1055:                // *****************************************************************************
1056:                // Section: File scope functions
1057:                // *****************************************************************************
1058:                // *****************************************************************************
1059:                
1060:                // *****************************************************************************
1061:                /* void _DRV_USART_HardwareSetup
1062:                   (
1063:                        USART_MODULE_ID  plibID,
1064:                        DRV_USART_INIT * init
1065:                   )
1066:                
1067:                  Summary:
1068:                    Initializes the USART module based on the init data structure.
1069:                
1070:                  Description:
1071:                    This function initializes the USART module based on the init data structure.
1072:                
1073:                  Remarks:
1074:                    This is a private function and should not be called directly by the
1075:                    application.
1076:                */
1077:                
1078:                void _DRV_USART_HardwareSetup(USART_MODULE_ID plibID, DRV_USART_INIT * init)
1079:                {
1080:                    bool loopbackMode   = false;
9D00A5B8  0B402973   J 0x9D00A5CC
9D00A5BC  00001021   ADDU V0, ZERO, ZERO
1081:                    bool irdaMode       = false;
9D00A5B4  00004021   ADDU T0, ZERO, ZERO
9D00A5C4  00004021   ADDU T0, ZERO, ZERO
1082:                    bool wakeFromSleep  = false;
1083:                    bool stopInIdle     = false;
1084:                    bool autoBaud       = false;
1085:                
1086:                    /* Default is to use UxTX and UxRX only */
1087:                    USART_OPERATION_MODE handshakeLines = USART_ENABLE_TX_RX_USED;
9D00A558  0002380B   MOVN A3, ZERO, V0
9D00A55C  2C480001   SLTIU T0, V0, 1
9D00A560  00001821   ADDU V1, ZERO, ZERO
9D00A564  0002180A   MOVZ V1, ZERO, V0
9D00A568  0B402973   J 0x9D00A5CC
9D00A56C  00601021   ADDU V0, V1, ZERO
9D00A5B0  00003821   ADDU A3, ZERO, ZERO
9D00A5C0  00003821   ADDU A3, ZERO, ZERO
1088:                
1089:                    /* Check the operational mode and update the relevant flags */
1090:                    switch(init->mode)
9D00A540  8CA20008   LW V0, 8(A1)
9D00A544  24030002   ADDIU V1, ZERO, 2
9D00A548  10430009   BEQ V0, V1, _DRV_USART_HardwareSetup::PLIB_USART_ReceiverAddressDetectEnable
9D00A54C  24030003   ADDIU V1, ZERO, 3
9D00A550  1043001B   BEQ V0, V1, 0x9D00A5C0
9D00A554  24070003   ADDIU A3, ZERO, 3
1091:                    {
1092:                        case DRV_USART_OPERATION_MODE_ADDRESSED:
1093:                        {
1094:                            PLIB_USART_ReceiverAddressDetectEnable(plibID);
1095:                            PLIB_USART_AddressSet(plibID, init->modeData.AddressedModeInit.address);
9D00A578  90A3000C   LBU V1, 12(A1)
1096:                #if defined (PLIB_USART_ExistsReceiverAddressAutoDetect)
1097:                            PLIB_USART_ReceiverAddressAutoDetectEnable(plibID, PLIB_USART_AddressGet(plibID));
1098:                #endif
1099:                        }
1100:                        break;
1101:                        case DRV_USART_OPERATION_MODE_IRDA:
1102:                            irdaMode = true;
1103:                            handshakeLines = USART_ENABLE_TX_RX_BCLK_USED;
1104:                            break;
1105:                        case DRV_USART_OPERATION_MODE_LOOPBACK:
1106:                            loopbackMode = true;
9D00A5C8  24020001   ADDIU V0, ZERO, 1
1107:                            break;
1108:                        default:
1109:                            break;
1110:                    }
1111:                
1112:                    /* Handshaking */
1113:                    if(init->handshake != DRV_USART_HANDSHAKE_NONE)
9D00A5CC  8CA30020   LW V1, 32(A1)
9D00A5D0  24060002   ADDIU A2, ZERO, 2
9D00A5D4  50660006   BEQL V1, A2, 0x9D00A5F0
9D00A5D8  8CA30010   LW V1, 16(A1)
1114:                    {
1115:                        /* Note that this mode is exclusive of DRV_USART_OPERATION_MODE_IRDA.
1116:                           In that if the driver must be set up to use DRV_USART_OPERATION_MODE_IRDA
1117:                           then handshake parameter of the init data structure must be
1118:                           DRV_USART_HANDSHAKE_NONE. Setting up the driver to use Simplex or
1119:                           flow control will over ride the requirements of the IRDA mode.*/
1120:                
1121:                        handshakeLines = USART_ENABLE_TX_RX_CTS_RTS_USED;
9D00A5E8  24070002   ADDIU A3, ZERO, 2
1122:                
1123:                        /* Set the handshake mode to either simplex or flow control */
1124:                
1125:                        PLIB_USART_HandshakeModeSelect(plibID, init->handshake);
1126:                    }
1127:                
1128:                
1129:                    /* Wake up the part from sleep on any activity on the RX Line */
1130:                    wakeFromSleep = (init->flags & DRV_USART_INIT_FLAG_WAKE_ON_START);
9D00A5EC  8CA30010   LW V1, 16(A1)
1131:                
1132:                    /* When the CPU enters IDLE mode, stop the USART */
1133:                    stopInIdle = (init->flags & DRV_USART_INIT_FLAG_STOP_IN_IDLE);
9D00A5F0  7C690080   EXT T1, V1, 2, 1
1134:                
1135:                    /* When the CPU enters IDLE mode, stop the USART */
1136:                    autoBaud = (init->flags & DRV_USART_INIT_FLAG_AUTO_BAUD);
9D00A5F4  7C6A0040   EXT T2, V1, 1, 1
1137:                
1138:                    /* Initialize the USART based on initialization data structure */
1139:                    PLIB_USART_InitializeModeGeneral(plibID, autoBaud, loopbackMode,
1140:                            wakeFromSleep, irdaMode, stopInIdle);
1141:                
1142:                    /* Set the line control mode */
1143:                    PLIB_USART_LineControlModeSelect(plibID, init->lineControl);
9D00A634  8CA20018   LW V0, 24(A1)
1144:                
1145:                    /* We set the receive interrupt mode to receive an interrupt whenever FIFO
1146:                       is not empty */
1147:                    PLIB_USART_InitializeOperation(plibID, USART_RECEIVE_FIFO_ONE_CHAR,
1148:                            USART_TRANSMIT_FIFO_IDLE, handshakeLines);
1149:                
1150:                    /* Set the baud rate and enable the USART */
1151:                    PLIB_USART_BaudSetAndEnable(plibID, init->brgClock, init->baud);
9D00A68C  8CA60014   LW A2, 20(A1)
9D00A690  8CA2001C   LW V0, 28(A1)
9D00A694  24031400   ADDIU V1, ZERO, 5120
9D00A698  AC830018   SW V1, 24(A0)
9D00A69C  00022842   SRL A1, V0, 1
9D00A6A0  00061882   SRL V1, A2, 2
9D00A6A4  00651821   ADDU V1, V1, A1
9D00A6A8  0062001B   DIVU V1, V0
9D00A6AC  004001F4   TEQ V0, ZERO
9D00A6B0  00001812   MFLO V1
9D00A6B4  2463FFFF   ADDIU V1, V1, -1
9D00A6B8  3C070001   LUI A3, 1
9D00A6BC  0067382B   SLTU A3, V1, A3
9D00A6C0  50E00006   BEQL A3, ZERO, _DRV_USART_HardwareSetup::PLIB_USART_BaudSetAndEnable
9D00A6C4  24030008   ADDIU V1, ZERO, 8
9D00A6C8  24020008   ADDIU V0, ZERO, 8
9D00A6CC  AC820008   SW V0, 8(A0)
9D00A6D0  AC830040   SW V1, 64(A0)
9D00A6D4  0B4029C0   J 0x9D00A700
9D00A6D8  34028000   ORI V0, ZERO, -32768
9D00A6DC  AC830004   SW V1, 4(A0)
9D00A6E0  00063102   SRL A2, A2, 4
9D00A6E4  00A62821   ADDU A1, A1, A2
9D00A6E8  00A2001B   DIVU A1, V0
9D00A6EC  004001F4   TEQ V0, ZERO
9D00A6F0  00002812   MFLO A1
9D00A6F4  24A5FFFF   ADDIU A1, A1, -1
9D00A6F8  AC850040   SW A1, 64(A0)
9D00A6FC  34028000   ORI V0, ZERO, -32768
9D00A700  AC820008   SW V0, 8(A0)
9D00A704  03E00008   JR RA
9D00A708  00000000   NOP
1152:                }
1153:                
1154:                // *****************************************************************************
1155:                /* Function:
1156:                    DRV_USART_CLIENT_OBJ * _DRV_USART_DriverHandleValidate(DRV_HANDLE handle)
1157:                
1158:                  Summary:
1159:                    Dynamic implementation of the _DRV_USART_DriverHandleValidate() function.
1160:                
1161:                  Description:
1162:                    Dynamic implementation of the _DRV_USART_DriverHandleValidate() function.
1163:                    This function return NULL if the handle is invalid else it return a pointer
1164:                    to the USART Driver Client Object associated with this handle.
1165:                
1166:                  Remarks:
1167:                    This is a private function and should not be called directly by an
1168:                    application.
1169:                */
1170:                
1171:                DRV_USART_CLIENT_OBJ * _DRV_USART_DriverHandleValidate(DRV_HANDLE handle)
1172:                {
1173:                    /* This function returns the pointer to the client object that is
1174:                       associated with this handle if the handle is valid. Returns NULL
1175:                       otherwise. */
1176:                
1177:                    DRV_USART_CLIENT_OBJ * client;
1178:                
1179:                    if((DRV_HANDLE_INVALID == handle) ||
9D015234  2482FFFF   ADDIU V0, A0, -1
9D015238  2C42FFFE   SLTIU V0, V0, -2
9D01523C  10400005   BEQ V0, ZERO, 0x9D015254
9D015240  00000000   NOP
1180:                            (0 == handle))
1181:                    {
1182:                        return(NULL);
1183:                    }
1184:                
1185:                    client = (DRV_USART_CLIENT_OBJ *)handle;
1186:                
1187:                    if(!client->inUse)
9D015244  90820008   LBU V0, 8(A0)
1188:                    {
1189:                        return(NULL);
9D015248  0002200A   MOVZ A0, ZERO, V0
9D01524C  03E00008   JR RA
9D015250  00801021   ADDU V0, A0, ZERO
1190:                    }
1191:                
1192:                    return(client);
1193:                }
9D015254  03E00008   JR RA
9D015258  00001021   ADDU V0, ZERO, ZERO
1194:                
1195:                // *****************************************************************************
1196:                // *****************************************************************************
1197:                // Section: File scope functions
1198:                // *****************************************************************************
1199:                // *****************************************************************************
1200:                
1201:                bool _DRV_USART_ClientBufferQueueObjectsRemove(DRV_USART_CLIENT_OBJ * clientObj)
1202:                {
1203:                    DRV_USART_OBJ * dObj = clientObj->hDriver;
1204:                    bool interruptWasEnabled = false;
1205:                    DRV_USART_BUFFER_OBJ * iterator = NULL;
1206:                
1207:                    if(OSAL_MUTEX_Lock(&(dObj->mutexDriverInstance), OSAL_WAIT_FOREVER) == OSAL_RESULT_TRUE)
1208:                    {
1209:                        /* Disable the transmit interrupt */
1210:                        interruptWasEnabled = _DRV_USART_InterruptSourceDisable(dObj->txInterruptSource);
1211:                        iterator = dObj->queueWrite;
1212:                        while(iterator != NULL)
1213:                        {
1214:                            if(clientObj == (DRV_USART_CLIENT_OBJ *)iterator->hClient)
1215:                            {
1216:                                /* That means this buffer object is owned
1217:                                   by this client. This buffer object should
1218:                                   be removed. The following code removes
1219:                                   the object from a doubly linked list queue. */
1220:                
1221:                                iterator->inUse = false;
1222:                                if(iterator->previous != NULL)
1223:                                {
1224:                                    iterator->previous->next = iterator->next;
1225:                                }
1226:                                if(iterator->next != NULL)
1227:                                {
1228:                                    iterator->next->previous = iterator->previous;
1229:                                }
1230:                                /* Decrementing Current queue size */
1231:                                dObj->queueSizeCurrentWrite --;
1232:                
1233:                            }
1234:                            iterator = iterator->next;
1235:                        }
1236:                        /* If there are no buffers in the write queue.
1237:                         * Make the head pointer point to NULL */
1238:                        if(dObj->queueSizeCurrentWrite == 0)
1239:                        {
1240:                            dObj->queueWrite = NULL;
1241:                        }
1242:                        else
1243:                        {
1244:                            /* Iterate to update the head pointer to point
1245:                             * the first valid buffer object in the queue */
1246:                            iterator = dObj->queueWrite;
1247:                            while(iterator != NULL)
1248:                            {
1249:                                if(iterator->inUse == true)
1250:                                {
1251:                                    dObj->queueWrite = iterator;
1252:                                    break;
1253:                                }
1254:                                iterator = iterator->next;
1255:                            }
1256:                        }
1257:                
1258:                
1259:                        /* Re-enable the interrupt if it was enabled */
1260:                        if(interruptWasEnabled)
1261:                        {
1262:                	        _DRV_USART_InterruptSourceEnable(dObj->txInterruptSource);
1263:                        }
1264:                
1265:                        /* Now check the receive buffer queue. Start by disabling the
1266:                           receive interrupt */
1267:                
1268:                        interruptWasEnabled = _DRV_USART_InterruptSourceDisable(dObj->rxInterruptSource);
1269:                        iterator = dObj->queueRead;
1270:                        while(iterator != NULL)
1271:                        {
1272:                            if(clientObj == (DRV_USART_CLIENT_OBJ *)iterator->hClient)
1273:                            {
1274:                                /* That means this buffer object is owned
1275:                                   by this client. This buffer object should
1276:                                   be removed. The following code removed
1277:                                   the object from a doubly linked list queue. */
1278:                
1279:                                iterator->inUse = false;
1280:                                if(iterator->previous != NULL)
1281:                                {
1282:                                    iterator->previous->next = iterator->next;
1283:                                }
1284:                                if(iterator->next != NULL)
1285:                                {
1286:                                    iterator->next->previous = iterator->previous;
1287:                                }
1288:                                /* Decrementing Current queue size */
1289:                                dObj->queueSizeCurrentRead --;
1290:                            }
1291:                            iterator = iterator->next;
1292:                        }
1293:                        /* If there are no buffers in the read queue.
1294:                         * Make the head pointer point to NULL */
1295:                        if(dObj->queueSizeCurrentRead == 0)
1296:                        {
1297:                            dObj->queueRead = NULL;
1298:                        }
1299:                        else
1300:                        {
1301:                            /* Iterate to update the head pointer to point
1302:                             * the first valid buffer object in the queue */
1303:                            iterator = dObj->queueRead;
1304:                            while(iterator != NULL)
1305:                            {
1306:                                if(iterator->inUse == true)
1307:                                {
1308:                                    dObj->queueRead = iterator;
1309:                                    break;
1310:                                }
1311:                                iterator = iterator->next;
1312:                            }
1313:                        }
1314:                
1315:                        if(interruptWasEnabled)
1316:                        {
1317:                            _DRV_USART_InterruptSourceEnable(dObj->rxInterruptSource);
1318:                        }
1319:                
1320:                        /* Unlock the mutex */
1321:                
1322:                        OSAL_MUTEX_Unlock(&(dObj->mutexDriverInstance));
1323:                    }
1324:                    else
1325:                    {
1326:                        /* The case where the mutex lock timed out and the
1327:                           client buffer objects could not be removed from
1328:                           the driver queue, the close function should fail. */
1329:                
1330:                        return false;
1331:                    }
1332:                
1333:                    return true;
1334:                }
1335:                
1336:                void _DRV_USART_BufferQueueRxTasks(SYS_MODULE_OBJ object)
1337:                {
9D00CB44  27BDFFE0   ADDIU SP, SP, -32
9D00CB48  AFBF001C   SW RA, 28(SP)
9D00CB4C  AFB20018   SW S2, 24(SP)
9D00CB50  AFB10014   SW S1, 20(SP)
9D00CB54  AFB00010   SW S0, 16(SP)
1338:                    DRV_USART_OBJ * hDriver = &gDrvUSARTObj[object];
9D00CB58  00041140   SLL V0, A0, 5
9D00CB5C  000421C0   SLL A0, A0, 7
9D00CB60  00822023   SUBU A0, A0, V0
9D00CB64  3C11A000   LUI S1, -24576
9D00CB68  26310C3C   ADDIU S1, S1, 3132
9D00CB6C  02248821   ADDU S1, S1, A0
1339:                    DRV_USART_BUFFER_OBJ * bufferObj;
1340:                    DRV_USART_CLIENT_OBJ * client;
1341:                    USART_MODULE_ID plibID;
1342:                
1343:                    bool status;
1344:                
1345:                    plibID = hDriver->moduleId;
1346:                
1347:                    /* If this driver is configured for polled mode in an RTOS, the tasks
1348:                       routine would be called from another thread. We need to get the driver
1349:                       instance mutex before updating the queue. If the driver is configured for
1350:                       interrupt mode, then _DRV_USART_TAKE_MUTEX will compile to true */
1351:                
1352:                    if(DRV_USART_INTERRUPT_MODE == false)
1353:                    {
1354:                        if(OSAL_MUTEX_Lock(&(hDriver->mutexDriverInstance), OSAL_WAIT_FOREVER) == OSAL_RESULT_TRUE)
1355:                        {
1356:                            /* We were able to take the mutex */
1357:                        }
1358:                        else
1359:                        {
1360:                            /* The mutex acquisition timed out. Return with an
1361:                               invalid handle. This code will not execute
1362:                               if there is no RTOS. */
1363:                            return;
1364:                        }
1365:                    }
1366:                
1367:                    /* In this function, the driver checks if there are any buffers in queue. If
1368:                       so the buffer is serviced. A buffer that is serviced completely is
1369:                       removed from the queue. Start by getting the buffer at the head of the
1370:                       queue */
1371:                
1372:                    bufferObj = hDriver->queueRead;
9D00CB70  8E300008   LW S0, 8(S1)
1373:                
1374:                    if(bufferObj != NULL)
9D00CB74  12000047   BEQ S0, ZERO, 0x9D00CC94
9D00CB78  8E220000   LW V0, 0(S1)
1375:                    {
1376:                        /* The USART driver is configured to generate an interrupt when the FIFO
1377:                           is not empty. Additionally the queue is not empty. Which means there
1378:                           is work to done in this routine. Read data from the FIFO until either
1379:                           the FIFO is empty or until we have read the requested number of bytes.
1380:                        */
1381:                        while((PLIB_USART_ReceiverDataIsAvailable(plibID))
9D00CB88  50400017   BEQL V0, ZERO, 0x9D00CBE8
9D00CB8C  8E03000C   LW V1, 12(S0)
9D00CBC8  50800007   BEQL A0, ZERO, 0x9D00CBE8
9D00CBCC  8E03000C   LW V1, 12(S0)
1382:                            && (bufferObj->nCurrentBytes < bufferObj->size ))
9D00CB90  8E02000C   LW V0, 12(S0)
9D00CB94  8E040010   LW A0, 16(S0)
9D00CB98  0044202B   SLTU A0, V0, A0
9D00CB9C  50800017   BEQL A0, ZERO, 0x9D00CBFC
9D00CBA0  8E120014   LW S2, 20(S0)
9D00CBD0  8E040010   LW A0, 16(S0)
9D00CBD4  0044202B   SLTU A0, V0, A0
9D00CBD8  1480FFF2   BNE A0, ZERO, _DRV_USART_BufferQueueRxTasks::PLIB_USART_ReceiverByteReceive
9D00CBDC  00000000   NOP
9D00CBE0  0B4032FF   J 0x9D00CBFC
9D00CBE4  8E120014   LW S2, 20(S0)
1383:                        {
1384:                            bufferObj->buffer[bufferObj->nCurrentBytes] = PLIB_USART_ReceiverByteReceive(plibID);
9D00CBA8  8E050004   LW A1, 4(S0)
9D00CBAC  00A21021   ADDU V0, A1, V0
9D00CBB0  A0440000   SB A0, 0(V0)
1385:                            bufferObj->nCurrentBytes ++;
9D00CBB4  8E02000C   LW V0, 12(S0)
9D00CBB8  24420001   ADDIU V0, V0, 1
9D00CBBC  AE02000C   SW V0, 12(S0)
1386:                        }
1387:                
1388:                        /* Check if this buffer is done */
1389:                        if(bufferObj->nCurrentBytes >= bufferObj->size)
9D00CBE8  8E020010   LW V0, 16(S0)
9D00CBEC  0062102B   SLTU V0, V1, V0
9D00CBF0  54400026   BNEL V0, ZERO, 0x9D00CC8C
9D00CBF4  8E220008   LW V0, 8(S1)
1390:                        {
1391:                            /* This means the buffer is completed. If there
1392:                               is a callback registered with client, then
1393:                               call it */
1394:                
1395:                            client = (DRV_USART_CLIENT_OBJ *)bufferObj->hClient;
9D00CBF8  8E120014   LW S2, 20(S0)
1396:                            if((client->eventHandler != NULL) && (bufferObj->flags & DRV_USART_BUFFER_OBJ_FLAG_BUFFER_ADD))
9D00CBFC  8E420038   LW V0, 56(S2)
9D00CC00  50400011   BEQL V0, ZERO, 0x9D00CC48
9D00CC04  8E020018   LW V0, 24(S0)
9D00CC08  8E020020   LW V0, 32(S0)
9D00CC0C  30420002   ANDI V0, V0, 2
9D00CC10  5040000D   BEQL V0, ZERO, 0x9D00CC48
9D00CC14  8E020018   LW V0, 24(S0)
1397:                            {
1398:                                /* Call the event handler. We additionally increment the
1399:                                   interrupt nesting count which lets the driver functions
1400:                                   that are called from the event handler know that an
1401:                                   interrupt context is active.
1402:                                   */
1403:                
1404:                                hDriver->interruptNestingCount ++;
9D00CC18  8E220020   LW V0, 32(S1)
9D00CC1C  24420001   ADDIU V0, V0, 1
9D00CC20  AE220020   SW V0, 32(S1)
1405:                
1406:                                client->eventHandler(DRV_USART_BUFFER_EVENT_COMPLETE,
9D00CC24  8E420038   LW V0, 56(S2)
9D00CC28  00002021   ADDU A0, ZERO, ZERO
9D00CC2C  8E050028   LW A1, 40(S0)
9D00CC30  0040F809   JALR V0
9D00CC34  8E460044   LW A2, 68(S2)
1407:                                        bufferObj->bufferHandle,
1408:                                        client->context);
1409:                
1410:                                hDriver->interruptNestingCount --;
9D00CC38  8E220020   LW V0, 32(S1)
9D00CC3C  2442FFFF   ADDIU V0, V0, -1
9D00CC40  AE220020   SW V0, 32(S1)
1411:                            }
1412:                
1413:                            /* Get the next buffer in the queue and deallocate
1414:                               this buffer */
1415:                
1416:                            hDriver->queueRead = bufferObj->next;
9D00CC44  8E020018   LW V0, 24(S0)
9D00CC48  AE220008   SW V0, 8(S1)
1417:                            bufferObj->inUse = false;
9D00CC4C  A2000000   SB ZERO, 0(S0)
1418:                            hDriver->queueSizeCurrentRead --;
9D00CC50  8E22003C   LW V0, 60(S1)
9D00CC54  2442FFFF   ADDIU V0, V0, -1
9D00CC58  AE22003C   SW V0, 60(S1)
1419:                
1420:                            /* Reset the next and previous pointers */
1421:                            bufferObj->next = NULL;
9D00CC5C  AE000018   SW ZERO, 24(S0)
1422:                            bufferObj->previous = NULL;
9D00CC60  AE00001C   SW ZERO, 28(S0)
1423:                
1424:                            /* Reset the current head's previous pointer */
1425:                            if (hDriver->queueRead != NULL)
9D00CC64  8E220008   LW V0, 8(S1)
9D00CC68  54400001   BNEL V0, ZERO, 0x9D00CC70
9D00CC6C  AC40001C   SW ZERO, 28(V0)
1426:                            {
1427:                                hDriver->queueRead->previous = NULL;
1428:                            }
1429:                
1430:                            if(bufferObj->flags & DRV_USART_BUFFER_OBJ_FLAG_READ_WRITE)
9D00CC70  8E020020   LW V0, 32(S0)
9D00CC74  30420001   ANDI V0, V0, 1
9D00CC78  50400004   BEQL V0, ZERO, 0x9D00CC8C
9D00CC7C  8E220008   LW V0, 8(S1)
1431:                            {
1432:                                /* This means we should post the semaphore */
1433:                                _DRV_USART_SEM_POST(&(client->semReadDone));
9D00CC80  0F4050E7   JAL OSAL_SEM_PostISR
9D00CC84  26440048   ADDIU A0, S2, 72
1434:                            }
1435:                        }
1436:                    }
1437:                
1438:                    if(hDriver->queueRead == NULL)
9D00CC88  8E220008   LW V0, 8(S1)
9D00CC8C  14400004   BNE V0, ZERO, 0x9D00CCA0
9D00CC90  8FBF001C   LW RA, 28(SP)
1439:                    {
1440:                        /* The queue is empty. We can disable the interrupt */
1441:                        status = _DRV_USART_InterruptSourceDisable(hDriver->rxInterruptSource);
9D00CC94  0F405058   JAL SYS_INT_SourceDisable
9D00CC98  8E240028   LW A0, 40(S1)
1442:                        /* Ignore the warning */
1443:                        (void)status;
1444:                    }
1445:                
1446:                    /* Release the mutex */
1447:                
1448:                   _DRV_USART_RELEASE_MUTEX(&(hDriver->mutexDriverInstance));
1449:                }
9D00CC9C  8FBF001C   LW RA, 28(SP)
9D00CCA0  8FB20018   LW S2, 24(SP)
9D00CCA4  8FB10014   LW S1, 20(SP)
9D00CCA8  8FB00010   LW S0, 16(SP)
9D00CCAC  03E00008   JR RA
9D00CCB0  27BD0020   ADDIU SP, SP, 32
1450:                
1451:                void _DRV_USART_BufferQueueTxTasks(SYS_MODULE_OBJ object)
1452:                {
9D008DF4  27BDFFD8   ADDIU SP, SP, -40
9D008DF8  AFBF0024   SW RA, 36(SP)
9D008DFC  AFB30020   SW S3, 32(SP)
9D008E00  AFB2001C   SW S2, 28(SP)
9D008E04  AFB10018   SW S1, 24(SP)
9D008E08  AFB00014   SW S0, 20(SP)
1453:                    /* Start by getting the buffer at the head of queue. */
1454:                
1455:                    DRV_USART_OBJ *hDriver = &gDrvUSARTObj[object];
9D008E0C  00041140   SLL V0, A0, 5
9D008E10  000421C0   SLL A0, A0, 7
9D008E14  00822023   SUBU A0, A0, V0
9D008E18  3C12A000   LUI S2, -24576
9D008E1C  26520C3C   ADDIU S2, S2, 3132
9D008E20  02449021   ADDU S2, S2, A0
1456:                    DRV_USART_BUFFER_OBJ * bufferObj;
1457:                    DRV_USART_CLIENT_OBJ * client;
1458:                    USART_MODULE_ID plibID;
1459:                
1460:                    bool status;
1461:                
1462:                    bufferObj = hDriver->queueWrite;
9D008E24  8E510004   LW S1, 4(S2)
1463:                    plibID = hDriver->moduleId;
1464:                
1465:                    /* If this driver is configured for polled mode in an RTOS, the tasks
1466:                       routine would be called from another thread. We need to get the driver
1467:                       instance mutex before updating the queue. If the driver is configured for
1468:                       interrupt mode, then _DRV_USART_TAKE_MUTEX will compile to true */
1469:                
1470:                    if(DRV_USART_INTERRUPT_MODE == false)
1471:                    {
1472:                        if(OSAL_MUTEX_Lock(&(hDriver->mutexDriverInstance), OSAL_WAIT_FOREVER))
1473:                        {
1474:                            /* We were able to take the mutex */
1475:                        }
1476:                        else
1477:                        {
1478:                            /* The mutex acquisition timed out. Return with an
1479:                               invalid handle. This code will not execute
1480:                               if there is no RTOS. */
1481:                            return;
1482:                        }
1483:                    }
1484:                
1485:                    if(bufferObj != NULL)
9D008E28  1220006C   BEQ S1, ZERO, 0x9D008FDC
9D008E2C  8E500000   LW S0, 0(S2)
1486:                    {
1487:                        /* This means the queue is not empty. Check if this buffer is done */
1488:                        if(bufferObj->nCurrentBytes >= bufferObj->size)
9D008E30  8E23000C   LW V1, 12(S1)
9D008E34  8E220010   LW V0, 16(S1)
9D008E38  0062102B   SLTU V0, V1, V0
9D008E3C  1440002A   BNE V0, ZERO, 0x9D008EE8
9D008E40  02201021   ADDU V0, S1, ZERO
1489:                        {
1490:                            /* This means the buffer is completed. If there
1491:                               is a callback registered with client, then
1492:                               call it */
1493:                
1494:                            client = (DRV_USART_CLIENT_OBJ *)bufferObj->hClient;
9D008E44  8E330014   LW S3, 20(S1)
1495:                            if((client->eventHandler != NULL) && (bufferObj->flags & DRV_USART_BUFFER_OBJ_FLAG_BUFFER_ADD))
9D008E48  8E620038   LW V0, 56(S3)
9D008E4C  50400011   BEQL V0, ZERO, 0x9D008E94
9D008E50  8E220018   LW V0, 24(S1)
9D008E54  8E220020   LW V0, 32(S1)
9D008E58  30420002   ANDI V0, V0, 2
9D008E5C  5040000D   BEQL V0, ZERO, 0x9D008E94
9D008E60  8E220018   LW V0, 24(S1)
1496:                            {
1497:                                /* Before calling the event handler, the interrupt nesting
1498:                                   counter is incremented. This will allow driver routine that
1499:                                   are called from the event handler to know the interrupt
1500:                                   nesting level. Events are only generated for buffers that
1501:                                   were submitted using the buffer add routine */
1502:                
1503:                                hDriver->interruptNestingCount ++;
9D008E64  8E420020   LW V0, 32(S2)
9D008E68  24420001   ADDIU V0, V0, 1
9D008E6C  AE420020   SW V0, 32(S2)
1504:                
1505:                                client->eventHandler(DRV_USART_BUFFER_EVENT_COMPLETE,
9D008E70  8E620038   LW V0, 56(S3)
9D008E74  00002021   ADDU A0, ZERO, ZERO
9D008E78  8E250028   LW A1, 40(S1)
9D008E7C  0040F809   JALR V0
9D008E80  8E660044   LW A2, 68(S3)
1506:                                        bufferObj->bufferHandle,
1507:                                        client->context);
1508:                
1509:                                /* Decrement the nesting count */
1510:                                hDriver->interruptNestingCount -- ;
9D008E84  8E420020   LW V0, 32(S2)
9D008E88  2442FFFF   ADDIU V0, V0, -1
9D008E8C  AE420020   SW V0, 32(S2)
1511:                            }
1512:                
1513:                            /* Get the next buffer in the queue and deallocate
1514:                             * this buffer */
1515:                
1516:                            hDriver->queueWrite = bufferObj->next;
9D008E90  8E220018   LW V0, 24(S1)
9D008E94  AE420004   SW V0, 4(S2)
1517:                            bufferObj->inUse = false;
9D008E98  A2200000   SB ZERO, 0(S1)
1518:                            hDriver->queueSizeCurrentWrite --;
9D008E9C  8E420040   LW V0, 64(S2)
9D008EA0  2442FFFF   ADDIU V0, V0, -1
9D008EA4  AE420040   SW V0, 64(S2)
1519:                
1520:                            /* Reset the next and previous pointers */
1521:                            bufferObj->next = NULL;
9D008EA8  AE200018   SW ZERO, 24(S1)
1522:                            bufferObj->previous = NULL;
9D008EAC  AE20001C   SW ZERO, 28(S1)
1523:                
1524:                            /* Reset the current head's previous pointer */
1525:                            if (hDriver->queueWrite != NULL)
9D008EB0  8E420004   LW V0, 4(S2)
9D008EB4  54400001   BNEL V0, ZERO, 0x9D008EBC
9D008EB8  AC40001C   SW ZERO, 28(V0)
1526:                            {
1527:                                hDriver->queueWrite->previous = NULL;
1528:                            }
1529:                
1530:                            if(bufferObj->flags & DRV_USART_BUFFER_OBJ_FLAG_READ_WRITE)
9D008EBC  8E220020   LW V0, 32(S1)
9D008EC0  30420001   ANDI V0, V0, 1
9D008EC4  50400004   BEQL V0, ZERO, 0x9D008ED8
9D008EC8  8E420004   LW V0, 4(S2)
1531:                            {
1532:                                /* This means we should post the semaphore */
1533:                                _DRV_USART_SEM_POST(&(client->semWriteDone));
9D008ECC  0F4050E7   JAL OSAL_SEM_PostISR
9D008ED0  2664004C   ADDIU A0, S3, 76
1534:                
1535:                            }
1536:                        }
1537:                    }
1538:                
1539:                    /* Check if the queue is still not empty and process
1540:                       the buffer */
1541:                
1542:                    if(hDriver->queueWrite != NULL)
9D008ED4  8E420004   LW V0, 4(S2)
9D008ED8  54400004   BNEL V0, ZERO, 0x9D008EEC
9D008EDC  8E440010   LW A0, 16(S2)
9D008EE0  0B4023F7   J 0x9D008FDC
9D008EE4  00000000   NOP
1543:                    {
1544:                        bufferObj = hDriver->queueWrite;
1545:                        if(hDriver->operationMode == DRV_USART_OPERATION_MODE_ADDRESSED)
9D008EE8  8E440010   LW A0, 16(S2)
9D008EEC  24030002   ADDIU V1, ZERO, 2
9D008EF0  1083000C   BEQ A0, V1, 0x9D008F24
9D008EF4  02002021   ADDU A0, S0, ZERO
1546:                        {
1547:                			uint16_t *buf_ptr;
1548:                            buf_ptr = (uint16_t *) bufferObj->buffer;
9D008F24  8C450004   LW A1, 4(V0)
1549:                
1550:                            /* Fill up the FIFO with data until the FIFO is full
1551:                               and we have data to send */
1552:                            while((!PLIB_USART_TransmitterBufferIsFull(plibID))
9D008F28  0B4023DC   J PLIB_USART_TransmitterBufferIsFull
9D008F2C  24060001   ADDIU A2, ZERO, 1
9D008F78  1460001B   BNE V1, ZERO, 0x9D008FE8
9D008F7C  8FBF0024   LW RA, 36(SP)
1553:                                    && (bufferObj->nCurrentBytes < bufferObj->size ))
9D008F80  8C43000C   LW V1, 12(V0)
9D008F84  8C440010   LW A0, 16(V0)
9D008F88  0064202B   SLTU A0, V1, A0
9D008F8C  1480FFE8   BNE A0, ZERO, 0x9D008F30
9D008F90  8FB30020   LW S3, 32(SP)
9D008F94  0B4023FB   J 0x9D008FEC
9D008F98  00000000   NOP
1554:                            {
1555:                                if((bufferObj->nCurrentBytes == 0) && (false == bufferObj->isAddressSent))
9D008F30  14600009   BNE V1, ZERO, 0x9D008F58
9D008F34  00031840   SLL V1, V1, 1
9D008F38  90440009   LBU A0, 9(V0)
9D008F3C  14800007   BNE A0, ZERO, PLIB_USART_Transmitter9BitsSend
9D008F40  00A31821   ADDU V1, A1, V1
1556:                                {
1557:                                    /* Send Address */
1558:                                    PLIB_USART_Transmitter9BitsSend(plibID, bufferObj->address, true);
1559:                                    bufferObj->isAddressSent = true;
9D008F50  0B4023DC   J PLIB_USART_TransmitterBufferIsFull
9D008F54  A0460009   SB A2, 9(V0)
1560:                                }
1561:                                else
1562:                                {
1563:                                    /* Send data */
1564:                                    PLIB_USART_Transmitter9BitsSend(plibID, buf_ptr[bufferObj->nCurrentBytes], false);
9D008F58  00A31821   ADDU V1, A1, V1
1565:                                    bufferObj->nCurrentBytes ++; // Here it is incrementing the 16-bit words number.
9D008F64  8C43000C   LW V1, 12(V0)
9D008F68  24630001   ADDIU V1, V1, 1
9D008F6C  AC43000C   SW V1, 12(V0)
1566:                                }
1567:                            }
1568:                        }
1569:                        else
1570:                        {
1571:                            /* Fill up the FIFO with data until the FIFO is full
1572:                               and we have data to send */
1573:                            while((!PLIB_USART_TransmitterBufferIsFull(plibID))
9D008F00  14600039   BNE V1, ZERO, 0x9D008FE8
9D008F04  8FBF0024   LW RA, 36(SP)
9D008FBC  14A0000A   BNE A1, ZERO, 0x9D008FE8
9D008FC0  8FBF0024   LW RA, 36(SP)
1574:                                    && (bufferObj->nCurrentBytes < bufferObj->size ))
9D008F08  8C43000C   LW V1, 12(V0)
9D008F0C  8C450010   LW A1, 16(V0)
9D008F10  0065282B   SLTU A1, V1, A1
9D008F14  54A00021   BNEL A1, ZERO, 0x9D008F9C
9D008F18  8C450004   LW A1, 4(V0)
9D008FC4  8C450010   LW A1, 16(V0)
9D008FC8  0065282B   SLTU A1, V1, A1
9D008FCC  54A0FFF3   BNEL A1, ZERO, 0x9D008F9C
9D008FD0  8C450004   LW A1, 4(V0)
9D008FD4  0B4023FB   J 0x9D008FEC
9D008FD8  8FB30020   LW S3, 32(SP)
1575:                            {
1576:                                /* Send data */
1577:                                PLIB_USART_TransmitterByteSend(plibID, bufferObj->buffer[bufferObj->nCurrentBytes]);
9D008F9C  00A31821   ADDU V1, A1, V1
1578:                                bufferObj->nCurrentBytes ++;
9D008FA8  8C43000C   LW V1, 12(V0)
9D008FAC  24630001   ADDIU V1, V1, 1
9D008FB0  AC43000C   SW V1, 12(V0)
1579:                            }
1580:                        }
1581:                    }
1582:                    else
1583:                    {
1584:                        /* If the queue is empty, then disable the TX interrupt */
1585:                        status = _DRV_USART_InterruptSourceDisable(hDriver->txInterruptSource);
9D008FDC  0F405058   JAL SYS_INT_SourceDisable
9D008FE0  8E440024   LW A0, 36(S2)
1586:                        /* Ignore the warning */
1587:                        (void)status;
1588:                    }
1589:                
1590:                    /* Release the mutex */
1591:                    _DRV_USART_RELEASE_MUTEX(&(hDriver->mutexDriverInstance));
1592:                }
9D008F1C  0B4023FB   J 0x9D008FEC
9D008F20  8FB30020   LW S3, 32(SP)
9D008FE4  8FBF0024   LW RA, 36(SP)
9D008FE8  8FB30020   LW S3, 32(SP)
9D008FEC  8FB2001C   LW S2, 28(SP)
9D008FF0  8FB10018   LW S1, 24(SP)
9D008FF4  8FB00014   LW S0, 20(SP)
9D008FF8  03E00008   JR RA
9D008FFC  27BD0028   ADDIU SP, SP, 40
1593:                
1594:                void _DRV_USART_BufferQueueErrorTasks(SYS_MODULE_OBJ object)
1595:                {
9D010850  27BDFFE0   ADDIU SP, SP, -32
9D010854  AFBF001C   SW RA, 28(SP)
9D010858  AFB20018   SW S2, 24(SP)
9D01085C  AFB10014   SW S1, 20(SP)
9D010860  AFB00010   SW S0, 16(SP)
1596:                    DRV_USART_OBJ *hDriver = &gDrvUSARTObj[object];
9D010864  00041140   SLL V0, A0, 5
9D010868  000421C0   SLL A0, A0, 7
9D01086C  00822023   SUBU A0, A0, V0
9D010870  3C10A000   LUI S0, -24576
9D010874  26100C3C   ADDIU S0, S0, 3132
9D010878  02048021   ADDU S0, S0, A0
1597:                    DRV_USART_BUFFER_OBJ * bufferObj;
1598:                    DRV_USART_CLIENT_OBJ * clientObj;
1599:                    bool mutexGrabbed  = true;
1600:                    bool status = false;
1601:                
1602:                    /* USART driver will take care that TX erros( like overflow etc) are not 
1603:                     * going to occur at any time based on checks before write.
1604:                     * So, only RX errors are to be handled/reported */
1605:                    
1606:                    /* Get the RX buffer at the head */
1607:                    bufferObj = hDriver->queueRead;
9D01087C  8E110008   LW S1, 8(S0)
1608:                
1609:                    /* If this driver is configured for polled mode in an RTOS, the tasks
1610:                     * routine would be called from another thread. We need to get the driver
1611:                     * instance mutex before updating the queue. If the driver is configured for
1612:                     * interrupt mode, then OSAL_MUTEX_Lock will compile to true */
1613:                
1614:                    if(DRV_USART_INTERRUPT_MODE == false)
1615:                    {
1616:                        if(!OSAL_MUTEX_Lock(&(hDriver->mutexDriverInstance), OSAL_WAIT_FOREVER))
1617:                        {
1618:                            /* The mutex acquisition timed out.
1619:                             * This code will not execute if there is no RTOS. */
1620:                            mutexGrabbed = false;
1621:                        }
1622:                    }
1623:                
1624:                    /* mutexGrabbed will always be true for non-RTOS case.
1625:                     * Will be false when mutex aquisition timed out in RTOS mode */
1626:                    if(true == mutexGrabbed)
1627:                    {
1628:                            
1629:                        if(bufferObj != NULL)
9D010880  12200024   BEQ S1, ZERO, 0x9D010914
9D010884  00000000   NOP
1630:                        {
1631:                            /* Get the client objact */
1632:                            clientObj = (DRV_USART_CLIENT_OBJ *)bufferObj->hClient;
9D010888  8E320014   LW S2, 20(S1)
1633:                            
1634:                            /* Update the USART client error flag */
1635:                            clientObj->error = PLIB_USART_ErrorsGet(hDriver->moduleId);
9D010898  AE42003C   SW V0, 60(S2)
1636:                
1637:                            /* Clear error condition */
1638:                            _DRV_USART_ErrorConditionClear(hDriver);
9D01089C  0F4047E7   JAL _DRV_USART_ErrorConditionClear
9D0108A0  02002021   ADDU A0, S0, ZERO
1639:                
1640:                            /* Call event handler in Buffer queue request only.
1641:                             * If it's a File i/o request then DRV_USART_Read call itself 
1642:                             * will return with error result */
1643:                            if((clientObj->eventHandler != NULL) && (bufferObj->flags & DRV_USART_BUFFER_OBJ_FLAG_BUFFER_ADD))
9D0108A4  8E420038   LW V0, 56(S2)
9D0108A8  5040000A   BEQL V0, ZERO, 0x9D0108D4
9D0108AC  8E220018   LW V0, 24(S1)
9D0108B0  8E230020   LW V1, 32(S1)
9D0108B4  30630002   ANDI V1, V1, 2
9D0108B8  50600006   BEQL V1, ZERO, 0x9D0108D4
9D0108BC  8E220018   LW V0, 24(S1)
1644:                            {
1645:                                /* Call the event handler with buffer event error state */
1646:                                clientObj->eventHandler(DRV_USART_BUFFER_EVENT_ERROR,
9D0108C0  24040001   ADDIU A0, ZERO, 1
9D0108C4  8E250028   LW A1, 40(S1)
9D0108C8  0040F809   JALR V0
9D0108CC  8E460044   LW A2, 68(S2)
1647:                                        bufferObj->bufferHandle,
1648:                                        clientObj->context);
1649:                            }
1650:                            
1651:                
1652:                            /* Get the next buffer in the queue and deallocate
1653:                             * this buffer */
1654:                            hDriver->queueRead = bufferObj->next;
9D0108D0  8E220018   LW V0, 24(S1)
9D0108D4  AE020008   SW V0, 8(S0)
1655:                            bufferObj->inUse = false;
9D0108D8  A2200000   SB ZERO, 0(S1)
1656:                            hDriver->queueSizeCurrentRead --;
9D0108DC  8E02003C   LW V0, 60(S0)
9D0108E0  2442FFFF   ADDIU V0, V0, -1
9D0108E4  AE02003C   SW V0, 60(S0)
1657:                
1658:                            /* Reset the next and previous pointers */
1659:                            bufferObj->next = NULL;
9D0108E8  AE200018   SW ZERO, 24(S1)
1660:                            bufferObj->previous = NULL;
9D0108EC  AE20001C   SW ZERO, 28(S1)
1661:                
1662:                            /* If queue head is not null, update buffer pointer parameters*/
1663:                            if (hDriver->queueRead != NULL)
9D0108F0  8E020008   LW V0, 8(S0)
9D0108F4  10400003   BEQ V0, ZERO, 0x9D010904
9D0108F8  00000000   NOP
9D0108FC  0B404247   J 0x9D01091C
9D010900  AC40001C   SW ZERO, 28(V0)
1664:                            {
1665:                                /* Reset the updated head's previous pointer */
1666:                                hDriver->queueRead->previous = NULL;
1667:                            }
1668:                            else
1669:                            {
1670:                                /* Queue is empty disable the RX interrupt */
1671:                                status = _DRV_USART_InterruptSourceDisable(hDriver->rxInterruptSource);
9D010904  0F405058   JAL SYS_INT_SourceDisable
9D010908  8E040028   LW A0, 40(S0)
1672:                                
1673:                                /* Ignore the warning */
1674:                                (void)status;
1675:                            }
1676:                        }
1677:                        else
1678:                        {
1679:                            /* There is no buffer in the queue.
1680:                             * Flush the RX to clear the error condition */
1681:                            _DRV_USART_ErrorConditionClear(hDriver);
9D010914  0F4047E7   JAL _DRV_USART_ErrorConditionClear
9D010918  02002021   ADDU A0, S0, ZERO
1682:                        }
1683:                    }
1684:                
1685:                    /* Release the mutex in RTOS environment*/
1686:                    _DRV_USART_RELEASE_MUTEX(&(hDriver->mutexDriverInstance));
1687:                }
9D01090C  0B404248   J 0x9D010920
9D010910  8FBF001C   LW RA, 28(SP)
9D01091C  8FBF001C   LW RA, 28(SP)
9D010920  8FB20018   LW S2, 24(SP)
9D010924  8FB10014   LW S1, 20(SP)
9D010928  8FB00010   LW S0, 16(SP)
9D01092C  03E00008   JR RA
9D010930  27BD0020   ADDIU SP, SP, 32
1688:                
1689:                void _DRV_USART_ErrorConditionClear(DRV_USART_OBJ *hDriver)
1690:                {
1691:                    uint8_t dummyData = 0u;
1692:                    /* RX length = (FIFO level + RX register) */
1693:                    uint8_t RXlength = _DRV_USART_RX_DEPTH;
1694:                        
1695:                    /* If it's a overrun error then clear it to flush FIFO */
1696:                    if(USART_ERROR_RECEIVER_OVERRUN & PLIB_USART_ErrorsGet(hDriver->moduleId))
9D011FA4  7C630040   EXT V1, V1, 1, 1
9D011FA8  5060000C   BEQL V1, ZERO, _DRV_USART_ErrorConditionClear::PLIB_USART_ErrorsGet
9D011FAC  8C830000   LW V1, 0(A0)
1697:                    {
1698:                        PLIB_USART_ReceiverOverrunErrorClear(hDriver->moduleId);
1699:                    }
1700:                
1701:                    /* Read existing error bytes from FIFO to clear parity and framing error flags*/
1702:                    while( (USART_ERROR_PARITY | USART_ERROR_FRAMING) & PLIB_USART_ErrorsGet(hDriver->moduleId) )
9D011FE8  30A50006   ANDI A1, A1, 6
9D011FEC  14A0FFF4   BNE A1, ZERO, _DRV_USART_ErrorConditionClear::PLIB_USART_ReceiverByteReceive
9D011FF0  00000000   NOP
1703:                    {
1704:                        dummyData = PLIB_USART_ReceiverByteReceive(hDriver->moduleId);
1705:                        RXlength--;
1706:                        
1707:                        /* Try to flush error bytes for one full FIFO and exit instead of 
1708:                         * blocking here if more error bytes are received*/
1709:                        if(0u == RXlength)
9D011FCC  14400004   BNE V0, ZERO, 0x9D011FE0
9D011FD0  00000000   NOP
9D011FD4  0B4047FE   J _DRV_USART_ErrorConditionClear::PLIB_INT_SourceFlagClear
9D011FD8  8C82002C   LW V0, 44(A0)
1710:                        {
1711:                            break;
1712:                        }
1713:                    }
1714:                    
1715:                    /* Ignore the warning */
1716:                    (void)dummyData;
1717:                    
1718:                    /* Clear error interrupt flag */
1719:                    SYS_INT_SourceStatusClear(hDriver->errorInterruptSource);
9D011FF4  8C82002C   LW V0, 44(A0)
1720:                            
1721:                    /* Clear up the receive interrupt flag so that RX interrupt is not 
1722:                     * triggered for error bytes*/
1723:                    SYS_INT_SourceStatusClear(hDriver->rxInterruptSource);
9D012018  8C820028   LW V0, 40(A0)
9D01201C  00022142   SRL A0, V0, 5
9D012020  00042100   SLL A0, A0, 4
9D012024  00A42821   ADDU A1, A1, A0
9D012028  00431004   SLLV V0, V1, V0
9D01202C  ACA20004   SW V0, 4(A1)
9D012030  03E00008   JR RA
9D012034  00000000   NOP
1724:                }
1725:                
1726:                void _DRV_USART_ByteTransmitTasks (SYS_MODULE_OBJ object)
1727:                {
1728:                    DRV_USART_OBJ * hDriver = &gDrvUSARTObj[object];
1729:                
1730:                    if (_DRV_USART_InterruptSourceIsEnabled(hDriver->txInterruptSource))
1731:                    {
1732:                        /* Disable the interrupt, to avoid calling ISR continuously*/
1733:                        _DRV_USART_InterruptSourceDisable(hDriver->txInterruptSource);
1734:                
1735:                        if (hDriver->transmitCallback != NULL)
1736:                        {
1737:                            hDriver->transmitCallback (object);
1738:                        }
1739:                    }
1740:                
1741:                }
1742:                
1743:                void _DRV_USART_ByteReceiveTasks (SYS_MODULE_OBJ object)
1744:                {
1745:                    DRV_USART_OBJ * hDriver = &gDrvUSARTObj[object];
1746:                
1747:                    if (_DRV_USART_InterruptSourceIsEnabled(hDriver->rxInterruptSource))
1748:                    {
1749:                        if (hDriver->receiveCallback != NULL)
1750:                        {
1751:                            hDriver->receiveCallback (object);
1752:                        }
1753:                    }
1754:                }
1755:                
1756:                void _DRV_USART_ByteErrorTasks (SYS_MODULE_OBJ object)
1757:                {
1758:                    DRV_USART_OBJ * hDriver = &gDrvUSARTObj[object];
1759:                
1760:                    if (_DRV_USART_InterruptSourceIsEnabled(hDriver->errorInterruptSource))
1761:                    {
1762:                        /* Clear error condition */
1763:                        _DRV_USART_ErrorConditionClear(hDriver);
1764:                        
1765:                        if (hDriver->errorCallback != NULL)
1766:                        {
1767:                            hDriver->errorCallback (object);
1768:                        }
1769:                    }
1770:                }
1771:                
1772:                /*******************************************************************************
1773:                 End of File
1774:                */
1775:                
---  /home/whatisthis/microchip/harmony/v2_04/framework/driver/i2c/src/dynamic/drv_i2c.c  ---------------
1:                   /*******************************************************************************
2:                     I2C Device Driver Definition
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       drv_i2c.c
9:                   
10:                    Summary:
11:                      I2C Device Driver Dynamic Multiple Client Implementation
12:                  
13:                    Description:
14:                      The I2C device driver provides a simple interface to manage the I2C
15:                      modules on Microchip microcontrollers.  This file Implements the core
16:                      interface routines for the I2C driver.
17:                  
18:                      While building the driver from source, ALWAYS use this file in the build.
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  //DOM-IGNORE-END
45:                  
46:                  
47:                  // *****************************************************************************
48:                  // *****************************************************************************
49:                  // Section: Include Files
50:                  // *****************************************************************************
51:                  // *****************************************************************************
52:                  
53:                  #include "driver/i2c/src/drv_i2c_local.h"
54:                  #include "osal/osal.h"
55:                  
56:                  bool _DRV_I2C_IsQueueEmpty(DRV_I2C_OBJ *dObj);
57:                  DRV_I2C_BUFFER_OBJECT* _DRV_I2C_QueueSlotGet ( DRV_I2C_OBJ *dObj );
58:                  
59:                  
60:                          static uint32_t ReadCoreTimer(void);
61:                  
62:                          static uint32_t ReadCoreTimer()
63:                          {
64:                              volatile uint32_t timer;
65:                  
66:                              // get the count reg
67:                              asm volatile("mfc0   %0, $9" : "=r"(timer));
68:                  
69:                              return(timer);
70:                          }
71:                  
72:                          uint32_t    starttime;
73:                  
74:                          #define BAUD_RATE_0         50000
75:                          #define BRG_1_TIME_0        SYS_CLK_PeripheralFrequencyGet(CLK_BUS_PERIPHERAL_2)/(2*BAUD_RATE_0)
76:                  
77:                  // *****************************************************************************
78:                  // *****************************************************************************
79:                  // Section: File Scope Variables
80:                  // *****************************************************************************
81:                  // *****************************************************************************
82:                  
83:                  // *****************************************************************************
84:                  /* Driver Hardware instance objects.
85:                  
86:                    Summary:
87:                      Defines the hardware instances objects that are available on the part
88:                  
89:                    Description:
90:                      This data type defines the hardware instance objects that are available on
91:                      the part, so as to capture the hardware state of the instance.
92:                  
93:                    Remarks:
94:                      Not all modes are available on all micro-controllers.
95:                  */
96:                  
97:                  static DRV_I2C_OBJ             gDrvI2CObj[DRV_I2C_INSTANCES_NUMBER] ;
98:                  
99:                  // *****************************************************************************
100:                 /* Driver Client instance objects.
101:                 
102:                   Summary:
103:                     Defines the Client instances objects that are available on the part
104:                 
105:                   Description:
106:                     This data type defines the Client instance objects that are available on
107:                     the part, so as to capture the Client state of the instance.
108:                 
109:                   Remarks:
110:                     None
111:                 */
112:                 
113:                 static DRV_I2C_CLIENT_OBJ      gDrvI2CClientObj [ DRV_I2C_CLIENTS_NUMBER ] ;
114:                 
115:                 
116:                 // *****************************************************************************
117:                 /* Driver data objects.
118:                 
119:                   Summary:
120:                     Defines the data object.
121:                 
122:                   Description:
123:                     This data type defines the data objects. This is used to queue the user
124:                     requests for different operations.
125:                 
126:                   Remarks:
127:                     None
128:                 */
129:                 
130:                 static DRV_I2C_BUFFER_OBJECT	gDrvI2CBufferObj [ DRV_I2C_INSTANCES_NUMBER ][ DRV_I2C_NUM_OF_BUFFER_OBJECTS ];
131:                 
132:                 
133:                 /* This object maintains data that is required by all USART
134:                    driver instances. */
135:                 DRV_I2C_COMMON_DATA_OBJ gDrvI2CCommonDataObj;
136:                 
137:                 // *****************************************************************************
138:                 /* Driver Shared Object protection
139:                  */
140:                 static uint32_t i2cNumInited = 0;
141:                 
142:                 //static OSAL_MUTEX_DECLARE(i2cClientMutex);
143:                 
144:                 // *****************************************************************************
145:                 /* Macro: _DRV_I2C_CLIENT_OBJ(obj,mem)
146:                 
147:                   Summary:
148:                     Returns the appropriate client member
149:                 
150:                   Description:
151:                     Either return the static object or returns the indexed dynamic object.
152:                     This macro has variations for dynamic or static driver.
153:                 */
154:                 
155:                 #define _DRV_I2C_CLIENT_OBJ(obj,mem)    obj->mem
156:                 
157:                 
158:                 // *****************************************************************************
159:                 /* Macro: _DRV_I2C_CLIENT_OBJ_GET(obj)
160:                 
161:                   Summary:
162:                     Returns the appropriate client instance
163:                 
164:                   Description:
165:                     Either return the static object or returns the indexed dynamic object.
166:                     This macro has variations for dynamic or static driver.
167:                 */
168:                 
169:                 #define _DRV_I2C_CLIENT_OBJ_GET(obj)    &gDrvI2CClientObj[obj]
170:                 
171:                 // *****************************************************************************
172:                 /* Macro: _DRV_I2C_DATA_OBJ(obj,mem)
173:                 
174:                   Summary:
175:                     Returns the appropriate client member
176:                 
177:                   Description:
178:                     Either return the static object or returns the indexed dynamic object.
179:                     This macro has variations for dynamic or static driver.
180:                 */
181:                 
182:                 #define _DRV_I2C_DATA_OBJ(obj,mem)    ((DRV_I2C_BUFFER_OBJECT*)(obj))->mem
183:                 
184:                 // *****************************************************************************
185:                 /*
186:                  Upper address limit for a 7-bit address
187:                  */
188:                 
189:                 #define ADDRESS_7BIT_UPPER_LIMIT                    0xFF
190:                 
191:                 // *****************************************************************************
192:                 // *****************************************************************************
193:                 // Section: File Scope Functions
194:                 // *****************************************************************************
195:                 // *****************************************************************************
196:                 
197:                 static void _DRV_I2C_LockMutex(DRV_I2C_OBJ *dObj);
198:                 static void _DRV_I2C_UnlockMutex(DRV_I2C_OBJ *dObj);
199:                 static void _DRV_I2C_SetupHardware ( const I2C_MODULE_ID plibId,
200:                                                      DRV_I2C_OBJ *dObj,
201:                                                      DRV_I2C_INIT * i2cInit );
202:                 
203:                 // *****************************************************************************
204:                 /* Function:
205:                     DRV_I2C_BUFFER_OBJ* _DRV_I2C_QueueSlotGet ( DRV_I2C_OBJ *dObj )
206:                 
207:                   Summary:
208:                     Adds an element to the queue.
209:                 
210:                   Description:
211:                     This API adds an element to the queue.
212:                 
213:                   Parameters:
214:                     i2cDataObj   - Pointer to the structure which holds the data which is to be
215:                     				added to the queue.
216:                 
217:                   Returns:
218:                     DRV_I2C_BUFFER_HANDLE - Handle, a pointer to the allocated element in the
219:                     						queue.
220:                 */
221:                 DRV_I2C_BUFFER_OBJECT* _DRV_I2C_QueueSlotGet ( DRV_I2C_OBJ *dObj )
222:                 {
9D00A190  27BDFFE0   ADDIU SP, SP, -32
9D00A194  AFBF001C   SW RA, 28(SP)
9D00A198  AFB20018   SW S2, 24(SP)
9D00A19C  AFB10014   SW S1, 20(SP)
9D00A1A0  AFB00010   SW S0, 16(SP)
9D00A1A4  00808021   ADDU S0, A0, ZERO
223:                     uint8_t numOfFreeQueueSlots;
224:                     DRV_I2C_BUFFER_OBJECT *lQueueObj;
225:                     bool interruptEnableState = false;
226:                 
227:                     SYS_MODULE_INDEX drvIndex = dObj->drvIndex;
9D00A1A8  9492001C   LHU S2, 28(A0)
228:                 
229:                     if (dObj->interruptNestingCount == 0)
9D00A1AC  8C83006C   LW V1, 108(A0)
9D00A1B0  14600011   BNE V1, ZERO, 0x9D00A1F8
9D00A1B4  00001021   ADDU V0, ZERO, ZERO
230:                     {
231:                         Nop();
9D00A1B8  00000040   SSNOP
232:                         if (OSAL_MUTEX_Lock(&(dObj->mutexDriverInstance), OSAL_WAIT_FOREVER)  == OSAL_RESULT_TRUE)
9D00A1BC  24840064   ADDIU A0, A0, 100
9D00A1C0  0F405267   JAL OSAL_MUTEX_Lock
9D00A1C4  3405FFFF   ORI A1, ZERO, -1
9D00A1C8  24030001   ADDIU V1, ZERO, 1
9D00A1CC  14430061   BNE V0, V1, 0x9D00A354
9D00A1D0  00001021   ADDU V0, ZERO, ZERO
233:                         {
234:                             /* We will disable interrupts so that the queue
235:                                status does not get updated asynchronously.
236:                                This code will always execute. */
237:                 
238:                             if (dObj->i2cMode == DRV_I2C_MODE_MASTER)
9D00A1D4  8E020024   LW V0, 36(S0)
9D00A1D8  14400005   BNE V0, ZERO, 0x9D00A1F0
9D00A1DC  00000000   NOP
239:                             {
240:                                 interruptEnableState = _DRV_I2C_InterruptSourceDisable(dObj->mstrInterruptSource);
9D00A1E0  0F405058   JAL SYS_INT_SourceDisable
9D00A1E4  8E040034   LW A0, 52(S0)
9D00A1E8  0B40287F   J 0x9D00A1FC
9D00A1EC  8E110054   LW S1, 84(S0)
241:                             }
242:                             else
243:                             {
244:                                 interruptEnableState = _DRV_I2C_InterruptSourceDisable(dObj->slaveInterruptSource);
9D00A1F0  0F405058   JAL SYS_INT_SourceDisable
9D00A1F4  8E040038   LW A0, 56(S0)
245:                             }
246:                         }
247:                         else
248:                         {
249:                             /* The mutex acquisition timed out. Return with an
250:                                invalid handle. This code will not execute
251:                                if there is no RTOS. */
252:                             return (DRV_I2C_BUFFER_OBJECT*)NULL;;
253:                 
254:                         }
255:                     }
256:                 
257:                 //    _DRV_I2C_LockMutex(dObj);
258:                 
259:                     /* if position of item populated in the queue (Queue-In pointer) is greater
260:                      * than the position where the item is to be taken out of the queue,
261:                      * (Queue-Out pointer) then the number of free slots is the remainder of the
262:                      * slots excluding the slot index where Queue Out pointer resides to the
263:                      * slot index where Queue-In pointer resides.
264:                      * Ex: # of Queue Slots = 6, Queue-In = 5 and Queue-Out = 2
265:                      * Number of free queue available  = 6 -(5-2) - 1 = 2 (free slots - 6 & 1)
266:                      *
267:                      * if Queue-Out pointer is greater than Queue-In pointer but the Queue Out
268:                      * pointer is adjacent to Queue-In pointer (Queue-Out - Queue-In == 1)
269:                      * then buffer is full. Return 0 slots available if it's the case.
270:                      * If Queue-Out pointer is greater than Queue-In pointer then slots starting
271:                      * from Queue-In pointer to Queue-Out pointer is number of available queue
272:                      * slots
273:                      * Ex: # of Queue Slots = 6, Queue-Out = 4 and Queue-In = 2
274:                      * Number of free queue slots available  = 4-2-1 (free slots - 3)
275:                      */
276:                 
277:                     if (dObj->queueIn >= dObj->queueOut)
9D00A1F8  8E110054   LW S1, 84(S0)
9D00A1FC  8E030058   LW V1, 88(S0)
9D00A200  0223202B   SLTU A0, S1, V1
9D00A204  54800005   BNEL A0, ZERO, 0x9D00A21C
9D00A208  2463FFFF   ADDIU V1, V1, -1
278:                     {
279:                         numOfFreeQueueSlots =  (DRV_I2C_NUM_OF_BUFFER_OBJECTS - (dObj->queueIn - dObj->queueOut) -1);
9D00A20C  24630006   ADDIU V1, V1, 6
9D00A210  00711823   SUBU V1, V1, S1
9D00A214  0B402889   J 0x9D00A224
9D00A218  306300FF   ANDI V1, V1, 255
280:                     }
281:                     else
282:                     {
283:                         numOfFreeQueueSlots = ((dObj->queueOut - dObj->queueIn) -1);
9D00A21C  00711823   SUBU V1, V1, S1
9D00A220  306300FF   ANDI V1, V1, 255
284:                     }
285:                 
286:                     if (numOfFreeQueueSlots > 0)
9D00A224  1060002D   BEQ V1, ZERO, 0x9D00A2DC
9D00A228  26230001   ADDIU V1, S1, 1
287:                     {
288:                         lQueueObj = &gDrvI2CBufferObj [ drvIndex ][ dObj->queueIn ];
289:                 
290:                         dObj->queueIn++;
9D00A230  0004180A   MOVZ V1, ZERO, A0
291:                 
292:                         if ( dObj->queueIn >= DRV_I2C_NUM_OF_BUFFER_OBJECTS )
9D00A22C  2C640007   SLTIU A0, V1, 7
293:                         {
294:                             dObj->queueIn = 0;
295:                         }
296:                 
297:                         /* We are done. Restore the interrupt enable status
298:                            and return. */
299:                 
300:                         if(interruptEnableState)
9D00A234  10400017   BEQ V0, ZERO, 0x9D00A294
9D00A238  AE030054   SW V1, 84(S0)
301:                         {
302:                             if (dObj->i2cMode == DRV_I2C_MODE_MASTER)
9D00A23C  8E020024   LW V0, 36(S0)
9D00A240  5440000C   BNEL V0, ZERO, _DRV_I2C_QueueSlotGet::PLIB_INT_SourceEnable
9D00A244  8E020038   LW V0, 56(S0)
303:                             {
304:                                 _DRV_I2C_InterruptSourceEnable(dObj->mstrInterruptSource);
9D00A248  8E020034   LW V0, 52(S0)
305:                             }
306:                             else
307:                             {
308:                                  _DRV_I2C_InterruptSourceEnable(dObj->slaveInterruptSource);
309:                             }
310:                         }
311:                 
312:                         if(dObj->interruptNestingCount == 0)
9D00A26C  0B4028A6   J 0x9D00A298
9D00A270  8E02006C   LW V0, 108(S0)
9D00A294  8E02006C   LW V0, 108(S0)
9D00A298  54400004   BNEL V0, ZERO, 0x9D00A2AC
9D00A29C  001110C0   SLL V0, S1, 3
313:                         {
314:                             /* Release mutex */
315:                             OSAL_MUTEX_Unlock(&(dObj->mutexDriverInstance));
9D00A2A0  0F40541A   JAL OSAL_MUTEX_Unlock
9D00A2A4  26040064   ADDIU A0, S0, 100
316:                         }
317:                 
318:                 //        _DRV_I2C_UnlockMutex(dObj);
319:                         return lQueueObj;
9D00A2A8  001110C0   SLL V0, S1, 3
9D00A2AC  00118980   SLL S1, S1, 6
9D00A2B0  02228823   SUBU S1, S1, V0
9D00A2B4  001210C0   SLL V0, S2, 3
9D00A2B8  00129180   SLL S2, S2, 6
9D00A2BC  02429023   SUBU S2, S2, V0
9D00A2C0  001210C0   SLL V0, S2, 3
9D00A2C4  00529023   SUBU S2, V0, S2
9D00A2C8  02329021   ADDU S2, S1, S2
9D00A2CC  3C02A000   LUI V0, -24576
9D00A2D0  24426F48   ADDIU V0, V0, 28488
9D00A2D4  0B4028D5   J 0x9D00A354
9D00A2D8  00521021   ADDU V0, V0, S2
320:                     }
321:                 
322:                     if(interruptEnableState)
9D00A2DC  50400018   BEQL V0, ZERO, 0x9D00A340
9D00A2E0  8E03006C   LW V1, 108(S0)
323:                     {
324:                         if (dObj->i2cMode == DRV_I2C_MODE_MASTER)
9D00A2E4  8E020024   LW V0, 36(S0)
9D00A2E8  5440000C   BNEL V0, ZERO, _DRV_I2C_QueueSlotGet::PLIB_INT_SourceEnable
9D00A2EC  8E020038   LW V0, 56(S0)
325:                         {
326:                             _DRV_I2C_InterruptSourceEnable(dObj->mstrInterruptSource);
9D00A2F0  8E020034   LW V0, 52(S0)
327:                         }
328:                         else
329:                         {
330:                              _DRV_I2C_InterruptSourceEnable(dObj->slaveInterruptSource);
331:                         }
332:                     }
333:                 
334:                     if(dObj->interruptNestingCount == 0)
9D00A314  0B4028D0   J 0x9D00A340
9D00A318  8E03006C   LW V1, 108(S0)
9D00A33C  8E03006C   LW V1, 108(S0)
9D00A340  14600004   BNE V1, ZERO, 0x9D00A354
9D00A344  00001021   ADDU V0, ZERO, ZERO
335:                     {
336:                         /* Release mutex */
337:                         OSAL_MUTEX_Unlock(&(dObj->mutexDriverInstance));
9D00A348  0F40541A   JAL OSAL_MUTEX_Unlock
9D00A34C  26040064   ADDIU A0, S0, 100
9D00A350  00001021   ADDU V0, ZERO, ZERO
338:                     }
339:                 
340:                    return (DRV_I2C_BUFFER_OBJECT*)NULL;
341:                 }
9D00A354  8FBF001C   LW RA, 28(SP)
9D00A358  8FB20018   LW S2, 24(SP)
9D00A35C  8FB10014   LW S1, 20(SP)
9D00A360  8FB00010   LW S0, 16(SP)
9D00A364  03E00008   JR RA
9D00A368  27BD0020   ADDIU SP, SP, 32
342:                 
343:                 DRV_I2C_BUFFER_OBJECT* _DRV_I2C_QueueTailReset ( SYS_MODULE_INDEX drvIndex )
344:                 {
345:                 
346:                     DRV_I2C_BUFFER_OBJECT *lQueueObj;
347:                 
348:                     lQueueObj = &gDrvI2CBufferObj [ drvIndex ][ 0 ];
349:                 
350:                     return lQueueObj;
351:                 }
352:                 
353:                 
354:                 // *****************************************************************************
355:                 /* Function:
356:                     DRV_I2C_BUFFER_OBJ* _DRV_I2C_QueuePop ( DRV_I2C_OBJ *dObj )
357:                 
358:                   Summary:
359:                     Removes a element from the queue
360:                 
361:                   Description:
362:                     This API removes an element from the queue
363:                 
364:                   Parameters:
365:                     i2cDataObj   - Pointer to the data structure to be removed from the queue
366:                 
367:                   Returns:
368:                     DRV_I2C_BUFFER_HANDLE - Handle, a pointer to the next allocated element in the
369:                     						queue.
370:                 */
371:                 
372:                 DRV_I2C_BUFFER_OBJECT * _DRV_I2C_QueuePop( DRV_I2C_OBJ *dObj)
373:                 {
374:                     SYS_MODULE_INDEX drvIndex = dObj->drvIndex;
375:                 
376:                     // Make sure that the pointer is valid inside out allocated space.
377:                     if (dObj < &gDrvI2CObj[0] || dObj > &gDrvI2CObj[DRV_I2C_INSTANCES_NUMBER-1])
9D011F00  3C03A000   LUI V1, -24576
9D011F04  246370F4   ADDIU V1, V1, 28916
9D011F08  14830020   BNE A0, V1, 0x9D011F8C
9D011F0C  9482001C   LHU V0, 28(A0)
378:                     {
379:                             return NULL;
9D011F8C  03E00008   JR RA
9D011F90  00001021   ADDU V0, ZERO, ZERO
380:                     }
381:                     // Make sure that this driver instance is actually in use.
382:                     if (dObj->inUse != true)
9D011F10  3C03A000   LUI V1, -24576
9D011F14  90637112   LBU V1, 28946(V1)
9D011F18  1060001E   BEQ V1, ZERO, 0x9D011F94
9D011F1C  3C04A000   LUI A0, -24576
383:                     {
384:                             return NULL;
385:                     }
386:                 
387:                     DRV_I2C_BUFFER_OBJECT * ret = &gDrvI2CBufferObj [ drvIndex ][ dObj->queueOut ];
9D011F20  248470F4   ADDIU A0, A0, 28916
9D011F24  8C830058   LW V1, 88(A0)
388:                 
389:                     if (dObj->i2cMode == DRV_I2C_MODE_SLAVE )
9D011F28  8C850024   LW A1, 36(A0)
9D011F2C  24040001   ADDIU A0, ZERO, 1
9D011F30  14A4000A   BNE A1, A0, 0x9D011F5C
9D011F34  000320C0   SLL A0, V1, 3
390:                     {
391:                         if ( dObj->queueOut >= (DRV_I2C_NUM_OF_BUFFER_OBJECTS-1) )
9D011F38  2C640006   SLTIU A0, V1, 6
9D011F3C  14800004   BNE A0, ZERO, 0x9D011F50
9D011F40  24650001   ADDIU A1, V1, 1
392:                         {
393:                             dObj->queueOut = 0;
9D011F44  3C04A000   LUI A0, -24576
9D011F48  0B4047D6   J 0x9D011F58
9D011F4C  AC80714C   SW ZERO, 29004(A0)
394:                         }
395:                         else
396:                         {
397:                             dObj->queueOut++;
9D011F50  3C04A000   LUI A0, -24576
9D011F54  AC85714C   SW A1, 29004(A0)
398:                         }
399:                     }
400:                 
401:                     return ret;
9D011F58  000320C0   SLL A0, V1, 3
9D011F5C  00031980   SLL V1, V1, 6
9D011F60  00641823   SUBU V1, V1, A0
9D011F64  000220C0   SLL A0, V0, 3
9D011F68  00021180   SLL V0, V0, 6
9D011F6C  00441023   SUBU V0, V0, A0
9D011F70  000220C0   SLL A0, V0, 3
9D011F74  00821023   SUBU V0, A0, V0
9D011F78  00621021   ADDU V0, V1, V0
9D011F7C  3C03A000   LUI V1, -24576
9D011F80  24636F48   ADDIU V1, V1, 28488
9D011F84  03E00008   JR RA
9D011F88  00621021   ADDU V0, V1, V0
402:                 }
9D011F94  03E00008   JR RA
9D011F98  00001021   ADDU V0, ZERO, ZERO
403:                 
404:                 
405:                 void _DRV_I2C_Advance_Queue( DRV_I2C_OBJ *dObj )
406:                 {
407:                 
408:                     if (dObj->i2cMode == DRV_I2C_MODE_MASTER &&
9D014C3C  8C820024   LW V0, 36(A0)
9D014C40  1440000A   BNE V0, ZERO, 0x9D014C6C
9D014C44  00000000   NOP
9D014C4C  8C830054   LW V1, 84(A0)
9D014C50  10430006   BEQ V0, V1, 0x9D014C6C
9D014C54  2C430006   SLTIU V1, V0, 6
409:                             (dObj->queueOut != dObj->queueIn))
9D014C48  8C820058   LW V0, 88(A0)
410:                     {
411:                         if ( dObj->queueOut >= (DRV_I2C_NUM_OF_BUFFER_OBJECTS-1) )
9D014C58  14600003   BNE V1, ZERO, 0x9D014C68
9D014C5C  24420001   ADDIU V0, V0, 1
9D014C60  03E00008   JR RA
9D014C64  AC800058   SW ZERO, 88(A0)
412:                         {
413:                             dObj->queueOut = 0;
414:                         }
415:                         else
416:                         {
417:                             dObj->queueOut++;
9D014C68  AC820058   SW V0, 88(A0)
9D014C6C  03E00008   JR RA
9D014C70  00000000   NOP
418:                         }
419:                     }
420:                 }
421:                 
422:                 // *****************************************************************************
423:                 /* Function:
424:                     DRV_I2C_BUFFER_OBJ* _DRV_I2C_IsQueueEmpty (DRV_I2C_OBJ *dObj)
425:                 
426:                   Summary:
427:                     Checks if the queue is empty
428:                 
429:                   Description:
430:                     This API checks if the end of queue has been reached or if the tail pointer
431:                     is at the same location as the head pointer. If the tail pointer and head
432:                     pointer coincide, it implies that the queue is empty
433:                 
434:                   Parameters:
435:                     i2cDataObj   - Pointer to the data structure to be removed from the queue
436:                     i2cbufferObj - Pointer to buffer where i2c objects are stored
437:                   Returns:
438:                     None
439:                 */
440:                 
441:                 bool _DRV_I2C_IsQueueEmpty(DRV_I2C_OBJ *dObj)
442:                 {
443:                 
444:                 //    DRV_I2C_BUFFER_OBJECT * temp;
445:                     // Make sure that the pointer is valid inside out allocated space.
446:                     if (dObj < &gDrvI2CObj[0] || dObj > &gDrvI2CObj[DRV_I2C_INSTANCES_NUMBER-1])
9D014A98  3C03A000   LUI V1, -24576
9D014A9C  246370F4   ADDIU V1, V1, 28916
9D014AA0  1464000A   BNE V1, A0, 0x9D014ACC
9D014AA4  00001021   ADDU V0, ZERO, ZERO
447:                     {
448:                         return false;
449:                     }
450:                     // Make sure that this driver instance is actually in use.
451:                     if (dObj->inUse != true)
9D014AA8  3C02A000   LUI V0, -24576
9D014AAC  90427112   LBU V0, 28946(V0)
9D014AB0  10400006   BEQ V0, ZERO, 0x9D014ACC
9D014AB4  3C03A000   LUI V1, -24576
452:                     {
453:                         return false;
454:                     }
455:                 
456:                 
457:                     if (dObj->queueOut == dObj->queueIn)
9D014AB8  246370F4   ADDIU V1, V1, 28916
9D014ABC  8C640058   LW A0, 88(V1)
9D014AC0  8C620054   LW V0, 84(V1)
9D014AC4  00821026   XOR V0, A0, V0
9D014AC8  2C420001   SLTIU V0, V0, 1
458:                         return true;
459:                 
460:                     return false;
461:                 
462:                 
463:                 }
9D014ACC  03E00008   JR RA
9D014AD0  00000000   NOP
464:                 
465:                 // *****************************************************************************
466:                 /* Function:
467:                     DRV_I2C_BUFFER_OBJ* _DRV_I2C_QueuePush (DRV_I2C_OBJ *dObj, DRV_I2C_BUFFER_OBJECT *buf)
468:                 
469:                   Summary:
470:                  Adds a DRV_I2C_OBJ into a I2C Buffer Object
471:                 
472:                   Description:
473:                     This API adds an DRV_I2C_OBJ into a buffer containing I2C objects
474:                 
475:                   Parameters:
476:                     i2cDataObj   - Pointer to the data structure to be removed from the queue
477:                     i2cbufferObj - Pointer to buffer where i2c objects are stored
478:                   Returns:
479:                     None
480:                 */
481:                 
482:                 void _DRV_I2C_QueuePush(DRV_I2C_OBJ *dObj, DRV_I2C_BUFFER_OBJECT *buf)
483:                 {
484:                 
485:                     SYS_MODULE_INDEX drvIndex=(SYS_MODULE_INDEX)0;
486:                 
487:                     // Make sure that the pointer is valid inside out allocated space.
488:                     if (dObj < &gDrvI2CObj[0] || dObj > &gDrvI2CObj[DRV_I2C_INSTANCES_NUMBER-1])
9D01152C  3C02A000   LUI V0, -24576
9D011530  244270F4   ADDIU V0, V0, 28916
9D011534  1444002A   BNE V0, A0, 0x9D0115E0
9D011538  3C02A000   LUI V0, -24576
489:                     {
490:                 	return;
491:                     }
492:                     // Make sure that this driver instance is actually in use.
493:                     if (dObj->inUse != true)
9D01153C  90427112   LBU V0, 28946(V0)
9D011540  10400027   BEQ V0, ZERO, 0x9D0115E0
9D011544  3C02A000   LUI V0, -24576
494:                     {
495:                     	return;
496:                     }
497:                 
498:                     drvIndex = dObj->drvIndex;
499:                     if (buf < &gDrvI2CBufferObj[drvIndex][0] || buf > &gDrvI2CBufferObj[drvIndex][DRV_I2C_NUM_OF_BUFFER_OBJECTS])
9D011548  94427110   LHU V0, 28944(V0)
9D01154C  000218C0   SLL V1, V0, 3
9D011550  00022180   SLL A0, V0, 6
9D011554  00831823   SUBU V1, A0, V1
9D011558  000320C0   SLL A0, V1, 3
9D01155C  00831823   SUBU V1, A0, V1
9D011560  3C04A000   LUI A0, -24576
9D011564  24846F48   ADDIU A0, A0, 28488
9D011568  00831821   ADDU V1, A0, V1
9D01156C  00A3182B   SLTU V1, A1, V1
9D011570  1460001B   BNE V1, ZERO, 0x9D0115E0
9D011574  24440001   ADDIU A0, V0, 1
9D011578  000430C0   SLL A2, A0, 3
9D01157C  00041980   SLL V1, A0, 6
9D011580  00661823   SUBU V1, V1, A2
9D011584  000320C0   SLL A0, V1, 3
9D011588  00831823   SUBU V1, A0, V1
9D01158C  3C04A000   LUI A0, -24576
9D011590  24846F48   ADDIU A0, A0, 28488
9D011594  00831821   ADDU V1, A0, V1
9D011598  0065282B   SLTU A1, V1, A1
9D01159C  14A00010   BNE A1, ZERO, 0x9D0115E0
9D0115A0  3C03A000   LUI V1, -24576
500:                     {
501:                     	return;
502:                     }
503:                 
504:                     dObj->queueHead = &gDrvI2CBufferObj[drvIndex][dObj->queueIn];
9D0115A4  246370F4   ADDIU V1, V1, 28916
9D0115A8  8C640054   LW A0, 84(V1)
9D0115AC  000428C0   SLL A1, A0, 3
9D0115B0  00042180   SLL A0, A0, 6
9D0115B4  00852023   SUBU A0, A0, A1
9D0115B8  000228C0   SLL A1, V0, 3
9D0115BC  00021180   SLL V0, V0, 6
9D0115C0  00451023   SUBU V0, V0, A1
9D0115C4  000228C0   SLL A1, V0, 3
9D0115C8  00A21023   SUBU V0, A1, V0
9D0115CC  00821021   ADDU V0, A0, V0
9D0115D0  3C04A000   LUI A0, -24576
9D0115D4  24846F48   ADDIU A0, A0, 28488
9D0115D8  00821021   ADDU V0, A0, V0
9D0115DC  AC62004C   SW V0, 76(V1)
9D0115E0  03E00008   JR RA
9D0115E4  00000000   NOP
505:                     return;
506:                 }
507:                 
508:                 
509:                 //******************************************************************************
510:                 /* Function:
511:                     static void _DRV_I2C_SetupHardware ( const I2C_MODULE_ID   plibId,
512:                                                         DRV_I2C_OBJ_HANDLE     dObj,
513:                                                         DRV_I2C_INIT         * i2cInit )
514:                 
515:                   Summary:
516:                     Sets up the hardware from the initialization structure
517:                 
518:                   Description:
519:                     This routine sets up the hardware from the initialization structure.
520:                 
521:                   Remarks:
522:                     None.
523:                 */
524:                 
525:                 static void _DRV_I2C_SetupHardware ( const I2C_MODULE_ID plibId,
526:                                                      DRV_I2C_OBJ *dObj,
527:                                                      DRV_I2C_INIT * i2cInit )
528:                 {
529:                     /* Initialize the Interrupt Sources */
530:                     dObj->mstrInterruptSource   = i2cInit->mstrInterruptSource;
9D006100  8E030034   LW V1, 52(S0)
9D006104  AC430034   SW V1, 52(V0)
531:                     dObj->slaveInterruptSource  = i2cInit->slaveInterruptSource;
9D006108  8E030038   LW V1, 56(S0)
9D00610C  AC430038   SW V1, 56(V0)
532:                     dObj->errInterruptSource    = i2cInit->errInterruptSource;
9D006110  8E03003C   LW V1, 60(S0)
9D006114  AC43003C   SW V1, 60(V0)
533:                 
534:                     /* Power state initialization */
535:                     if( _DRV_I2C_POWER_STATE_GET( i2cInit->moduleInit.value ) == SYS_MODULE_POWER_IDLE_STOP )
9D006118  92020000   LBU V0, 0(S0)
9D00611C  24030002   ADDIU V1, ZERO, 2
9D006120  54430005   BNEL V0, V1, DRV_I2C_Initialize::_DRV_I2C_SetupHardware
9D006124  24030003   ADDIU V1, ZERO, 3
536:                     {
537:                         PLIB_I2C_StopInIdleEnable( plibId  );
538:                     }
539:                     else if( ( _DRV_I2C_POWER_STATE_GET( i2cInit->moduleInit.value ) == SYS_MODULE_POWER_IDLE_RUN ) ||
9D006138  50430005   BEQL V0, V1, 0x9D006150
9D00613C  24022000   ADDIU V0, ZERO, 8192
9D006140  2403000F   ADDIU V1, ZERO, 15
9D006144  54430005   BNEL V0, V1, DRV_I2C_Initialize::_DRV_I2C_SetupHardware
9D006148  8E030000   LW V1, 0(S0)
540:                                 ( _DRV_I2C_POWER_STATE_GET( i2cInit->moduleInit.value ) == SYS_MODULE_POWER_RUN_FULL ) )
541:                     {
542:                         PLIB_I2C_StopInIdleDisable( plibId  );
543:                     }
544:                     else
545:                     {
546:                         if( _DRV_I2C_POWER_STATE_GET( i2cInit->moduleInit.sys.powerState ) == SYS_MODULE_POWER_IDLE_STOP )
9D00615C  3063000F   ANDI V1, V1, 15
9D006160  24020002   ADDIU V0, ZERO, 2
9D006164  54620004   BNEL V1, V0, 0x9D006178
9D006168  8E030008   LW V1, 8(S0)
547:                         {
548:                             PLIB_I2C_StopInIdleEnable( plibId  );
549:                         }
550:                     }
551:                 
552:                      /* Set I2C operational mode -- Master or Slave */
553:                      dObj->i2cMode = _DRV_I2C_OPERATION_MODE_GET(i2cInit->i2cMode);
9D006130  0B40185E   J 0x9D006178
9D006134  8E030008   LW V1, 8(S0)
9D006154  0B40185E   J 0x9D006178
9D006158  8E030008   LW V1, 8(S0)
9D006174  8E030008   LW V1, 8(S0)
9D006178  3C02A000   LUI V0, -24576
9D00617C  244270F4   ADDIU V0, V0, 28916
9D006180  AC430024   SW V1, 36(V0)
554:                     /* assign SCL and SDA ports for bit banging purposes*/
555:                     dObj->portSCL   = i2cInit->portSCL;
9D006184  8E030010   LW V1, 16(S0)
9D006188  AC43000C   SW V1, 12(V0)
556:                     dObj->pinSCL    = i2cInit->pinSCL;
9D00618C  8E030014   LW V1, 20(S0)
9D006190  AC430010   SW V1, 16(V0)
557:                     dObj->portSDA   = i2cInit->portSDA;
9D006194  8E030018   LW V1, 24(S0)
9D006198  AC430014   SW V1, 20(V0)
558:                     dObj->pinSDA    = i2cInit->pinSDA;
9D00619C  8E03001C   LW V1, 28(S0)
9D0061A0  AC430018   SW V1, 24(V0)
559:                 
560:                 
561:                      /* Set Baud Rate */
562:                      if ( DRV_I2C_MODE_MASTER == _DRV_I2C_OPERATION_MODE_GET(i2cInit->i2cMode))
9D0061A4  8E020008   LW V0, 8(S0)
9D0061A8  54400013   BNEL V0, ZERO, 0x9D0061F8
9D0061AC  8E020028   LW V0, 40(S0)
563:                      {
564:                         PLIB_I2C_BaudRateSet ( plibId, SYS_CLK_PeripheralFrequencyGet(CLK_BUS_PERIPHERAL_1),
9D0061B0  0F405679   JAL SYS_CLK_PeripheralFrequencyGet
9D0061B4  00002021   ADDU A0, ZERO, ZERO
565:                                                 _DRV_I2C_BAUD_RATE_VALUE_GET(i2cInit->baudRate) );
566:                         dObj->modulemainstate = DRV_I2C_MODULE_IDLE;
9D0061EC  3C02A000   LUI V0, -24576
9D0061F0  AC407138   SW ZERO, 28984(V0)
567:                      }
568:                 
569:                      /* Set SLEW rate based on baud-rate; if baud-rate is either <= 100k
570:                         OR baud-rate = 1M; I2C2xCON.DISSLW = 1  */
571:                     if (_DRV_I2C_BAUD_RATE_VALUE_GET(i2cInit->baudRate) <= 100000 ||
9D0061F4  8E020028   LW V0, 40(S0)
9D0061F8  3C030001   LUI V1, 1
9D0061FC  346386A1   ORI V1, V1, -31071
9D006200  0043182B   SLTU V1, V0, V1
9D006204  54600005   BNEL V1, ZERO, DRV_I2C_Initialize::_DRV_I2C_SetupHardware::PLIB_I2C_HighFrequencyEnable
9D006208  24020200   ADDIU V0, ZERO, 512
9D00620C  3C03000F   LUI V1, 15
9D006210  24634240   ADDIU V1, V1, 16960
9D006214  14430004   BNE V0, V1, DRV_I2C_Initialize::_DRV_I2C_SetupHardware
9D006218  24020200   ADDIU V0, ZERO, 512
572:                             _DRV_I2C_BAUD_RATE_VALUE_GET(i2cInit->baudRate) == 1000000 )
573:                     {
574:                         PLIB_I2C_HighFrequencyEnable(plibId);
575:                     }
576:                      else
577:                     {
578:                         PLIB_I2C_HighFrequencyDisable(plibId);
579:                     }
580:                 
581:                     /* SMBus Input Level */
582:                     dObj->buslevel = _DRV_I2C_SMBus_LEVEL_GET(i2cInit->buslevel);
9D006220  0B40188C   J 0x9D006230
9D006224  8E03002C   LW V1, 44(S0)
9D00622C  8E03002C   LW V1, 44(S0)
9D006230  3C02A000   LUI V0, -24576
9D006234  AC437124   SW V1, 28964(V0)
583:                 
584:                     /* Slave Address width select */
585:                     if ( DRV_I2C_MODE_SLAVE == _DRV_I2C_OPERATION_MODE_GET(i2cInit->i2cMode))
9D006238  8E030008   LW V1, 8(S0)
9D00623C  24020001   ADDIU V0, ZERO, 1
9D006240  54620029   BNEL V1, V0, 0x9D0062E8
9D006244  92030024   LBU V1, 36(S0)
586:                     {
587:                         dObj->modulemainstate = DRV_I2C_MODULE_IDLE;
9D006248  3C02A000   LUI V0, -24576
9D00624C  AC407138   SW ZERO, 28984(V0)
588:                 
589:                         if (DRV_I2C_7BIT_SLAVE == _DRV_I2C_ADDRESS_WIDTH_GET(i2cInit->addWidth))
9D006250  8E030020   LW V1, 32(S0)
9D006254  24020001   ADDIU V0, ZERO, 1
9D006258  14620007   BNE V1, V0, DRV_I2C_Initialize::_DRV_I2C_SetupHardware
9D00625C  96020026   LHU V0, 38(S0)
590:                             PLIB_I2C_SlaveAddress7BitSet(plibId, (I2C_SLAVE_ADDRESS_7bit)(i2cInit->slaveaddvalue>>1));
591:                         else
592:                             PLIB_I2C_SlaveAddress10BitSet (plibId,(i2cInit->slaveaddvalue>>1) );
593:                 
594:                         PLIB_I2C_SlaveClockStretchingEnable(plibId);
595:                         PLIB_I2C_ReservedAddressProtectEnable(plibId);
596:                         PLIB_I2C_GeneralCallDisable ( plibId );
597:                         PLIB_I2C_ReservedAddressProtectEnable(plibId);
598:                         PLIB_I2C_SlaveMask7BitSet ( plibId, i2cInit->maskslaveaddress );
599:                         _DRV_I2C_InterruptSourceEnable( dObj->slaveInterruptSource ) ;
9D0062AC  3C02A000   LUI V0, -24576
9D0062B0  8C42712C   LW V0, 28972(V0)
600:                         SYS_INT_SourceStatusClear(dObj->slaveInterruptSource);
601:                     }
602:                 
603:                     /* Allow reserved slave address */
604:                      dObj->reservedaddenable = _DRV_I2C_RESERVED_ADDRESS_EN_GET(i2cInit->reservedaddenable);
9D0062E4  92030024   LBU V1, 36(S0)
9D0062E8  3C02A000   LUI V0, -24576
9D0062EC  244270F4   ADDIU V0, V0, 28916
9D0062F0  A043002C   SB V1, 44(V0)
605:                 
606:                 } /* _DRV_I2C_SetupHardware */
607:                 
608:                 //******************************************************************************
609:                 /* Function:
610:                     static void _DRV_I2C_LockMutex(DRV_I2C_OBJ *dObj)
611:                 
612:                  Summary:
613:                     Invokes OSAL call
614:                 
615:                  Parameters:
616:                     i2cDataObj   - Pointer to the structure which holds the data which is to be
617:                     				added to the queue.
618:                 
619:                   Remarks:
620:                     None.
621:                 */
622:                 
623:                 void _DRV_I2C_LockMutex(DRV_I2C_OBJ *dObj)
624:                 {
625:                     bool tmp = false;
626:                     tmp = tmp; // Remove compile warning
627:                     Nop();
9D00E4D0  00000040   SSNOP
628:                     if (OSAL_MUTEX_Lock(&dObj->mutexDriverInstance, OSAL_WAIT_FOREVER)  != OSAL_RESULT_TRUE) {/* Report error*/}
9D00E4D4  3C04A000   LUI A0, -24576
9D00E4D8  24847158   ADDIU A0, A0, 29016
9D00E4DC  0F405267   JAL OSAL_MUTEX_Lock
9D00E4E0  3405FFFF   ORI A1, ZERO, -1
629:                 } /*    _DRV_I2C_LockMutex  */
630:                 
631:                 //******************************************************************************
632:                 /* Function:
633:                     static void _DRV_I2C_UnlockMutex(DRV_I2C_OBJ *dObj)
634:                 
635:                  Summary:
636:                     Invokes OSAL call
637:                 
638:                  Parameters:
639:                     i2cDataObj   - Pointer to the structure which holds the data which is to be
640:                     				added to the queue.
641:                 
642:                   Remarks:
643:                     None.
644:                 */
645:                 
646:                 void _DRV_I2C_UnlockMutex(DRV_I2C_OBJ *dObj)
647:                 {
648:                     bool tmp = false;
649:                     tmp = tmp; // Remove compile warning
650:                     if (OSAL_MUTEX_Unlock(&dObj->mutexDriverInstance)  != OSAL_RESULT_TRUE) {/* Report error*/}
9D00E510  3C04A000   LUI A0, -24576
9D00E524  0F40541A   JAL OSAL_MUTEX_Unlock
9D00E528  24847158   ADDIU A0, A0, 29016
651:                 } /* _DRV_I2C_UnlockMutex */
652:                 
653:                 
654:                 // *****************************************************************************
655:                 // *****************************************************************************
656:                 // Section: Driver Interface Function Definitions
657:                 // *****************************************************************************
658:                 // *****************************************************************************
659:                 
660:                 //******************************************************************************
661:                 /* Function:
662:                     SYS_MODULE_OBJ DRV_I2C_Initialize ( const SYS_MODULE_INDEX  index,
663:                                                        const SYS_MODULE_INIT * const init )
664:                 
665:                   Summary:
666:                     Initializes hardware and data for the given instance of the I2C module
667:                 
668:                   Description:
669:                     This routine initializes hardware for the instance of the I2C module,
670:                     using the hardware initialization given data.  It also initializes all
671:                     necessary internal data.
672:                 
673:                   Parameters:
674:                     index           - Identifies the driver instance to be initialized
675:                 
676:                     init            - Pointer to the data structure containing all data
677:                                       necessary to initialize the hardware. This pointer may
678:                                       be null if no data is required and static initialization
679:                                       values are to be used.
680:                 
681:                   Returns:
682:                     If successful, returns a valid handle to a driver instance object.
683:                     Otherwise, it returns SYS_MODULE_OBJ_INVALID.
684:                 */
685:                 
686:                 SYS_MODULE_OBJ DRV_I2C_Initialize ( const SYS_MODULE_INDEX   drvIndex,
687:                                                    const SYS_MODULE_INIT    * const init )
688:                 {
9D006084  27BDFFE0   ADDIU SP, SP, -32
9D006088  AFBF001C   SW RA, 28(SP)
9D00608C  AFB10018   SW S1, 24(SP)
9D006090  AFB00014   SW S0, 20(SP)
689:                     DRV_I2C_INIT * i2cInit;
690:                     I2C_MODULE_ID i2cId;
691:                 
692:                     uint16_t index;
693:                     DRV_I2C_BUFFER_OBJECT   *lBufferObj;
694:                 
695:                     /* Validate the driver index */
696:                     if ( drvIndex >= DRV_I2C_INSTANCES_NUMBER )
9D00606C  148000EA   BNE A0, ZERO, 0x9D006418
9D006070  2403FFFF   ADDIU V1, ZERO, -1
697:                     {
698:                         return SYS_MODULE_OBJ_INVALID;
699:                     }
700:                     DRV_I2C_OBJ *dObj = _DRV_I2C_INSTANCE_GET ( drvIndex );
701:                 
702:                     /* Cheap dead man's mutex during initialization to make sure two different
703:                        tasks don't try to initialize the same driver at the same time.*/
704:                 
705:                     if (dObj->inUse)
9D006074  3C02A000   LUI V0, -24576
9D006078  90427112   LBU V0, 28946(V0)
9D00607C  144000E6   BNE V0, ZERO, 0x9D006418
9D006080  00000000   NOP
706:                     {
707:                         return SYS_MODULE_OBJ_INVALID;
708:                     }
709:                 
710:                     if (i2cNumInited == 0)
9D006094  8F82806C   LW V0, -32660(GP)
9D006098  1440000C   BNE V0, ZERO, 0x9D0060CC
9D00609C  00A08021   ADDU S0, A1, ZERO
711:                     {
712:                         memset(gDrvI2CClientObj, 0, sizeof(gDrvI2CClientObj));
9D0060A0  3C03A000   LUI V1, -24576
9D0060A4  AC6070D0   SW ZERO, 28880(V1)
9D0060A8  246370D0   ADDIU V1, V1, 28880
9D0060AC  AC600004   SW ZERO, 4(V1)
9D0060B0  AC600008   SW ZERO, 8(V1)
9D0060B4  AC60000C   SW ZERO, 12(V1)
9D0060B8  AC600010   SW ZERO, 16(V1)
9D0060BC  AC600014   SW ZERO, 20(V1)
9D0060C0  AC600018   SW ZERO, 24(V1)
9D0060C4  AC60001C   SW ZERO, 28(V1)
9D0060C8  AC600020   SW ZERO, 32(V1)
713:                     }
714:                 
715:                     i2cNumInited++;
9D0060CC  24420001   ADDIU V0, V0, 1
9D0060D0  AF82806C   SW V0, -32660(GP)
716:                 
717:                     /* Assign to the local pointer the init data passed */
718:                     i2cInit = ( DRV_I2C_INIT * ) init;
719:                 
720:                     /* Object is valid, set it in use */
721:                     dObj->inUse = true;
9D0060D4  3C02A000   LUI V0, -24576
9D0060D8  244270F4   ADDIU V0, V0, 28916
9D0060DC  24030001   ADDIU V1, ZERO, 1
9D0060E0  A043001E   SB V1, 30(V0)
722:                 
723:                     /* Save the index of the driver. Important to know this
724:                     as we are using reference based accessing */
725:                     dObj->drvIndex = drvIndex;
9D0060E4  A440001C   SH ZERO, 28(V0)
726:                 
727:                     /* Update the I2C Module Index */
728:                     dObj->i2cId = i2cInit->i2cId;
9D0060E8  8E110004   LW S1, 4(S0)
9D0060EC  AC510004   SW S1, 4(V0)
729:                 
730:                     /* set QueueHead to NULL */
731:                     dObj->queueHead = NULL;
9D0060F0  AC40004C   SW ZERO, 76(V0)
732:                 
733:                     /* initialize QueueTail to NULL */
734:                     dObj->queueTail = NULL;
9D0060F4  AC400050   SW ZERO, 80(V0)
735:                 
736:                     dObj->queueIn = 0;
9D0060F8  AC400054   SW ZERO, 84(V0)
737:                 
738:                     dObj->queueOut = 0;
9D0060FC  AC400058   SW ZERO, 88(V0)
739:                 
740:                     /* Speed up accessing, take it to a local variable */
741:                     i2cId = dObj->i2cId;
742:                 
743:                     /* Setup the Hardware */
744:                     _DRV_I2C_SetupHardware ( i2cId, dObj, i2cInit );
745:                 
746:                     /* Reset the number of clients */
747:                     dObj->numClients = 0;
9D0062F4  A0400020   SB ZERO, 32(V0)
748:                 
749:                     /* Reset the locally used variables */
750:                     dObj->lastClientHandle  = DRV_I2C_CLIENTS_NUMBER+1;
9D0062F8  24030002   ADDIU V1, ZERO, 2
9D0062FC  AC43005C   SW V1, 92(V0)
751:                 
752:                     dObj->operationStarting = i2cInit->operationStarting;
9D006300  8E030044   LW V1, 68(S0)
9D006304  AC430068   SW V1, 104(V0)
9D006308  3C02A000   LUI V0, -24576
9D00630C  24426F48   ADDIU V0, V0, 28488
9D006310  24430188   ADDIU V1, V0, 392
753:                 
754:                 
755:                     for ( index=0; index<DRV_I2C_NUM_OF_BUFFER_OBJECTS; index++ )
9D006320  5443FFFD   BNEL V0, V1, 0x9D006318
9D006324  A0400000   SB ZERO, 0(V0)
756:                     {
757:                         lBufferObj = &gDrvI2CBufferObj [ drvIndex ][ index ];
758:                 
759:                         lBufferObj->inUse   = false;
9D006314  A0400000   SB ZERO, 0(V0)
760:                         lBufferObj->next    = NULL;
9D006318  AC400030   SW ZERO, 48(V0)
9D00631C  24420038   ADDIU V0, V0, 56
761:                     }
762:                 
763:                     /* Interrupt flag cleared on the safer side */
764:                 
765:                     _DRV_I2C_InterruptSourceClear( dObj->mstrInterruptSource );
9D006328  3C04A000   LUI A0, -24576
9D00632C  248270F4   ADDIU V0, A0, 28916
9D006330  8C450034   LW A1, 52(V0)
766:                     _DRV_I2C_InterruptSourceClear( dObj->slaveInterruptSource );
9D006354  8C450038   LW A1, 56(V0)
767:                     _DRV_I2C_InterruptSourceClear( dObj->errInterruptSource );
9D00636C  8C45003C   LW A1, 60(V0)
768:                 
769:                     /* Set the current driver state */
770:                     dObj->status = SYS_STATUS_READY;
9D006384  24030002   ADDIU V1, ZERO, 2
9D006388  AC8370F4   SW V1, 28916(A0)
771:                 
772:                     dObj->interruptNestingCount = 0;
9D00638C  AC40006C   SW ZERO, 108(V0)
773:                 
774:                         /* Create the hardware instance mutex. */
775:                     if(OSAL_MUTEX_Create(&(dObj->mutexDriverInstance)) != OSAL_RESULT_TRUE)
9D006390  3C04A000   LUI A0, -24576
9D006394  0F4052B5   JAL OSAL_MUTEX_Create
9D006398  24847158   ADDIU A0, A0, 29016
9D00639C  14500018   BNE V0, S0, 0x9D006400
9D0063A0  2403FFFF   ADDIU V1, ZERO, -1
776:                     {
777:                        return SYS_MODULE_OBJ_INVALID;
778:                     }
779:                 
780:                         /* Check if the global mutexes have been created. If not
781:                        then create these. */
782:                 
783:                     if(!gDrvI2CCommonDataObj.membersAreInitialized)
9D0063A4  3C02A000   LUI V0, -24576
9D0063A8  90420B84   LBU V0, 2948(V0)
9D0063AC  14400011   BNE V0, ZERO, 0x9D0063F4
9D0063B0  34028000   ORI V0, ZERO, -32768
784:                     {
785:                         /* This means that mutexes where not created. Create them. */
786:                         if(OSAL_MUTEX_Create(&(gDrvI2CCommonDataObj.mutexClientObjects)) != OSAL_RESULT_TRUE)
9D0063B4  3C04A000   LUI A0, -24576
9D0063B8  0F4052B5   JAL OSAL_MUTEX_Create
9D0063BC  24840B88   ADDIU A0, A0, 2952
9D0063C0  24040001   ADDIU A0, ZERO, 1
9D0063C4  1444000E   BNE V0, A0, 0x9D006400
9D0063C8  2403FFFF   ADDIU V1, ZERO, -1
787:                         {
788:                                  return SYS_MODULE_OBJ_INVALID;
789:                         }
790:                         if(OSAL_MUTEX_Create(&(gDrvI2CCommonDataObj.mutexBufferQueueObjects)) != OSAL_RESULT_TRUE)
9D0063CC  3C04A000   LUI A0, -24576
9D0063D0  0F4052B5   JAL OSAL_MUTEX_Create
9D0063D4  24840B8C   ADDIU A0, A0, 2956
9D0063D8  24040001   ADDIU A0, ZERO, 1
9D0063DC  14440008   BNE V0, A0, 0x9D006400
9D0063E0  2403FFFF   ADDIU V1, ZERO, -1
791:                         {
792:                                  return SYS_MODULE_OBJ_INVALID;
793:                         }
794:                         /* Set this flag so that global mutexes get allocated only once */
795:                         gDrvI2CCommonDataObj.membersAreInitialized = true;
9D0063E4  24030001   ADDIU V1, ZERO, 1
9D0063E8  3C02A000   LUI V0, -24576
9D0063EC  A0430B84   SB V1, 2948(V0)
796:                     }
797:                 
798:                     /* Enable the I2C module */
799:                     PLIB_I2C_Enable( i2cId ) ;
800:                 
801:                 
802:                         /* if device used is PIC32MZ-EC*/
803:                     #if defined  __PIC32MZ &&  (__PIC32_FEATURE_SET0 == 'E') && (__PIC32_FEATURE_SET1 == 'C')
804:                     /*   Errata for PIC32MZ where STOP condition is Bit-banged */
805:                         #ifdef MZ_EC_ERRATA_25_BB_STOP               //GJV
806:                             if (i2cInit->i2cMode == DRV_I2C_MODE_MASTER)
807:                             {
808:                                 /* assign SCL and SDA ports for bit banging purposes*/
809:                                 dObj->portSCL   = i2cInit->portSCL;
810:                                 dObj->pinSCL    = i2cInit->pinSCL;
811:                                 dObj->portSDA   = i2cInit->portSDA;
812:                                 dObj->pinSDA    = i2cInit->pinSDA;
813:                 
814:                                 /* set SDA to 0 */
815:                                 PLIB_PORTS_PinClear(PORTS_ID_0, dObj->portSDA, dObj->pinSDA);
816:                                 /* set SCL to 1 */
817:                                 PLIB_PORTS_PinSet(PORTS_ID_0, dObj->portSCL, dObj->pinSCL);
818:                                 /* set SDA to O/P */
819:                                 PLIB_PORTS_PinDirectionOutputSet(PORTS_ID_0, dObj->portSDA, dObj->pinSDA);
820:                                 /* set SCL to I/P */
821:                                 PLIB_PORTS_PinDirectionInputSet(PORTS_ID_0, dObj->portSCL, dObj->pinSCL);
822:                             }
823:                         #endif
824:                     #endif
825:                 
826:                     /* Return the driver handle */
827:                     return( (SYS_MODULE_OBJ) dObj );
9D0063F8  3C03A000   LUI V1, -24576
9D0063FC  246370F4   ADDIU V1, V1, 28916
828:                 } /* DRV_I2C_Initialize */
9D006400  00601021   ADDU V0, V1, ZERO
9D006404  8FBF001C   LW RA, 28(SP)
9D006408  8FB10018   LW S1, 24(SP)
9D00640C  8FB00014   LW S0, 20(SP)
9D006410  03E00008   JR RA
9D006414  27BD0020   ADDIU SP, SP, 32
9D006418  03E00008   JR RA
9D00641C  00601021   ADDU V0, V1, ZERO
829:                 
830:                 
831:                 //******************************************************************************
832:                 /* Function:
833:                     void DRV_I2C_Deinitialize ( SYS_MODULE_OBJ object )
834:                 
835:                   Summary:
836:                     De-initializes the specific module instance of the I2C module
837:                 
838:                   Description:
839:                     De-initializes the specific module instance disabling its operation (and any
840:                     hardware for driver modules).  Resets all the internal data structures and
841:                     fields for the specified instance to the default settings.
842:                 
843:                   Parameters:
844:                     object          - Identifies the Driver Object returned by the Initialize
845:                                       interface
846:                 
847:                   Returns:
848:                     None
849:                 */
850:                 
851:                 void DRV_I2C_Deinitialize ( SYS_MODULE_OBJ object )
852:                 {
853:                 	DRV_I2C_OBJ *dObj = (DRV_I2C_OBJ*) object;
854:                 	I2C_MODULE_ID i2cId = dObj->i2cId;
855:                 	size_t iClient;
856:                 	uint8_t iDriver;
857:                 	if (dObj->inUse == false)
858:                 	{
859:                 		return;
860:                 	}
861:                 
862:                 	/* Interrupt De-Registration */
863:                 #if defined (DRV_I2C_INTERRUPT_MODE) && (DRV_I2C_INTERRUPT_MODE == true)
864:                      if (dObj->mstrInterruptEnabled) _DRV_I2C_InterruptSourceDisable(dObj->mstrInterruptSource);
865:                      if (dObj->slaveInterruptEnabled) _DRV_I2C_InterruptSourceDisable(dObj->slaveInterruptSource);
866:                      if (dObj->errInterruptEnabled) _DRV_I2C_InterruptSourceDisable(dObj->errInterruptSource);
867:                 #endif
868:                 
869:                     PLIB_I2C_Disable(i2cId);
870:                     /* Delete the hardware instance mutex. */
871:                     if(OSAL_MUTEX_Delete(&(dObj->mutexDriverInstance)) != OSAL_RESULT_TRUE)
872:                     {
873:                        return;
874:                     }
875:                 
876:                     /* Check if the global mutexes have been created. If so
877:                        then delete these. */
878:                     if(gDrvI2CCommonDataObj.membersAreInitialized)
879:                     {
880:                         /* This means that mutexes where created. Delete them. */
881:                         if(OSAL_MUTEX_Delete(&(gDrvI2CCommonDataObj.mutexClientObjects)) != OSAL_RESULT_TRUE)
882:                         {
883:                                  return;
884:                         }
885:                         if(OSAL_MUTEX_Delete(&(gDrvI2CCommonDataObj.mutexBufferQueueObjects)) != OSAL_RESULT_TRUE)
886:                         {
887:                                  return;
888:                         }
889:                         /* Set this flag so that global mutexes get allocated only once */
890:                         gDrvI2CCommonDataObj.membersAreInitialized = false;
891:                     }
892:                 
893:                 
894:                 	for (iClient = 0; iClient < DRV_I2C_CLIENTS_NUMBER; iClient++)
895:                 	{
896:                         if (gDrvI2CClientObj[iClient].driverObject == dObj)
897:                         {
898:                                 gDrvI2CClientObj[iClient].driverObject = NULL;
899:                         }
900:                 	}
901:                 
902:                 	dObj->numClients = 0;
903:                 	dObj->isExclusive = false;
904:                 	/* Clear all the pending requests */
905:                         //while (_DRV_I2C_QueuePop(dObj) != NULL);
906:                     while ((_DRV_I2C_IsQueueEmpty(dObj) == false))
907:                     {
908:                         _DRV_I2C_Advance_Queue(dObj);
909:                     }
910:                 
911:                 	dObj->queueHead = NULL;
912:                 	/* Set the Device Status */
913:                 	dObj->status = SYS_STATUS_UNINITIALIZED;
914:                 
915:                 	/* Remove the driver usage */
916:                 	dObj->inUse = false;
917:                 
918:                 	for (iDriver = 0; iDriver < DRV_I2C_INSTANCES_NUMBER; iDriver++)
919:                 	{
920:                         DRV_I2C_OBJ * obj = _DRV_I2C_INSTANCE_GET ( iDriver );
921:                 
922:                         if (obj->inUse == true)
923:                         {
924:                             return;
925:                         }
926:                 	}
927:                     i2cNumInited--;
928:                 
929:                     return;
930:                 
931:                 } /* DRV_I2C_Deinitialize */
932:                 
933:                 
934:                 //******************************************************************************
935:                 /* Function:
936:                     SYS_STATUS DRV_I2C_Status ( SYS_MODULE_OBJ object )
937:                 
938:                   Summary:
939:                     Provides the current status of the hardware instance of the I2C module
940:                 
941:                   Description:
942:                     This routine Provides the current status of the hardware instance of the
943:                     I2C module.
944:                 
945:                   Parameters:
946:                     object          - Identifies the Driver Object returned by the Initialize
947:                                       interface
948:                 
949:                   Returns:
950:                     SYS_STATUS_READY    Indicates that any previous module operation for the
951:                                         specified module has completed
952:                 
953:                     SYS_STATUS_BUSY     Indicates that a previous module operation for the
954:                                         specified module has not yet completed
955:                 
956:                     SYS_STATUS_ERROR    Indicates that the specified module is in an error state
957:                 */
958:                 
959:                 SYS_STATUS DRV_I2C_Status ( SYS_MODULE_OBJ object )
960:                 {
961:                     if ( object == SYS_MODULE_OBJ_INVALID )
962:                     {
963:                         //SYS_ASSERT( " Handle is invalid " );
964:                         return SYS_MODULE_OBJ_INVALID;
965:                     }
966:                     DRV_I2C_OBJ *dObj = (DRV_I2C_OBJ*) object;
967:                 
968:                     /* Return the status associated with the driver handle */
969:                     return ( dObj->status );
970:                 } /* DRV_I2C_Status */
971:                 
972:                 
973:                 //******************************************************************************
974:                 /* Function:
975:                     void DRV_I2C_Tasks ( SYS_MODULE_OBJ object )
976:                 
977:                   Summary:
978:                     Used to maintain the driver's state machine and implement its ISR
979:                 
980:                   Description:
981:                     This routine is used to maintain the driver's internal state machine and
982:                     implement its ISR for interrupt-driven implementations.
983:                 
984:                   Parameters:
985:                     object          - Identifies the Driver Object returned by the Initialize
986:                                       interface
987:                 
988:                   Returns:
989:                     None.
990:                 */
991:                 
992:                 void DRV_I2C_Tasks ( SYS_MODULE_OBJ object )
993:                 {
9D0036A4  27BDFFE0   ADDIU SP, SP, -32
9D0036A8  AFBF001C   SW RA, 28(SP)
9D0036AC  AFB20018   SW S2, 24(SP)
9D0036B0  AFB10014   SW S1, 20(SP)
9D0036B4  AFB00010   SW S0, 16(SP)
9D0036B8  00808021   ADDU S0, A0, ZERO
994:                 
995:                     DRV_I2C_OBJ             *dObj           = (DRV_I2C_OBJ*)object;
996:                     DRV_I2C_BUFFER_OBJECT   *lBufferObj     = dObj->taskLObj;
9D0036BC  8C910060   LW S1, 96(A0)
997:                     I2C_MODULE_ID           i2cId           = dObj->i2cId;
998:                 
999:                     if ( object == SYS_MODULE_OBJ_INVALID )
9D0036C0  2402FFFF   ADDIU V0, ZERO, -1
9D0036C4  10820263   BEQ A0, V0, 0x9D004054
9D0036C8  8C920004   LW S2, 4(A0)
1000:                    {
1001:                        //SYS_ASSERT( " Handle is invalid " );
1002:                        return;
1003:                    }
1004:                
1005:                        switch ( dObj->task )
9D0036CC  8C820048   LW V0, 72(A0)
9D0036D0  2C42000A   SLTIU V0, V0, 10
9D0036D4  104001FA   BEQ V0, ZERO, 0x9D003EC0
9D0036D8  3C029D00   LUI V0, -25344
9D0036DC  8C830048   LW V1, 72(A0)
9D0036E0  00031880   SLL V1, V1, 2
9D0036E4  244236F8   ADDIU V0, V0, 14072
9D0036E8  00431021   ADDU V0, V0, V1
9D0036EC  8C420000   LW V0, 0(V0)
9D0036F0  00400008   JR V0
9D0036F4  00000000   NOP
1006:                        {
1007:                            case DRV_I2C_TASK_SEND_DEVICE_ADDRESS:
1008:                
1009:                                /* Pop the first element from the queue */
1010:                                if ( (_DRV_I2C_OPERATION_MODE_GET(dObj->i2cMode)) == DRV_I2C_MODE_MASTER)
9D003720  8C820024   LW V0, 36(A0)
9D003724  14400021   BNE V0, ZERO, 0x9D0037AC
9D003728  24030001   ADDIU V1, ZERO, 1
1011:                                {
1012:                                      if ( ( dObj->queueHead != NULL ) )
9D00372C  8C82004C   LW V0, 76(A0)
9D003730  504001E4   BEQL V0, ZERO, DRV_I2C_Tasks::PLIB_INT_SourceFlagGet
9D003734  8E02003C   LW V0, 60(S0)
1013:                                      {
1014:                                        /* This should be a global variable since the control could
1015:                                        go out of this function */
1016:                                        dObj->taskLObj = _DRV_I2C_QueuePop(dObj);
9D003738  0F4047C0   JAL _DRV_I2C_QueuePop
9D00373C  00000000   NOP
9D003740  00408821   ADDU S1, V0, ZERO
9D003744  AE020060   SW V0, 96(S0)
1017:                
1018:                                        /* Take it to a local variable to avoid multiple referencing and to speed up */
1019:                                        lBufferObj   = dObj->taskLObj;
1020:                
1021:                
1022:                                        if ( lBufferObj->operation == DRV_I2C_OP_READ )
9D003748  8C43000C   LW V1, 12(V0)
9D00374C  24020001   ADDIU V0, ZERO, 1
9D003750  1462000A   BNE V1, V0, DRV_I2C_Tasks::PLIB_I2C_TransmitterByteSend
9D003754  92220008   LBU V0, 8(S1)
1023:                                        {
1024:                
1025:                                            PLIB_I2C_TransmitterByteSend( i2cId,(DRV_I2C_OP_READ | lBufferObj->slaveaddresshighbyte) );
9D003758  34420001   ORI V0, V0, 1
1026:                
1027:                                            /* if it is a 10-bit address, then only MSB of the
1028:                                             * address needs to be send unlike a write; Thus for
1029:                                             * reads 7-bit and 10-bit follows the same logic
1030:                                             */
1031:                                            _DRV_I2C_CLIENT_OBJ(lBufferObj, status) = DRV_I2C_BUFFER_SLAVE_READ_REQUESTED;
9D003764  24020005   ADDIU V0, ZERO, 5
9D003768  AE22002C   SW V0, 44(S1)
1032:                
1033:                                            dObj->modulemainstate = DRV_I2C_MASTER_RX_FROM_SLAVE;
9D00376C  24030002   ADDIU V1, ZERO, 2
9D003770  AE030044   SW V1, 68(S0)
9D003774  0B400FB0   J 0x9D003EC0
9D003778  AE020048   SW V0, 72(S0)
1034:                                            dObj->task = DRV_I2C_TASK_SET_RCEN_ONLY;
1035:                                        }
1036:                                        else
1037:                                        {
1038:                
1039:                                            PLIB_I2C_TransmitterByteSend ( i2cId, lBufferObj->slaveaddresshighbyte ) ;
1040:                
1041:                                            /* if it is a 10-bit address, then subsequent state
1042:                                             * will send the next byte of the address.
1043:                                             * Otherwise state is set to write data
1044:                                             */
1045:                
1046:                                            if (lBufferObj->slaveaddresslowbyte)
9D003780  92220009   LBU V0, 9(S1)
9D003784  10400004   BEQ V0, ZERO, 0x9D003798
9D003788  24020006   ADDIU V0, ZERO, 6
1047:                                            {
1048:                                                dObj->task = DRV_I2C_SEND_DEVICE_ADDRESS_BYTE_2;
9D00378C  24020001   ADDIU V0, ZERO, 1
9D003790  0B400FB0   J 0x9D003EC0
9D003794  AE020048   SW V0, 72(S0)
1049:                                            }
1050:                                            else
1051:                                            {
1052:                                                _DRV_I2C_CLIENT_OBJ(lBufferObj, status) = DRV_I2C_BUFFER_SLAVE_WRITE_REQUESTED;
9D003798  AE22002C   SW V0, 44(S1)
1053:                
1054:                                                dObj->task = lBufferObj->operation + DRV_I2C_TASK_PROCESS_WRITE_ONLY;
9D00379C  8E22000C   LW V0, 12(S1)
9D0037A0  24420002   ADDIU V0, V0, 2
9D0037A4  0B400FB0   J 0x9D003EC0
9D0037A8  AE020048   SW V0, 72(S0)
1055:                                            }
1056:                                        }
1057:                                    }
1058:                                }
1059:                                else if ( (_DRV_I2C_OPERATION_MODE_GET(dObj->i2cMode)) == DRV_I2C_MODE_SLAVE)
9D0037AC  544301C5   BNEL V0, V1, DRV_I2C_Tasks::PLIB_INT_SourceFlagGet
9D0037B0  8E02003C   LW V0, 60(S0)
1060:                                {
1061:                                    /* master writing data to slave when R/W = 0 and Address is detected */
1062:                                    dObj->task = DRV_I2C_TASK_SEND_DEVICE_ADDRESS;
9D0037B4  AC800048   SW ZERO, 72(A0)
1063:                
1064:                                    /* Slave is accepting data from Master */
1065:                                    if ( (!PLIB_I2C_SlaveReadIsRequested(i2cId)) && (PLIB_I2C_SlaveAddressIsDetected(i2cId)) )
9D0037C0  14400017   BNE V0, ZERO, DRV_I2C_Tasks::PLIB_I2C_SlaveReadIsRequested
9D0037C4  00000000   NOP
9D0037D0  14400013   BNE V0, ZERO, DRV_I2C_Tasks::PLIB_I2C_SlaveReadIsRequested
9D0037D4  24020003   ADDIU V0, ZERO, 3
1066:                                    {
1067:                                        /* slave is set to accept data from master */
1068:                                        dObj->modulemainstate = DRV_I2C_SLAVE_READY_TO_RX_FROM_MASTER;
1069:                
1070:                                        if (lBufferObj)
9D0037D8  12200002   BEQ S1, ZERO, 0x9D0037E4
9D0037DC  AC820044   SW V0, 68(A0)
1071:                                        {
1072:                                            lBufferObj->inUse = false;
9D0037E0  A2200000   SB ZERO, 0(S1)
1073:                                        }
1074:                
1075:                                        if (dObj->operationStarting)
9D0037E4  8E020068   LW V0, 104(S0)
9D0037E8  10400003   BEQ V0, ZERO, 0x9D0037F8
9D0037EC  24040005   ADDIU A0, ZERO, 5
1076:                                        {
1077:                                            dObj->operationStarting(DRV_I2C_BUFFER_SLAVE_READ_REQUESTED, 0);
9D0037F0  0040F809   JALR V0
9D0037F4  00002821   ADDU A1, ZERO, ZERO
1078:                                        }
1079:                
1080:                                        /* This should be a global variable since the control could
1081:                                            go out of this function */
1082:                                        dObj->taskLObj = _DRV_I2C_QueuePop(dObj);
9D0037F8  0F4047C0   JAL _DRV_I2C_QueuePop
9D0037FC  02002021   ADDU A0, S0, ZERO
9D003800  00408821   ADDU S1, V0, ZERO
9D003804  AE020060   SW V0, 96(S0)
1083:                
1084:                                        /* Take it to a local variable to avoid multiple referencing and to speed up */
1085:                                        lBufferObj   = dObj->taskLObj;
1086:                
1087:                                        lBufferObj->actualtransfersize = 0;
9D003808  AC400020   SW ZERO, 32(V0)
1088:                
1089:                                        /* do a dummy read so that I2CxRCV is cleared and not clobbered with data */
1090:                                        PLIB_I2C_ReceivedByteGet (i2cId);
1091:                                        PLIB_I2C_SlaveClockRelease (i2cId);
1092:                                    }
1093:                                    /*  Slave is sending data back to the Master    */
1094:                                    else if ( (PLIB_I2C_SlaveReadIsRequested(i2cId)) && (PLIB_I2C_SlaveAddressIsDetected(i2cId)) )
9D003828  10400022   BEQ V0, ZERO, DRV_I2C_Tasks::PLIB_I2C_SlaveReadIsRequested
9D00382C  00000000   NOP
9D003838  1440001E   BNE V0, ZERO, DRV_I2C_Tasks::PLIB_I2C_SlaveReadIsRequested
9D00383C  00000000   NOP
1095:                                    {
1096:                
1097:                                        PLIB_I2C_ReceivedByteGet ( i2cId );
1098:                
1099:                                        PLIB_I2C_SlaveClockHold (i2cId);
1100:                
1101:                                        dObj->modulemainstate = DRV_I2C_SLAVE_READY_TO_TX_TO_MASTER;
9D00384C  24020004   ADDIU V0, ZERO, 4
1102:                
1103:                                        if (lBufferObj)
9D003850  12200002   BEQ S1, ZERO, 0x9D00385C
9D003854  AE020044   SW V0, 68(S0)
1104:                                        {
1105:                                            lBufferObj->inUse = false;
9D003858  A2200000   SB ZERO, 0(S1)
1106:                                        }
1107:                
1108:                                        if (dObj->operationStarting)
9D00385C  8E020068   LW V0, 104(S0)
9D003860  10400003   BEQ V0, ZERO, 0x9D003870
9D003864  24040006   ADDIU A0, ZERO, 6
1109:                                        {
1110:                                            dObj->operationStarting(DRV_I2C_BUFFER_SLAVE_WRITE_REQUESTED, 0);
9D003868  0040F809   JALR V0
9D00386C  00002821   ADDU A1, ZERO, ZERO
1111:                                        }
1112:                                        lBufferObj = dObj->taskLObj = _DRV_I2C_QueuePop(dObj);
9D003870  0F4047C0   JAL _DRV_I2C_QueuePop
9D003874  02002021   ADDU A0, S0, ZERO
9D003878  00408821   ADDU S1, V0, ZERO
9D00387C  AE020060   SW V0, 96(S0)
1113:                
1114:                                        lBufferObj->actualtransfersize = 0;
9D003880  AC400020   SW ZERO, 32(V0)
1115:                
1116:                                        // transmit first byte
1117:                                        PLIB_I2C_TransmitterByteSend(_DRV_I2C_PERIPHERAL_ID_GET(i2cId), *lBufferObj->txBuffer++);
9D003884  8C420010   LW V0, 16(V0)
9D003888  24430001   ADDIU V1, V0, 1
9D00388C  AE230010   SW V1, 16(S1)
1118:                                        lBufferObj->actualtransfersize++;
9D003898  8E220020   LW V0, 32(S1)
9D00389C  24420001   ADDIU V0, V0, 1
9D0038A0  AE220020   SW V0, 32(S1)
1119:                                        PLIB_I2C_SlaveClockRelease ( i2cId );
1120:                                    }
1121:                                    else if ( (!PLIB_I2C_SlaveReadIsRequested(i2cId)) && PLIB_I2C_SlaveDataIsDetected( i2cId ))
9D0038BC  1440003B   BNE V0, ZERO, DRV_I2C_Tasks::PLIB_I2C_SlaveReadIsRequested
9D0038C0  00000000   NOP
9D0038CC  10400037   BEQ V0, ZERO, DRV_I2C_Tasks::PLIB_I2C_SlaveReadIsRequested
9D0038D0  24020003   ADDIU V0, ZERO, 3
1122:                                    {
1123:                                        /*        Master sends data to the slave        */
1124:                                        if (dObj->modulemainstate == DRV_I2C_SLAVE_READY_TO_RX_FROM_MASTER)
9D0038D4  8E030044   LW V1, 68(S0)
9D0038D8  5462017A   BNEL V1, V0, DRV_I2C_Tasks::PLIB_INT_SourceFlagGet
9D0038DC  8E02003C   LW V0, 60(S0)
1125:                                        {
1126:                                            PLIB_I2C_SlaveClockRelease ( i2cId );
1127:                
1128:                                            if (lBufferObj->actualtransfersize < lBufferObj->transferSize)
9D0038E8  8E230020   LW V1, 32(S1)
9D0038EC  8E220018   LW V0, 24(S1)
9D0038F0  0062102B   SLTU V0, V1, V0
9D0038F4  1040001B   BEQ V0, ZERO, 0x9D003964
9D0038F8  24020002   ADDIU V0, ZERO, 2
1129:                                            {
1130:                                                *lBufferObj->rxBuffer++ = PLIB_I2C_ReceivedByteGet ( i2cId );
9D0038FC  8E220014   LW V0, 20(S1)
9D003900  24430001   ADDIU V1, V0, 1
9D003904  AE230014   SW V1, 20(S1)
1131:                                                lBufferObj->actualtransfersize++;
9D003910  8E220020   LW V0, 32(S1)
9D003914  24420001   ADDIU V0, V0, 1
9D003918  AE220020   SW V0, 32(S1)
1132:                
1133:                                                _DRV_I2C_CLIENT_OBJ(lBufferObj, status) = DRV_I2C_BUFFER_SLAVE_READ_BYTE;
9D00391C  24020007   ADDIU V0, ZERO, 7
9D003920  AE22002C   SW V0, 44(S1)
1134:                
1135:                                                if ( _DRV_I2C_CLIENT_OBJ(((DRV_I2C_CLIENT_OBJ *)lBufferObj->clientHandle), callback) != NULL )
9D003924  8E220004   LW V0, 4(S1)
9D003928  8C420020   LW V0, 32(V0)
9D00392C  10400164   BEQ V0, ZERO, 0x9D003EC0
9D003930  24040007   ADDIU A0, ZERO, 7
1136:                                                {
1137:                                                    /*  Call the event handler. Increment the interrupt nesting
1138:                                                        count which lets the driver functions that are called
1139:                                                        from the event handler know that an interrupt context
1140:                                                        is active.
1141:                                                    */
1142:                
1143:                                                    dObj->interruptNestingCount++;
9D003934  8E02006C   LW V0, 108(S0)
9D003938  24420001   ADDIU V0, V0, 1
9D00393C  AE02006C   SW V0, 108(S0)
1144:                
1145:                                                    _DRV_I2C_CLIENT_OBJ(((DRV_I2C_CLIENT_OBJ *)lBufferObj->clientHandle),
9D003940  8E220004   LW V0, 4(S1)
1146:                                                                callback)( DRV_I2C_BUFFER_SLAVE_READ_BYTE, (DRV_I2C_BUFFER_HANDLE)lBufferObj, 0x00 );
9D003944  8C420020   LW V0, 32(V0)
9D003948  02202821   ADDU A1, S1, ZERO
9D00394C  0040F809   JALR V0
9D003950  00003021   ADDU A2, ZERO, ZERO
1147:                
1148:                                                    dObj->interruptNestingCount--;
9D003954  8E02006C   LW V0, 108(S0)
9D003958  2442FFFF   ADDIU V0, V0, -1
9D00395C  0B400FB0   J 0x9D003EC0
9D003960  AE02006C   SW V0, 108(S0)
1149:                                                }
1150:                                            }
1151:                                            else
1152:                                            {
1153:                                                _DRV_I2C_CLIENT_OBJ(lBufferObj, status) = DRV_I2C_BUFFER_EVENT_ERROR;
9D003964  AE22002C   SW V0, 44(S1)
1154:                
1155:                                                PLIB_I2C_ReceivedByteGet ( i2cId );
1156:                
1157:                                                if ( _DRV_I2C_CLIENT_OBJ(((DRV_I2C_CLIENT_OBJ *)lBufferObj->clientHandle), callback) != NULL )
9D00396C  8E220004   LW V0, 4(S1)
9D003970  8C420020   LW V0, 32(V0)
9D003974  10400152   BEQ V0, ZERO, 0x9D003EC0
9D003978  24040002   ADDIU A0, ZERO, 2
1158:                                                {
1159:                                                    /*  Call the event handler. Increment the interrupt nesting
1160:                                                        count which lets the driver functions that are called
1161:                                                        from the event handler know that an interrupt context
1162:                                                        is active.
1163:                                                    */
1164:                
1165:                                                    dObj->interruptNestingCount++;
9D00397C  8E02006C   LW V0, 108(S0)
9D003980  24420001   ADDIU V0, V0, 1
9D003984  AE02006C   SW V0, 108(S0)
1166:                
1167:                                                    _DRV_I2C_CLIENT_OBJ(((DRV_I2C_CLIENT_OBJ *)lBufferObj->clientHandle),
9D003988  8E220004   LW V0, 4(S1)
1168:                                                                callback)( DRV_I2C_BUFFER_EVENT_ERROR, (DRV_I2C_BUFFER_HANDLE)lBufferObj, 0x00 );
9D00398C  8C420020   LW V0, 32(V0)
9D003990  02202821   ADDU A1, S1, ZERO
9D003994  0040F809   JALR V0
9D003998  00003021   ADDU A2, ZERO, ZERO
1169:                
1170:                                                    dObj->interruptNestingCount--;
9D00399C  8E02006C   LW V0, 108(S0)
9D0039A0  2442FFFF   ADDIU V0, V0, -1
9D0039A4  0B400FB0   J 0x9D003EC0
9D0039A8  AE02006C   SW V0, 108(S0)
1171:                                                }
1172:                                            }
1173:                                        }
1174:                                    }
1175:                                    else if (PLIB_I2C_SlaveReadIsRequested(i2cId) && PLIB_I2C_SlaveDataIsDetected( i2cId ))
9D0039B4  50400143   BEQL V0, ZERO, DRV_I2C_Tasks::PLIB_INT_SourceFlagGet
9D0039B8  8E02003C   LW V0, 60(S0)
9D0039C4  5040013F   BEQL V0, ZERO, DRV_I2C_Tasks::PLIB_INT_SourceFlagGet
9D0039C8  8E02003C   LW V0, 60(S0)
1176:                                    {
1177:                                        PLIB_I2C_SlaveClockHold (i2cId);
1178:                
1179:                                        if ( PLIB_I2C_TransmitterByteWasAcknowledged(i2cId) )
9D0039DC  14400036   BNE V0, ZERO, DRV_I2C_Tasks::PLIB_I2C_TransmitterByteWasAcknowledged
9D0039E0  00000000   NOP
1180:                                        {
1181:                                            if ( lBufferObj->actualtransfersize < lBufferObj->transferSize )
9D0039E4  8E230020   LW V1, 32(S1)
9D0039E8  8E220018   LW V0, 24(S1)
9D0039EC  0062102B   SLTU V0, V1, V0
9D0039F0  1040001E   BEQ V0, ZERO, 0x9D003A6C
9D0039F4  24020002   ADDIU V0, ZERO, 2
1182:                                            {
1183:                                                PLIB_I2C_SlaveClockRelease(i2cId);
1184:                                                PLIB_I2C_TransmitterByteSend ( _DRV_I2C_PERIPHERAL_ID_GET ( i2cId ), *lBufferObj->txBuffer++ );
9D003A00  8E220010   LW V0, 16(S1)
9D003A04  24430001   ADDIU V1, V0, 1
9D003A08  AE230010   SW V1, 16(S1)
1185:                                                lBufferObj->actualtransfersize++;
9D003A14  8E220020   LW V0, 32(S1)
9D003A18  24420001   ADDIU V0, V0, 1
9D003A1C  AE220020   SW V0, 32(S1)
1186:                                                lBufferObj->inUse = false;
9D003A20  A2200000   SB ZERO, 0(S1)
1187:                
1188:                                                _DRV_I2C_CLIENT_OBJ(lBufferObj, status) = DRV_I2C_BUFFER_SLAVE_WRITE_BYTE;
9D003A24  2402000A   ADDIU V0, ZERO, 10
9D003A28  AE22002C   SW V0, 44(S1)
1189:                
1190:                                                if ( _DRV_I2C_CLIENT_OBJ(((DRV_I2C_CLIENT_OBJ *)lBufferObj->clientHandle), callback) != NULL )
9D003A2C  8E220004   LW V0, 4(S1)
9D003A30  8C420020   LW V0, 32(V0)
9D003A34  10400122   BEQ V0, ZERO, 0x9D003EC0
9D003A38  2404000A   ADDIU A0, ZERO, 10
1191:                                                {
1192:                                                    /*  Call the event handler. Increment the interrupt nesting
1193:                                                        count which lets the driver functions that are called
1194:                                                        from the event handler know that an interrupt context
1195:                                                        is active.
1196:                                                    */
1197:                
1198:                                                    dObj->interruptNestingCount++;
9D003A3C  8E02006C   LW V0, 108(S0)
9D003A40  24420001   ADDIU V0, V0, 1
9D003A44  AE02006C   SW V0, 108(S0)
1199:                
1200:                                                    _DRV_I2C_CLIENT_OBJ(((DRV_I2C_CLIENT_OBJ *)lBufferObj->clientHandle),
9D003A48  8E220004   LW V0, 4(S1)
1201:                                                                callback)( DRV_I2C_BUFFER_SLAVE_WRITE_BYTE, (DRV_I2C_BUFFER_HANDLE)lBufferObj, 0x00 );
9D003A4C  8C420020   LW V0, 32(V0)
9D003A50  02202821   ADDU A1, S1, ZERO
9D003A54  0040F809   JALR V0
9D003A58  00003021   ADDU A2, ZERO, ZERO
1202:                
1203:                                                    dObj->interruptNestingCount--;
9D003A5C  8E02006C   LW V0, 108(S0)
9D003A60  2442FFFF   ADDIU V0, V0, -1
9D003A64  0B400FB0   J 0x9D003EC0
9D003A68  AE02006C   SW V0, 108(S0)
1204:                                                }
1205:                                            }
1206:                                            else
1207:                                            {
1208:                                               _DRV_I2C_CLIENT_OBJ(lBufferObj, status) = DRV_I2C_BUFFER_EVENT_ERROR;
9D003A6C  AE22002C   SW V0, 44(S1)
1209:                
1210:                                                /* Have a check here because DRV_I2C_ClientSetup function call is optional */
1211:                                                if ( _DRV_I2C_CLIENT_OBJ(((DRV_I2C_CLIENT_OBJ *)lBufferObj->clientHandle), callback) != NULL )
9D003A70  8E220004   LW V0, 4(S1)
9D003A74  8C420020   LW V0, 32(V0)
9D003A78  1040000C   BEQ V0, ZERO, DRV_I2C_Tasks::PLIB_I2C_TransmitterByteSend
9D003A7C  24040002   ADDIU A0, ZERO, 2
1212:                                                {
1213:                                                    /*  Call the event handler. Increment the interrupt nesting
1214:                                                        count which lets the driver functions that are called
1215:                                                        from the event handler know that an interrupt context
1216:                                                        is active.
1217:                                                    */
1218:                
1219:                                                    dObj->interruptNestingCount++;
9D003A80  8E02006C   LW V0, 108(S0)
9D003A84  24420001   ADDIU V0, V0, 1
9D003A88  AE02006C   SW V0, 108(S0)
1220:                
1221:                                                    /* Give an indication to the higher layer upon successful transmission */
1222:                                                   _DRV_I2C_CLIENT_OBJ(((DRV_I2C_CLIENT_OBJ *)lBufferObj->clientHandle), callback)
9D003A8C  8E220004   LW V0, 4(S1)
1223:                                                            ( DRV_I2C_BUFFER_EVENT_ERROR, (DRV_I2C_BUFFER_HANDLE)lBufferObj, 0x00 );
9D003A90  8C420020   LW V0, 32(V0)
9D003A94  02202821   ADDU A1, S1, ZERO
9D003A98  0040F809   JALR V0
9D003A9C  00003021   ADDU A2, ZERO, ZERO
1224:                
1225:                                                    dObj->interruptNestingCount--;
9D003AA0  8E02006C   LW V0, 108(S0)
9D003AA4  2442FFFF   ADDIU V0, V0, -1
9D003AA8  AE02006C   SW V0, 108(S0)
1226:                                                }
1227:                                                /* dummy write - pad with zeros - cases where master requests more data than what is in buffer */
1228:                                                PLIB_I2C_TransmitterByteSend(_DRV_I2C_PERIPHERAL_ID_GET(i2cId), 0);
1229:                                            }
1230:                                        }
1231:                                        else if ( !PLIB_I2C_TransmitterByteWasAcknowledged(i2cId) )
9D003AC0  50400100   BEQL V0, ZERO, DRV_I2C_Tasks::PLIB_INT_SourceFlagGet
9D003AC4  8E02003C   LW V0, 60(S0)
1232:                                        {
1233:                
1234:                                           _DRV_I2C_CLIENT_OBJ(lBufferObj, status) = DRV_I2C_BUFFER_EVENT_COMPLETE;
9D003AC8  24020001   ADDIU V0, ZERO, 1
9D003ACC  AE22002C   SW V0, 44(S1)
1235:                
1236:                                             /* Have a check here because DRV_I2C_ClientSetup function call is optional */
1237:                                            if ( _DRV_I2C_CLIENT_OBJ(((DRV_I2C_CLIENT_OBJ *)lBufferObj->clientHandle), callback) != NULL )
9D003AD0  8E220004   LW V0, 4(S1)
9D003AD4  8C420020   LW V0, 32(V0)
9D003AD8  104000F9   BEQ V0, ZERO, 0x9D003EC0
9D003ADC  24040001   ADDIU A0, ZERO, 1
1238:                                            {
1239:                                                /*  Call the event handler. Increment the interrupt nesting
1240:                                                    count which lets the driver functions that are called
1241:                                                    from the event handler know that an interrupt context
1242:                                                    is active.
1243:                                                */
1244:                
1245:                                                dObj->interruptNestingCount++;
9D003AE0  8E02006C   LW V0, 108(S0)
9D003AE4  24420001   ADDIU V0, V0, 1
9D003AE8  AE02006C   SW V0, 108(S0)
1246:                
1247:                                                /* Give an indication to the higher layer upon successful transmission */
1248:                                                _DRV_I2C_CLIENT_OBJ(((DRV_I2C_CLIENT_OBJ *)lBufferObj->clientHandle), callback)
9D003AEC  8E220004   LW V0, 4(S1)
1249:                                                      ( DRV_I2C_BUFFER_EVENT_COMPLETE, (DRV_I2C_BUFFER_HANDLE)lBufferObj, 0x00 );
9D003AF0  8C420020   LW V0, 32(V0)
9D003AF4  02202821   ADDU A1, S1, ZERO
9D003AF8  0040F809   JALR V0
9D003AFC  00003021   ADDU A2, ZERO, ZERO
1250:                
1251:                                                dObj->interruptNestingCount--;
9D003B00  8E02006C   LW V0, 108(S0)
9D003B04  2442FFFF   ADDIU V0, V0, -1
9D003B08  0B400FB0   J 0x9D003EC0
9D003B0C  AE02006C   SW V0, 108(S0)
1252:                                            }
1253:                                        }
1254:                                    }
1255:                                }
1256:                                break;
1257:                            case DRV_I2C_SEND_DEVICE_ADDRESS_BYTE_2:
1258:                
1259:                                if ( lBufferObj->operation == DRV_I2C_OP_READ )
9D003B10  8E23000C   LW V1, 12(S1)
9D003B14  24020001   ADDIU V0, ZERO, 1
9D003B18  1462000A   BNE V1, V0, 0x9D003B44
9D003B1C  24020006   ADDIU V0, ZERO, 6
1260:                                {
1261:                                    _DRV_I2C_CLIENT_OBJ(lBufferObj, status) = DRV_I2C_BUFFER_SLAVE_READ_REQUESTED;
9D003B20  24020005   ADDIU V0, ZERO, 5
9D003B24  AE22002C   SW V0, 44(S1)
1262:                
1263:                                    dObj->modulemainstate = DRV_I2C_MASTER_RX_FROM_SLAVE;
9D003B28  24030002   ADDIU V1, ZERO, 2
9D003B2C  AC830044   SW V1, 68(A0)
1264:                                    PLIB_I2C_TransmitterByteSend( i2cId,lBufferObj->slaveaddresslowbyte>>1) ;
9D003B30  92230009   LBU V1, 9(S1)
1265:                                    dObj->task = DRV_I2C_TASK_SET_RCEN_ONLY;
1266:                                }
1267:                                else
1268:                                {
1269:                                    _DRV_I2C_CLIENT_OBJ(lBufferObj, status) = DRV_I2C_BUFFER_SLAVE_WRITE_REQUESTED;
9D003B44  AE22002C   SW V0, 44(S1)
1270:                
1271:                                    PLIB_I2C_TransmitterByteSend (i2cId, lBufferObj->slaveaddresslowbyte>>1) ;
9D003B48  92220009   LBU V0, 9(S1)
1272:                                    dObj->task = lBufferObj->operation + DRV_I2C_TASK_PROCESS_WRITE_ONLY;
9D003B54  8E22000C   LW V0, 12(S1)
9D003B58  24420002   ADDIU V0, V0, 2
9D003B5C  0B400FB0   J 0x9D003EC0
9D003B60  AC820048   SW V0, 72(A0)
1273:                                }
1274:                
1275:                                break;
1276:                            case DRV_I2C_SEND_RANDOM_READ_DEVICE_ADDRESS:
1277:                                    dObj->modulemainstate = DRV_I2C_MASTER_RX_FROM_SLAVE;
9D003B64  24020002   ADDIU V0, ZERO, 2
9D003B68  AC820044   SW V0, 68(A0)
1278:                                    PLIB_I2C_TransmitterByteSend( i2cId,(DRV_I2C_OP_READ | lBufferObj->slaveaddresshighbyte) );
9D003B6C  92220008   LBU V0, 8(S1)
9D003B70  34420001   ORI V0, V0, 1
1279:                                    dObj->task = DRV_I2C_TASK_SET_RCEN_ONLY;
9D003B7C  24020005   ADDIU V0, ZERO, 5
1280:                                break;
9D003B80  0B400FB0   J 0x9D003EC0
9D003B84  AC820048   SW V0, 72(A0)
1281:                            case DRV_I2C_TASK_PROCESS_READ_ONLY:
1282:                                /* Read I2CxRCV register for received data */
1283:                                if ( (_DRV_I2C_OPERATION_MODE_GET(dObj->i2cMode)) == DRV_I2C_MODE_MASTER)
9D003B88  8C820024   LW V0, 36(A0)
9D003B8C  544000CD   BNEL V0, ZERO, DRV_I2C_Tasks::PLIB_INT_SourceFlagGet
9D003B90  8E02003C   LW V0, 60(S0)
1284:                                {
1285:                                    if (lBufferObj->transferSize)
9D003B94  8E220018   LW V0, 24(S1)
9D003B98  504000CA   BEQL V0, ZERO, DRV_I2C_Tasks::PLIB_INT_SourceFlagGet
9D003B9C  8E02003C   LW V0, 60(S0)
1286:                                    {
1287:                                        dObj->modulemainstate = DRV_I2C_MASTER_RX_FROM_SLAVE;
9D003BA0  24020002   ADDIU V0, ZERO, 2
9D003BA4  AC820044   SW V0, 68(A0)
1288:                
1289:                                        if ( PLIB_I2C_ReceivedByteIsAvailable (i2cId) )
9D003BB0  504000C4   BEQL V0, ZERO, DRV_I2C_Tasks::PLIB_INT_SourceFlagGet
9D003BB4  8E02003C   LW V0, 60(S0)
1290:                                        {
1291:                                            /* If all but one reception is complete */
1292:                                            if ( lBufferObj->transferSize > 1 )
9D003BB8  8E220018   LW V0, 24(S1)
9D003BBC  2C430002   SLTIU V1, V0, 2
9D003BC0  1460001A   BNE V1, ZERO, 0x9D003C2C
9D003BC4  2442FFFF   ADDIU V0, V0, -1
1293:                                            {
1294:                                                *lBufferObj->rxBuffer++ = PLIB_I2C_ReceivedByteGet (i2cId);
9D003BC8  8E220014   LW V0, 20(S1)
9D003BCC  24430001   ADDIU V1, V0, 1
9D003BD0  AE230014   SW V1, 20(S1)
1295:                                                lBufferObj->transferSize--;
9D003BDC  8E220018   LW V0, 24(S1)
9D003BE0  2442FFFF   ADDIU V0, V0, -1
9D003BE4  AE220018   SW V0, 24(S1)
1296:                                                lBufferObj->actualtransfersize++;
9D003BE8  8E220020   LW V0, 32(S1)
9D003BEC  24420001   ADDIU V0, V0, 1
9D003BF0  AE220020   SW V0, 32(S1)
1297:                                                dObj->task = DRV_I2C_TASK_SET_RCEN_ONLY;
9D003BF4  24020005   ADDIU V0, ZERO, 5
9D003BF8  AC820048   SW V0, 72(A0)
1298:                
1299:                                                if (PLIB_I2C_MasterReceiverReadyToAcknowledge(i2cId))
9D003C04  544000AF   BNEL V0, ZERO, DRV_I2C_Tasks::PLIB_INT_SourceFlagGet
9D003C08  8E02003C   LW V0, 60(S0)
1300:                                                {
1301:                                                    _DRV_I2C_CLIENT_OBJ(lBufferObj, status) = DRV_I2C_BUFFER_MASTER_ACK_SEND;
9D003C0C  24020008   ADDIU V0, ZERO, 8
9D003C10  AE22002C   SW V0, 44(S1)
1302:                
1303:                                                    PLIB_I2C_ReceivedByteAcknowledge ( i2cId, true );
1304:                                                }
1305:                                            }
1306:                                            else
1307:                                            {
1308:                                                lBufferObj->transferSize--;
9D003C2C  AE220018   SW V0, 24(S1)
1309:                                                lBufferObj->actualtransfersize++;
9D003C30  8E220020   LW V0, 32(S1)
9D003C34  24420001   ADDIU V0, V0, 1
9D003C38  AE220020   SW V0, 32(S1)
1310:                
1311:                                                *lBufferObj->rxBuffer++ = PLIB_I2C_ReceivedByteGet ( i2cId );
9D003C3C  8E220014   LW V0, 20(S1)
9D003C40  24430001   ADDIU V1, V0, 1
9D003C44  AE230014   SW V1, 20(S1)
1312:                                                if (PLIB_I2C_MasterReceiverReadyToAcknowledge(i2cId))
9D003C58  14400006   BNE V0, ZERO, 0x9D003C74
9D003C5C  24020007   ADDIU V0, ZERO, 7
1313:                                                {
1314:                                                    _DRV_I2C_CLIENT_OBJ(lBufferObj, status) = DRV_I2C_BUFFER_MASTER_NACK_SEND;
9D003C60  24020009   ADDIU V0, ZERO, 9
9D003C64  AE22002C   SW V0, 44(S1)
1315:                
1316:                                                    PLIB_I2C_ReceivedByteAcknowledge ( i2cId, false  );
1317:                                                }
1318:                
1319:                                                dObj->task = DRV_I2C_BUS_SILENT;
9D003C70  24020007   ADDIU V0, ZERO, 7
9D003C74  0B400FB0   J 0x9D003EC0
9D003C78  AE020048   SW V0, 72(S0)
1320:                                            }
1321:                                        }
1322:                                        else
1323:                                        {
1324:                                            // Do not block in any case
1325:                                            break;
1326:                                        }
1327:                                    }
1328:                                }
1329:                                break;
1330:                            case DRV_I2C_TASK_PROCESS_WRITE_ONLY:
1331:                            case DRV_I2C_TASK_PROCESS_WRITE_READ:
1332:                
1333:                                if ( (_DRV_I2C_OPERATION_MODE_GET(dObj->i2cMode)) == DRV_I2C_MODE_MASTER)
9D003C7C  8C820024   LW V0, 36(A0)
9D003C80  54400090   BNEL V0, ZERO, DRV_I2C_Tasks::PLIB_INT_SourceFlagGet
9D003C84  8E02003C   LW V0, 60(S0)
1334:                                {
1335:                                    /* Loop till the transmit size, do not block though */
1336:                                    if( lBufferObj->transferSize )
9D003C88  8E220018   LW V0, 24(S1)
9D003C8C  5040002C   BEQL V0, ZERO, 0x9D003D40
9D003C90  24020008   ADDIU V0, ZERO, 8
1337:                                    {
1338:                                        if ( PLIB_I2C_TransmitterByteHasCompleted (_DRV_I2C_PERIPHERAL_ID_GET (i2cId)) )
9D003C9C  54600089   BNEL V1, ZERO, DRV_I2C_Tasks::PLIB_INT_SourceFlagGet
9D003CA0  8E02003C   LW V0, 60(S0)
1339:                                        {
1340:                                            if ( PLIB_I2C_TransmitterByteWasAcknowledged (_DRV_I2C_PERIPHERAL_ID_GET (i2cId)) ||
9D003CAC  10600005   BEQ V1, ZERO, 0x9D003CC4
9D003CB0  2C430002   SLTIU V1, V0, 2
9D003CB4  92230024   LBU V1, 36(S1)
9D003CB8  5060001C   BEQL V1, ZERO, 0x9D003D2C
9D003CBC  24020008   ADDIU V0, ZERO, 8
1341:                                                   (lBufferObj->transmitForced)  )
1342:                                            {
1343:                                                /* Handle the overflow */
1344:                                                if ( lBufferObj->transferSize > 1 )
9D003CC0  2C430002   SLTIU V1, V0, 2
9D003CC4  1460000D   BNE V1, ZERO, 0x9D003CFC
9D003CC8  2442FFFF   ADDIU V0, V0, -1
1345:                                                {
1346:                                                    lBufferObj->actualtransfersize++;
9D003CCC  8E220020   LW V0, 32(S1)
9D003CD0  24420001   ADDIU V0, V0, 1
9D003CD4  AE220020   SW V0, 32(S1)
1347:                                                    PLIB_I2C_TransmitterByteSend ( _DRV_I2C_PERIPHERAL_ID_GET ( i2cId ), *lBufferObj->txBuffer++ );
9D003CD8  8E220010   LW V0, 16(S1)
9D003CDC  24430001   ADDIU V1, V0, 1
9D003CE0  AE230010   SW V1, 16(S1)
1348:                                                    lBufferObj->transferSize--;
9D003CEC  8E220018   LW V0, 24(S1)
9D003CF0  2442FFFF   ADDIU V0, V0, -1
9D003CF4  0B400FB0   J 0x9D003EC0
9D003CF8  AE220018   SW V0, 24(S1)
1349:                                                }
1350:                                                else
1351:                                                {
1352:                                                    lBufferObj->transferSize--;
9D003CFC  AE220018   SW V0, 24(S1)
1353:                                                    lBufferObj->actualtransfersize++;
9D003D00  8E220020   LW V0, 32(S1)
9D003D04  24420001   ADDIU V0, V0, 1
9D003D08  AE220020   SW V0, 32(S1)
1354:                
1355:                                                    PLIB_I2C_TransmitterByteSend ( _DRV_I2C_PERIPHERAL_ID_GET ( i2cId ), *lBufferObj->txBuffer++ );
9D003D0C  8E220010   LW V0, 16(S1)
9D003D10  24430001   ADDIU V1, V0, 1
9D003D14  AE230010   SW V1, 16(S1)
1356:                
1357:                                                    dObj->task = DRV_I2C_BUS_SILENT;
9D003D20  24020007   ADDIU V0, ZERO, 7
9D003D24  0B400FB0   J 0x9D003EC0
9D003D28  AE020048   SW V0, 72(S0)
1358:                
1359:                                                }
1360:                                            }
1361:                                            else
1362:                                            {
1363:                                                #if defined  __PIC32MZ &&  (__PIC32_FEATURE_SET0 == 'E') && (__PIC32_FEATURE_SET1 == 'C')
1364:                                                /*   Errata for PIC32MZ which requires reset of I2C module */
1365:                
1366:                                                    dObj->task = DRV_I2C_TASK_SEND_DEVICE_ADDRESS;
1367:                
1368:                                                    /* alternate method to do STOP (previous errata note) */
1369:                
1370:                                                    #ifdef MZ_EC_ERRATA_25_BB_STOP
1371:                                                        /* Bit bang procedure for STOP */
1372:                
1373:                                                        starttime = ReadCoreTimer();
1374:                                                        while(ReadCoreTimer()-starttime < BRG_1_TIME_0);
1375:                
1376:                                                        /* Disable I2C */
1377:                                                        PLIB_I2C_Disable(i2cId);
1378:                
1379:                                                        /* Wait 2 BRG */
1380:                                                        starttime = ReadCoreTimer();
1381:                                                        while(ReadCoreTimer()- starttime < BRG_1_TIME_0);
1382:                
1383:                                                        /* Set SDA as I/P */
1384:                                                        PLIB_PORTS_PinDirectionInputSet(PORTS_ID_0, dObj->portSDA, dObj->pinSDA);
1385:                
1386:                                                        /* Wait 3 BRG */
1387:                                                        starttime = ReadCoreTimer();
1388:                                                        while(ReadCoreTimer()- starttime < BRG_1_TIME_0);
1389:                
1390:                                                        PLIB_I2C_Enable(i2cId);
1391:                                                        PLIB_PORTS_PinClear(PORTS_ID_0, dObj->portSDA, dObj->pinSDA);
1392:                                                        PLIB_PORTS_PinSet(PORTS_ID_0, dObj->portSCL, dObj->pinSCL);
1393:                                                        PLIB_PORTS_PinDirectionOutputSet(PORTS_ID_0, dObj->portSDA, dObj->pinSDA);
1394:                                                        PLIB_PORTS_PinDirectionInputSet(PORTS_ID_0, dObj->portSCL, dObj->pinSCL);
1395:                
1396:                                                        /* End-of-Bit-Bang procedure for STOP */
1397:                                                    #else
1398:                                                      PLIB_I2C_Disable(i2cId);
1399:                                                      PLIB_I2C_Enable(i2cId);
1400:                                                    #endif
1401:                
1402:                                                    if (lBufferObj)
1403:                                                    {
1404:                                                        lBufferObj->inUse = false;
1405:                                                    }
1406:                
1407:                                                    /*clear any previous status flags */
1408:                                                    _DRV_I2C_CLIENT_OBJ(lBufferObj, status) = 0;
1409:                
1410:                                                    /* set status to buffer event complete */
1411:                                                    _DRV_I2C_CLIENT_OBJ(lBufferObj, status) |=
1412:                                                        DRV_I2C_BUFFER_EVENT_ERROR;
1413:                
1414:                                                    /* Have a check here because DRV_I2C_ClientSetup function call is optional */                       //Issue Callback for STOP event
1415:                                                    if ( _DRV_I2C_CLIENT_OBJ(((DRV_I2C_CLIENT_OBJ *)lBufferObj->clientHandle), callback) != NULL )
1416:                                                    {
1417:                                                        dObj->interruptNestingCount++;
1418:                
1419:                                                        /* Give an indication to the higher layer upon successful transmission */
1420:                                                        _DRV_I2C_CLIENT_OBJ(((DRV_I2C_CLIENT_OBJ *)lBufferObj->clientHandle), callback)
1421:                                                                ( DRV_I2C_BUFFER_EVENT_ERROR, (DRV_I2C_BUFFER_HANDLE)lBufferObj, 0x00 );
1422:                
1423:                                                        dObj->interruptNestingCount--;
1424:                                                    }
1425:                                                #else
1426:                                                    dObj->task = DRV_I2C_TASK_PROCESS_STOP;
9D003D2C  AC820048   SW V0, 72(A0)
1427:                                                    PLIB_I2C_MasterStop (i2cId);
1428:                                                #endif
1429:                                            }
1430:                                        }
1431:                                        else
1432:                                        {
1433:                                            /* Do not block in any case */
1434:                                            break;
1435:                                        }
1436:                                    }
1437:                                    else
1438:                                    {
1439:                                        #if defined  __PIC32MZ &&  (__PIC32_FEATURE_SET0 == 'E') && (__PIC32_FEATURE_SET1 == 'C')
1440:                                        /*   Errata for PIC32MZ which requires reset of I2C module */
1441:                
1442:                                            dObj->task = DRV_I2C_TASK_SEND_DEVICE_ADDRESS;
1443:                
1444:                                            /* alternate method to do STOP (previous errata note) */
1445:                
1446:                                            #ifdef MZ_EC_ERRATA_25_BB_STOP               //GJV
1447:                                                /* Bit bang procedure for STOP */
1448:                
1449:                                                starttime = ReadCoreTimer();
1450:                                                while(ReadCoreTimer()-starttime < BRG_1_TIME_0);
1451:                
1452:                                                /* Disable I2C */
1453:                                                PLIB_I2C_Disable(i2cId);
1454:                
1455:                                                /* Wait 2 BRG */
1456:                                                starttime = ReadCoreTimer();
1457:                                                while(ReadCoreTimer()- starttime < BRG_1_TIME_0);
1458:                
1459:                                                /* Set SDA as I/P */
1460:                                                PLIB_PORTS_PinDirectionInputSet(PORTS_ID_0, dObj->portSDA, dObj->pinSDA);
1461:                
1462:                                                /* Wait 3 BRG */
1463:                                                starttime = ReadCoreTimer();
1464:                                                while(ReadCoreTimer()- starttime < BRG_1_TIME_0);
1465:                
1466:                                                PLIB_I2C_Enable(i2cId);
1467:                                                PLIB_PORTS_PinClear(PORTS_ID_0, dObj->portSDA, dObj->pinSDA);
1468:                                                PLIB_PORTS_PinSet(PORTS_ID_0, dObj->portSCL, dObj->pinSCL);
1469:                                                PLIB_PORTS_PinDirectionOutputSet(PORTS_ID_0, dObj->portSDA, dObj->pinSDA);
1470:                                                PLIB_PORTS_PinDirectionInputSet(PORTS_ID_0, dObj->portSCL, dObj->pinSCL);
1471:                
1472:                                                /* End-of-Bit-Bang procedure for STOP */
1473:                                            #else
1474:                                              PLIB_I2C_Disable(i2cId);
1475:                                              PLIB_I2C_Enable(i2cId);
1476:                                            #endif
1477:                
1478:                                            if (lBufferObj)
1479:                                            {
1480:                                                lBufferObj->inUse = false;
1481:                                            }
1482:                
1483:                                            /*clear any previous status flags */
1484:                                            _DRV_I2C_CLIENT_OBJ(lBufferObj, status) = 0;
1485:                
1486:                                            /* set status to buffer event complete */
1487:                                            _DRV_I2C_CLIENT_OBJ(lBufferObj, status) |=
1488:                                                DRV_I2C_BUFFER_EVENT_ERROR;
1489:                
1490:                                            /* Have a check here because DRV_I2C_ClientSetup function call is optional */                       //Issue Callback for STOP event
1491:                                            if ( _DRV_I2C_CLIENT_OBJ(((DRV_I2C_CLIENT_OBJ *)lBufferObj->clientHandle), callback) != NULL )
1492:                                            {
1493:                                                dObj->interruptNestingCount++;
1494:                
1495:                                                /* Give an indication to the higher layer upon successful transmission */
1496:                                                _DRV_I2C_CLIENT_OBJ(((DRV_I2C_CLIENT_OBJ *)lBufferObj->clientHandle), callback)
1497:                                                        ( DRV_I2C_BUFFER_EVENT_ERROR, (DRV_I2C_BUFFER_HANDLE)lBufferObj, 0x00 );
1498:                
1499:                                                dObj->interruptNestingCount--;
1500:                                            }
1501:                                        #else
1502:                                            dObj->task = DRV_I2C_TASK_PROCESS_STOP;
9D003D40  AC820048   SW V0, 72(A0)
1503:                                            PLIB_I2C_MasterStop (i2cId);
1504:                                        #endif
1505:                                    }
1506:                                }
1507:                                break;
1508:                            case DRV_I2C_BUS_SILENT:
1509:                
1510:                                /*  The Bus is Silent/Idle when the last byte is either ACK'ed  OR
1511:                                    in the event of slave unexpectedly aborting operation, check
1512:                                    if transmission is complete and NACK is received   */
1513:                
1514:                                if ( PLIB_I2C_TransmitterByteWasAcknowledged ( _DRV_I2C_PERIPHERAL_ID_GET ( i2cId ) ) ||
9D003D5C  5040000A   BEQL V0, ZERO, 0x9D003D88
9D003D60  8E23000C   LW V1, 12(S1)
9D003D6C  54400055   BNEL V0, ZERO, DRV_I2C_Tasks::PLIB_INT_SourceFlagGet
9D003D70  8E02003C   LW V0, 60(S0)
1515:                                      ( PLIB_I2C_TransmitterByteHasCompleted ( _DRV_I2C_PERIPHERAL_ID_GET ( i2cId ) )  &&
9D003D7C  50400051   BEQL V0, ZERO, DRV_I2C_Tasks::PLIB_INT_SourceFlagGet
9D003D80  8E02003C   LW V0, 60(S0)
1516:                                            (!PLIB_I2C_TransmitterByteWasAcknowledged ( _DRV_I2C_PERIPHERAL_ID_GET ( i2cId ) )) ) )
1517:                                {
1518:                                    if ( lBufferObj->operation == DRV_I2C_OP_WRITE_READ )
9D003D84  8E23000C   LW V1, 12(S1)
9D003D88  24020002   ADDIU V0, ZERO, 2
9D003D8C  54620016   BNEL V1, V0, 0x9D003DE8
9D003D90  24020008   ADDIU V0, ZERO, 8
1519:                                    {
1520:                
1521:                                        SYS_INT_SourceStatusClear(dObj->mstrInterruptSource);
9D003D94  8E030034   LW V1, 52(S0)
1522:                
1523:                                        dObj->task  = DRV_I2C_SEND_RANDOM_READ_DEVICE_ADDRESS;
9D003DB8  24030009   ADDIU V1, ZERO, 9
9D003DBC  AE030048   SW V1, 72(S0)
1524:                
1525:                                        lBufferObj->operation = DRV_I2C_OP_READ;
9D003DC0  AE22000C   SW V0, 12(S1)
1526:                
1527:                                        lBufferObj->transferSize = lBufferObj->readtransferSize;    //Assign # of bytes to be read into transfer size
9D003DC4  8E22001C   LW V0, 28(S1)
9D003DC8  AE220018   SW V0, 24(S1)
1528:                
1529:                                        _DRV_I2C_CLIENT_OBJ(lBufferObj, status) = DRV_I2C_SEND_RESTART_EVENT;
9D003DCC  24020004   ADDIU V0, ZERO, 4
9D003DD0  AE22002C   SW V0, 44(S1)
1530:                
1531:                                        PLIB_I2C_MasterStartRepeat (dObj->i2cId);
1532:                
1533:                                    }
1534:                                    else
1535:                                    {
1536:                
1537:                                    #if defined  __PIC32MZ &&  (__PIC32_FEATURE_SET0 == 'E') && (__PIC32_FEATURE_SET1 == 'C')
1538:                                    /*   Errata for PIC32MZ which requires reset of I2C module */
1539:                
1540:                                        #ifdef MZ_EC_ERRATA_25_BB_STOP               //GJV
1541:                
1542:                                            /* Bit bang procedure for STOP */
1543:                                            starttime = ReadCoreTimer();
1544:                                            while(ReadCoreTimer()-starttime < BRG_1_TIME_0);
1545:                
1546:                                            /* Disable I2C */
1547:                                            PLIB_I2C_Disable(i2cId);
1548:                
1549:                                            /* Wait 2 BRG */
1550:                                            starttime = ReadCoreTimer();
1551:                                            while(ReadCoreTimer()- starttime < BRG_1_TIME_0);
1552:                
1553:                                            /* Set SDA as I/P */
1554:                                            PLIB_PORTS_PinDirectionInputSet(PORTS_ID_0, dObj->portSDA, dObj->pinSDA);
1555:                
1556:                                            /* Wait 3 BRG */
1557:                                            starttime = ReadCoreTimer();
1558:                                            while(ReadCoreTimer()- starttime < BRG_1_TIME_0);
1559:                
1560:                                            PLIB_I2C_Enable(i2cId);
1561:                                            PLIB_PORTS_PinClear(PORTS_ID_0, dObj->portSDA, dObj->pinSDA);
1562:                                            PLIB_PORTS_PinSet(PORTS_ID_0, dObj->portSCL, dObj->pinSCL);
1563:                                            PLIB_PORTS_PinDirectionOutputSet(PORTS_ID_0, dObj->portSDA, dObj->pinSDA);
1564:                                            PLIB_PORTS_PinDirectionInputSet(PORTS_ID_0, dObj->portSCL, dObj->pinSCL);
1565:                                        #else
1566:                                            /* alternate method to do STOP (previous errata note) */
1567:                                            PLIB_I2C_Disable(i2cId);
1568:                                            PLIB_I2C_Enable(i2cId);
1569:                                        #endif
1570:                
1571:                                        /* End-of-Bit-Bang procedure for STOP */
1572:                
1573:                                        if (lBufferObj)
1574:                                        {
1575:                                            lBufferObj->inUse = false;
1576:                                        }
1577:                
1578:                                        /* set buffer event complete status and callback here instead of STOP condition
1579:                                        because STOP condition is PIC32MZ-EC is bit-banged and would not generate an interrupt  */
1580:                                        dObj->task = DRV_I2C_TASK_SEND_DEVICE_ADDRESS;
1581:                
1582:                                        /*clear any previous status flags */
1583:                                        _DRV_I2C_CLIENT_OBJ(lBufferObj, status) = 0;
1584:                
1585:                                        /* set status to buffer event complete */
1586:                                        _DRV_I2C_CLIENT_OBJ(lBufferObj, status) |=
1587:                                                DRV_I2C_BUFFER_EVENT_COMPLETE;
1588:                
1589:                                        if ( _DRV_I2C_CLIENT_OBJ(((DRV_I2C_CLIENT_OBJ *)lBufferObj->clientHandle), callback) != NULL )
1590:                                        {
1591:                                            dObj->interruptNestingCount++;
1592:                
1593:                                            /* Give an indication to the higher layer upon successful transmission */
1594:                                            _DRV_I2C_CLIENT_OBJ(((DRV_I2C_CLIENT_OBJ *)lBufferObj->clientHandle), callback)
1595:                                            ( DRV_I2C_BUFFER_EVENT_COMPLETE, (DRV_I2C_BUFFER_HANDLE)lBufferObj, 0x00 );
1596:                
1597:                                            dObj->interruptNestingCount--;
1598:                                        }
1599:                                    #else
1600:                                        dObj->task = DRV_I2C_TASK_PROCESS_STOP;
9D003DE8  AE020048   SW V0, 72(S0)
1601:                                        PLIB_I2C_MasterStop (i2cId);
1602:                                    #endif
1603:                
1604:                                    }
1605:                                }
1606:                                break;
1607:                            case DRV_I2C_TASK_SET_RCEN_ONLY:
1608:                                if ( PLIB_I2C_TransmitterByteHasCompleted (i2cId) )
9D003E04  5440002F   BNEL V0, ZERO, DRV_I2C_Tasks::PLIB_INT_SourceFlagGet
9D003E08  8E02003C   LW V0, 60(S0)
1609:                                {
1610:                                    if ( PLIB_I2C_TransmitterByteWasAcknowledged(i2cId) )
9D003E14  1440000A   BNE V0, ZERO, 0x9D003E40
9D003E18  24020008   ADDIU V0, ZERO, 8
1611:                                    {
1612:                                        if (PLIB_I2C_ReceiverByteAcknowledgeHasCompleted(i2cId))
9D003E24  54400027   BNEL V0, ZERO, DRV_I2C_Tasks::PLIB_INT_SourceFlagGet
9D003E28  8E02003C   LW V0, 60(S0)
1613:                                        {
1614:                                            PLIB_I2C_MasterReceiverClock1Byte (i2cId);
1615:                                            dObj->task = DRV_I2C_TASK_PROCESS_READ_ONLY;
9D003E34  24020003   ADDIU V0, ZERO, 3
9D003E38  0B400FB0   J 0x9D003EC0
9D003E3C  AC820048   SW V0, 72(A0)
1616:                                        }
1617:                                    }
1618:                                    else
1619:                                    {
1620:                
1621:                                        #if defined  __PIC32MZ &&  (__PIC32_FEATURE_SET0 == 'E') && (__PIC32_FEATURE_SET1 == 'C')
1622:                                        /*   Errata for PIC32MZ which requires reset of I2C module */
1623:                
1624:                                            dObj->task = DRV_I2C_TASK_SEND_DEVICE_ADDRESS;
1625:                
1626:                                            /* alternate method to do STOP (previous errata note) */
1627:                
1628:                                            #ifdef MZ_EC_ERRATA_25_BB_STOP               //GJV
1629:                                                /* Bit bang procedure for STOP */
1630:                
1631:                                                starttime = ReadCoreTimer();
1632:                                                while(ReadCoreTimer()-starttime < BRG_1_TIME_0);
1633:                
1634:                                                /* Disable I2C */
1635:                                                PLIB_I2C_Disable(i2cId);
1636:                
1637:                                                /* Wait 2 BRG */
1638:                                                starttime = ReadCoreTimer();
1639:                                                while(ReadCoreTimer()- starttime < BRG_1_TIME_0);
1640:                
1641:                                                /* Set SDA as I/P */
1642:                                                PLIB_PORTS_PinDirectionInputSet(PORTS_ID_0, dObj->portSDA, dObj->pinSDA);
1643:                
1644:                                                /* Wait 3 BRG */
1645:                                                starttime = ReadCoreTimer();
1646:                                                while(ReadCoreTimer()- starttime < BRG_1_TIME_0);
1647:                
1648:                                                PLIB_I2C_Enable(i2cId);
1649:                                                PLIB_PORTS_PinClear(PORTS_ID_0, dObj->portSDA, dObj->pinSDA);
1650:                                                PLIB_PORTS_PinSet(PORTS_ID_0, dObj->portSCL, dObj->pinSCL);
1651:                                                PLIB_PORTS_PinDirectionOutputSet(PORTS_ID_0, dObj->portSDA, dObj->pinSDA);
1652:                                                PLIB_PORTS_PinDirectionInputSet(PORTS_ID_0, dObj->portSCL, dObj->pinSCL);
1653:                
1654:                                                /* End-of-Bit-Bang procedure for STOP */
1655:                                            #else                                                   //GJV
1656:                                              PLIB_I2C_Disable(i2cId);
1657:                                              PLIB_I2C_Enable(i2cId);
1658:                                            #endif                                                  //GJV
1659:                
1660:                                            if (lBufferObj)
1661:                                            {
1662:                                                lBufferObj->inUse = false;
1663:                                            }
1664:                
1665:                                            /*clear any previous status flags */
1666:                                            _DRV_I2C_CLIENT_OBJ(lBufferObj, status) = 0;
1667:                
1668:                                            /* set status to buffer event complete */
1669:                                            _DRV_I2C_CLIENT_OBJ(lBufferObj, status) |=
1670:                                                DRV_I2C_BUFFER_EVENT_COMPLETE;
1671:                
1672:                                            /* Have a check here because DRV_I2C_ClientSetup function call is optional */                       //Issue Callback for STOP event
1673:                                            if ( _DRV_I2C_CLIENT_OBJ(((DRV_I2C_CLIENT_OBJ *)lBufferObj->clientHandle), callback) != NULL )
1674:                                            {
1675:                                                dObj->interruptNestingCount++;
1676:                
1677:                                                /* Give an indication to the higher layer upon successful transmission */
1678:                                                _DRV_I2C_CLIENT_OBJ(((DRV_I2C_CLIENT_OBJ *)lBufferObj->clientHandle), callback)
1679:                                                        ( DRV_I2C_BUFFER_EVENT_COMPLETE, (DRV_I2C_BUFFER_HANDLE)lBufferObj, 0x00 );
1680:                
1681:                                                dObj->interruptNestingCount--;
1682:                                            }
1683:                                        #else
1684:                                            dObj->task = DRV_I2C_TASK_PROCESS_STOP;
9D003E40  AC820048   SW V0, 72(A0)
1685:                                            PLIB_I2C_MasterStop (i2cId);
1686:                                        #endif
1687:                
1688:                                    }
1689:                                }
1690:                                break;
1691:                            case DRV_I2C_TASK_PROCESS_STOP:
1692:                
1693:                //#if defined (DRV_I2C_INTERRUPT_MODE) && (DRV_I2C_INTERRUPT_MODE == true)
1694:                //                 _DRV_I2C_InterruptSourceDisable (_DRV_I2C_INT_SRC_GET(dObj->mstrInterruptSource));
1695:                //#endif
1696:                
1697:                                dObj->task = DRV_I2C_TASK_SEND_DEVICE_ADDRESS;
9D003E54  AC800048   SW ZERO, 72(A0)
1698:                
1699:                                if( lBufferObj->transferSize )
9D003E58  8E220018   LW V0, 24(S1)
9D003E5C  10400004   BEQ V0, ZERO, 0x9D003E70
9D003E60  24020001   ADDIU V0, ZERO, 1
1700:                                {
1701:                                    _DRV_I2C_CLIENT_OBJ(lBufferObj, status) = DRV_I2C_BUFFER_EVENT_ERROR;
9D003E64  24020002   ADDIU V0, ZERO, 2
9D003E68  0B400F9D   J 0x9D003E74
9D003E6C  AE22002C   SW V0, 44(S1)
1702:                
1703:                                }
1704:                                else
1705:                                {
1706:                                    _DRV_I2C_CLIENT_OBJ(lBufferObj, status) = DRV_I2C_BUFFER_EVENT_COMPLETE;
9D003E70  AE22002C   SW V0, 44(S1)
1707:                
1708:                                }
1709:                
1710:                               /* Have a check here because DRV_I2C_ClientSetup function call is optional */
1711:                                if ( _DRV_I2C_CLIENT_OBJ(((DRV_I2C_CLIENT_OBJ *)lBufferObj->clientHandle), callback) != NULL )
9D003E74  8E220004   LW V0, 4(S1)
9D003E78  8C420020   LW V0, 32(V0)
9D003E7C  1040000C   BEQ V0, ZERO, 0x9D003EB0
9D003E80  02202821   ADDU A1, S1, ZERO
1712:                                {
1713:                                    dObj->interruptNestingCount++;
9D003E84  8E02006C   LW V0, 108(S0)
9D003E88  24420001   ADDIU V0, V0, 1
9D003E8C  AE02006C   SW V0, 108(S0)
1714:                
1715:                                    /* Give an indication to the higher layer upon successful transmission */
1716:                                    _DRV_I2C_CLIENT_OBJ(((DRV_I2C_CLIENT_OBJ *)lBufferObj->clientHandle), callback)
9D003E90  8E220004   LW V0, 4(S1)
1717:                                    ( _DRV_I2C_CLIENT_OBJ(lBufferObj, status), (DRV_I2C_BUFFER_HANDLE)lBufferObj, 0x00 );
9D003E94  8C420020   LW V0, 32(V0)
9D003E98  8E24002C   LW A0, 44(S1)
9D003E9C  0040F809   JALR V0
9D003EA0  00003021   ADDU A2, ZERO, ZERO
1718:                
1719:                                    dObj->interruptNestingCount--;
9D003EA4  8E02006C   LW V0, 108(S0)
9D003EA8  2442FFFF   ADDIU V0, V0, -1
9D003EAC  AE02006C   SW V0, 108(S0)
1720:                                }
1721:                
1722:                
1723:                                if (lBufferObj)
9D003EB0  52200004   BEQL S1, ZERO, DRV_I2C_Tasks::PLIB_INT_SourceFlagGet
9D003EB4  8E02003C   LW V0, 60(S0)
1724:                                {
1725:                                    lBufferObj->inUse = false;
9D003EB8  A2200000   SB ZERO, 0(S1)
1726:                                    Nop();
9D003EBC  00000040   SSNOP
1727:                                }
1728:                
1729:                                break;
1730:                            default:
1731:                                break;
1732:                
1733:                        }
1734:                
1735:                        /* This state is encountered when an error interrupt has occurred.
1736:                           or an error has occurred during read */
1737:                
1738:                        if ( true == _DRV_I2C_InterruptSourceStatusGet ( dObj->errInterruptSource ) )
9D003818  0B400FB1   J DRV_I2C_Tasks::PLIB_INT_SourceFlagGet
9D00381C  8E02003C   LW V0, 60(S0)
9D0038AC  0B400FB1   J DRV_I2C_Tasks::PLIB_INT_SourceFlagGet
9D0038B0  8E02003C   LW V0, 60(S0)
9D003AB0  0B400FB1   J DRV_I2C_Tasks::PLIB_INT_SourceFlagGet
9D003AB4  8E02003C   LW V0, 60(S0)
9D003C24  0B400FB1   J DRV_I2C_Tasks::PLIB_INT_SourceFlagGet
9D003C28  8E02003C   LW V0, 60(S0)
9D003D38  0B400FB1   J DRV_I2C_Tasks::PLIB_INT_SourceFlagGet
9D003D3C  8E02003C   LW V0, 60(S0)
9D003D4C  0B400FB1   J DRV_I2C_Tasks::PLIB_INT_SourceFlagGet
9D003D50  8E02003C   LW V0, 60(S0)
9D003DE0  0B400FB1   J DRV_I2C_Tasks::PLIB_INT_SourceFlagGet
9D003DE4  8E02003C   LW V0, 60(S0)
9D003DF4  0B400FB1   J DRV_I2C_Tasks::PLIB_INT_SourceFlagGet
9D003DF8  8E02003C   LW V0, 60(S0)
9D003E4C  0B400FB1   J DRV_I2C_Tasks::PLIB_INT_SourceFlagGet
9D003E50  8E02003C   LW V0, 60(S0)
9D003EC0  8E02003C   LW V0, 60(S0)
9D003EE4  50400011   BEQL V0, ZERO, DRV_I2C_Tasks::PLIB_INT_SourceFlagGet
9D003EE8  8E020034   LW V0, 52(S0)
1739:                        {
1740:                            /* Check for the overflow error */
1741:                            if ( PLIB_I2C_ReceiverOverflowHasOccurred ( i2cId ) )
9D003EF4  50400004   BEQL V0, ZERO, DRV_I2C_Tasks::PLIB_INT_SourceFlagClear
9D003EF8  8E02003C   LW V0, 60(S0)
1742:                            {
1743:                                if ( PLIB_I2C_ExistsReceiverOverflow ( i2cId ) )
1744:                                {
1745:                                    PLIB_I2C_ReceiverOverflowClear ( i2cId );
1746:                                }
1747:                            }
1748:                
1749:                            _DRV_I2C_InterruptSourceClear ( dObj->errInterruptSource );
9D003F04  8E02003C   LW V0, 60(S0)
1750:                        }
1751:                
1752:                        if (SYS_INT_SourceStatusGet(dObj->mstrInterruptSource))
9D003F28  8E020034   LW V0, 52(S0)
9D003F50  50800005   BEQL A0, ZERO, DRV_I2C_Tasks::PLIB_INT_SourceFlagGet
9D003F54  8E020038   LW V0, 56(S0)
1753:                        {
1754:                            SYS_INT_SourceStatusClear(dObj->mstrInterruptSource);
1755:                        }
1756:                        if (SYS_INT_SourceStatusGet(dObj->slaveInterruptSource))
9D003F64  8E020038   LW V0, 56(S0)
9D003F8C  50800007   BEQL A0, ZERO, DRV_I2C_Tasks::PLIB_INT_SourceFlagGet
9D003F90  8E02003C   LW V0, 60(S0)
1757:                        {
1758:                            SYS_INT_SourceStatusClear(dObj->slaveInterruptSource);
1759:                            PLIB_I2C_SlaveClockRelease ( i2cId );
1760:                        }
1761:                        if (SYS_INT_SourceStatusGet(dObj->errInterruptSource))
9D003FA8  8E02003C   LW V0, 60(S0)
9D003FD0  50800005   BEQL A0, ZERO, 0x9D003FE8
9D003FD4  8E020024   LW V0, 36(S0)
1762:                        {
1763:                            SYS_INT_SourceStatusClear(dObj->errInterruptSource);
1764:                        }
1765:                
1766:                        if ( (dObj->i2cMode) == DRV_I2C_MODE_MASTER)
9D003FE4  8E020024   LW V0, 36(S0)
9D003FE8  1440001B   BNE V0, ZERO, 0x9D004058
9D003FEC  8FBF001C   LW RA, 28(SP)
1767:                        {
1768:                            if ( (lBufferObj != NULL) &&  ((_DRV_I2C_CLIENT_OBJ(lBufferObj, status) == DRV_I2C_BUFFER_EVENT_COMPLETE) || (_DRV_I2C_CLIENT_OBJ(lBufferObj, status) == DRV_I2C_BUFFER_EVENT_ERROR) ))
9D003FF0  1220001A   BEQ S1, ZERO, 0x9D00405C
9D003FF4  8FB20018   LW S2, 24(SP)
9D003FF8  8E22002C   LW V0, 44(S1)
9D003FFC  2442FFFF   ADDIU V0, V0, -1
9D004000  2C420002   SLTIU V0, V0, 2
9D004004  50400016   BEQL V0, ZERO, 0x9D004060
9D004008  8FB10014   LW S1, 20(SP)
1769:                            {
1770:                                _DRV_I2C_Advance_Queue(dObj);
9D00400C  0F40530F   JAL _DRV_I2C_Advance_Queue
9D004010  02002021   ADDU A0, S0, ZERO
1771:                                if ((_DRV_I2C_IsQueueEmpty(dObj) == false))
9D004014  0F4052A6   JAL _DRV_I2C_IsQueueEmpty
9D004018  02002021   ADDU A0, S0, ZERO
9D00401C  1440000E   BNE V0, ZERO, 0x9D004058
9D004020  8FBF001C   LW RA, 28(SP)
1772:                                {
1773:                                    if (PLIB_I2C_BusIsIdle(dObj->i2cId))
1774:                                    {
1775:                                        PLIB_I2C_MasterStart(dObj->i2cId);
1776:                                        Nop();
9D004050  00000040   SSNOP
1777:                                    }
1778:                                }
1779:                            }
1780:                        }
1781:                
1782:                
1783:                }   /* DRV_I2C_TASKS */
9D004054  8FBF001C   LW RA, 28(SP)
9D004058  8FB20018   LW S2, 24(SP)
9D00405C  8FB10014   LW S1, 20(SP)
9D004060  8FB00010   LW S0, 16(SP)
9D004064  03E00008   JR RA
9D004068  27BD0020   ADDIU SP, SP, 32
1784:                
1785:                
1786:                //******************************************************************************
1787:                /* Function:
1788:                    DRV_HANDLE DRV_I2C_Open ( const SYS_MODULE_INDEX    index,
1789:                                             const DRV_IO_INTENT       intent )
1790:                
1791:                  Summary:
1792:                    Opens the specific module instance and returns a handle
1793:                
1794:                  Description:
1795:                    This routine opens a driver for use by any client module and provides a
1796:                    handle that must be provided to any of the other driver operations to
1797:                    identify the caller and the instance of the driver/hardware module.
1798:                
1799:                  Parameters:
1800:                    index           - Identifier for the instance to be initialized
1801:                    ioIntent        - Possible values from the enumeration DRV_IO_INTENT
1802:                
1803:                  Returns:
1804:                    If successful, the routine returns a valid open-instance handle (a number
1805:                    identifying both the caller and the module instance)
1806:                    If an error occurs, the return value is DRV_HANDLE_INVALID
1807:                */
1808:                
1809:                DRV_HANDLE DRV_I2C_Open ( const SYS_MODULE_INDEX   drvIndex,
1810:                                         const DRV_IO_INTENT      ioIntent )
1811:                {
9D00E4B8  27BDFFE0   ADDIU SP, SP, -32
9D00E4BC  AFBF001C   SW RA, 28(SP)
9D00E4C0  AFB20018   SW S2, 24(SP)
9D00E4C4  AFB10014   SW S1, 20(SP)
9D00E4C8  AFB00010   SW S0, 16(SP)
9D00E4CC  00A08021   ADDU S0, A1, ZERO
1812:                    /* Multi client variables are removed from single client builds. */
1813:                
1814:                    DRV_I2C_OBJ         *dObj;
1815:                    size_t              iClient;
1816:                
1817:                    /* Validate the driver index */
1818:                    if( drvIndex >= DRV_I2C_INSTANCES_NUMBER )
9D00E4B0  1480004A   BNE A0, ZERO, 0x9D00E5DC
9D00E4B4  2403FFFF   ADDIU V1, ZERO, -1
1819:                    {
1820:                        return DRV_HANDLE_INVALID;
1821:                    }
1822:                    dObj = _DRV_I2C_INSTANCE_GET(drvIndex);
1823:                
1824:                    /* Check for exclusive access */
1825:                    _DRV_I2C_LockMutex(dObj);
1826:                
1827:                    /* Check if max number of clients open */
1828:                    if ( ( dObj->isExclusive == true ) ||
9D00E4E4  3C02A000   LUI V0, -24576
9D00E4E8  90427113   LBU V0, 28947(V0)
9D00E4EC  14400008   BNE V0, ZERO, DRV_I2C_Open::_DRV_I2C_UnlockMutex
9D00E4F0  3C02A000   LUI V0, -24576
9D00E4F4  90427112   LBU V0, 28946(V0)
9D00E4F8  10400006   BEQ V0, ZERO, 0x9D00E514
9D00E4FC  3C04A000   LUI A0, -24576
1829:                         ( dObj->inUse != true ) ||
9D00E504  90427114   LBU V0, 28948(V0)
9D00E508  10400006   BEQ V0, ZERO, DRV_I2C_Open::_DRV_I2C_UnlockMutex
9D00E50C  00000000   NOP
1830:                         (( dObj->numClients > 0 ) &&
9D00E500  3C02A000   LUI V0, -24576
1831:                            DRV_IO_ISEXCLUSIVE( ioIntent )) ||
1832:                         (dObj->numClients >= DRV_I2C_CLIENTS_NUMBER))
1833:                    {
1834:                        /* Set that the hardware instance is opened in exclusive mode */
1835:                        _DRV_I2C_UnlockMutex(dObj);
1836:                         return DRV_HANDLE_INVALID;
9D00E51C  0B403970   J 0x9D00E5C0
9D00E520  2403FFFF   ADDIU V1, ZERO, -1
1837:                    }
1838:                    _DRV_I2C_UnlockMutex(dObj);
1839:                
1840:                
1841:                    if(OSAL_MUTEX_Lock(&(gDrvI2CCommonDataObj.mutexClientObjects), OSAL_WAIT_FOREVER) == OSAL_RESULT_TRUE)
9D00E52C  3C04A000   LUI A0, -24576
9D00E530  24840B88   ADDIU A0, A0, 2952
9D00E534  0F405267   JAL OSAL_MUTEX_Lock
9D00E538  3405FFFF   ORI A1, ZERO, -1
9D00E53C  24040001   ADDIU A0, ZERO, 1
9D00E540  1444001F   BNE V0, A0, 0x9D00E5C0
9D00E544  2403FFFF   ADDIU V1, ZERO, -1
1842:                    {
1843:                        /* Setup client operations */
1844:                        /* Find available slot in array of client objects */
1845:                        for ( iClient = 0; iClient < DRV_I2C_CLIENTS_NUMBER ; iClient++ )
1846:                        {
1847:                            DRV_I2C_CLIENT_OBJ  *clientObj      =
1848:                                            ( DRV_I2C_CLIENT_OBJ* ) _DRV_I2C_CLIENT_OBJ_GET(iClient);
1849:                            if ( !clientObj->inUse )
9D00E548  3C02A000   LUI V0, -24576
9D00E54C  904270D4   LBU V0, 28884(V0)
9D00E550  54400018   BNEL V0, ZERO, 0x9D00E5B4
9D00E554  3C04A000   LUI A0, -24576
1850:                            {
1851:                                /* Increment the client in case of Multi client support, otherwise remove
1852:                                the below statement */
1853:                
1854:                                dObj->numClients++;
9D00E558  3C02A000   LUI V0, -24576
9D00E55C  244270F4   ADDIU V0, V0, 28916
9D00E560  90430020   LBU V1, 32(V0)
9D00E564  24630001   ADDIU V1, V1, 1
9D00E568  A0430020   SB V1, 32(V0)
1855:                
1856:                                /* Update that, the client is opened in exclusive access mode */
1857:                                if( DRV_IO_ISEXCLUSIVE( ioIntent ) )
9D00E56C  32020008   ANDI V0, S0, 8
9D00E570  10400003   BEQ V0, ZERO, 0x9D00E580
9D00E574  3C02A000   LUI V0, -24576
1858:                                {
1859:                                    dObj->isExclusive = true;
9D00E578  24030001   ADDIU V1, ZERO, 1
9D00E57C  A0437113   SB V1, 28947(V0)
1860:                                }
1861:                                clientObj->inUse  = true;
9D00E580  3C12A000   LUI S2, -24576
9D00E584  265170D0   ADDIU S1, S2, 28880
9D00E588  24020001   ADDIU V0, ZERO, 1
9D00E58C  A2220004   SB V0, 4(S1)
1862:                
1863:                                /* We have found a client object. Release the mutex */
1864:                
1865:                                OSAL_MUTEX_Unlock(&(gDrvI2CCommonDataObj.mutexClientObjects));
9D00E590  3C04A000   LUI A0, -24576
9D00E594  0F40541A   JAL OSAL_MUTEX_Unlock
9D00E598  24840B88   ADDIU A0, A0, 2952
1866:                
1867:                    //            _DRV_I2C_UnlockMutex(dObj);
1868:                                clientObj->driverObject = dObj;
9D00E59C  3C02A000   LUI V0, -24576
9D00E5A0  244270F4   ADDIU V0, V0, 28916
9D00E5A4  AE4270D0   SW V0, 28880(S2)
1869:                                clientObj->intent = ioIntent;
9D00E5A8  AE300008   SW S0, 8(S1)
1870:                
1871:                                /* Return the client object */
1872:                                return ( DRV_HANDLE ) clientObj;
9D00E5AC  0B403970   J 0x9D00E5C0
9D00E5B0  02201821   ADDU V1, S1, ZERO
1873:                            }
1874:                        }
1875:                
1876:                        /* Could not find a client object. Release the mutex and
1877:                           return with an invalid handle. */
1878:                        OSAL_MUTEX_Unlock(&(gDrvI2CCommonDataObj.mutexClientObjects));
9D00E5B4  0F40541A   JAL OSAL_MUTEX_Unlock
9D00E5B8  24840B88   ADDIU A0, A0, 2952
1879:                    }
1880:                //    _DRV_I2C_UnlockMutex(dObj);
1881:                
1882:                    return  DRV_HANDLE_INVALID ;
9D00E5BC  2403FFFF   ADDIU V1, ZERO, -1
1883:                } /* DRV_I2C_Open */
9D00E5C0  00601021   ADDU V0, V1, ZERO
9D00E5C4  8FBF001C   LW RA, 28(SP)
9D00E5C8  8FB20018   LW S2, 24(SP)
9D00E5CC  8FB10014   LW S1, 20(SP)
9D00E5D0  8FB00010   LW S0, 16(SP)
9D00E5D4  03E00008   JR RA
9D00E5D8  27BD0020   ADDIU SP, SP, 32
9D00E5DC  03E00008   JR RA
9D00E5E0  00601021   ADDU V0, V1, ZERO
1884:                
1885:                
1886:                //******************************************************************************
1887:                /* Function:
1888:                    void DRV_I2C_Close ( DRV_HANDLE handle )
1889:                
1890:                  Summary:
1891:                    Closes an opened-instance of a driver
1892:                
1893:                  Description:
1894:                    This routine closes an opened-instance of a driver, invalidating the given
1895:                    handle.
1896:                
1897:                  Parameters:
1898:                    handle       - A valid open-instance handle, returned from the driver's
1899:                                   open routine
1900:                
1901:                  Returns:
1902:                    None
1903:                */
1904:                
1905:                void DRV_I2C_Close ( DRV_HANDLE handle )
1906:                {
1907:                    /* Multi client variables are removed from single client builds. */
1908:                    DRV_I2C_CLIENT_OBJ *clientObj = (DRV_I2C_CLIENT_OBJ*)handle;
1909:                
1910:                    if (clientObj->inUse == false)
1911:                    {
1912:                        //_DRV_I2C_UnlockMutex(clientObj->driverObject);
1913:                        return;
1914:                    }
1915:                
1916:                    /* Free the Client Instance */
1917:                	if (clientObj->driverObject != NULL)
1918:                	{
1919:                		clientObj->driverObject->numClients --;
1920:                		clientObj->driverObject->isExclusive = false;
1921:                	}
1922:                    clientObj->inUse = false ;
1923:                
1924:                } /* DRV_I2C_Close */
1925:                
1926:                
1927:                // *****************************************************************************
1928:                /* Function:
1929:                    void DRV_I2C_ClientSetup ( DRV_HANDLE handle,
1930:                                                 const DRV_I2C_CLIENT_SETUP * const config )
1931:                
1932:                  Summary:
1933:                    Sets up the device communication parameters
1934:                
1935:                  Description:
1936:                    This function sets up the device communication parameters
1937:                
1938:                  Parameters:
1939:                    handle       - A valid open-instance handle, returned from the driver's
1940:                                   open routine
1941:                
1942:                    config       - Port parameters tied to IRQ line
1943:                
1944:                  Returns:
1945:                    None
1946:                */
1947:                
1948:                void DRV_I2C_ClientSetup ( DRV_HANDLE handle,
1949:                                                 const DRV_I2C_CLIENT_SETUP * const config )
1950:                {
1951:                //    bool temp;
1952:                    DRV_I2C_CLIENT_OBJ *clientObj = (DRV_I2C_CLIENT_OBJ*) handle;
1953:                
1954:                
1955:                    _DRV_I2C_SAVE_LAST_CLIENT();
1956:                //    temp = config->irqSetupLogicLevel;
1957:                
1958:                    clientObj->irqSelectLogicLevel  = config->irqSetupLogicLevel;
1959:                    clientObj->irqSelectPort        = config->irqSetupPort;
1960:                    clientObj->irqSelectBitPos      = config->irqSetupBitPos;
1961:                
1962:                    SYS_PORTS_PinDirectionSelect( PORTS_ID_0, SYS_PORTS_DIRECTION_OUTPUT,
1963:                            clientObj->irqSelectPort, clientObj->irqSelectBitPos);
1964:                    if (clientObj->irqSelectLogicLevel == true)
1965:                        SYS_PORTS_PinSet (PORTS_ID_0, clientObj->irqSelectPort, clientObj->irqSelectBitPos );
1966:                    else
1967:                        SYS_PORTS_PinClear (PORTS_ID_0, clientObj->irqSelectPort, clientObj->irqSelectBitPos );
1968:                
1969:                }  /* DRV_I2C_ClientSetup */
1970:                
1971:                //******************************************************************************
1972:                /* Function:
1973:                    void DRV_I2C_BufferEventHandlerSet ( const DRV_HANDLE handle,
1974:                                    const DRV_I2C_BUFFER_EVENT_HANDLER eventHandler,
1975:                                    const uintptr_t context )
1976:                
1977:                  Summary:
1978:                	Adds a callback function for a client.
1979:                
1980:                  Description:
1981:                    This routine adds a callback function for a client.
1982:                
1983:                  Parameters:
1984:                        handle       	- A valid open-instance handle, returned from the driver's
1985:                						open routine.
1986:                
1987:                	eventHandler    - Call back function.
1988:                
1989:                	context		 	-  context.
1990:                
1991:                  Returns:
1992:                    None.
1993:                */
1994:                
1995:                void DRV_I2C_BufferEventHandlerSet (const DRV_HANDLE handle,
1996:                                    const DRV_I2C_BUFFER_EVENT_HANDLER eventHandler,
1997:                                    const uintptr_t context )
1998:                {
1999:                	( (DRV_I2C_CLIENT_OBJ *) handle)->callback = eventHandler;
2000:                
2001:                	( (DRV_I2C_CLIENT_OBJ *) handle)->context = context;
2002:                }   /* DRV_I2C_BufferEventHandlerSet */
2003:                
2004:                
2005:                //******************************************************************************
2006:                /* Function:
2007:                    DRV_I2C_BUFFER_HANDLE DRV_I2C_Receive  (    DRV_HANDLE handle,
2008:                                                                uint8_t* address,
2009:                                                                void *rxBuffer,
2010:                                                                size_t size,
2011:                                                                void * context);
2012:                
2013:                  Summary:
2014:                    Adds a buffer to queue with a read request. Driver will process this
2015:                    request in the task routine.
2016:                
2017:                  Description:
2018:                    This routine adds a buffer to queue with a read request. Driver will process
2019:                    this request in the task routine.
2020:                
2021:                  Parameters:
2022:                    handle      - A valid open-instance handle, returned from the driver's open
2023:                                  routine
2024:                    address     - Device address of slave. If this API is used in Slave mode,
2025:                                  then a dummy value can be used
2026:                    buffer      - This buffer holds data is received
2027:                    size        - The number of bytes that the Master expects to read from Slave.
2028:                                  This value can be kept as the MAX BUFFER SIZE for slave.
2029:                                  This is because the Master controls when the READ operation
2030:                                  is terminated.
2031:                    callbackContext     - Not implemented, future expansion
2032:                
2033:                  Returns:
2034:                    DRV_I2C_BUFFER_HANDLE using which application can track the current status of
2035:                    the buffer.
2036:                */
2037:                
2038:                
2039:                DRV_I2C_BUFFER_HANDLE DRV_I2C_Receive   (   DRV_HANDLE handle,
2040:                                                            uint16_t address,
2041:                                                            void *buffer,
2042:                                                            size_t size,
2043:                                                            void * callbackContext )
2044:                {
2045:                    DRV_I2C_BUFFER_OBJECT   *i2cDataObj;
2046:                    DRV_I2C_OBJ             *dObj = ((DRV_I2C_CLIENT_OBJ *) handle)->driverObject;
2047:                
2048:                    /* Get a slot in the queue */
2049:                   i2cDataObj = _DRV_I2C_QueueSlotGet ( dObj );
2050:                
2051:                
2052:                    if ( i2cDataObj != NULL )
2053:                    {
2054:                        /* Fill the data directly to the queue. Set the inUse flag only at the end */
2055:                        i2cDataObj->clientHandle    = handle;
2056:                        if (address > ADDRESS_7BIT_UPPER_LIMIT )
2057:                        {
2058:                            i2cDataObj->slaveaddresshighbyte = (uint8_t)((address & 0xFF00)>>8);
2059:                            i2cDataObj->slaveaddresslowbyte  = (uint8_t)(address & 0x00FF);
2060:                        }
2061:                        else
2062:                        {
2063:                            i2cDataObj->slaveaddresshighbyte = (uint8_t)(address & 0x00FF);
2064:                            i2cDataObj->slaveaddresslowbyte  = 0;
2065:                        }
2066:                        i2cDataObj->operation       = DRV_I2C_OP_READ;
2067:                        i2cDataObj->txBuffer        = NULL;
2068:                        i2cDataObj->rxBuffer        = buffer;
2069:                        i2cDataObj->transferSize    = size;
2070:                        i2cDataObj->actualtransfersize = 0;
2071:                        i2cDataObj->status          = DRV_I2C_BUFFER_EVENT_PENDING;
2072:                        i2cDataObj->context         = callbackContext;
2073:                        i2cDataObj->transmitForced  = false;
2074:                
2075:                        _DRV_I2C_QueuePush( dObj, i2cDataObj);
2076:                
2077:                        if ( (_DRV_I2C_OPERATION_MODE_GET(dObj->i2cMode)) == DRV_I2C_MODE_MASTER)
2078:                        {
2079:                
2080:                            /*  if either START and STOP were not detected which is true the
2081:                                first time OR if STOP was detected, then it assumed the
2082:                                transaction on the bus is complete */
2083:                
2084:                            if ( ((!(PLIB_I2C_StartWasDetected(dObj->i2cId))) && (!(PLIB_I2C_StopWasDetected(dObj->i2cId)))) ||
2085:                                    (PLIB_I2C_StopWasDetected(dObj->i2cId)) )
2086:                            {
2087:                
2088:                                /* if Bus IDLE and I2CxMIF = 0, then I2C is not running*/
2089:                
2090:                                if ( (PLIB_I2C_BusIsIdle(dObj->i2cId)) &&
2091:                                       (!(SYS_INT_SourceStatusGet(dObj->mstrInterruptSource))) )
2092:                                {
2093:                //                    SYS_INT_SourceStatusClear(dObj->mstrInterruptSource);
2094:                                    _DRV_I2C_InterruptSourceEnable( dObj->mstrInterruptSource ) ;
2095:                                    _DRV_I2C_InterruptSourceEnable( dObj->errInterruptSource );
2096:                                    dObj->task = DRV_I2C_TASK_SEND_DEVICE_ADDRESS;
2097:                                    PLIB_I2C_MasterStart(dObj->i2cId);
2098:                                }
2099:                            }
2100:                        }
2101:                        else
2102:                        {
2103:                            SYS_INT_SourceStatusClear(dObj->slaveInterruptSource);
2104:                            _DRV_I2C_InterruptSourceEnable( dObj->slaveInterruptSource ) ;
2105:                        }
2106:                        return (DRV_I2C_BUFFER_HANDLE)i2cDataObj;
2107:                    }
2108:                    return (DRV_I2C_BUFFER_HANDLE)NULL;
2109:                }   /* DRV_I2C_Receive */
2110:                
2111:                
2112:                //******************************************************************************
2113:                /* Function:
2114:                    DRV_I2C_BUFFER_HANDLE DRV_I2C_BufferAddRead (   DRV_HANDLE handle,
2115:                                                                    uint8_t* address,
2116:                                                                    void *rxBuffer,
2117:                                                                    size_t size,
2118:                                                                    void * context);
2119:                
2120:                  Summary:
2121:                    Adds a buffer to queue with a read request. Driver will process this
2122:                    request in the task routine.
2123:                
2124:                  Description:
2125:                    This routine adds a buffer to queue with a read request. Driver will process
2126:                    this request in the task routine.
2127:                
2128:                  Parameters:
2129:                    drvHandle   - A valid open-instance handle, returned from the driver's open
2130:                                  routine
2131:                    address     - Device address of slave. If this API is used in Slave mode,
2132:                                  then a dummy value can be used
2133:                    rxBuffer    - This buffer holds data is received
2134:                    size        - The number of bytes that the Master expects to read from Slave.
2135:                                  This value can be kept as the MAX BUFFER SIZE for slave.
2136:                                  This is because the Master controls when the READ operation
2137:                                  is terminated.
2138:                    context     - Not implemented, future expansion
2139:                
2140:                  Returns:
2141:                    DRV_I2C_BUFFER_HANDLE using which application can track the current status of
2142:                    the buffer.
2143:                */
2144:                
2145:                
2146:                DRV_I2C_BUFFER_HANDLE DRV_I2C_BufferAddRead (   DRV_HANDLE handle,
2147:                                                                uint8_t* address,
2148:                                                                void *rxBuffer,
2149:                                                                size_t size,
2150:                                                                void * context )
2151:                {
2152:                    DRV_I2C_BUFFER_OBJECT   *i2cDataObj;
2153:                    DRV_I2C_OBJ             *dObj = ((DRV_I2C_CLIENT_OBJ *) handle)->driverObject;
2154:                
2155:                    /* Get a slot in the queue */
2156:                   i2cDataObj = _DRV_I2C_QueueSlotGet ( dObj );
2157:                
2158:                
2159:                    if ( i2cDataObj != NULL )
2160:                    {
2161:                        /* Fill the data directly to the queue. Set the inUse flag only at the end */
2162:                        i2cDataObj->clientHandle            = handle;
2163:                        i2cDataObj->slaveaddresshighbyte    = *(address);
2164:                        i2cDataObj->slaveaddresslowbyte     = 0x00;
2165:                        i2cDataObj->operation               = DRV_I2C_OP_READ;
2166:                        i2cDataObj->txBuffer                = NULL;
2167:                        i2cDataObj->rxBuffer                = rxBuffer;
2168:                        i2cDataObj->transferSize            = size;
2169:                        i2cDataObj->actualtransfersize      = 0;
2170:                        i2cDataObj->status                  = DRV_I2C_BUFFER_EVENT_PENDING;
2171:                        i2cDataObj->context                 = context;
2172:                        i2cDataObj->transmitForced          = false;
2173:                
2174:                        _DRV_I2C_QueuePush( dObj, i2cDataObj);
2175:                
2176:                        if ( (_DRV_I2C_OPERATION_MODE_GET(dObj->i2cMode)) == DRV_I2C_MODE_MASTER)
2177:                        {
2178:                            /*  if either START and STOP were not detected which is true the
2179:                                first time OR if STOP was detected, then it assumed the
2180:                                transaction on the bus is complete */
2181:                
2182:                            if ( ((!(PLIB_I2C_StartWasDetected(dObj->i2cId))) && (!(PLIB_I2C_StopWasDetected(dObj->i2cId)))) ||
2183:                                    (PLIB_I2C_StopWasDetected(dObj->i2cId)) )
2184:                            {
2185:                
2186:                                /* if Bus IDLE and I2CxMIF = 0, then I2C is not running*/
2187:                
2188:                                if ( (PLIB_I2C_BusIsIdle(dObj->i2cId)) &&
2189:                                       (!(SYS_INT_SourceStatusGet(dObj->mstrInterruptSource))) )
2190:                                {
2191:                //                    SYS_INT_SourceStatusClear(dObj->mstrInterruptSource);
2192:                                    _DRV_I2C_InterruptSourceEnable( dObj->mstrInterruptSource ) ;
2193:                
2194:                                    _DRV_I2C_InterruptSourceEnable( dObj->errInterruptSource );
2195:                                    dObj->task = DRV_I2C_TASK_SEND_DEVICE_ADDRESS;
2196:                                    PLIB_I2C_MasterStart(dObj->i2cId);
2197:                                }
2198:                            }
2199:                        }
2200:                        else
2201:                        {
2202:                            SYS_INT_SourceStatusClear(dObj->slaveInterruptSource);
2203:                            _DRV_I2C_InterruptSourceEnable( dObj->slaveInterruptSource ) ;
2204:                        }
2205:                        return (DRV_I2C_BUFFER_HANDLE)i2cDataObj;
2206:                    }
2207:                    return (DRV_I2C_BUFFER_HANDLE)NULL;
2208:                }   /* DRV_I2C_BufferAddRead */
2209:                
2210:                
2211:                
2212:                //******************************************************************************
2213:                /* Function:
2214:                    DRV_I2C_BUFFER_HANDLE DRV_I2C_Transmit  (   DRV_HANDLE handle,
2215:                                                                uint16_t address,
2216:                                                                void *txBuffer,
2217:                                                                size_t size,
2218:                                                                void * context);
2219:                  Summary:
2220:                    Adds a buffer to queue with a write request. Driver will process this
2221:                    request in the task routine.
2222:                
2223:                  Description:
2224:                    This routine adds a buffer to queue with a read request. Driver will process
2225:                    this request in the task routine.
2226:                
2227:                  Parameters:
2228:                    handle      - A valid open-instance handle, returned from the driver's open
2229:                                  routine
2230:                    address     - Device address of slave. If this API is used in Slave mode,
2231:                                  then a dummy value can be used
2232:                    buffer      - Contains data to be transferred
2233:                    size        - The number of bytes that the Master expects to write to Slave.
2234:                                  This value can be kept as the MAX BUFFER SIZE for slave.
2235:                                  This is because the Master controls when the WRITE operation
2236:                                  is terminated.
2237:                    callbackContext     - Not implemented, future expansion
2238:                
2239:                  Returns:
2240:                    DRV_I2C_BUFFER_HANDLE using which application can track the current status of
2241:                    the buffer.
2242:                */
2243:                
2244:                DRV_I2C_BUFFER_HANDLE DRV_I2C_Transmit (    DRV_HANDLE handle,
2245:                                                            uint16_t address,
2246:                                                            void *writeBuffer,
2247:                                                            size_t size,
2248:                                                            void * callbackContext)
2249:                {
9D009DCC  27BDFFD0   ADDIU SP, SP, -48
9D009DD0  AFBF002C   SW RA, 44(SP)
9D009DD4  AFB50028   SW S5, 40(SP)
9D009DD8  AFB40024   SW S4, 36(SP)
9D009DDC  AFB30020   SW S3, 32(SP)
9D009DE0  AFB2001C   SW S2, 28(SP)
9D009DE4  AFB10018   SW S1, 24(SP)
9D009DE8  AFB00014   SW S0, 20(SP)
9D009DEC  00809821   ADDU S3, A0, ZERO
9D009DF0  00A09021   ADDU S2, A1, ZERO
9D009DF4  00C0A821   ADDU S5, A2, ZERO
9D009DF8  00E0A021   ADDU S4, A3, ZERO
2250:                    DRV_I2C_BUFFER_OBJECT *i2cDataObj;
2251:                    DRV_I2C_OBJ *dObj = ((DRV_I2C_CLIENT_OBJ *) handle)->driverObject;
9D009DFC  8C910000   LW S1, 0(A0)
2252:                
2253:                    /* Get a slot in the queue */
2254:                    i2cDataObj = _DRV_I2C_QueueSlotGet (dObj);
9D009E00  0F402864   JAL _DRV_I2C_QueueSlotGet
9D009E04  02202021   ADDU A0, S1, ZERO
2255:                
2256:                    if ( i2cDataObj != NULL )
9D009E08  10400052   BEQ V0, ZERO, 0x9D009F54
9D009E0C  00408021   ADDU S0, V0, ZERO
2257:                    {
2258:                        /* Fill the data directly to the queue. Set the inUse flag only at the end */
2259:                        i2cDataObj->clientHandle    = handle;
9D009E10  AC530004   SW S3, 4(V0)
2260:                        if (address > ADDRESS_7BIT_UPPER_LIMIT )
9D009E14  2E420100   SLTIU V0, S2, 256
9D009E18  54400005   BNEL V0, ZERO, 0x9D009E30
9D009E1C  A2120008   SB S2, 8(S0)
2261:                        {
2262:                            i2cDataObj->slaveaddresshighbyte = (uint8_t)((address & 0xFF00)>>8);
9D009E20  00121202   SRL V0, S2, 8
9D009E24  A2020008   SB V0, 8(S0)
9D009E28  0B40278D   J 0x9D009E34
9D009E2C  A2120009   SB S2, 9(S0)
2263:                            i2cDataObj->slaveaddresslowbyte  = (uint8_t)(address & 0x00FF);
2264:                        }
2265:                        else
2266:                        {
2267:                            i2cDataObj->slaveaddresshighbyte = (uint8_t)(address & 0x00FF);
2268:                            i2cDataObj->slaveaddresslowbyte  = 0;
9D009E30  A2000009   SB ZERO, 9(S0)
2269:                        }
2270:                        i2cDataObj->operation       = DRV_I2C_OP_WRITE;
9D009E34  AE00000C   SW ZERO, 12(S0)
2271:                        i2cDataObj->txBuffer        = writeBuffer;
9D009E38  AE150010   SW S5, 16(S0)
2272:                        i2cDataObj->rxBuffer        = NULL;
9D009E3C  AE000014   SW ZERO, 20(S0)
2273:                        i2cDataObj->transferSize    = size;
9D009E40  AE140018   SW S4, 24(S0)
2274:                        i2cDataObj->actualtransfersize = 0;
9D009E44  AE000020   SW ZERO, 32(S0)
2275:                        i2cDataObj->status          = DRV_I2C_BUFFER_EVENT_PENDING;
9D009E48  AE00002C   SW ZERO, 44(S0)
2276:                        i2cDataObj->context         = callbackContext;
9D009E4C  8FA20040   LW V0, 64(SP)
9D009E50  AE020034   SW V0, 52(S0)
2277:                        i2cDataObj->transmitForced  = false;
9D009E54  A2000024   SB ZERO, 36(S0)
2278:                
2279:                        _DRV_I2C_QueuePush( dObj, i2cDataObj);
9D009E58  02202021   ADDU A0, S1, ZERO
9D009E5C  0F40454B   JAL _DRV_I2C_QueuePush
9D009E60  02002821   ADDU A1, S0, ZERO
2280:                
2281:                        if ( (_DRV_I2C_OPERATION_MODE_GET(dObj->i2cMode)) == DRV_I2C_MODE_MASTER)
9D009E64  8E220024   LW V0, 36(S1)
9D009E68  54400028   BNEL V0, ZERO, DRV_I2C_Transmit::PLIB_INT_SourceFlagClear
9D009E6C  8E220038   LW V0, 56(S1)
2282:                        {
2283:                            /*  if either START and STOP were not detected which is true the
2284:                                first time OR if STOP was detected, then it assumed the
2285:                                transaction on the bus is complete */
2286:                
2287:                            if ( ((!(PLIB_I2C_StartWasDetected(dObj->i2cId))) && (!(PLIB_I2C_StopWasDetected(dObj->i2cId)))) ||
9D009E7C  14600005   BNE V1, ZERO, DRV_I2C_Transmit::PLIB_I2C_StopWasDetected
9D009E80  00000000   NOP
9D009E8C  10600005   BEQ V1, ZERO, DRV_I2C_Transmit::PLIB_I2C_BusIsIdle
9D009E90  00000000   NOP
9D009E9C  5060003B   BEQL V1, ZERO, 0x9D009F8C
9D009EA0  02001021   ADDU V0, S0, ZERO
2288:                                    (PLIB_I2C_StopWasDetected(dObj->i2cId)) )
2289:                            {
2290:                
2291:                                /* if Bus IDLE and I2CxMIF = 0, then I2C is not running*/
2292:                
2293:                                if ( (PLIB_I2C_BusIsIdle(dObj->i2cId)) &&
9D009F80  5080FFD2   BEQL A0, ZERO, DRV_I2C_Transmit::PLIB_INT_SourceEnable
9D009F84  AE200048   SW ZERO, 72(S1)
9D009F88  02001021   ADDU V0, S0, ZERO
2294:                                       (!(SYS_INT_SourceStatusGet(dObj->mstrInterruptSource))) )
2295:                                {
2296:                                    dObj->task = DRV_I2C_TASK_SEND_DEVICE_ADDRESS;
2297:                //                    SYS_INT_SourceStatusClear(dObj->mstrInterruptSource);
2298:                                    _DRV_I2C_InterruptSourceEnable( dObj->mstrInterruptSource ) ;
2299:                
2300:                                    _DRV_I2C_InterruptSourceEnable( dObj->errInterruptSource );
9D009EE4  8E23003C   LW V1, 60(S1)
2301:                                    PLIB_I2C_MasterStart(dObj->i2cId);
2302:                                }
2303:                            }
2304:                        }
2305:                        else
2306:                        {
2307:                           SYS_INT_SourceStatusClear(dObj->slaveInterruptSource);
2308:                           _DRV_I2C_InterruptSourceEnable( dObj->slaveInterruptSource ) ;
9D009F2C  8E220038   LW V0, 56(S1)
2309:                
2310:                        }
2311:                        return (DRV_I2C_BUFFER_HANDLE) i2cDataObj;
9D009EC4  0B4027E3   J 0x9D009F8C
9D009EC8  02001021   ADDU V0, S0, ZERO
9D009F04  0B4027E3   J 0x9D009F8C
9D009F08  02001021   ADDU V0, S0, ZERO
9D009F4C  0B4027E3   J 0x9D009F8C
9D009F50  02001021   ADDU V0, S0, ZERO
2312:                    }
2313:                    return (DRV_I2C_BUFFER_HANDLE)NULL;
9D009F54  0B4027E3   J 0x9D009F8C
9D009F58  00001021   ADDU V0, ZERO, ZERO
2314:                } /* DRV_I2C_Transmit */
9D009F8C  8FBF002C   LW RA, 44(SP)
9D009F90  8FB50028   LW S5, 40(SP)
9D009F94  8FB40024   LW S4, 36(SP)
9D009F98  8FB30020   LW S3, 32(SP)
9D009F9C  8FB2001C   LW S2, 28(SP)
9D009FA0  8FB10018   LW S1, 24(SP)
9D009FA4  8FB00014   LW S0, 20(SP)
9D009FA8  03E00008   JR RA
9D009FAC  27BD0030   ADDIU SP, SP, 48
2315:                
2316:                
2317:                //******************************************************************************
2318:                /* Function:
2319:                    DRV_I2C_BUFFER_HANDLE DRV_I2C_BufferAddWrite (  DRV_HANDLE handle,
2320:                                                                    uint8_t* address,
2321:                                                                    void *txBuffer,
2322:                                                                    size_t size,
2323:                                                                    void * context);
2324:                  Summary:
2325:                    Adds a buffer to queue with a write request. Driver will process this
2326:                    request in the task routine.
2327:                
2328:                  Description:
2329:                    This routine adds a buffer to queue with a read request. Driver will process
2330:                    this request in the task routine.
2331:                
2332:                  Parameters:
2333:                    drvHandle   - A valid open-instance handle, returned from the driver's open
2334:                                  routine
2335:                    slaveaddress- Device address of slave. If this API is used in Slave mode,
2336:                                  then a dummy value can be used
2337:                    txBuffer    - Contains data to be transffered
2338:                    size        - The number of bytes that the Master expects to write to Slave.
2339:                                  This value can be kept as the MAX BUFFER SIZE for slave.
2340:                                  This is because the Master controls when the WRITE operation
2341:                                  is terminated.
2342:                    context     - Not implemented, future expansion
2343:                
2344:                  Returns:
2345:                    DRV_I2C_BUFFER_HANDLE using which application can track the current status of
2346:                    the buffer.
2347:                */
2348:                
2349:                DRV_I2C_BUFFER_HANDLE DRV_I2C_BufferAddWrite (  DRV_HANDLE handle,
2350:                                                                uint8_t* address,
2351:                                                                void *txBuffer,
2352:                                                                size_t size,
2353:                                                                void * context)
2354:                {
2355:                    DRV_I2C_BUFFER_OBJECT *i2cDataObj;
2356:                    DRV_I2C_OBJ *dObj = ((DRV_I2C_CLIENT_OBJ *) handle)->driverObject;
2357:                
2358:                    /* Get a slot in the queue */
2359:                    i2cDataObj = _DRV_I2C_QueueSlotGet (dObj);
2360:                
2361:                    if ( i2cDataObj != NULL )
2362:                    {
2363:                        /* Fill the data directly to the queue. Set the inUse flag only at the end */
2364:                        i2cDataObj->clientHandle                = handle;
2365:                        i2cDataObj->slaveaddresshighbyte        = *(address);
2366:                        i2cDataObj->slaveaddresslowbyte         = 0x00;
2367:                        i2cDataObj->operation                   = DRV_I2C_OP_WRITE;
2368:                        i2cDataObj->txBuffer                    = txBuffer;
2369:                        i2cDataObj->rxBuffer                    = NULL;
2370:                        i2cDataObj->transferSize                = size;
2371:                        i2cDataObj->actualtransfersize          = 0;
2372:                        i2cDataObj->status                      = DRV_I2C_BUFFER_EVENT_PENDING;
2373:                        i2cDataObj->context                     = context;
2374:                        i2cDataObj->transmitForced              = false;
2375:                
2376:                        _DRV_I2C_QueuePush( dObj, i2cDataObj);
2377:                
2378:                        if ( (_DRV_I2C_OPERATION_MODE_GET(dObj->i2cMode)) == DRV_I2C_MODE_MASTER)
2379:                        {
2380:                
2381:                            /*  if either START and STOP were not detected which is true the
2382:                                first time OR if STOP was detected, then it assumed the
2383:                                transaction on the bus is complete */
2384:                
2385:                            if ( ((!(PLIB_I2C_StartWasDetected(dObj->i2cId))) && (!(PLIB_I2C_StopWasDetected(dObj->i2cId)))) ||
2386:                                    (PLIB_I2C_StopWasDetected(dObj->i2cId)) )
2387:                            {
2388:                
2389:                                /* if Bus IDLE and I2CxMIF = 0, then I2C is not running*/
2390:                
2391:                                if ( (PLIB_I2C_BusIsIdle(dObj->i2cId)) &&
2392:                                       (!(SYS_INT_SourceStatusGet(dObj->mstrInterruptSource))) )
2393:                                {
2394:                //                    SYS_INT_SourceStatusClear(dObj->mstrInterruptSource);
2395:                                    _DRV_I2C_InterruptSourceEnable( dObj->mstrInterruptSource ) ;
2396:                
2397:                                    _DRV_I2C_InterruptSourceEnable( dObj->errInterruptSource );
2398:                                    dObj->task = DRV_I2C_TASK_SEND_DEVICE_ADDRESS;
2399:                                    PLIB_I2C_MasterStart(dObj->i2cId);
2400:                                }
2401:                            }
2402:                        }
2403:                        else
2404:                        {
2405:                           SYS_INT_SourceStatusClear(dObj->slaveInterruptSource);
2406:                           _DRV_I2C_InterruptSourceEnable( dObj->slaveInterruptSource ) ;
2407:                
2408:                        }
2409:                        return (DRV_I2C_BUFFER_HANDLE) i2cDataObj;
2410:                    }
2411:                    return (DRV_I2C_BUFFER_HANDLE)NULL;
2412:                } /* DRV_I2C_BufferAddWrite */
2413:                
2414:                //******************************************************************************
2415:                /* Function:
2416:                    DRV_I2C_BUFFER_HANDLE DRV_I2C_TransmitReceive ( DRV_HANDLE handle,
2417:                                                                    uint8_t* address,
2418:                                                                    void *txBuffer,
2419:                                                                    size_t wsize,
2420:                                                                    void *rxBuffer,
2421:                                                                    size_t rsize,
2422:                                                                    void * context);
2423:                
2424:                  Summary:
2425:                    This function writes data to Slave, inserts restart and requests read from
2426:                    slave.
2427:                
2428:                  Description:
2429:                    Master calls this function to send a register address value to the slave and
2430:                    then queries the slave with a read request to read the contents indexed by
2431:                    the register location. The Master sends a restart condition after the
2432:                    initial write before sending the device address with R/W = 1. The restart
2433:                    condition prevents the Master from relinquishing the control of the bus. The
2434:                    slave should not use this function. Driver will process this request
2435:                    in the task routine.
2436:                
2437:                  Parameters:
2438:                    handle      - A valid open-instance handle, returned from the driver's open
2439:                                  routine
2440:                    address     - Device address of slave. If this API is used in Slave mode,
2441:                                  then a dummy value can be used
2442:                    writeBuffer - Contains data to be transferred
2443:                    writeSize   - The number of bytes that the Master expects to write to Slave.
2444:                                  This value can be kept as the MAX BUFFER SIZE for slave.
2445:                                  This is because the Master controls when the WRITE operation
2446:                                  is terminated.
2447:                    readBuffer  - This buffer holds data that is send back from slave after
2448:                                  read operation.
2449:                    readSize    - The number of bytes the Master expects to be read from the
2450:                                  slave
2451:                    callbackContext     - Not implemented, future expansion
2452:                
2453:                  Returns:
2454:                    DRV_I2C_BUFFER_HANDLE using which application can track the current status of
2455:                    the buffer.
2456:                */
2457:                
2458:                DRV_I2C_BUFFER_HANDLE DRV_I2C_TransmitThenReceive   (   DRV_HANDLE handle,
2459:                                                                        uint16_t address,
2460:                                                                        void *writeBuffer,
2461:                                                                        size_t writeSize,
2462:                                                                        void *readBuffer,
2463:                                                                        size_t readSize,
2464:                                                                        void * callbackContext)
2465:                {
9D0099E8  27BDFFD0   ADDIU SP, SP, -48
9D0099EC  AFBF002C   SW RA, 44(SP)
9D0099F0  AFB50028   SW S5, 40(SP)
9D0099F4  AFB40024   SW S4, 36(SP)
9D0099F8  AFB30020   SW S3, 32(SP)
9D0099FC  AFB2001C   SW S2, 28(SP)
9D009A00  AFB10018   SW S1, 24(SP)
9D009A04  AFB00014   SW S0, 20(SP)
9D009A08  00809821   ADDU S3, A0, ZERO
9D009A0C  00A09021   ADDU S2, A1, ZERO
9D009A10  00C0A821   ADDU S5, A2, ZERO
9D009A14  00E0A021   ADDU S4, A3, ZERO
2466:                    DRV_I2C_BUFFER_OBJECT *i2cDataObj;
2467:                    DRV_I2C_OBJ *dObj = ((DRV_I2C_CLIENT_OBJ *) handle)->driverObject;
9D009A18  8C910000   LW S1, 0(A0)
2468:                
2469:                     /* Get a slot in the queue */
2470:                    i2cDataObj = _DRV_I2C_QueueSlotGet (dObj);
9D009A1C  0F402864   JAL _DRV_I2C_QueueSlotGet
9D009A20  02202021   ADDU A0, S1, ZERO
2471:                
2472:                    if ( i2cDataObj != NULL )
9D009A24  10400056   BEQ V0, ZERO, 0x9D009B80
9D009A28  00408021   ADDU S0, V0, ZERO
2473:                    {
2474:                      /* Fill the data directly to the queue. Set the inUse flag only at the end */
2475:                        i2cDataObj->clientHandle        = handle;
9D009A2C  AC530004   SW S3, 4(V0)
2476:                        if (address > ADDRESS_7BIT_UPPER_LIMIT )
9D009A30  2E420100   SLTIU V0, S2, 256
9D009A34  54400005   BNEL V0, ZERO, 0x9D009A4C
9D009A38  A2120008   SB S2, 8(S0)
2477:                        {
2478:                            i2cDataObj->slaveaddresshighbyte = (uint8_t)((address & 0xFF00)>>8);
9D009A3C  00121202   SRL V0, S2, 8
9D009A40  A2020008   SB V0, 8(S0)
9D009A44  0B402694   J 0x9D009A50
9D009A48  A2120009   SB S2, 9(S0)
2479:                            i2cDataObj->slaveaddresslowbyte  = (uint8_t)(address & 0x00FF);
2480:                        }
2481:                        else
2482:                        {
2483:                            i2cDataObj->slaveaddresshighbyte = (uint8_t)(address & 0x00FF);
2484:                            i2cDataObj->slaveaddresslowbyte  = 0;
9D009A4C  A2000009   SB ZERO, 9(S0)
2485:                        }
2486:                        i2cDataObj->operation           = DRV_I2C_OP_WRITE_READ;
9D009A50  24020002   ADDIU V0, ZERO, 2
9D009A54  AE02000C   SW V0, 12(S0)
2487:                        i2cDataObj->txBuffer            = writeBuffer;
9D009A58  AE150010   SW S5, 16(S0)
2488:                        i2cDataObj->transferSize        = writeSize;
9D009A5C  AE140018   SW S4, 24(S0)
2489:                        i2cDataObj->rxBuffer            = readBuffer;
9D009A60  8FA20040   LW V0, 64(SP)
9D009A64  AE020014   SW V0, 20(S0)
2490:                        i2cDataObj->readtransferSize    = readSize;
9D009A68  8FA20044   LW V0, 68(SP)
9D009A6C  AE02001C   SW V0, 28(S0)
2491:                        i2cDataObj->actualtransfersize  = 0;
9D009A70  AE000020   SW ZERO, 32(S0)
2492:                        i2cDataObj->status              = DRV_I2C_BUFFER_EVENT_PENDING;
9D009A74  AE00002C   SW ZERO, 44(S0)
2493:                        i2cDataObj->context             = callbackContext;
9D009A78  8FA20048   LW V0, 72(SP)
9D009A7C  AE020034   SW V0, 52(S0)
2494:                        i2cDataObj->transmitForced      = false;
9D009A80  A2000024   SB ZERO, 36(S0)
2495:                
2496:                        _DRV_I2C_QueuePush( dObj, i2cDataObj);
9D009A84  02202021   ADDU A0, S1, ZERO
9D009A88  0F40454B   JAL _DRV_I2C_QueuePush
9D009A8C  02002821   ADDU A1, S0, ZERO
2497:                
2498:                        if ( (_DRV_I2C_OPERATION_MODE_GET(dObj->i2cMode)) == DRV_I2C_MODE_MASTER)
9D009A90  8E220024   LW V0, 36(S1)
9D009A94  54400028   BNEL V0, ZERO, DRV_I2C_TransmitThenReceive::PLIB_INT_SourceFlagClear
9D009A98  8E220038   LW V0, 56(S1)
2499:                        {
2500:                
2501:                            /*  if either START and STOP were not detected which is true the
2502:                                first time OR if STOP was detected, then it assumed the
2503:                                transaction on the bus is complete */
2504:                
2505:                            if ( ((!(PLIB_I2C_StartWasDetected(dObj->i2cId))) && (!(PLIB_I2C_StopWasDetected(dObj->i2cId)))) ||
9D009AA8  14600005   BNE V1, ZERO, DRV_I2C_TransmitThenReceive::PLIB_I2C_StopWasDetected
9D009AAC  00000000   NOP
9D009AB8  10600005   BEQ V1, ZERO, DRV_I2C_TransmitThenReceive::PLIB_I2C_BusIsIdle
9D009ABC  00000000   NOP
9D009AC8  5060003B   BEQL V1, ZERO, 0x9D009BB8
9D009ACC  02001021   ADDU V0, S0, ZERO
2506:                                    (PLIB_I2C_StopWasDetected(dObj->i2cId)) )
2507:                            {
2508:                
2509:                                /* if Bus IDLE and I2CxMIF = 0, then I2C is not running*/
2510:                
2511:                                if ( (PLIB_I2C_BusIsIdle(dObj->i2cId)) &&
9D009BAC  1080FFD2   BEQ A0, ZERO, DRV_I2C_TransmitThenReceive::PLIB_INT_SourceEnable
9D009BB0  3C04BF88   LUI A0, -16504
9D009BB4  02001021   ADDU V0, S0, ZERO
2512:                                       (!(SYS_INT_SourceStatusGet(dObj->mstrInterruptSource))) )
2513:                                {
2514:                //                    SYS_INT_SourceStatusClear(dObj->mstrInterruptSource);
2515:                                    _DRV_I2C_InterruptSourceEnable( dObj->mstrInterruptSource ) ;
2516:                
2517:                                    _DRV_I2C_InterruptSourceEnable( dObj->errInterruptSource );
9D009B0C  8E23003C   LW V1, 60(S1)
2518:                                    dObj->task = DRV_I2C_TASK_SEND_DEVICE_ADDRESS;
9D009B24  AE200048   SW ZERO, 72(S1)
2519:                                    PLIB_I2C_MasterStart(dObj->i2cId);
2520:                                }
2521:                            }
2522:                        }
2523:                        else
2524:                        {
2525:                           SYS_INT_SourceStatusClear(dObj->slaveInterruptSource);
2526:                           _DRV_I2C_InterruptSourceEnable( dObj->slaveInterruptSource ) ;
9D009B58  8E220038   LW V0, 56(S1)
2527:                
2528:                        }
2529:                        return (DRV_I2C_BUFFER_HANDLE) i2cDataObj;
9D009AF0  0B4026EE   J 0x9D009BB8
9D009AF4  02001021   ADDU V0, S0, ZERO
9D009B30  0B4026EE   J 0x9D009BB8
9D009B34  02001021   ADDU V0, S0, ZERO
9D009B78  0B4026EE   J 0x9D009BB8
9D009B7C  02001021   ADDU V0, S0, ZERO
2530:                    }
2531:                     return (DRV_I2C_BUFFER_HANDLE)NULL;
9D009B80  0B4026EE   J 0x9D009BB8
9D009B84  00001021   ADDU V0, ZERO, ZERO
2532:                } /* DRV_I2C_TransmitThenReceive */
9D009BB8  8FBF002C   LW RA, 44(SP)
9D009BBC  8FB50028   LW S5, 40(SP)
9D009BC0  8FB40024   LW S4, 36(SP)
9D009BC4  8FB30020   LW S3, 32(SP)
9D009BC8  8FB2001C   LW S2, 28(SP)
9D009BCC  8FB10018   LW S1, 24(SP)
9D009BD0  8FB00014   LW S0, 20(SP)
9D009BD4  03E00008   JR RA
9D009BD8  27BD0030   ADDIU SP, SP, 48
2533:                
2534:                //******************************************************************************
2535:                /* Function:
2536:                    DRV_I2C_BUFFER_HANDLE DRV_I2C_BufferAddWriteRead (  DRV_HANDLE handle,
2537:                                                                        uint8_t* address,
2538:                                                                        void *txBuffer,
2539:                                                                        size_t wsize,
2540:                                                                        void *rxBuffer,
2541:                                                                        size_t rsize,
2542:                                                                        void * context);
2543:                
2544:                  Summary:
2545:                    This function writes data to Slave, inserts restart and requests read from
2546:                    slave.
2547:                
2548:                  Description:
2549:                    Master calls this function to send a register address value to the slave and
2550:                    then queries the slave with a read request to read the contents indexed by
2551:                    the register location. The Master sends a restart condition after the
2552:                    initial write before sending the device address with R/W = 1. The restart
2553:                    condition prevents the Master from relinquishing the control of the bus. The
2554:                    slave should not use this function. Driver will process this request
2555:                    in the task routine.
2556:                
2557:                  Parameters:
2558:                    drvHandle   - A valid open-instance handle, returned from the driver's open
2559:                                  routine
2560:                    address     - Device address of slave. If this API is used in Slave mode,
2561:                                  then a dummy value can be used
2562:                    txBuffer    - Contains data to be transffered
2563:                    wsize       - The number of bytes that the Master expects to write to Slave.
2564:                                  This value can be kept as the MAX BUFFER SIZE for slave.
2565:                                  This is because the Master controls when the WRITE operation
2566:                                  is terminated.
2567:                    rxBuffer    - This buffer holds data that is send back from slave after
2568:                                  read operation.
2569:                    rsize       - The number of bytes the Master expects to be read from the
2570:                                  slave
2571:                    context     - Not implemented, future expansion
2572:                
2573:                  Returns:
2574:                    DRV_I2C_BUFFER_HANDLE using which application can track the current status of
2575:                    the buffer.
2576:                */
2577:                
2578:                DRV_I2C_BUFFER_HANDLE DRV_I2C_BufferAddWriteRead (  DRV_HANDLE handle,
2579:                                                                    uint8_t* address,
2580:                                                                    void *txBuffer,
2581:                                                                    size_t wsize,
2582:                                                                    void *rxBuffer,
2583:                                                                    size_t rsize,
2584:                                                                    void * context)
2585:                {
2586:                    DRV_I2C_BUFFER_OBJECT *i2cDataObj;
2587:                    DRV_I2C_OBJ *dObj = ((DRV_I2C_CLIENT_OBJ *) handle)->driverObject;
2588:                
2589:                     /* Get a slot in the queue */
2590:                    i2cDataObj = _DRV_I2C_QueueSlotGet (dObj);
2591:                
2592:                    if ( i2cDataObj != NULL )
2593:                    {
2594:                      /* Fill the data directly to the queue. Set the inUse flag only at the end */
2595:                        i2cDataObj->clientHandle                = handle;
2596:                        i2cDataObj->slaveaddresshighbyte        = *(address);
2597:                        i2cDataObj->slaveaddresslowbyte         = 0x00;
2598:                        i2cDataObj->operation                   = DRV_I2C_OP_WRITE_READ;
2599:                        i2cDataObj->txBuffer                    = txBuffer;
2600:                        i2cDataObj->transferSize                = wsize;
2601:                        i2cDataObj->rxBuffer                    = rxBuffer;
2602:                        i2cDataObj->readtransferSize            = rsize;
2603:                        i2cDataObj->actualtransfersize          = 0;
2604:                        i2cDataObj->status                      = DRV_I2C_BUFFER_EVENT_PENDING;
2605:                        i2cDataObj->context                     = context;
2606:                        i2cDataObj->transmitForced              = false;
2607:                
2608:                        _DRV_I2C_QueuePush( dObj, i2cDataObj);
2609:                
2610:                        if ( (_DRV_I2C_OPERATION_MODE_GET(dObj->i2cMode)) == DRV_I2C_MODE_MASTER)
2611:                        {
2612:                
2613:                            /*  if either START and STOP were not detected which is true the
2614:                                first time OR if STOP was detected, then it assumed the
2615:                                transaction on the bus is complete */
2616:                
2617:                            if ( ((!(PLIB_I2C_StartWasDetected(dObj->i2cId))) && (!(PLIB_I2C_StopWasDetected(dObj->i2cId)))) ||
2618:                                    (PLIB_I2C_StopWasDetected(dObj->i2cId)) )
2619:                            {
2620:                
2621:                                /* if Bus IDLE and I2CxMIF = 0, then I2C is not running*/
2622:                
2623:                                if ( (PLIB_I2C_BusIsIdle(dObj->i2cId)) &&
2624:                                       (!(SYS_INT_SourceStatusGet(dObj->mstrInterruptSource))) )
2625:                                {
2626:                //                    SYS_INT_SourceStatusClear(dObj->mstrInterruptSource);
2627:                                    _DRV_I2C_InterruptSourceEnable( dObj->mstrInterruptSource ) ;
2628:                
2629:                                    _DRV_I2C_InterruptSourceEnable( dObj->errInterruptSource );
2630:                                    dObj->task = DRV_I2C_TASK_SEND_DEVICE_ADDRESS;
2631:                                    PLIB_I2C_MasterStart(dObj->i2cId);
2632:                                }
2633:                            }
2634:                        }
2635:                        else
2636:                        {
2637:                           SYS_INT_SourceStatusClear(dObj->slaveInterruptSource);
2638:                           _DRV_I2C_InterruptSourceEnable( dObj->slaveInterruptSource ) ;
2639:                
2640:                        }
2641:                        return (DRV_I2C_BUFFER_HANDLE) i2cDataObj;
2642:                    }
2643:                     return (DRV_I2C_BUFFER_HANDLE)NULL;
2644:                } /* DRV_I2C_BufferAddWrite */
2645:                
2646:                // *****************************************************************************
2647:                /* Function:
2648:                    DRV_I2C_BUFFER_EVENT DRV_I2C_BufferStatus ( DRV_I2C_BUFFER_HANDLE bufferHandle )
2649:                
2650:                  Summary:
2651:                    Returns the transmitter and receiver transfer status
2652:                
2653:                  Description:
2654:                    This returns the transmitter and receiver transfer status.
2655:                
2656:                  Parameters:
2657:                
2658:                    handle          - A valid open-instance handle, returned from the driver's
2659:                                      open routine
2660:                    bufferHandle    - A valid open-instance handle, returned when calling the
2661:                                      BufferAddRead/BufferAddWrite/BufferAddReadWrite function
2662:                
2663:                  Returns:
2664:                    A DRV_I2C_TRANSFER_STATUS value describing the current status of the
2665:                    transfer.
2666:                */
2667:                
2668:                DRV_I2C_BUFFER_EVENT DRV_I2C_TransferStatusGet  ( DRV_HANDLE handle,
2669:                                                                  DRV_I2C_BUFFER_HANDLE bufferHandle )
2670:                {
2671:                    /* return the transfer status. This doesn't have any protection */
2672:                
2673:                    return _DRV_I2C_DATA_OBJ(bufferHandle, status);
2674:                
2675:                } /* DRV_I2C_TransferStatus */
9D015A08  03E00008   JR RA
9D015A0C  8CA2002C   LW V0, 44(A1)
2676:                
2677:                
2678:                // *****************************************************************************
2679:                /* Function:
2680:                    DRV_I2C_BUFFER_EVENT DRV_I2C_BufferStatus ( DRV_I2C_BUFFER_HANDLE bufferHandle )
2681:                
2682:                  Summary:
2683:                    Returns the transmitter and receiver transfer status
2684:                
2685:                  Description:
2686:                    This returns the transmitter and receiver transfer status.
2687:                
2688:                  Parameters:
2689:                    handle       - A valid open-instance handle, returned from the driver's
2690:                                   open routine
2691:                
2692:                  Returns:
2693:                    A DRV_I2C_TRANSFER_STATUS value describing the current status of the
2694:                    transfer.
2695:                */
2696:                
2697:                DRV_I2C_BUFFER_EVENT DRV_I2C_BufferStatus ( DRV_I2C_BUFFER_HANDLE bufferHandle )
2698:                {
2699:                    /* return the transfer status. This doesn't have any protection */
2700:                
2701:                    return _DRV_I2C_DATA_OBJ(bufferHandle, status);
2702:                
2703:                } /* DRV_I2C_TransferStatus */
2704:                
2705:                
2706:                // *****************************************************************************
2707:                /* Function:
2708:                    uint32_t DRV_I2C_BytesTransferred ( DRV_I2C_BUFFER_HANDLE bufferHandle )
2709:                
2710:                  Summary:
2711:                    Returns the number of bytes transmitted or received in a particular I2C
2712:                    transaction. The transaction is identified by the handle.
2713:                
2714:                  Description:
2715:                    This returns the transmitter and receiver transfer status.
2716:                
2717:                  Parameters:
2718:                
2719:                    handle      - A valid open-instance handle, returned from the driver's open
2720:                                  routine
2721:                    bufferHandle  -  A valid open-instance handle, returned when calling the
2722:                                     BufferAddRead/BufferAddWrite/BufferAddReadWrite function
2723:                
2724:                  Returns:
2725:                    The number of bytes transferred in a particular I2C transaction.
2726:                */
2727:                
2728:                uint32_t DRV_I2C_BytesTransferred ( DRV_HANDLE handle,
2729:                                                    DRV_I2C_BUFFER_HANDLE bufferHandle )
2730:                {
2731:                    /* returns the number of bytes in an I2C transaction */
2732:                
2733:                    return _DRV_I2C_DATA_OBJ(bufferHandle, actualtransfersize);
2734:                
2735:                } /* DRV_I2C_BytesTransferred */
2736:                
2737:                
2738:                
2739:                //******************************************************************************
2740:                /* Function:
2741:                    unsigned int DRV_I2C_VersionGet( const SYS_MODULE_INDEX drvIndex )
2742:                
2743:                  Summary:
2744:                    Gets I2C driver version in numerical format.
2745:                
2746:                  Description:
2747:                    This routine gets the I2C driver version. The version is encoded as
2748:                    major * 10000 + minor * 100 + patch. The stringized version can be obtained
2749:                    using DRV_I2C_VersionStrGet()
2750:                
2751:                  Parameters:
2752:                    None.
2753:                
2754:                  Returns:
2755:                    Current driver version in numerical format.
2756:                */
2757:                
2758:                unsigned int DRV_I2C_VersionGet( const SYS_MODULE_INDEX drvIndex )
2759:                {
2760:                    return( ( _DRV_I2C_VERSION_MAJOR * 10000 ) +
2761:                            ( _DRV_I2C_VERSION_MINOR * 100 ) +
2762:                            ( _DRV_I2C_VERSION_PATCH ) );
2763:                
2764:                } /* DRV_I2C_VersionGet */
2765:                
2766:                
2767:                // *****************************************************************************
2768:                /* Function:
2769:                    char * DRV_I2C_VersionStrGet ( const SYS_MODULE_INDEX drvIndex )
2770:                
2771:                  Summary:
2772:                    Gets I2C driver version in string format.
2773:                
2774:                  Description:
2775:                    This routine gets the I2C driver version. The version is returned as
2776:                    major.minor.path[type], where type is optional. The numerical version can
2777:                    be obtained using DRV_I2C_VersionGet()
2778:                
2779:                  Parameters:
2780:                    None.
2781:                
2782:                  Returns:
2783:                    Current I2C driver version in the string format.
2784:                
2785:                  Remarks:
2786:                    None.
2787:                */
2788:                
2789:                char * DRV_I2C_VersionStrGet( const SYS_MODULE_INDEX drvIndex )
2790:                {
2791:                    return _DRV_I2C_VERSION_STR;
2792:                
2793:                } /* DRV_I2C_VersionStrGet */
2794:                
2795:                // *****************************************************************************
2796:                /*
2797:                  Remarks:
2798:                    The functions DRV_I2C_StopEventSend, DRV_I2C_RestartEventSend and
2799:                    and DRV_I2C_IRQEventSend are deprecated but maintained for backward
2800:                    compatibility
2801:                */
2802:                
2803:                void DRV_I2C_StopEventSend(DRV_HANDLE handle)
2804:                {
2805:                    DRV_I2C_OBJ *dObj = ((DRV_I2C_CLIENT_OBJ *) handle)->driverObject;
2806:                    if ( (_DRV_I2C_OPERATION_MODE_GET(dObj->i2cMode)) == DRV_I2C_MODE_MASTER)
2807:                    {
2808:                        PLIB_I2C_MasterStop (dObj->i2cId);
2809:                    }
2810:                }
2811:                
2812:                void DRV_I2C_RestartEventSend(DRV_HANDLE handle)
2813:                {
2814:                    DRV_I2C_OBJ *dObj = ((DRV_I2C_CLIENT_OBJ *) handle)->driverObject;
2815:                
2816:                    if ( (_DRV_I2C_OPERATION_MODE_GET(dObj->i2cMode)) == DRV_I2C_MODE_MASTER)
2817:                    {
2818:                        PLIB_I2C_MasterStartRepeat (dObj->i2cId);
2819:                    }
2820:                }
2821:                
2822:                void DRV_I2C_IRQEventSend(DRV_HANDLE handle)
2823:                {
2824:                    DRV_I2C_CLIENT_OBJ *clientObj = (DRV_I2C_CLIENT_OBJ*) handle;
2825:                
2826:                    DRV_I2C_OBJ  *dObj = ((DRV_I2C_CLIENT_OBJ *) handle)->driverObject;
2827:                
2828:                    if ( (_DRV_I2C_OPERATION_MODE_GET(dObj->i2cMode)) == DRV_I2C_MODE_SLAVE)
2829:                    {
2830:                        PLIB_PORTS_PinClear(PORTS_ID_0, clientObj->irqSelectPort, clientObj->irqSelectBitPos);
2831:                        dObj->modulemainstate = DRV_I2C_SLAVE_READY_TO_TX_TO_MASTER;
2832:                    }
2833:                }
2834:                
2835:                
2836:                // *****************************************************************************
2837:                /* Function:
2838:                    void DRV_I2C_Bus_Reset ( SYS_MODULE_OBJ object )
2839:                
2840:                  Summary:
2841:                    Resets any slaves on the I2C bus which might be stuck in thier internal state
2842:                    machines.
2843:                
2844:                  Description:
2845:                    This returns the transmitter and receiver transfer status.  From the I2C
2846:                    Specification:
2847:                    "If the data line (SDA) is stuck LOW, the master should send nine clock pulses.
2848:                    The device that held the bus LOW should release it sometime within those nine
2849:                    clocks. If not, then use the HW reset or cycle power to clear the bus."
2850:                    This function sends a Start signal, 9 clocks, and then a Stop singal.
2851:                
2852:                  Parameters:
2853:                    object          - Identifies the Driver Object returned by the Initialize
2854:                                      interface
2855:                
2856:                  Returns:
2857:                
2858:                  Remarks:
2859:                    NOTE:   This is a blocking function.  It is NOT multi client friendly.  It
2860:                            should be used with caution.  It is meant to be used in a single
2861:                            Master environment where the PIC using it is the sole Master device
2862:                            on the I2C bus.  Under normal conditions, it should only be
2863:                            necessary during development.  Reseting the PIC32 without resetting
2864:                            slave devices on the I2C bus can sometimes cause them to be stuck
2865:                            in the middle of a reception or transmission.  This function can
2866:                            clear the bus in those cases.
2867:                */
2868:                void DRV_I2C_Bus_Clear ( SYS_MODULE_OBJ object )
2869:                {
2870:                    uint32_t    starttime;
2871:                    DRV_I2C_OBJ *dObj = (DRV_I2C_OBJ*) object;
2872:                    if ( DRV_I2C_BIT_BANG != dObj->i2cPerph)
2873:                    {
2874:                        PLIB_I2C_Disable (dObj->i2cId);
2875:                    }
2876:                
2877:                    /* Wait 50k BRG */
2878:                    starttime = ReadCoreTimer();
2879:                    while(ReadCoreTimer()- starttime < BRG_1_TIME_0);
2880:                
2881:                    // I2C Bus reset consists of an empty byte transfer.
2882:                    // That is,
2883:                    // a Start signal, Data Goes Low while Clock is High.
2884:                    // sequence of 9 clocks so that any slave state machine completes.
2885:                    // A Stop signal, Data Goes High while Clock is High.
2886:                    // Set Both pins High
2887:                    PLIB_PORTS_PinClear(PORTS_ID_0, dObj->portSCL, dObj->pinSCL);
2888:                    PLIB_PORTS_PinClear(PORTS_ID_0, dObj->portSDA, dObj->pinSDA);
2889:                    PLIB_PORTS_PinDirectionInputSet(PORTS_ID_0, dObj->portSCL, dObj->pinSCL);
2890:                    PLIB_PORTS_PinDirectionInputSet(PORTS_ID_0, dObj->portSDA, dObj->pinSDA);
2891:                    /* Wait 50k BRG */
2892:                    starttime = ReadCoreTimer();
2893:                    while(ReadCoreTimer()- starttime < BRG_1_TIME_0);
2894:                
2895:                    // Change SDA  to LOW  --  Start Signal.
2896:                    PLIB_PORTS_PinDirectionOutputSet(PORTS_ID_0, dObj->portSDA, dObj->pinSDA);
2897:                    /* Wait 50k BRG */
2898:                    starttime = ReadCoreTimer();
2899:                    while(ReadCoreTimer()- starttime < BRG_1_TIME_0);
2900:                
2901:                    // Change SDA  to HIGH  --  Allows SDA to float so no data is sent from master.
2902:                    PLIB_PORTS_PinDirectionInputSet(PORTS_ID_0, dObj->portSDA, dObj->pinSDA);
2903:                    /* Wait 50k BRG */
2904:                    starttime = ReadCoreTimer();
2905:                    while(ReadCoreTimer()- starttime < BRG_1_TIME_0);
2906:                
2907:                    int i;
2908:                    // sequence of 9 clocks so that any slave state machine completes.
2909:                    for(i=0;i<10;i++)
2910:                    {
2911:                        // Change SCL to LOW
2912:                        PLIB_PORTS_PinDirectionOutputSet(PORTS_ID_0, dObj->portSCL, dObj->pinSCL);
2913:                        if(i == 9)
2914:                        {
2915:                            /* Wait 50k BRG */
2916:                            starttime = ReadCoreTimer();
2917:                            while(ReadCoreTimer()- starttime < BRG_1_TIME_0);
2918:                            PLIB_PORTS_PinDirectionOutputSet(PORTS_ID_0, dObj->portSDA, dObj->pinSDA);
2919:                        }
2920:                        /* Wait 50k BRG */
2921:                        starttime = ReadCoreTimer();
2922:                        while(ReadCoreTimer()- starttime < BRG_1_TIME_0);
2923:                        // Change SCL to HIGH
2924:                        PLIB_PORTS_PinDirectionInputSet(PORTS_ID_0, dObj->portSCL, dObj->pinSCL);
2925:                        /* Wait 50k BRG */
2926:                        starttime = ReadCoreTimer();
2927:                        while(ReadCoreTimer()- starttime < BRG_1_TIME_0);
2928:                    }
2929:                    // After this sequence, the clock is high, and the data is low.
2930:                
2931:                    // A Stop signal, Data Goes High while Clock is High.
2932:                    PLIB_PORTS_PinDirectionInputSet(PORTS_ID_0, dObj->portSDA, dObj->pinSDA);
2933:                    /* Wait 50k BRG */
2934:                    starttime = ReadCoreTimer();
2935:                    while(ReadCoreTimer()- starttime < BRG_1_TIME_0);
2936:                    // At this point both lines are high, and the Bus is idle.
2937:                    if ( DRV_I2C_BIT_BANG != dObj->i2cPerph)
2938:                    {
2939:                        PLIB_I2C_Enable (dObj->i2cId);
2940:                    }
2941:                }
2942:                
2943:                void DRV_I2C_QueueFlush ( DRV_HANDLE handle )
2944:                {
2945:                    uint16_t index;
2946:                
2947:                    DRV_I2C_OBJ  *dObj = ((DRV_I2C_CLIENT_OBJ *) handle)->driverObject;
2948:                
2949:                    SYS_MODULE_INDEX drvIndex = dObj->drvIndex;
2950:                
2951:                    DRV_I2C_BUFFER_OBJECT *lQueueObj;
2952:                
2953:                    dObj->queueHead = NULL;
2954:                
2955:                    dObj->queueIn = 0;
2956:                
2957:                    dObj->queueOut = 0;
2958:                
2959:                    for ( index=0; index<DRV_I2C_NUM_OF_BUFFER_OBJECTS; index++ )
2960:                    {
2961:                        lQueueObj = &gDrvI2CBufferObj [ drvIndex ][ index ];
2962:                
2963:                        lQueueObj->inUse    = false;
2964:                
2965:                        lQueueObj->next     = NULL;
2966:                
2967:                        lQueueObj->status   = DRV_I2C_BUFFER_EVENT_COMPLETE;
2968:                    }
2969:                
2970:                    /* When an I2C transaction is attempted without any pull-ups on the bus
2971:                       I2C Master ISR is triggered for START condition, but also Bus Exception
2972:                       ISR is also triggered, to clear BCL bit, I2C has to reset */
2973:                
2974:                    SYS_INT_SourceStatusClear(dObj->errInterruptSource);
2975:                    PLIB_I2C_Disable (dObj->i2cId);
2976:                    PLIB_I2C_Enable (dObj->i2cId);
2977:                }
2978:                
2979:                
2980:                /*******************************************************************************
2981:                End of File
2982:                */
2983:                
2984:                
2985:                
---  /home/whatisthis/microchip/harmony/v2_04/framework/crypto/src/misc.c  ------------------------------
1:                   /**************************************************************************
2:                     Crypto Framework Library Source
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       misc.c
9:                     
10:                    Summary:
11:                      Crypto Framework Libarary source for cryptographic functions.
12:                  
13:                    Description:
14:                      This source file contains functions that make up the Cryptographic 
15:                  	Framework Library for PIC32 families of Microchip microcontrollers.
16:                  **************************************************************************/
17:                  
18:                  //DOM-IGNORE-BEGIN
19:                  /******************************************************************************
20:                  File Name:  misc.c
21:                  Copyright  2013 released Microchip Technology Inc.  All rights reserved.
22:                  
23:                  Microchip licenses to you the right to use, modify, copy and distribute
24:                  Software only when embedded on a Microchip microcontroller or digital signal
25:                  controller that is integrated into your product or third party product
26:                  (pursuant to the sublicense terms in the accompanying license agreement).
27:                  
28:                  You should refer to the license agreement accompanying this Software for
29:                  additional information regarding your rights and obligations.
30:                  
31:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
32:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
33:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
34:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
35:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
36:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
37:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
38:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
39:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
40:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
41:                  *******************************************************************************/
42:                  //DOM-IGNORE-END
43:                  
44:                  
45:                  
46:                  #ifdef HAVE_CONFIG_H
47:                      #include "config.h"
48:                  #endif
49:                  #include "system_config.h"
50:                  
51:                  #include "crypto/src/settings.h"
52:                  
53:                  #ifndef WOLF_CRYPT_MISC_C
54:                  #define WOLF_CRYPT_MISC_C
55:                  
56:                  #include "crypto/src/misc.h"
57:                  
58:                  /* inlining these functions is a huge speed increase and a small size decrease,
59:                     because the functions are smaller than function call setup/cleanup, e.g.,
60:                     md5 benchmark is twice as fast with inline.  If you don't want it, then
61:                     define NO_INLINE and compile this file into wolfssl, otherwise it's used as
62:                     a source header
63:                   */
64:                  
65:                  #ifdef NO_INLINE
66:                      #define STATIC
67:                  #else
68:                      #define STATIC static
69:                  #endif
70:                  
71:                  /* Check for if compiling misc.c when not needed. */
72:                  #if !defined(WOLFSSL_MISC_INCLUDED) && !defined(NO_INLINE)
73:                  /*    #warning misc.c does not need to be compiled when using inline (NO_INLINE not defined) */
74:                  #else
75:                  
76:                  
77:                  #if defined(__ICCARM__)
78:                      #include <intrinsics.h>
79:                  #endif
80:                  
81:                  
82:                  #ifdef INTEL_INTRINSICS
83:                  
84:                      #include <stdlib.h>      /* get intrinsic definitions */
85:                  
86:                      /* for non visual studio probably need no long version, 32 bit only
87:                       * i.e., _rotl and _rotr */
88:                      #pragma intrinsic(_lrotl, _lrotr)
89:                  
90:                      STATIC INLINE word32 rotlFixed(word32 x, word32 y)
91:                      {
92:                          return y ? _lrotl(x, y) : x;
93:                      }
94:                  
95:                      STATIC INLINE word32 rotrFixed(word32 x, word32 y)
96:                      {
97:                          return y ? _lrotr(x, y) : x;
98:                      }
99:                  
100:                 #else /* generic */
101:                 
102:                     STATIC INLINE word32 rotlFixed(word32 x, word32 y)
103:                     {
104:                         return (x << y) | (x >> (sizeof(y) * 8 - y));
9D002268  00231E42   ROTR V1, V1, 25
9D002294  00273D02   ROTR A3, A3, 20
9D0022C0  002843C2   ROTR T0, T0, 15
9D0022EC  00252A82   ROTR A1, A1, 10
9D002318  00231E42   ROTR V1, V1, 25
9D002344  00273D02   ROTR A3, A3, 20
9D002370  002A53C2   ROTR T2, T2, 15
9D00239C  00252A82   ROTR A1, A1, 10
9D0023C8  00231E42   ROTR V1, V1, 25
9D0023F4  00273D02   ROTR A3, A3, 20
9D002420  002E73C2   ROTR T6, T6, 15
9D00244C  00252A82   ROTR A1, A1, 10
9D002478  00231E42   ROTR V1, V1, 25
9D0024A4  00273D02   ROTR A3, A3, 20
9D0024D0  0036B3C2   ROTR S6, S6, 15
9D0024FC  00252A82   ROTR A1, A1, 10
9D002524  00231EC2   ROTR V1, V1, 27
9D00254C  00273DC2   ROTR A3, A3, 23
9D002574  0036B482   ROTR S6, S6, 18
9D00259C  00252B02   ROTR A1, A1, 12
9D0025C4  00231EC2   ROTR V1, V1, 27
9D0025EC  00273DC2   ROTR A3, A3, 23
9D002614  0036B482   ROTR S6, S6, 18
9D00263C  00252B02   ROTR A1, A1, 12
9D002664  00231EC2   ROTR V1, V1, 27
9D00268C  00273DC2   ROTR A3, A3, 23
9D0026B4  0036B482   ROTR S6, S6, 18
9D0026DC  00252B02   ROTR A1, A1, 12
9D002704  00231EC2   ROTR V1, V1, 27
9D00272C  00273DC2   ROTR A3, A3, 23
9D002754  0036B482   ROTR S6, S6, 18
9D00277C  00252B02   ROTR A1, A1, 12
9D00279C  0037BF02   ROTR S7, S7, 28
9D0027C0  00273D42   ROTR A3, A3, 21
9D0027E4  0036B402   ROTR S6, S6, 16
9D002808  00252A42   ROTR A1, A1, 9
9D00282C  0037BF02   ROTR S7, S7, 28
9D002850  00273D42   ROTR A3, A3, 21
9D002874  00231C02   ROTR V1, V1, 16
9D002898  00252A42   ROTR A1, A1, 9
9D0028BC  0037BF02   ROTR S7, S7, 28
9D0028E0  00273D42   ROTR A3, A3, 21
9D002904  00231C02   ROTR V1, V1, 16
9D002928  0036B242   ROTR S6, S6, 9
9D00294C  00252F02   ROTR A1, A1, 28
9D002970  00273D42   ROTR A3, A3, 21
9D002994  0037BC02   ROTR S7, S7, 16
9D0029B8  00231A42   ROTR V1, V1, 9
9D0029E0  00252E82   ROTR A1, A1, 26
9D002A08  00273D82   ROTR A3, A3, 22
9D002A30  0037BC42   ROTR S7, S7, 17
9D002A58  00231AC2   ROTR V1, V1, 11
9D002A80  00318E82   ROTR S1, S1, 26
9D002AA8  00308582   ROTR S0, S0, 22
9D002AD0  00273C42   ROTR A3, A3, 17
9D002AF8  00252AC2   ROTR A1, A1, 11
9D002B20  00231E82   ROTR V1, V1, 26
9D002B48  002E7582   ROTR T6, T6, 22
9D002B70  00273C42   ROTR A3, A3, 17
9D002B98  00252AC2   ROTR A1, A1, 11
9D002BC0  00231E82   ROTR V1, V1, 26
9D002BE8  002E7582   ROTR T6, T6, 22
9D002C10  00273C42   ROTR A3, A3, 17
9D002C48  00252AC2   ROTR A1, A1, 11
105:                     }
106:                 
107:                 
108:                     STATIC INLINE word32 rotrFixed(word32 x, word32 y)
109:                     {
110:                         return (x >> y) | (x << (sizeof(y) * 8 - y));
111:                     }
112:                 
113:                 #endif
114:                 
115:                 
116:                 STATIC INLINE word32 ByteReverseWord32(word32 value)
117:                 {
118:                 #ifdef PPC_INTRINSICS
119:                     /* PPC: load reverse indexed instruction */
120:                     return (word32)__lwbrx(&value,0);
121:                 #elif defined(__ICCARM__)
122:                     return (word32)__REV(value);
123:                 #elif defined(KEIL_INTRINSICS)
124:                     return (word32)__rev(value);
125:                 #elif defined(FAST_ROTATE)
126:                     /* 5 instructions with rotate instruction, 9 without */
127:                     return (rotrFixed(value, 8U) & 0xff00ff00) |
128:                            (rotlFixed(value, 8U) & 0x00ff00ff);
129:                 #else
130:                     /* 6 instructions with rotate instruction, 8 without */
131:                     value = ((value & 0xFF00FF00) >> 8) | ((value & 0x00FF00FF) << 8);
132:                     return rotlFixed(value, 16U);
133:                 #endif
134:                 }
135:                 
136:                 
137:                 STATIC INLINE void ByteReverseWords(word32* out, const word32* in,
138:                                                     word32 byteCount)
139:                 {
140:                     word32 count = byteCount/(word32)sizeof(word32), i;
141:                 
142:                     for (i = 0; i < count; i++)
143:                         out[i] = ByteReverseWord32(in[i]);
144:                 
145:                 }
146:                 
147:                 
148:                 #ifdef WORD64_AVAILABLE
149:                 
150:                 
151:                 STATIC INLINE word64 rotlFixed64(word64 x, word64 y)
152:                 {
153:                     return (x << y) | (x >> (sizeof(y) * 8 - y));
154:                 }
155:                 
156:                 
157:                 STATIC INLINE word64 rotrFixed64(word64 x, word64 y)
158:                 {
159:                     return (x >> y) | (x << (sizeof(y) * 8 - y));
160:                 }
161:                 
162:                 
163:                 STATIC INLINE word64 ByteReverseWord64(word64 value)
164:                 {
165:                 #if defined(WOLFCRYPT_SLOW_WORD64)
166:                 	return (word64)(ByteReverseWord32((word32)value)) << 32 |
167:                                     ByteReverseWord32((word32)(value>>32));
168:                 #else
169:                 	value = ((value & W64LIT(0xFF00FF00FF00FF00)) >> 8) |
170:                             ((value & W64LIT(0x00FF00FF00FF00FF)) << 8);
171:                 	value = ((value & W64LIT(0xFFFF0000FFFF0000)) >> 16) |
172:                             ((value & W64LIT(0x0000FFFF0000FFFF)) << 16);
173:                 	return rotlFixed64(value, 32U);
174:                 #endif
175:                 }
176:                 
177:                 
178:                 STATIC INLINE void ByteReverseWords64(word64* out, const word64* in,
179:                                                       word32 byteCount)
180:                 {
181:                     word32 count = byteCount/(word32)sizeof(word64), i;
182:                 
183:                     for (i = 0; i < count; i++)
184:                         out[i] = ByteReverseWord64(in[i]);
185:                 
186:                 }
187:                 
188:                 #endif /* WORD64_AVAILABLE */
189:                 
190:                 
191:                 STATIC INLINE void XorWords(wolfssl_word* r, const wolfssl_word* a, word32 n)
192:                 {
193:                     word32 i;
194:                 
195:                     for (i = 0; i < n; i++) r[i] ^= a[i];
196:                 }
197:                 
198:                 
199:                 STATIC INLINE void xorbuf(void* buf, const void* mask, word32 count)
200:                 {
201:                     if (((wolfssl_word)buf | (wolfssl_word)mask | count) % WOLFSSL_WORD_SIZE == 0)
202:                         XorWords( (wolfssl_word*)buf,
203:                                   (const wolfssl_word*)mask, count / WOLFSSL_WORD_SIZE);
204:                     else {
205:                         word32 i;
206:                         byte*       b = (byte*)buf;
207:                         const byte* m = (const byte*)mask;
208:                 
209:                         for (i = 0; i < count; i++) b[i] ^= m[i];
210:                     }
211:                 }
212:                 
213:                 
214:                 /* Make sure compiler doesn't skip */
215:                 STATIC INLINE void ForceZero(const void* mem, word32 len)
216:                 {
217:                     volatile byte* z = (volatile byte*)mem;
218:                 #ifdef WOLFSSL_X86_64_BUILD
219:                     volatile word64* w;
220:                 
221:                     for (w = (volatile word64*)z; len >= sizeof(*w); len -= sizeof(*w))
222:                         *w++ = 0;
223:                     z = (volatile byte*)w;
224:                 #endif
225:                     while (len--) *z++ = 0;
226:                 }
227:                 
228:                 
229:                 /* check all length bytes for equality, return 0 on success */
230:                 STATIC INLINE int ConstantCompare(const byte* a, const byte* b, int length)
231:                 {
232:                     int i;
233:                     int compareSum = 0;
234:                 
235:                     for (i = 0; i < length; i++) {
236:                         compareSum |= a[i] ^ b[i];
237:                     }
238:                 
239:                     return compareSum;
240:                 }
241:                 
242:                 
243:                 #ifndef WOLFSSL_HAVE_MIN
244:                     #define WOLFSSL_HAVE_MIN
245:                     #if defined(HAVE_FIPS) && !defined(min) /* so ifdef check passes */
246:                         #define min min
247:                     #endif
248:                     STATIC INLINE word32 min(word32 a, word32 b)
249:                     {
250:                         return a > b ? b : a;
251:                     }
252:                 #endif /* !WOLFSSL_HAVE_MIN */
253:                 
254:                 #ifndef WOLFSSL_HAVE_MAX
255:                     #define WOLFSSL_HAVE_MAX
256:                     #if defined(HAVE_FIPS) && !defined(max) /* so ifdef check passes */
257:                         #define max max
258:                     #endif
259:                     STATIC INLINE word32 max(word32 a, word32 b)
260:                     {
261:                         return a > b ? a : b;
262:                     }
263:                 #endif /* !WOLFSSL_HAVE_MAX */
264:                 
265:                 
266:                 #undef STATIC
267:                 
268:                 #endif /* !WOLFSSL_MISC_INCLUDED && !NO_INLINE */
269:                 
270:                 #endif /* WOLF_CRYPT_MISC_C */
---  /home/whatisthis/microchip/harmony/v2_04/framework/crypto/src/md5.c  -------------------------------
1:                   /**************************************************************************
2:                     Crypto Framework Library Source
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       md5.c
9:                     
10:                    Summary:
11:                      Crypto Framework Libarary source for cryptographic functions.
12:                  
13:                    Description:
14:                      This source file contains functions that make up the Cryptographic 
15:                  	Framework Library for PIC32 families of Microchip microcontrollers.
16:                  **************************************************************************/
17:                  
18:                  //DOM-IGNORE-BEGIN
19:                  /******************************************************************************
20:                  File Name:  md5.c
21:                  Copyright  2013-2017 released Microchip Technology Inc.  All rights reserved.
22:                  
23:                  Microchip licenses to you the right to use, modify, copy and distribute
24:                  Software only when embedded on a Microchip microcontroller or digital signal
25:                  controller that is integrated into your product or third party product
26:                  (pursuant to the sublicense terms in the accompanying license agreement).
27:                  
28:                  You should refer to the license agreement accompanying this Software for
29:                  additional information regarding your rights and obligations.
30:                  
31:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
32:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
33:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
34:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
35:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
36:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
37:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
38:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
39:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
40:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
41:                  *******************************************************************************/
42:                  //DOM-IGNORE-END
43:                  
44:                  
45:                  
46:                  
47:                  #ifdef HAVE_CONFIG_H
48:                      #include "config.h"
49:                  #endif
50:                  #include "system_config.h"
51:                  
52:                  #include "crypto/src/settings.h"
53:                  #if !defined(NO_MD5)
54:                  
55:                  #if defined(WOLFSSL_TI_HASH)
56:                      /* #include <wolfcrypt/src/port/ti/ti-hash.c> included by wc_port.c */
57:                  
58:                  #else
59:                  
60:                  #include "crypto/src/md5.h"
61:                  #include "crypto/src/error-crypt.h"
62:                  #include "crypto/src/logging.h"
63:                  
64:                  #ifdef NO_INLINE
65:                      #include "crypto/src/misc.h"
66:                  #else
67:                      #define WOLFSSL_MISC_INCLUDED
68:                      #include "crypto/src/misc.c"
69:                  #endif
70:                  
71:                  
72:                  /* Hardware Acceleration */
73:                  #if defined(STM32F2_HASH) || defined(STM32F4_HASH)
74:                      /*
75:                       * STM32F2/F4 hardware MD5 support through the standard peripheral
76:                       * library. (See note in README).
77:                       */
78:                  
79:                      #define HAVE_MD5_CUST_API
80:                  
81:                      int wc_InitMd5_ex(Md5* md5, void* heap, int devId)
82:                      {
83:                          (void)heap;
84:                          (void)devId;
85:                  
86:                          /* STM32 struct notes:
87:                           * md5->buffer  = first 4 bytes used to hold partial block if needed
88:                           * md5->buffLen = num bytes currently stored in md5->buffer
89:                           * md5->loLen   = num bytes that have been written to STM32 FIFO
90:                           */
91:                          XMEMSET(md5->buffer, 0, MD5_REG_SIZE);
92:                  
93:                          md5->buffLen = 0;
94:                          md5->loLen = 0;
95:                  
96:                          /* initialize HASH peripheral */
97:                          HASH_DeInit();
98:                  
99:                          /* configure algo used, algo mode, datatype */
100:                         HASH->CR &= ~ (HASH_CR_ALGO | HASH_CR_DATATYPE | HASH_CR_MODE);
101:                         HASH->CR |= (HASH_AlgoSelection_MD5 | HASH_AlgoMode_HASH
102:                                  | HASH_DataType_8b);
103:                 
104:                         /* reset HASH processor */
105:                         HASH->CR |= HASH_CR_INIT;
106:                 
107:                         return 0;
108:                     }
109:                 
110:                     int wc_Md5Update(Md5* md5, const byte* data, word32 len)
111:                     {
112:                         word32 i = 0;
113:                         word32 fill = 0;
114:                         word32 diff = 0;
115:                 
116:                         /* if saved partial block is available */
117:                         if (md5->buffLen > 0) {
118:                             fill = 4 - md5->buffLen;
119:                 
120:                             /* if enough data to fill, fill and push to FIFO */
121:                             if (fill <= len) {
122:                                 XMEMCPY((byte*)md5->buffer + md5->buffLen, data, fill);
123:                                 HASH_DataIn(*(uint32_t*)md5->buffer);
124:                 
125:                                 data += fill;
126:                                 len -= fill;
127:                                 md5->loLen += 4;
128:                                 md5->buffLen = 0;
129:                             } else {
130:                                 /* append partial to existing stored block */
131:                                 XMEMCPY((byte*)md5->buffer + md5->buffLen, data, len);
132:                                 md5->buffLen += len;
133:                                 return 0;
134:                             }
135:                         }
136:                 
137:                         /* write input block in the IN FIFO */
138:                         for (i = 0; i < len; i += 4)
139:                         {
140:                             diff = len - i;
141:                             if (diff < 4) {
142:                                 /* store incomplete last block, not yet in FIFO */
143:                                 XMEMSET(md5->buffer, 0, MD5_REG_SIZE);
144:                                 XMEMCPY((byte*)md5->buffer, data, diff);
145:                                 md5->buffLen = diff;
146:                             } else {
147:                                 HASH_DataIn(*(uint32_t*)data);
148:                                 data+=4;
149:                             }
150:                         }
151:                 
152:                         /* keep track of total data length thus far */
153:                         md5->loLen += (len - md5->buffLen);
154:                 
155:                         return 0;
156:                     }
157:                 
158:                     int wc_Md5Final(Md5* md5, byte* hash)
159:                     {
160:                         __IO uint16_t nbvalidbitsdata = 0;
161:                 
162:                         /* finish reading any trailing bytes into FIFO */
163:                         if (md5->buffLen > 0) {
164:                             HASH_DataIn(*(uint32_t*)md5->buffer);
165:                             md5->loLen += md5->buffLen;
166:                         }
167:                 
168:                         /* calculate number of valid bits in last word of input data */
169:                         nbvalidbitsdata = 8 * (md5->loLen % MD5_REG_SIZE);
170:                 
171:                         /* configure number of valid bits in last word of the data */
172:                         HASH_SetLastWordValidBitsNbr(nbvalidbitsdata);
173:                 
174:                         /* start HASH processor */
175:                         HASH_StartDigest();
176:                 
177:                         /* wait until Busy flag == RESET */
178:                         while (HASH_GetFlagStatus(HASH_FLAG_BUSY) != RESET) {}
179:                 
180:                         /* read message digest */
181:                         md5->digest[0] = HASH->HR[0];
182:                         md5->digest[1] = HASH->HR[1];
183:                         md5->digest[2] = HASH->HR[2];
184:                         md5->digest[3] = HASH->HR[3];
185:                 
186:                         ByteReverseWords(md5->digest, md5->digest, MD5_DIGEST_SIZE);
187:                 
188:                         XMEMCPY(hash, md5->digest, MD5_DIGEST_SIZE);
189:                 
190:                         return wc_InitMd5(md5);  /* reset state */
191:                     }
192:                 
193:                 #elif defined(FREESCALE_MMCAU_SHA)
194:                     #include "cau_api.h"
195:                     #define XTRANSFORM(S,B)  Transform((S), (B))
196:                 
197:                     static int Transform(Md5* md5, byte* data)
198:                     {
199:                         int ret = wolfSSL_CryptHwMutexLock();
200:                         if(ret == 0) {
201:                         #ifdef FREESCALE_MMCAU_CLASSIC_SHA
202:                             cau_md5_hash_n(data, 1, (unsigned char*)md5->digest);
203:                         #else
204:                             MMCAU_MD5_HashN(data, 1, (uint32_t*)md5->digest);
205:                         #endif
206:                             wolfSSL_CryptHwMutexUnLock();
207:                         }
208:                         return ret;
209:                     }
210:                 
211:                 #elif defined(WOLFSSL_PIC32MZ_HASH)
212:                     #include "crypto/src/pic32mz-crypt.h"
213:                     #define HAVE_MD5_CUST_API
214:                 
215:                 #else
216:                     #define NEED_SOFT_MD5
217:                 
218:                 #endif /* End Hardware Acceleration */
219:                 
220:                 
221:                 #ifdef NEED_SOFT_MD5
222:                 
223:                     #define XTRANSFORM(S,B)  Transform((S))
224:                 
225:                     #define F1(x, y, z) (z ^ (x & (y ^ z)))
226:                     #define F2(x, y, z) F1(z, x, y)
227:                     #define F3(x, y, z) (x ^ y ^ z)
228:                     #define F4(x, y, z) (y ^ (x | ~z))
229:                 
230:                     #define MD5STEP(f, w, x, y, z, data, s) \
231:                         w = rotlFixed(w + f(x, y, z) + data, s) + x
232:                 
233:                     static int Transform(Md5* md5)
234:                     {
9D00220C  27BDFFD8   ADDIU SP, SP, -40
9D002210  AFBE0024   SW S8, 36(SP)
9D002214  AFB70020   SW S7, 32(SP)
9D002218  AFB6001C   SW S6, 28(SP)
9D00221C  AFB50018   SW S5, 24(SP)
9D002220  AFB40014   SW S4, 20(SP)
9D002224  AFB30010   SW S3, 16(SP)
9D002228  AFB2000C   SW S2, 12(SP)
9D00222C  AFB10008   SW S1, 8(SP)
9D002230  AFB00004   SW S0, 4(SP)
235:                         /* Copy context->state[] to working vars  */
236:                         word32 a = md5->digest[0];
237:                         word32 b = md5->digest[1];
9D002234  8C820050   LW V0, 80(A0)
238:                         word32 c = md5->digest[2];
9D002238  8C860054   LW A2, 84(A0)
239:                         word32 d = md5->digest[3];
240:                 
241:                         MD5STEP(F1, a, b, c, d, md5->buffer[0]  + 0xd76aa478,  7);
9D00223C  8C95000C   LW S5, 12(A0)
9D002240  8C83004C   LW V1, 76(A0)
9D002244  00752821   ADDU A1, V1, S5
9D002248  3C03D76A   LUI V1, -10390
9D00224C  3463A478   ORI V1, V1, -23432
9D002250  00A31821   ADDU V1, A1, V1
9D002254  8C870058   LW A3, 88(A0)
9D002258  00E62826   XOR A1, A3, A2
9D00225C  00A22824   AND A1, A1, V0
9D002260  00A72826   XOR A1, A1, A3
9D002264  00651821   ADDU V1, V1, A1
9D00226C  00621821   ADDU V1, V1, V0
242:                         MD5STEP(F1, d, a, b, c, md5->buffer[1]  + 0xe8c7b756, 12);
9D002270  8C980010   LW T8, 16(A0)
9D002274  00F82821   ADDU A1, A3, T8
9D002278  3C07E8C7   LUI A3, -5945
9D00227C  34E7B756   ORI A3, A3, -18602
9D002280  00A73821   ADDU A3, A1, A3
9D002284  00C22826   XOR A1, A2, V0
9D002288  00652824   AND A1, V1, A1
9D00228C  00A62826   XOR A1, A1, A2
9D002290  00E53821   ADDU A3, A3, A1
9D002298  00E33821   ADDU A3, A3, V1
243:                         MD5STEP(F1, c, d, a, b, md5->buffer[2]  + 0x242070db, 17);
9D00229C  8C890014   LW T1, 20(A0)
9D0022A0  00C92821   ADDU A1, A2, T1
9D0022A4  3C082420   LUI T0, 9248
9D0022A8  250870DB   ADDIU T0, T0, 28891
9D0022AC  00A84021   ADDU T0, A1, T0
9D0022B0  00622826   XOR A1, V1, V0
9D0022B4  00E52824   AND A1, A3, A1
9D0022B8  00A22826   XOR A1, A1, V0
9D0022BC  01054021   ADDU T0, T0, A1
9D0022C4  01074021   ADDU T0, T0, A3
244:                         MD5STEP(F1, b, c, d, a, md5->buffer[3]  + 0xc1bdceee, 22);
9D0022C8  8C900018   LW S0, 24(A0)
9D0022CC  00505021   ADDU T2, V0, S0
9D0022D0  3C05C1BD   LUI A1, -15939
9D0022D4  34A5CEEE   ORI A1, A1, -12562
9D0022D8  01452821   ADDU A1, T2, A1
9D0022DC  00E35026   XOR T2, A3, V1
9D0022E0  010A5024   AND T2, T0, T2
9D0022E4  01435026   XOR T2, T2, V1
9D0022E8  00AA2821   ADDU A1, A1, T2
9D0022F0  00A82821   ADDU A1, A1, T0
245:                         MD5STEP(F1, a, b, c, d, md5->buffer[4]  + 0xf57c0faf,  7);
9D0022F4  8C8B001C   LW T3, 28(A0)
9D0022F8  3C0AF57C   LUI T2, -2692
9D0022FC  254A0FAF   ADDIU T2, T2, 4015
9D002300  016A5021   ADDU T2, T3, T2
9D002304  01431821   ADDU V1, T2, V1
9D002308  01075026   XOR T2, T0, A3
9D00230C  00AA5024   AND T2, A1, T2
9D002310  01475026   XOR T2, T2, A3
9D002314  006A1821   ADDU V1, V1, T2
9D00231C  00651821   ADDU V1, V1, A1
246:                         MD5STEP(F1, d, a, b, c, md5->buffer[5]  + 0x4787c62a, 12);
9D002320  8C920020   LW S2, 32(A0)
9D002324  3C0A4787   LUI T2, 18311
9D002328  354AC62A   ORI T2, T2, -14806
9D00232C  024A5021   ADDU T2, S2, T2
9D002330  01473821   ADDU A3, T2, A3
9D002334  00A85026   XOR T2, A1, T0
9D002338  006A5024   AND T2, V1, T2
9D00233C  01485026   XOR T2, T2, T0
9D002340  00EA3821   ADDU A3, A3, T2
9D002348  00E33821   ADDU A3, A3, V1
247:                         MD5STEP(F1, c, d, a, b, md5->buffer[6]  + 0xa8304613, 17);
9D00234C  8C8D0024   LW T5, 36(A0)
9D002350  3C0AA830   LUI T2, -22480
9D002354  254A4613   ADDIU T2, T2, 17939
9D002358  01AA5021   ADDU T2, T5, T2
9D00235C  01484021   ADDU T0, T2, T0
9D002360  00655026   XOR T2, V1, A1
9D002364  00EA5024   AND T2, A3, T2
9D002368  01455026   XOR T2, T2, A1
9D00236C  010A5021   ADDU T2, T0, T2
9D002374  01475021   ADDU T2, T2, A3
248:                         MD5STEP(F1, b, c, d, a, md5->buffer[7]  + 0xfd469501, 22);
9D002378  8C940028   LW S4, 40(A0)
9D00237C  3C08FD46   LUI T0, -698
9D002380  35089501   ORI T0, T0, -27391
9D002384  02884021   ADDU T0, S4, T0
9D002388  01052821   ADDU A1, T0, A1
9D00238C  00E34026   XOR T0, A3, V1
9D002390  01484024   AND T0, T2, T0
9D002394  01034026   XOR T0, T0, V1
9D002398  00A82821   ADDU A1, A1, T0
9D0023A0  00AA2821   ADDU A1, A1, T2
249:                         MD5STEP(F1, a, b, c, d, md5->buffer[8]  + 0x698098d8,  7);
9D0023A4  8C8F002C   LW T7, 44(A0)
9D0023A8  3C086980   LUI T0, 27008
9D0023AC  350898D8   ORI T0, T0, -26408
9D0023B0  01E84021   ADDU T0, T7, T0
9D0023B4  01031821   ADDU V1, T0, V1
9D0023B8  01474026   XOR T0, T2, A3
9D0023BC  00A84024   AND T0, A1, T0
9D0023C0  01074026   XOR T0, T0, A3
9D0023C4  00681821   ADDU V1, V1, T0
9D0023CC  00651821   ADDU V1, V1, A1
250:                         MD5STEP(F1, d, a, b, c, md5->buffer[9]  + 0x8b44f7af, 12);
9D0023D0  8C880030   LW T0, 48(A0)
9D0023D4  3C0C8B44   LUI T4, -29884
9D0023D8  358CF7AF   ORI T4, T4, -2129
9D0023DC  010C6021   ADDU T4, T0, T4
9D0023E0  01873821   ADDU A3, T4, A3
9D0023E4  00AA6026   XOR T4, A1, T2
9D0023E8  006C6024   AND T4, V1, T4
9D0023EC  018A6026   XOR T4, T4, T2
9D0023F0  00EC3821   ADDU A3, A3, T4
9D0023F8  00E33821   ADDU A3, A3, V1
251:                         MD5STEP(F1, c, d, a, b, md5->buffer[10] + 0xffff5bb1, 17);
9D0023FC  8C990034   LW T9, 52(A0)
9D002400  3C0EFFFF   LUI T6, -1
9D002404  25CE5BB1   ADDIU T6, T6, 23473
9D002408  032E7021   ADDU T6, T9, T6
9D00240C  01CA5021   ADDU T2, T6, T2
9D002410  00656026   XOR T4, V1, A1
9D002414  00EC6024   AND T4, A3, T4
9D002418  01856026   XOR T4, T4, A1
9D00241C  014C7021   ADDU T6, T2, T4
9D002424  01C77021   ADDU T6, T6, A3
252:                         MD5STEP(F1, b, c, d, a, md5->buffer[11] + 0x895cd7be, 22);
9D002428  8C8A0038   LW T2, 56(A0)
9D00242C  3C0C895C   LUI T4, -30372
9D002430  358CD7BE   ORI T4, T4, -10306
9D002434  014C6021   ADDU T4, T2, T4
9D002438  01852821   ADDU A1, T4, A1
9D00243C  00E36026   XOR T4, A3, V1
9D002440  01CC6024   AND T4, T6, T4
9D002444  01836026   XOR T4, T4, V1
9D002448  00AC2821   ADDU A1, A1, T4
9D002450  00AE2821   ADDU A1, A1, T6
253:                         MD5STEP(F1, a, b, c, d, md5->buffer[12] + 0x6b901122,  7);
9D002454  8C91003C   LW S1, 60(A0)
9D002458  3C0C6B90   LUI T4, 27536
9D00245C  258C1122   ADDIU T4, T4, 4386
9D002460  022C6021   ADDU T4, S1, T4
9D002464  01831821   ADDU V1, T4, V1
9D002468  01C76026   XOR T4, T6, A3
9D00246C  00AC6024   AND T4, A1, T4
9D002470  01876026   XOR T4, T4, A3
9D002474  006C1821   ADDU V1, V1, T4
9D00247C  00651821   ADDU V1, V1, A1
254:                         MD5STEP(F1, d, a, b, c, md5->buffer[13] + 0xfd987193, 12);
9D002480  8C8C0040   LW T4, 64(A0)
9D002484  3C13FD98   LUI S3, -616
9D002488  26737193   ADDIU S3, S3, 29075
9D00248C  01939821   ADDU S3, T4, S3
9D002490  02673821   ADDU A3, S3, A3
9D002494  00AE9826   XOR S3, A1, T6
9D002498  00739824   AND S3, V1, S3
9D00249C  026E9826   XOR S3, S3, T6
9D0024A0  00F33821   ADDU A3, A3, S3
9D0024A8  00E33821   ADDU A3, A3, V1
255:                         MD5STEP(F1, c, d, a, b, md5->buffer[14] + 0xa679438e, 17);
9D0024AC  8C930044   LW S3, 68(A0)
9D0024B0  3C16A679   LUI S6, -22919
9D0024B4  26D6438E   ADDIU S6, S6, 17294
9D0024B8  0276B021   ADDU S6, S3, S6
9D0024BC  02CE7021   ADDU T6, S6, T6
9D0024C0  0065B026   XOR S6, V1, A1
9D0024C4  00F6B024   AND S6, A3, S6
9D0024C8  02C5B026   XOR S6, S6, A1
9D0024CC  01D6B021   ADDU S6, T6, S6
9D0024D4  02C7B021   ADDU S6, S6, A3
256:                         MD5STEP(F1, b, c, d, a, md5->buffer[15] + 0x49b40821, 22);
9D0024D8  8C8E0048   LW T6, 72(A0)
9D0024DC  3C1749B4   LUI S7, 18868
9D0024E0  26F70821   ADDIU S7, S7, 2081
9D0024E4  01D7B821   ADDU S7, T6, S7
9D0024E8  02E52821   ADDU A1, S7, A1
9D0024EC  00E3B826   XOR S7, A3, V1
9D0024F0  02D7B824   AND S7, S6, S7
9D0024F4  02E3B826   XOR S7, S7, V1
9D0024F8  00B72821   ADDU A1, A1, S7
9D002500  00B62821   ADDU A1, A1, S6
257:                 
258:                         MD5STEP(F2, a, b, c, d, md5->buffer[1]  + 0xf61e2562,  5);
9D002504  3C17F61E   LUI S7, -2530
9D002508  26F72562   ADDIU S7, S7, 9570
9D00250C  0317B821   ADDU S7, T8, S7
9D002510  02E31821   ADDU V1, S7, V1
9D002514  00B6B826   XOR S7, A1, S6
9D002518  02E7B824   AND S7, S7, A3
9D00251C  02F6B826   XOR S7, S7, S6
9D002520  00771821   ADDU V1, V1, S7
9D002528  00651821   ADDU V1, V1, A1
259:                         MD5STEP(F2, d, a, b, c, md5->buffer[6]  + 0xc040b340,  9);
9D00252C  3C17C040   LUI S7, -16320
9D002530  36F7B340   ORI S7, S7, -19648
9D002534  01B7B821   ADDU S7, T5, S7
9D002538  02E73821   ADDU A3, S7, A3
9D00253C  0065B826   XOR S7, V1, A1
9D002540  02F6B824   AND S7, S7, S6
9D002544  02E5B826   XOR S7, S7, A1
9D002548  00F73821   ADDU A3, A3, S7
9D002550  00E33821   ADDU A3, A3, V1
260:                         MD5STEP(F2, c, d, a, b, md5->buffer[11] + 0x265e5a51, 14);
9D002554  3C17265E   LUI S7, 9822
9D002558  26F75A51   ADDIU S7, S7, 23121
9D00255C  0157B821   ADDU S7, T2, S7
9D002560  02F6B021   ADDU S6, S7, S6
9D002564  00E3B826   XOR S7, A3, V1
9D002568  02E5B824   AND S7, S7, A1
9D00256C  02E3B826   XOR S7, S7, V1
9D002570  02D7B021   ADDU S6, S6, S7
9D002578  02C7B021   ADDU S6, S6, A3
261:                         MD5STEP(F2, b, c, d, a, md5->buffer[0]  + 0xe9b6c7aa, 20);
9D00257C  3C17E9B6   LUI S7, -5706
9D002580  36F7C7AA   ORI S7, S7, -14422
9D002584  02B7B821   ADDU S7, S5, S7
9D002588  02E52821   ADDU A1, S7, A1
9D00258C  02C7B826   XOR S7, S6, A3
9D002590  02E3B824   AND S7, S7, V1
9D002594  02E7B826   XOR S7, S7, A3
9D002598  00B72821   ADDU A1, A1, S7
9D0025A0  00B62821   ADDU A1, A1, S6
262:                         MD5STEP(F2, a, b, c, d, md5->buffer[5]  + 0xd62f105d,  5);
9D0025A4  3C17D62F   LUI S7, -10705
9D0025A8  26F7105D   ADDIU S7, S7, 4189
9D0025AC  0257B821   ADDU S7, S2, S7
9D0025B0  02E31821   ADDU V1, S7, V1
9D0025B4  00B6B826   XOR S7, A1, S6
9D0025B8  02E7B824   AND S7, S7, A3
9D0025BC  02F6B826   XOR S7, S7, S6
9D0025C0  00771821   ADDU V1, V1, S7
9D0025C8  00651821   ADDU V1, V1, A1
263:                         MD5STEP(F2, d, a, b, c, md5->buffer[10] + 0x02441453,  9);
9D0025CC  3C170244   LUI S7, 580
9D0025D0  26F71453   ADDIU S7, S7, 5203
9D0025D4  0337B821   ADDU S7, T9, S7
9D0025D8  02E73821   ADDU A3, S7, A3
9D0025DC  0065B826   XOR S7, V1, A1
9D0025E0  02F6B824   AND S7, S7, S6
9D0025E4  02E5B826   XOR S7, S7, A1
9D0025E8  00F73821   ADDU A3, A3, S7
9D0025F0  00E33821   ADDU A3, A3, V1
264:                         MD5STEP(F2, c, d, a, b, md5->buffer[15] + 0xd8a1e681, 14);
9D0025F4  3C17D8A1   LUI S7, -10079
9D0025F8  36F7E681   ORI S7, S7, -6527
9D0025FC  01D7B821   ADDU S7, T6, S7
9D002600  02F6B021   ADDU S6, S7, S6
9D002604  00E3B826   XOR S7, A3, V1
9D002608  02E5B824   AND S7, S7, A1
9D00260C  02E3B826   XOR S7, S7, V1
9D002610  02D7B021   ADDU S6, S6, S7
9D002618  02C7B021   ADDU S6, S6, A3
265:                         MD5STEP(F2, b, c, d, a, md5->buffer[4]  + 0xe7d3fbc8, 20);
9D00261C  3C17E7D3   LUI S7, -6189
9D002620  36F7FBC8   ORI S7, S7, -1080
9D002624  0177B821   ADDU S7, T3, S7
9D002628  02E52821   ADDU A1, S7, A1
9D00262C  02C7B826   XOR S7, S6, A3
9D002630  02E3B824   AND S7, S7, V1
9D002634  02E7B826   XOR S7, S7, A3
9D002638  00B72821   ADDU A1, A1, S7
9D002640  00B62821   ADDU A1, A1, S6
266:                         MD5STEP(F2, a, b, c, d, md5->buffer[9]  + 0x21e1cde6,  5);
9D002644  3C1721E1   LUI S7, 8673
9D002648  36F7CDE6   ORI S7, S7, -12826
9D00264C  0117B821   ADDU S7, T0, S7
9D002650  02E31821   ADDU V1, S7, V1
9D002654  00B6B826   XOR S7, A1, S6
9D002658  02E7B824   AND S7, S7, A3
9D00265C  02F6B826   XOR S7, S7, S6
9D002660  00771821   ADDU V1, V1, S7
9D002668  00651821   ADDU V1, V1, A1
267:                         MD5STEP(F2, d, a, b, c, md5->buffer[14] + 0xc33707d6,  9);
9D00266C  3C17C337   LUI S7, -15561
9D002670  26F707D6   ADDIU S7, S7, 2006
9D002674  0277B821   ADDU S7, S3, S7
9D002678  02E73821   ADDU A3, S7, A3
9D00267C  0065B826   XOR S7, V1, A1
9D002680  02F6B824   AND S7, S7, S6
9D002684  02E5B826   XOR S7, S7, A1
9D002688  00F73821   ADDU A3, A3, S7
9D002690  00E33821   ADDU A3, A3, V1
268:                         MD5STEP(F2, c, d, a, b, md5->buffer[3]  + 0xf4d50d87, 14);
9D002694  3C17F4D5   LUI S7, -2859
9D002698  26F70D87   ADDIU S7, S7, 3463
9D00269C  0217B821   ADDU S7, S0, S7
9D0026A0  02F6B021   ADDU S6, S7, S6
9D0026A4  00E3B826   XOR S7, A3, V1
9D0026A8  02E5B824   AND S7, S7, A1
9D0026AC  02E3B826   XOR S7, S7, V1
9D0026B0  02D7B021   ADDU S6, S6, S7
9D0026B8  02C7B021   ADDU S6, S6, A3
269:                         MD5STEP(F2, b, c, d, a, md5->buffer[8]  + 0x455a14ed, 20);
9D0026BC  3C17455A   LUI S7, 17754
9D0026C0  26F714ED   ADDIU S7, S7, 5357
9D0026C4  01F7B821   ADDU S7, T7, S7
9D0026C8  02E52821   ADDU A1, S7, A1
9D0026CC  02C7B826   XOR S7, S6, A3
9D0026D0  02E3B824   AND S7, S7, V1
9D0026D4  02E7B826   XOR S7, S7, A3
9D0026D8  00B72821   ADDU A1, A1, S7
9D0026E0  00B62821   ADDU A1, A1, S6
270:                         MD5STEP(F2, a, b, c, d, md5->buffer[13] + 0xa9e3e905,  5);
9D0026E4  3C17A9E3   LUI S7, -22045
9D0026E8  36F7E905   ORI S7, S7, -5883
9D0026EC  0197B821   ADDU S7, T4, S7
9D0026F0  02E31821   ADDU V1, S7, V1
9D0026F4  00B6B826   XOR S7, A1, S6
9D0026F8  02E7B824   AND S7, S7, A3
9D0026FC  02F6B826   XOR S7, S7, S6
9D002700  00771821   ADDU V1, V1, S7
9D002708  00651821   ADDU V1, V1, A1
271:                         MD5STEP(F2, d, a, b, c, md5->buffer[2]  + 0xfcefa3f8,  9);
9D00270C  3C17FCEF   LUI S7, -785
9D002710  36F7A3F8   ORI S7, S7, -23560
9D002714  0137B821   ADDU S7, T1, S7
9D002718  02E73821   ADDU A3, S7, A3
9D00271C  0065B826   XOR S7, V1, A1
9D002720  02F6B824   AND S7, S7, S6
9D002724  02E5B826   XOR S7, S7, A1
9D002728  00F73821   ADDU A3, A3, S7
9D002730  00E33821   ADDU A3, A3, V1
272:                         MD5STEP(F2, c, d, a, b, md5->buffer[7]  + 0x676f02d9, 14);
9D002734  3C17676F   LUI S7, 26479
9D002738  26F702D9   ADDIU S7, S7, 729
9D00273C  0297B821   ADDU S7, S4, S7
9D002740  02F6B021   ADDU S6, S7, S6
9D002744  00E3B826   XOR S7, A3, V1
9D002748  02E5B824   AND S7, S7, A1
9D00274C  02E3B826   XOR S7, S7, V1
9D002750  02D7B021   ADDU S6, S6, S7
9D002758  02C7B021   ADDU S6, S6, A3
273:                         MD5STEP(F2, b, c, d, a, md5->buffer[12] + 0x8d2a4c8a, 20);
9D00275C  02C7B826   XOR S7, S6, A3
9D002760  3C1E8D2A   LUI S8, -29398
9D002764  27DE4C8A   ADDIU S8, S8, 19594
9D002768  023EF021   ADDU S8, S1, S8
9D00276C  03C5F021   ADDU S8, S8, A1
9D002770  02E32824   AND A1, S7, V1
9D002774  00A72826   XOR A1, A1, A3
9D002778  03C52821   ADDU A1, S8, A1
9D002780  00B62821   ADDU A1, A1, S6
274:                 
275:                         MD5STEP(F3, a, b, c, d, md5->buffer[5]  + 0xfffa3942,  4);
9D002784  3C1EFFFA   LUI S8, -6
9D002788  27DE3942   ADDIU S8, S8, 14658
9D00278C  025EF021   ADDU S8, S2, S8
9D002790  03C31821   ADDU V1, S8, V1
9D002794  02E5B826   XOR S7, S7, A1
9D002798  0077B821   ADDU S7, V1, S7
9D0027A0  02E5B821   ADDU S7, S7, A1
276:                         MD5STEP(F3, d, a, b, c, md5->buffer[8]  + 0x8771f681, 11);
9D0027A4  3C038771   LUI V1, -30863
9D0027A8  3463F681   ORI V1, V1, -2431
9D0027AC  01E31821   ADDU V1, T7, V1
9D0027B0  00673821   ADDU A3, V1, A3
9D0027B4  00B61826   XOR V1, A1, S6
9D0027B8  00771826   XOR V1, V1, S7
9D0027BC  00E33821   ADDU A3, A3, V1
9D0027C4  00F73821   ADDU A3, A3, S7
277:                         MD5STEP(F3, c, d, a, b, md5->buffer[11] + 0x6d9d6122, 16);
9D0027C8  3C036D9D   LUI V1, 28061
9D0027CC  24636122   ADDIU V1, V1, 24866
9D0027D0  01431821   ADDU V1, T2, V1
9D0027D4  0076B021   ADDU S6, V1, S6
9D0027D8  02E51826   XOR V1, S7, A1
9D0027DC  00671826   XOR V1, V1, A3
9D0027E0  02C3B021   ADDU S6, S6, V1
9D0027E8  02C7B021   ADDU S6, S6, A3
278:                         MD5STEP(F3, b, c, d, a, md5->buffer[14] + 0xfde5380c, 23);
9D0027EC  3C03FDE5   LUI V1, -539
9D0027F0  2463380C   ADDIU V1, V1, 14348
9D0027F4  02631821   ADDU V1, S3, V1
9D0027F8  00652821   ADDU A1, V1, A1
9D0027FC  00F71826   XOR V1, A3, S7
9D002800  00761826   XOR V1, V1, S6
9D002804  00A32821   ADDU A1, A1, V1
9D00280C  00B62821   ADDU A1, A1, S6
279:                         MD5STEP(F3, a, b, c, d, md5->buffer[1]  + 0xa4beea44,  4);
9D002810  3C03A4BE   LUI V1, -23362
9D002814  3463EA44   ORI V1, V1, -5564
9D002818  03031821   ADDU V1, T8, V1
9D00281C  0077B821   ADDU S7, V1, S7
9D002820  02C71826   XOR V1, S6, A3
9D002824  00651826   XOR V1, V1, A1
9D002828  02E3B821   ADDU S7, S7, V1
9D002830  02E5B821   ADDU S7, S7, A1
280:                         MD5STEP(F3, d, a, b, c, md5->buffer[4]  + 0x4bdecfa9, 11);
9D002834  3C034BDE   LUI V1, 19422
9D002838  3463CFA9   ORI V1, V1, -12375
9D00283C  01631821   ADDU V1, T3, V1
9D002840  00673821   ADDU A3, V1, A3
9D002844  00B61826   XOR V1, A1, S6
9D002848  00771826   XOR V1, V1, S7
9D00284C  00E33821   ADDU A3, A3, V1
9D002854  00F73821   ADDU A3, A3, S7
281:                         MD5STEP(F3, c, d, a, b, md5->buffer[7]  + 0xf6bb4b60, 16);
9D002858  3C03F6BB   LUI V1, -2373
9D00285C  24634B60   ADDIU V1, V1, 19296
9D002860  02831821   ADDU V1, S4, V1
9D002864  0076B021   ADDU S6, V1, S6
9D002868  02E51826   XOR V1, S7, A1
9D00286C  00671826   XOR V1, V1, A3
9D002870  02C31821   ADDU V1, S6, V1
9D002878  00671821   ADDU V1, V1, A3
282:                         MD5STEP(F3, b, c, d, a, md5->buffer[10] + 0xbebfbc70, 23);
9D00287C  3C16BEBF   LUI S6, -16705
9D002880  36D6BC70   ORI S6, S6, -17296
9D002884  0336B021   ADDU S6, T9, S6
9D002888  02C52821   ADDU A1, S6, A1
9D00288C  00F7B026   XOR S6, A3, S7
9D002890  02C3B026   XOR S6, S6, V1
9D002894  00B62821   ADDU A1, A1, S6
9D00289C  00A32821   ADDU A1, A1, V1
283:                         MD5STEP(F3, a, b, c, d, md5->buffer[13] + 0x289b7ec6,  4);
9D0028A0  3C16289B   LUI S6, 10395
9D0028A4  26D67EC6   ADDIU S6, S6, 32454
9D0028A8  0196B021   ADDU S6, T4, S6
9D0028AC  02D7B821   ADDU S7, S6, S7
9D0028B0  0067B026   XOR S6, V1, A3
9D0028B4  02C5B026   XOR S6, S6, A1
9D0028B8  02F6B821   ADDU S7, S7, S6
9D0028C0  02E5B821   ADDU S7, S7, A1
284:                         MD5STEP(F3, d, a, b, c, md5->buffer[0]  + 0xeaa127fa, 11);
9D0028C4  3C16EAA1   LUI S6, -5471
9D0028C8  26D627FA   ADDIU S6, S6, 10234
9D0028CC  02B6B021   ADDU S6, S5, S6
9D0028D0  02C73821   ADDU A3, S6, A3
9D0028D4  00A3B026   XOR S6, A1, V1
9D0028D8  02D7B026   XOR S6, S6, S7
9D0028DC  00F63821   ADDU A3, A3, S6
9D0028E4  00F73821   ADDU A3, A3, S7
285:                         MD5STEP(F3, c, d, a, b, md5->buffer[3]  + 0xd4ef3085, 16);
9D0028E8  3C16D4EF   LUI S6, -11025
9D0028EC  26D63085   ADDIU S6, S6, 12421
9D0028F0  0216B021   ADDU S6, S0, S6
9D0028F4  02C31821   ADDU V1, S6, V1
9D0028F8  02E5B026   XOR S6, S7, A1
9D0028FC  02C7B026   XOR S6, S6, A3
9D002900  00761821   ADDU V1, V1, S6
9D002908  00671821   ADDU V1, V1, A3
286:                         MD5STEP(F3, b, c, d, a, md5->buffer[6]  + 0x04881d05, 23);
9D00290C  3C160488   LUI S6, 1160
9D002910  26D61D05   ADDIU S6, S6, 7429
9D002914  01B6B021   ADDU S6, T5, S6
9D002918  02C52821   ADDU A1, S6, A1
9D00291C  00F7B026   XOR S6, A3, S7
9D002920  02C3B026   XOR S6, S6, V1
9D002924  00B6B021   ADDU S6, A1, S6
9D00292C  02C3B021   ADDU S6, S6, V1
287:                         MD5STEP(F3, a, b, c, d, md5->buffer[9]  + 0xd9d4d039,  4);
9D002930  3C05D9D4   LUI A1, -9772
9D002934  34A5D039   ORI A1, A1, -12231
9D002938  01052821   ADDU A1, T0, A1
9D00293C  00B7B821   ADDU S7, A1, S7
9D002940  00672826   XOR A1, V1, A3
9D002944  00B62826   XOR A1, A1, S6
9D002948  02E52821   ADDU A1, S7, A1
9D002950  00B62821   ADDU A1, A1, S6
288:                         MD5STEP(F3, d, a, b, c, md5->buffer[12] + 0xe6db99e5, 11);
9D002954  3C17E6DB   LUI S7, -6437
9D002958  36F799E5   ORI S7, S7, -26139
9D00295C  0237B821   ADDU S7, S1, S7
9D002960  02E73821   ADDU A3, S7, A3
9D002964  02C3B826   XOR S7, S6, V1
9D002968  02E5B826   XOR S7, S7, A1
9D00296C  00F73821   ADDU A3, A3, S7
9D002974  00E53821   ADDU A3, A3, A1
289:                         MD5STEP(F3, c, d, a, b, md5->buffer[15] + 0x1fa27cf8, 16);
9D002978  3C171FA2   LUI S7, 8098
9D00297C  26F77CF8   ADDIU S7, S7, 31992
9D002980  01D7B821   ADDU S7, T6, S7
9D002984  02E31821   ADDU V1, S7, V1
9D002988  00B6B826   XOR S7, A1, S6
9D00298C  02E7B826   XOR S7, S7, A3
9D002990  0077B821   ADDU S7, V1, S7
9D002998  02E7B821   ADDU S7, S7, A3
290:                         MD5STEP(F3, b, c, d, a, md5->buffer[2]  + 0xc4ac5665, 23);
9D00299C  3C03C4AC   LUI V1, -15188
9D0029A0  24635665   ADDIU V1, V1, 22117
9D0029A4  01231821   ADDU V1, T1, V1
9D0029A8  0076B021   ADDU S6, V1, S6
9D0029AC  00E51826   XOR V1, A3, A1
9D0029B0  00771826   XOR V1, V1, S7
9D0029B4  02C31821   ADDU V1, S6, V1
9D0029BC  00771821   ADDU V1, V1, S7
291:                 
292:                         MD5STEP(F4, a, b, c, d, md5->buffer[0]  + 0xf4292244,  6);
9D0029C0  3C16F429   LUI S6, -3031
9D0029C4  26D62244   ADDIU S6, S6, 8772
9D0029C8  02B6A821   ADDU S5, S5, S6
9D0029CC  02A52821   ADDU A1, S5, A1
9D0029D0  0007F027   NOR S8, ZERO, A3
9D0029D4  007EF025   OR S8, V1, S8
9D0029D8  03D7F026   XOR S8, S8, S7
9D0029DC  00BE2821   ADDU A1, A1, S8
9D0029E4  00A32821   ADDU A1, A1, V1
293:                         MD5STEP(F4, d, a, b, c, md5->buffer[7]  + 0x432aff97, 10);
9D0029E8  3C15432A   LUI S5, 17194
9D0029EC  36B5FF97   ORI S5, S5, -105
9D0029F0  0295A021   ADDU S4, S4, S5
9D0029F4  02873821   ADDU A3, S4, A3
9D0029F8  0017A827   NOR S5, ZERO, S7
9D0029FC  00B5A825   OR S5, A1, S5
9D002A00  02A3A826   XOR S5, S5, V1
9D002A04  00F53821   ADDU A3, A3, S5
9D002A0C  00E53821   ADDU A3, A3, A1
294:                         MD5STEP(F4, c, d, a, b, md5->buffer[14] + 0xab9423a7, 15);
9D002A10  3C14AB94   LUI S4, -21612
9D002A14  269423A7   ADDIU S4, S4, 9127
9D002A18  02749821   ADDU S3, S3, S4
9D002A1C  0277B821   ADDU S7, S3, S7
9D002A20  0003A027   NOR S4, ZERO, V1
9D002A24  00F4A025   OR S4, A3, S4
9D002A28  0285A026   XOR S4, S4, A1
9D002A2C  02F4B821   ADDU S7, S7, S4
9D002A34  02E7B821   ADDU S7, S7, A3
295:                         MD5STEP(F4, b, c, d, a, md5->buffer[5]  + 0xfc93a039, 21);
9D002A38  3C13FC93   LUI S3, -877
9D002A3C  3673A039   ORI S3, S3, -24519
9D002A40  02539021   ADDU S2, S2, S3
9D002A44  02431821   ADDU V1, S2, V1
9D002A48  00059827   NOR S3, ZERO, A1
9D002A4C  02F39825   OR S3, S7, S3
9D002A50  02679826   XOR S3, S3, A3
9D002A54  00731821   ADDU V1, V1, S3
9D002A5C  00771821   ADDU V1, V1, S7
296:                         MD5STEP(F4, a, b, c, d, md5->buffer[12] + 0x655b59c3,  6);
9D002A60  3C12655B   LUI S2, 25947
9D002A64  265259C3   ADDIU S2, S2, 22979
9D002A68  02328821   ADDU S1, S1, S2
9D002A6C  02258821   ADDU S1, S1, A1
9D002A70  00079027   NOR S2, ZERO, A3
9D002A74  00729025   OR S2, V1, S2
9D002A78  02579026   XOR S2, S2, S7
9D002A7C  02328821   ADDU S1, S1, S2
9D002A84  02238821   ADDU S1, S1, V1
297:                         MD5STEP(F4, d, a, b, c, md5->buffer[3]  + 0x8f0ccc92, 10);
9D002A88  3C058F0C   LUI A1, -28916
9D002A8C  34A5CC92   ORI A1, A1, -13166
9D002A90  02058021   ADDU S0, S0, A1
9D002A94  02078021   ADDU S0, S0, A3
9D002A98  00172827   NOR A1, ZERO, S7
9D002A9C  02252825   OR A1, S1, A1
9D002AA0  00A32826   XOR A1, A1, V1
9D002AA4  02058021   ADDU S0, S0, A1
9D002AAC  02118021   ADDU S0, S0, S1
298:                         MD5STEP(F4, c, d, a, b, md5->buffer[10] + 0xffeff47d, 15);
9D002AB0  3C07FFEF   LUI A3, -17
9D002AB4  34E7F47D   ORI A3, A3, -2947
9D002AB8  0327C821   ADDU T9, T9, A3
9D002ABC  0337B821   ADDU S7, T9, S7
9D002AC0  00032827   NOR A1, ZERO, V1
9D002AC4  02052825   OR A1, S0, A1
9D002AC8  00B12826   XOR A1, A1, S1
9D002ACC  02E53821   ADDU A3, S7, A1
9D002AD4  00F03821   ADDU A3, A3, S0
299:                         MD5STEP(F4, b, c, d, a, md5->buffer[1]  + 0x85845dd1, 21);
9D002AD8  3C058584   LUI A1, -31356
9D002ADC  24A55DD1   ADDIU A1, A1, 24017
9D002AE0  0305C021   ADDU T8, T8, A1
9D002AE4  03031821   ADDU V1, T8, V1
9D002AE8  00112827   NOR A1, ZERO, S1
9D002AEC  00E52825   OR A1, A3, A1
9D002AF0  00B02826   XOR A1, A1, S0
9D002AF4  00652821   ADDU A1, V1, A1
9D002AFC  00A72821   ADDU A1, A1, A3
300:                         MD5STEP(F4, a, b, c, d, md5->buffer[8]  + 0x6fa87e4f,  6);
9D002B00  3C036FA8   LUI V1, 28584
9D002B04  24637E4F   ADDIU V1, V1, 32335
9D002B08  01E37821   ADDU T7, T7, V1
9D002B0C  01F18821   ADDU S1, T7, S1
9D002B10  00101827   NOR V1, ZERO, S0
9D002B14  00A31825   OR V1, A1, V1
9D002B18  00671826   XOR V1, V1, A3
9D002B1C  02231821   ADDU V1, S1, V1
9D002B24  00651821   ADDU V1, V1, A1
301:                         MD5STEP(F4, d, a, b, c, md5->buffer[15] + 0xfe2ce6e0, 10);
9D002B28  3C0FFE2C   LUI T7, -468
9D002B2C  35EFE6E0   ORI T7, T7, -6432
9D002B30  01CF7021   ADDU T6, T6, T7
9D002B34  01D07021   ADDU T6, T6, S0
9D002B38  00077827   NOR T7, ZERO, A3
9D002B3C  006F7825   OR T7, V1, T7
9D002B40  01E57826   XOR T7, T7, A1
9D002B44  01CF7021   ADDU T6, T6, T7
9D002B4C  01C37021   ADDU T6, T6, V1
302:                         MD5STEP(F4, c, d, a, b, md5->buffer[6]  + 0xa3014314, 15);
9D002B50  3C0FA301   LUI T7, -23807
9D002B54  25EF4314   ADDIU T7, T7, 17172
9D002B58  01AF6821   ADDU T5, T5, T7
9D002B5C  01A73821   ADDU A3, T5, A3
9D002B60  00057827   NOR T7, ZERO, A1
9D002B64  01CF7825   OR T7, T6, T7
9D002B68  01E37826   XOR T7, T7, V1
9D002B6C  00EF3821   ADDU A3, A3, T7
9D002B74  00EE3821   ADDU A3, A3, T6
303:                         MD5STEP(F4, b, c, d, a, md5->buffer[13] + 0x4e0811a1, 21);
9D002B78  3C0D4E08   LUI T5, 19976
9D002B7C  25AD11A1   ADDIU T5, T5, 4513
9D002B80  018D6021   ADDU T4, T4, T5
9D002B84  01852821   ADDU A1, T4, A1
9D002B88  00036827   NOR T5, ZERO, V1
9D002B8C  00ED6825   OR T5, A3, T5
9D002B90  01AE6826   XOR T5, T5, T6
9D002B94  00AD2821   ADDU A1, A1, T5
9D002B9C  00A72821   ADDU A1, A1, A3
304:                         MD5STEP(F4, a, b, c, d, md5->buffer[4]  + 0xf7537e82,  6);
9D002BA0  3C0CF753   LUI T4, -2221
9D002BA4  258C7E82   ADDIU T4, T4, 32386
9D002BA8  016C5821   ADDU T3, T3, T4
9D002BAC  01631821   ADDU V1, T3, V1
9D002BB0  000E6027   NOR T4, ZERO, T6
9D002BB4  00AC6025   OR T4, A1, T4
9D002BB8  01876026   XOR T4, T4, A3
9D002BBC  006C1821   ADDU V1, V1, T4
9D002BC4  00651821   ADDU V1, V1, A1
305:                         MD5STEP(F4, d, a, b, c, md5->buffer[11] + 0xbd3af235, 10);
9D002BC8  3C0BBD3A   LUI T3, -17094
9D002BCC  356BF235   ORI T3, T3, -3531
9D002BD0  014B5021   ADDU T2, T2, T3
9D002BD4  014E7021   ADDU T6, T2, T6
9D002BD8  00075827   NOR T3, ZERO, A3
9D002BDC  006B5825   OR T3, V1, T3
9D002BE0  01655826   XOR T3, T3, A1
9D002BE4  01CB7021   ADDU T6, T6, T3
9D002BEC  01C37021   ADDU T6, T6, V1
306:                         MD5STEP(F4, c, d, a, b, md5->buffer[2]  + 0x2ad7d2bb, 15);
9D002BF0  3C0A2AD7   LUI T2, 10967
9D002BF4  354AD2BB   ORI T2, T2, -11589
9D002BF8  012A4821   ADDU T1, T1, T2
9D002BFC  01273821   ADDU A3, T1, A3
9D002C00  00055027   NOR T2, ZERO, A1
9D002C04  01CA5025   OR T2, T6, T2
9D002C08  01435026   XOR T2, T2, V1
9D002C0C  00EA3821   ADDU A3, A3, T2
9D002C14  00EE3821   ADDU A3, A3, T6
307:                         MD5STEP(F4, b, c, d, a, md5->buffer[9]  + 0xeb86d391, 21);
9D002C24  00E21021   ADDU V0, A3, V0
9D002C28  3C09EB86   LUI T1, -5242
9D002C2C  3529D391   ORI T1, T1, -11375
9D002C30  01094021   ADDU T0, T0, T1
9D002C34  01052821   ADDU A1, T0, A1
9D002C38  00031827   NOR V1, ZERO, V1
9D002C3C  00E31825   OR V1, A3, V1
9D002C40  006E1826   XOR V1, V1, T6
9D002C44  00A32821   ADDU A1, A1, V1
308:                 
309:                         /* Add the working vars back into digest state[]  */
310:                         md5->digest[0] += a;
9D002C18  8C8A004C   LW T2, 76(A0)
9D002C1C  006A4821   ADDU T1, V1, T2
9D002C20  AC89004C   SW T1, 76(A0)
311:                         md5->digest[1] += b;
9D002C4C  00451021   ADDU V0, V0, A1
9D002C50  AC820050   SW V0, 80(A0)
312:                         md5->digest[2] += c;
9D002C54  00E63021   ADDU A2, A3, A2
9D002C58  AC860054   SW A2, 84(A0)
313:                         md5->digest[3] += d;
9D002C5C  8C820058   LW V0, 88(A0)
9D002C60  01C27021   ADDU T6, T6, V0
9D002C64  AC8E0058   SW T6, 88(A0)
314:                 
315:                         return 0;
316:                     }
9D002C68  00001021   ADDU V0, ZERO, ZERO
9D002C6C  8FBE0024   LW S8, 36(SP)
9D002C70  8FB70020   LW S7, 32(SP)
9D002C74  8FB6001C   LW S6, 28(SP)
9D002C78  8FB50018   LW S5, 24(SP)
9D002C7C  8FB40014   LW S4, 20(SP)
9D002C80  8FB30010   LW S3, 16(SP)
9D002C84  8FB2000C   LW S2, 12(SP)
9D002C88  8FB10008   LW S1, 8(SP)
9D002C8C  8FB00004   LW S0, 4(SP)
9D002C90  03E00008   JR RA
9D002C94  27BD0028   ADDIU SP, SP, 40
317:                 #endif /* NEED_SOFT_MD5 */
318:                 
319:                 
320:                 #ifndef HAVE_MD5_CUST_API
321:                 static INLINE void AddMd5Length(Md5* md5, word32 len)
322:                 {
323:                     word32 tmp = md5->loLen;
9D00A904  8C840004   LW A0, 4(A0)
9D00F68C  8E430004   LW V1, 4(S2)
324:                     if ((md5->loLen += len) < tmp) {
9D00A908  00821821   ADDU V1, A0, V0
9D00A90C  AE030004   SW V1, 4(S0)
9D00A910  0064182B   SLTU V1, V1, A0
9D00A914  10600005   BEQ V1, ZERO, 0x9D00A92C
9D00A918  24430001   ADDIU V1, V0, 1
9D00F690  24620040   ADDIU V0, V1, 64
9D00F694  AE420004   SW V0, 4(S2)
9D00F698  0043102B   SLTU V0, V0, V1
9D00F69C  50400005   BEQL V0, ZERO, 0x9D00F6B4
9D00F6A0  AE400000   SW ZERO, 0(S2)
325:                         md5->hiLen++;                       /* carry low to high */
9D00A91C  8E030008   LW V1, 8(S0)
9D00A920  24630001   ADDIU V1, V1, 1
9D00A924  AE030008   SW V1, 8(S0)
9D00F6A4  8E420008   LW V0, 8(S2)
9D00F6A8  24420001   ADDIU V0, V0, 1
9D00F6AC  AE420008   SW V0, 8(S2)
326:                     }
327:                 }
328:                 
329:                 static int _InitMd5(Md5* md5)
330:                 {
331:                     int ret = 0;
332:                 
333:                     md5->digest[0] = 0x67452301L;
9D00AA24  3C026745   LUI V0, 26437
9D013F60  3C026745   LUI V0, 26437
334:                     md5->digest[1] = 0xefcdab89L;
9D00AA30  3C02EFCD   LUI V0, -4147
9D013F6C  3C02EFCD   LUI V0, -4147
335:                     md5->digest[2] = 0x98badcfeL;
9D00AA3C  3C0298BA   LUI V0, -26438
9D013F78  3C0298BA   LUI V0, -26438
336:                     md5->digest[3] = 0x10325476L;
9D00AA48  3C021032   LUI V0, 4146
9D013F84  3C021032   LUI V0, 4146
337:                 
338:                     md5->buffLen = 0;
9D00AA54  AE000000   SW ZERO, 0(S0)
9D013F90  AC800000   SW ZERO, 0(A0)
339:                     md5->loLen   = 0;
9D00AA58  AE000004   SW ZERO, 4(S0)
9D013F94  AC800004   SW ZERO, 4(A0)
340:                     md5->hiLen   = 0;
9D00AA5C  AE000008   SW ZERO, 8(S0)
9D013F98  AC800008   SW ZERO, 8(A0)
341:                 
342:                     return ret;
343:                 }
344:                 
345:                 int wc_InitMd5_ex(Md5* md5, void* heap, int devId)
346:                 {
347:                     int ret = 0;
348:                 
349:                     if (md5 == NULL)
9D013F54  10800013   BEQ A0, ZERO, 0x9D013FA4
9D013F58  00000000   NOP
350:                         return BAD_FUNC_ARG;
351:                 
352:                     md5->heap = heap;
9D013F5C  AC85005C   SW A1, 92(A0)
353:                 
354:                     ret = _InitMd5(md5);
355:                     if (ret != 0)
356:                         return ret;
357:                 
358:                 #if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_MD5)
359:                     ret = wolfAsync_DevCtxInit(&md5->asyncDev, WOLFSSL_ASYNC_MARKER_MD5,
360:                                                                             md5->heap, devId);
361:                 #else
362:                     (void)devId;
363:                 #endif
364:                     return ret;
365:                 }
9D013FA4  03E00008   JR RA
9D013FA8  2402FF53   ADDIU V0, ZERO, -173
366:                 
367:                 int wc_Md5Update(Md5* md5, const byte* data, word32 len)
368:                 {
9D00F5F4  27BDFFD0   ADDIU SP, SP, -48
9D00F5F8  AFBF002C   SW RA, 44(SP)
9D00F5FC  AFB50028   SW S5, 40(SP)
9D00F600  AFB40024   SW S4, 36(SP)
9D00F604  AFB30020   SW S3, 32(SP)
9D00F608  AFB2001C   SW S2, 28(SP)
9D00F60C  AFB10018   SW S1, 24(SP)
9D00F610  AFB00014   SW S0, 20(SP)
369:                     int ret = 0;
370:                     byte* local;
371:                 
372:                     if (md5 == NULL || (data == NULL && len > 0)) {
9D00F614  1080002B   BEQ A0, ZERO, 0x9D00F6C4
9D00F618  00809021   ADDU S2, A0, ZERO
9D00F61C  00A09821   ADDU S3, A1, ZERO
9D00F620  14A00003   BNE A1, ZERO, 0x9D00F630
9D00F624  00C08021   ADDU S0, A2, ZERO
9D00F628  14C0002B   BNE A2, ZERO, 0x9D00F6D8
9D00F62C  2402FF53   ADDIU V0, ZERO, -173
373:                         return BAD_FUNC_ARG;
9D00F6C4  0B403DB6   J 0x9D00F6D8
9D00F6C8  2402FF53   ADDIU V0, ZERO, -173
374:                     }
375:                 
376:                 #if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_MD5)
377:                     if (md5->asyncDev.marker == WOLFSSL_ASYNC_MARKER_MD5) {
378:                     #if defined(HAVE_INTEL_QA)
379:                         return IntelQaSymMd5(&md5->asyncDev, NULL, data, len);
380:                     #endif
381:                     }
382:                 #endif /* WOLFSSL_ASYNC_CRYPT */
383:                 
384:                     /* do block size increments */
385:                     local = (byte*)md5->buffer;
386:                 
387:                     /* check that internal buffLen is valid */
388:                     if (md5->buffLen >= MD5_BLOCK_SIZE)
9D00F630  8E420000   LW V0, 0(S2)
9D00F634  2C420040   SLTIU V0, V0, 64
9D00F638  10400024   BEQ V0, ZERO, 0x9D00F6CC
9D00F63C  2655000C   ADDIU S5, S2, 12
389:                         return BUFFER_E;
9D00F6CC  0B403DB6   J 0x9D00F6D8
9D00F6D0  2402FF7C   ADDIU V0, ZERO, -132
9D00F6D4  00001021   ADDU V0, ZERO, ZERO
390:                 
391:                     while (len) {
9D00F640  12000024   BEQ S0, ZERO, 0x9D00F6D4
9D00F644  24140040   ADDIU S4, ZERO, 64
9D00F6B4  5600FFE5   BNEL S0, ZERO, 0x9D00F64C
9D00F6B8  8E440000   LW A0, 0(S2)
9D00F6BC  0B403DB6   J 0x9D00F6D8
9D00F6C0  00001021   ADDU V0, ZERO, ZERO
392:                         word32 add = min(len, MD5_BLOCK_SIZE - md5->buffLen);
9D00F648  8E440000   LW A0, 0(S2)
9D00F64C  02841023   SUBU V0, S4, A0
9D00F650  0050882B   SLTU S1, V0, S0
9D00F654  0211100A   MOVZ V0, S0, S1
9D00F658  00408821   ADDU S1, V0, ZERO
393:                         XMEMCPY(&local[md5->buffLen], data, add);
9D00F65C  02A42021   ADDU A0, S5, A0
9D00F660  02602821   ADDU A1, S3, ZERO
9D00F664  0F40343F   JAL memcpy
9D00F668  00403021   ADDU A2, V0, ZERO
394:                 
395:                         md5->buffLen += add;
9D00F66C  8E420000   LW V0, 0(S2)
9D00F670  02221021   ADDU V0, S1, V0
9D00F674  AE420000   SW V0, 0(S2)
396:                         data         += add;
9D00F678  02719821   ADDU S3, S3, S1
397:                         len          -= add;
398:                 
399:                         if (md5->buffLen == MD5_BLOCK_SIZE) {
9D00F67C  1454000D   BNE V0, S4, 0x9D00F6B4
9D00F680  02118023   SUBU S0, S0, S1
400:                         #if defined(BIG_ENDIAN_ORDER) && !defined(FREESCALE_MMCAU_SHA)
401:                             ByteReverseWords(md5->buffer, md5->buffer, MD5_BLOCK_SIZE);
402:                         #endif
403:                             XTRANSFORM(md5, local);
9D00F684  0F400883   JAL Transform
9D00F688  02402021   ADDU A0, S2, ZERO
404:                             AddMd5Length(md5, MD5_BLOCK_SIZE);
405:                             md5->buffLen = 0;
9D00F6B0  AE400000   SW ZERO, 0(S2)
406:                         }
407:                     }
408:                     return ret;
409:                 }
9D00F6D8  8FBF002C   LW RA, 44(SP)
9D00F6DC  8FB50028   LW S5, 40(SP)
9D00F6E0  8FB40024   LW S4, 36(SP)
9D00F6E4  8FB30020   LW S3, 32(SP)
9D00F6E8  8FB2001C   LW S2, 28(SP)
9D00F6EC  8FB10018   LW S1, 24(SP)
9D00F6F0  8FB00014   LW S0, 20(SP)
9D00F6F4  03E00008   JR RA
9D00F6F8  27BD0030   ADDIU SP, SP, 48
410:                 
411:                 int wc_Md5Final(Md5* md5, byte* hash)
412:                 {
9D00A8D4  27BDFFD8   ADDIU SP, SP, -40
9D00A8D8  AFBF0024   SW RA, 36(SP)
9D00A8DC  AFB30020   SW S3, 32(SP)
9D00A8E0  AFB2001C   SW S2, 28(SP)
9D00A8E4  AFB10018   SW S1, 24(SP)
9D00A8E8  AFB00014   SW S0, 20(SP)
413:                     byte* local;
414:                 
415:                     if (md5 == NULL || hash == NULL) {
9D00A8EC  1080005E   BEQ A0, ZERO, 0x9D00AA68
9D00A8F0  00808021   ADDU S0, A0, ZERO
9D00A8F4  10A0005E   BEQ A1, ZERO, 0x9D00AA70
9D00A8F8  00A08821   ADDU S1, A1, ZERO
416:                         return BAD_FUNC_ARG;
9D00AA68  0B402A9D   J 0x9D00AA74
9D00AA6C  2402FF53   ADDIU V0, ZERO, -173
9D00AA70  2402FF53   ADDIU V0, ZERO, -173
417:                     }
418:                 
419:                 #if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_MD5)
420:                     if (md5->asyncDev.marker == WOLFSSL_ASYNC_MARKER_MD5) {
421:                     #if defined(HAVE_INTEL_QA)
422:                         return IntelQaSymMd5(&md5->asyncDev, hash, NULL, MD5_DIGEST_SIZE);
423:                     #endif
424:                     }
425:                 #endif /* WOLFSSL_ASYNC_CRYPT */
426:                 
427:                     local = (byte*)md5->buffer;
9D00A8FC  2492000C   ADDIU S2, A0, 12
428:                 
429:                     AddMd5Length(md5, md5->buffLen);  /* before adding pads */
9D00A900  8C820000   LW V0, 0(A0)
430:                     local[md5->buffLen++] = 0x80;  /* add 1 */
9D00A928  24430001   ADDIU V1, V0, 1
9D00A92C  AE030000   SW V1, 0(S0)
9D00A930  02421021   ADDU V0, S2, V0
9D00A934  2403FF80   ADDIU V1, ZERO, -128
9D00A938  A0430000   SB V1, 0(V0)
431:                 
432:                     /* pad with zeros */
433:                     if (md5->buffLen > MD5_PAD_SIZE) {
9D00A93C  8E060000   LW A2, 0(S0)
9D00A940  2CC20039   SLTIU V0, A2, 57
9D00A944  5440000B   BNEL V0, ZERO, 0x9D00A974
9D00A948  8E020000   LW V0, 0(S0)
434:                         XMEMSET(&local[md5->buffLen], 0, MD5_BLOCK_SIZE - md5->buffLen);
9D00A94C  24130040   ADDIU S3, ZERO, 64
9D00A950  02462021   ADDU A0, S2, A2
9D00A954  00002821   ADDU A1, ZERO, ZERO
9D00A958  0F40464F   JAL memset
9D00A95C  02663023   SUBU A2, S3, A2
435:                         md5->buffLen += MD5_BLOCK_SIZE - md5->buffLen;
9D00A960  AE130000   SW S3, 0(S0)
436:                 
437:                     #if defined(BIG_ENDIAN_ORDER) && !defined(FREESCALE_MMCAU_SHA)
438:                         ByteReverseWords(md5->buffer, md5->buffer, MD5_BLOCK_SIZE);
439:                     #endif
440:                         XTRANSFORM(md5, local);
9D00A964  0F400883   JAL Transform
9D00A968  02002021   ADDU A0, S0, ZERO
441:                         md5->buffLen = 0;
9D00A96C  AE000000   SW ZERO, 0(S0)
442:                     }
443:                     XMEMSET(&local[md5->buffLen], 0, MD5_PAD_SIZE - md5->buffLen);
9D00A970  8E020000   LW V0, 0(S0)
9D00A974  02422021   ADDU A0, S2, V0
9D00A978  00002821   ADDU A1, ZERO, ZERO
9D00A97C  24060038   ADDIU A2, ZERO, 56
9D00A980  0F40464F   JAL memset
9D00A984  00C23023   SUBU A2, A2, V0
444:                 
445:                 #if defined(BIG_ENDIAN_ORDER) && !defined(FREESCALE_MMCAU_SHA)
446:                     ByteReverseWords(md5->buffer, md5->buffer, MD5_BLOCK_SIZE);
447:                 #endif
448:                 
449:                     /* put lengths in bits */
450:                     md5->hiLen = (md5->loLen >> (8*sizeof(md5->loLen) - 3)) +
9D00A988  8E020004   LW V0, 4(S0)
9D00A994  00022742   SRL A0, V0, 29
9D00A998  00641821   ADDU V1, V1, A0
9D00A99C  AE030008   SW V1, 8(S0)
451:                                  (md5->hiLen << 3);
9D00A98C  8E030008   LW V1, 8(S0)
9D00A990  000318C0   SLL V1, V1, 3
452:                     md5->loLen = md5->loLen << 3;
9D00A9A0  000210C0   SLL V0, V0, 3
9D00A9A4  AE020004   SW V0, 4(S0)
453:                 
454:                     /* store lengths */
455:                     /* ! length ordering dependent on digest endian type ! */
456:                     XMEMCPY(&local[MD5_PAD_SIZE], &md5->loLen, sizeof(word32));
9D00A9A8  26020044   ADDIU V0, S0, 68
9D00A9AC  26030004   ADDIU V1, S0, 4
9D00A9B0  88640003   LWL A0, 3(V1)
9D00A9B4  98640000   LWR A0, 0(V1)
9D00A9B8  AA040047   SWL A0, 71(S0)
9D00A9BC  B8440000   SWR A0, 0(V0)
457:                     XMEMCPY(&local[MD5_PAD_SIZE + sizeof(word32)], &md5->hiLen, sizeof(word32));
9D00A9C0  26020048   ADDIU V0, S0, 72
9D00A9C4  26030008   ADDIU V1, S0, 8
9D00A9C8  88640003   LWL A0, 3(V1)
9D00A9CC  98640000   LWR A0, 0(V1)
9D00A9D0  AA04004B   SWL A0, 75(S0)
9D00A9D4  B8440000   SWR A0, 0(V0)
458:                 
459:                     /* final transform and result to hash */
460:                     XTRANSFORM(md5, local);
9D00A9D8  0F400883   JAL Transform
9D00A9DC  02002021   ADDU A0, S0, ZERO
461:                 #ifdef BIG_ENDIAN_ORDER
462:                     ByteReverseWords(md5->digest, md5->digest, MD5_DIGEST_SIZE);
463:                 #endif
464:                     XMEMCPY(hash, md5->digest, MD5_DIGEST_SIZE);
9D00A9E0  2602004C   ADDIU V0, S0, 76
9D00A9E4  88450003   LWL A1, 3(V0)
9D00A9E8  98450000   LWR A1, 0(V0)
9D00A9EC  88440007   LWL A0, 7(V0)
9D00A9F0  98440004   LWR A0, 4(V0)
9D00A9F4  8843000B   LWL V1, 11(V0)
9D00A9F8  98430008   LWR V1, 8(V0)
9D00A9FC  8846000F   LWL A2, 15(V0)
9D00AA00  9846000C   LWR A2, 12(V0)
9D00AA04  AA250003   SWL A1, 3(S1)
9D00AA08  BA250000   SWR A1, 0(S1)
9D00AA0C  AA240007   SWL A0, 7(S1)
9D00AA10  BA240004   SWR A0, 4(S1)
9D00AA14  AA23000B   SWL V1, 11(S1)
9D00AA18  BA230008   SWR V1, 8(S1)
9D00AA1C  AA26000F   SWL A2, 15(S1)
9D00AA20  BA26000C   SWR A2, 12(S1)
465:                 
466:                     return _InitMd5(md5); /* reset state */
9D00AA60  0B402A9D   J 0x9D00AA74
9D00AA64  00001021   ADDU V0, ZERO, ZERO
467:                 }
9D00AA74  8FBF0024   LW RA, 36(SP)
9D00AA78  8FB30020   LW S3, 32(SP)
9D00AA7C  8FB2001C   LW S2, 28(SP)
9D00AA80  8FB10018   LW S1, 24(SP)
9D00AA84  8FB00014   LW S0, 20(SP)
9D00AA88  03E00008   JR RA
9D00AA8C  27BD0028   ADDIU SP, SP, 40
468:                 #endif /* !HAVE_MD5_CUST_API */
469:                 
470:                 
471:                 int wc_InitMd5(Md5* md5)
472:                 {
9D015040  27BDFFE8   ADDIU SP, SP, -24
9D015044  AFBF0014   SW RA, 20(SP)
473:                     if (md5 == NULL) {
9D015038  10800007   BEQ A0, ZERO, 0x9D015058
9D01503C  00002821   ADDU A1, ZERO, ZERO
474:                         return BAD_FUNC_ARG;
9D015058  03E00008   JR RA
9D01505C  2402FF53   ADDIU V0, ZERO, -173
475:                     }
476:                     return wc_InitMd5_ex(md5, NULL, INVALID_DEVID);
9D015048  0F404FD5   JAL wc_InitMd5_ex
9D01504C  2406FFFE   ADDIU A2, ZERO, -2
9D015050  0B405418   J 0x9D015060
9D015054  8FBF0014   LW RA, 20(SP)
477:                 }
9D015060  03E00008   JR RA
9D015064  27BD0018   ADDIU SP, SP, 24
478:                 
479:                 void wc_Md5Free(Md5* md5)
480:                 {
481:                     if (md5 == NULL)
482:                         return;
483:                 #if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_MD5)
484:                     wolfAsync_DevCtxFree(&md5->asyncDev, WOLFSSL_ASYNC_MARKER_MD5);
485:                 #endif /* WOLFSSL_ASYNC_CRYPT */
486:                 }
487:                 
488:                 int wc_Md5GetHash(Md5* md5, byte* hash)
489:                 {
490:                     int ret;
491:                     Md5 tmpMd5;
492:                 
493:                     if (md5 == NULL || hash == NULL)
494:                         return BAD_FUNC_ARG;
495:                 
496:                     ret = wc_Md5Copy(md5, &tmpMd5);
497:                     if (ret == 0) {
498:                         ret = wc_Md5Final(&tmpMd5, hash);
499:                     }
500:                 
501:                     return ret;
502:                 }
503:                 
504:                 int wc_Md5Copy(Md5* src, Md5* dst)
505:                 {
506:                     int ret = 0;
507:                 
508:                     if (src == NULL || dst == NULL)
509:                         return BAD_FUNC_ARG;
510:                 
511:                     XMEMCPY(dst, src, sizeof(Md5));
512:                 
513:                 #ifdef WOLFSSL_ASYNC_CRYPT
514:                     ret = wolfAsync_DevCopy(&src->asyncDev, &dst->asyncDev);
515:                 #endif
516:                 #ifdef WOLFSSL_PIC32MZ_HASH
517:                     ret = wc_Pic32HashCopy(&src->cache, &dst->cache);
518:                 #endif
519:                 
520:                     return ret;
521:                 }
522:                 
523:                 #endif /* WOLFSSL_TI_HASH */
524:                 #endif /* NO_MD5 */
---  /home/whatisthis/microchip/harmony/v2_04/framework/crypto/src/crypto.c  ----------------------------
1:                   /**************************************************************************
2:                     Crypto Framework Library Source
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       crypto.c
9:                   
10:                    Summary:
11:                      Crypto Framework Libarary source for cryptographic functions.
12:                  
13:                    Description:
14:                      This source file contains functions that make up the Cryptographic
15:                  	Framework Library for PIC32 families of Microchip microcontrollers.
16:                  **************************************************************************/
17:                  
18:                  //DOM-IGNORE-BEGIN
19:                  /******************************************************************************
20:                  File Name:  crypto.c
21:                  Copyright  2013 released Microchip Technology Inc.  All rights reserved.
22:                  
23:                  Microchip licenses to you the right to use, modify, copy and distribute
24:                  Software only when embedded on a Microchip microcontroller or digital signal
25:                  controller that is integrated into your product or third party product
26:                  (pursuant to the sublicense terms in the accompanying license agreement).
27:                  
28:                  You should refer to the license agreement accompanying this Software for
29:                  additional information regarding your rights and obligations.
30:                  
31:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
32:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
33:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
34:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
35:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
36:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
37:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
38:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
39:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
40:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
41:                  *******************************************************************************/
42:                  //DOM-IGNORE-END
43:                  
44:                  
45:                  
46:                  
47:                  /* Implements Microchip CRYPTO API layer */
48:                  #ifdef HAVE_CONFIG_H
49:                      #include "config.h"
50:                  #endif
51:                  #include "system_config.h"
52:                  
53:                  #include "crypto/crypto.h"
54:                  
55:                  #include "crypto/src/md5.h"
56:                  #include "crypto/src/sha.h"
57:                  #include "crypto/src/sha256.h"
58:                  #include "crypto/src/sha512.h"
59:                  #include "crypto/src/hmac.h"
60:                  #include "crypto/src/compress.h"
61:                  #include "crypto/src/random.h"
62:                  #include "crypto/src/des3.h"
63:                  #include "crypto/src/aes.h"
64:                  #include "crypto/src/rsa.h"
65:                  #include "crypto/src/ecc.h"
66:                  #include "crypto/src/error-crypt.h"
67:                  
68:                  #ifndef NO_MD5
69:                  /* Initialize MD5 */
70:                  int CRYPT_MD5_Initialize(CRYPT_MD5_CTX* md5)
71:                  {
9D014ED8  27BDFFE8   ADDIU SP, SP, -24
9D014EDC  AFBF0014   SW RA, 20(SP)
72:                      typedef char md5_test[sizeof(CRYPT_MD5_CTX) >= sizeof(Md5) ? 1 : -1];
73:                      (void)sizeof(md5_test);
74:                  
75:                      if (md5 == NULL)
9D014ED0  10800007   BEQ A0, ZERO, 0x9D014EF0
9D014ED4  00000000   NOP
76:                          return BAD_FUNC_ARG;
9D014EF0  03E00008   JR RA
9D014EF4  2402FF53   ADDIU V0, ZERO, -173
77:                  
78:                      wc_InitMd5((Md5*)md5);
9D014EE0  0F40540E   JAL wc_InitMd5
9D014EE4  00000000   NOP
79:                  
80:                      return 0;
9D014EE8  0B4053BE   J 0x9D014EF8
9D014EEC  00001021   ADDU V0, ZERO, ZERO
81:                  }
9D014EF8  8FBF0014   LW RA, 20(SP)
9D014EFC  03E00008   JR RA
9D014F00  27BD0018   ADDIU SP, SP, 24
82:                  
83:                  int CRYPT_MD5_DataSizeSet(CRYPT_MD5_CTX* md5, unsigned int sz)
84:                  {
85:                      if (md5 == NULL)
86:                          return BAD_FUNC_ARG;
87:                  
88:                  #ifdef WOLFSSL_PIC32MZ_HASH
89:                      wc_Md5SizeSet((Md5*)md5, sz);
90:                  #endif
91:                  
92:                      return 0;
93:                  }
9D0159C0  2402FF53   ADDIU V0, ZERO, -173
9D0159C4  03E00008   JR RA
9D0159C8  0004100B   MOVN V0, ZERO, A0
94:                  
95:                  
96:                  /* Add data to MD5 */
97:                  int CRYPT_MD5_DataAdd(CRYPT_MD5_CTX* md5, const unsigned char* input,
98:                                        unsigned int sz)
99:                  {
9D0148EC  27BDFFE8   ADDIU SP, SP, -24
9D0148F0  AFBF0014   SW RA, 20(SP)
100:                     if (md5 == NULL || input == NULL)
9D0148DC  10800009   BEQ A0, ZERO, 0x9D014904
9D0148E0  00000000   NOP
9D0148E4  10A00009   BEQ A1, ZERO, 0x9D01490C
9D0148E8  00000000   NOP
101:                         return BAD_FUNC_ARG;
9D014904  03E00008   JR RA
9D014908  2402FF53   ADDIU V0, ZERO, -173
9D01490C  03E00008   JR RA
9D014910  2402FF53   ADDIU V0, ZERO, -173
102:                 
103:                     return wc_Md5Update((Md5*)md5, input, sz);
9D0148F4  0F403D7D   JAL wc_Md5Update
9D0148F8  00000000   NOP
9D0148FC  0B405245   J 0x9D014914
9D014900  8FBF0014   LW RA, 20(SP)
104:                 }
9D014914  03E00008   JR RA
9D014918  27BD0018   ADDIU SP, SP, 24
105:                 
106:                 
107:                 /* Get MD5 Final into digest */
108:                 int CRYPT_MD5_Finalize(CRYPT_MD5_CTX* md5, unsigned char* digest)
109:                 {
9D01492C  27BDFFE8   ADDIU SP, SP, -24
9D014930  AFBF0014   SW RA, 20(SP)
110:                     if (md5 == NULL || digest == NULL)
9D01491C  10800009   BEQ A0, ZERO, 0x9D014944
9D014920  00000000   NOP
9D014924  10A00009   BEQ A1, ZERO, 0x9D01494C
9D014928  00000000   NOP
111:                         return BAD_FUNC_ARG;
9D014944  03E00008   JR RA
9D014948  2402FF53   ADDIU V0, ZERO, -173
9D01494C  03E00008   JR RA
9D014950  2402FF53   ADDIU V0, ZERO, -173
112:                 
113:                     return wc_Md5Final((Md5*)md5, digest);
9D014934  0F402A35   JAL wc_Md5Final
9D014938  00000000   NOP
9D01493C  0B405255   J 0x9D014954
9D014940  8FBF0014   LW RA, 20(SP)
114:                 }
9D014954  03E00008   JR RA
9D014958  27BD0018   ADDIU SP, SP, 24
115:                 #endif  // NO_MD5
116:                 
117:                 #ifndef NO_SHA
118:                 /* Initialize SHA */
119:                 int CRYPT_SHA_Initialize(CRYPT_SHA_CTX* sha)
120:                 {
121:                     typedef char sha_test[sizeof(CRYPT_SHA_CTX) >= sizeof(Sha) ? 1 : -1];
122:                     (void)sizeof(sha_test);
123:                 
124:                     if (sha == NULL)
125:                         return BAD_FUNC_ARG;
126:                 
127:                     return wc_InitSha((Sha*)sha);
128:                 }
129:                 
130:                 int CRYPT_SHA_DataSizeSet(CRYPT_SHA_CTX* sha, unsigned int sz)
131:                 {
132:                     if (sha == NULL)
133:                         return BAD_FUNC_ARG;
134:                 
135:                 #ifdef WOLFSSL_PIC32MZ_HASH
136:                     wc_ShaSizeSet((Sha*)sha, sz);
137:                 #endif
138:                 
139:                     return 0;
140:                 }
141:                 
142:                 
143:                 /* Add data to SHA */
144:                 int CRYPT_SHA_DataAdd(CRYPT_SHA_CTX* sha, const unsigned char* input,
145:                                        unsigned int sz)
146:                 {
147:                     if (sha == NULL || input == NULL)
148:                         return BAD_FUNC_ARG;
149:                 
150:                     return wc_ShaUpdate((Sha*)sha, input, sz);
151:                 }
152:                 
153:                 
154:                 /* Get SHA Final into digest */
155:                 int CRYPT_SHA_Finalize(CRYPT_SHA_CTX* sha, unsigned char* digest)
156:                 {
157:                     if (sha == NULL || digest == NULL)
158:                         return BAD_FUNC_ARG;
159:                 
160:                     return wc_ShaFinal((Sha*)sha, digest);
161:                 }
162:                 #endif // NO_SHA
163:                 
164:                 #ifndef NO_SHA256
165:                 /* Initialize SHA-256 */
166:                 int CRYPT_SHA256_Initialize(CRYPT_SHA256_CTX* sha256)
167:                 {
168:                     typedef char sha_test[sizeof(CRYPT_SHA256_CTX) >= sizeof(Sha256) ? 1 : -1];
169:                     (void)sizeof(sha_test);
170:                 
171:                     if (sha256 == NULL)
172:                         return BAD_FUNC_ARG;
173:                 
174:                     return wc_InitSha256((Sha256*)sha256);
175:                 }
176:                 
177:                 int CRYPT_SHA256_DataSizeSet(CRYPT_SHA256_CTX* sha256, unsigned int sz)
178:                 {
179:                     if (sha256 == NULL)
180:                         return BAD_FUNC_ARG;
181:                 
182:                 #ifdef WOLFSSL_PIC32MZ_HASH
183:                     void wc_Sha256SizeSet(Sha256* sha256, word32 len);
184:                 
185:                     wc_Sha256SizeSet((Sha256*)sha256, sz);
186:                 #endif
187:                 
188:                     return 0;
189:                 }
190:                 
191:                 
192:                 /* Add data to SHA-256 */
193:                 int CRYPT_SHA256_DataAdd(CRYPT_SHA256_CTX* sha256, const unsigned char* input,
194:                                          unsigned int sz)
195:                 {
196:                     if (sha256 == NULL || input == NULL)
197:                         return BAD_FUNC_ARG;
198:                 
199:                     return wc_Sha256Update((Sha256*)sha256, input, sz);
200:                 }
201:                 
202:                 
203:                 /* Get SHA-256 Final into digest */
204:                 int CRYPT_SHA256_Finalize(CRYPT_SHA256_CTX* sha256, unsigned char* digest)
205:                 {
206:                     if (sha256 == NULL || digest == NULL)
207:                         return BAD_FUNC_ARG;
208:                 
209:                     return wc_Sha256Final((Sha256*)sha256, digest);
210:                 }
211:                 #endif // NO_SHA256
212:                 #ifdef WOLFSSL_SHA384
213:                 
214:                 /* Initialize SHA-384 */
215:                 int CRYPT_SHA384_Initialize(CRYPT_SHA384_CTX* sha384)
216:                 {
217:                     typedef char sha_test[sizeof(CRYPT_SHA384_CTX) >= sizeof(Sha384) ? 1 : -1];
218:                     (void)sizeof(sha_test);
219:                 
220:                     if (sha384 == NULL)
221:                         return BAD_FUNC_ARG;
222:                 
223:                     return wc_InitSha384((Sha384*)sha384);
224:                 }
225:                 
226:                 
227:                 /* Add data to SHA-384 */
228:                 int CRYPT_SHA384_DataAdd(CRYPT_SHA384_CTX* sha384, const unsigned char* input,
229:                                          unsigned int sz)
230:                 {
231:                     if (sha384 == NULL || input == NULL)
232:                         return BAD_FUNC_ARG;
233:                 
234:                     return wc_Sha384Update((Sha384*)sha384, input, sz);
235:                 }
236:                 
237:                 
238:                 /* Get SHA-384 Final into digest */
239:                 int CRYPT_SHA384_Finalize(CRYPT_SHA384_CTX* sha384, unsigned char* digest)
240:                 {
241:                     if (sha384 == NULL || digest == NULL)
242:                         return BAD_FUNC_ARG;
243:                 
244:                     return wc_Sha384Final((Sha384*)sha384, digest);
245:                 }
246:                 
247:                 #endif  // WOLFSSL_SHA384
248:                 
249:                 #ifdef WOLFSSL_SHA512
250:                 
251:                 /* Initialize SHA-512 */
252:                 int CRYPT_SHA512_Initialize(CRYPT_SHA512_CTX* sha512)
253:                 {
254:                     typedef char sha_test[sizeof(CRYPT_SHA512_CTX) >= sizeof(Sha512) ? 1 : -1];
255:                     (void)sizeof(sha_test);
256:                 
257:                     if (sha512 == NULL)
258:                         return BAD_FUNC_ARG;
259:                 
260:                     return wc_InitSha512((Sha512*)sha512);
261:                 }
262:                 
263:                 
264:                 /* Add data to SHA-512 */
265:                 int CRYPT_SHA512_DataAdd(CRYPT_SHA512_CTX* sha512, const unsigned char* input,
266:                                          unsigned int sz)
267:                 {
268:                     if (sha512 == NULL || input == NULL)
269:                         return BAD_FUNC_ARG;
270:                 
271:                     return wc_Sha512Update((Sha512*)sha512, input, sz);
272:                 }
273:                 
274:                 
275:                 /* Get SHA-512 Final into digest */
276:                 int CRYPT_SHA512_Finalize(CRYPT_SHA512_CTX* sha512, unsigned char* digest)
277:                 {
278:                     if (sha512 == NULL || digest == NULL)
279:                         return BAD_FUNC_ARG;
280:                 
281:                     return wc_Sha512Final((Sha512*)sha512, digest);
282:                 }
283:                 
284:                 #endif  // WOLFSSL_SHA512
285:                 
286:                 #ifndef NO_HMAC
287:                 
288:                 /* Set HMAC key with type */
289:                 int CRYPT_HMAC_SetKey(CRYPT_HMAC_CTX* hmac, int type, const unsigned char* key,
290:                                       unsigned int sz)
291:                 {
292:                     typedef char hmac_test[sizeof(CRYPT_HMAC_CTX) >= sizeof(Hmac) ? 1 : -1];
293:                     (void)sizeof(hmac_test);
294:                 
295:                     if (hmac == NULL || key == NULL)
296:                         return BAD_FUNC_ARG;
297:                 
298:                     if (type != CRYPT_HMAC_SHA && type != CRYPT_HMAC_SHA256 &&
299:                         type != CRYPT_HMAC_SHA384 && type != CRYPT_HMAC_SHA512) {
300:                         return BAD_FUNC_ARG;  /* bad hmac type */
301:                     }
302:                 
303:                     return wc_HmacSetKey((Hmac*)hmac, type, key, sz);
304:                 }
305:                 
306:                 
307:                 int CRYPT_HMAC_DataAdd(CRYPT_HMAC_CTX* hmac, const unsigned char* input,
308:                                        unsigned int sz)
309:                 {
310:                     if (hmac == NULL || input == NULL)
311:                         return BAD_FUNC_ARG;
312:                 
313:                     return wc_HmacUpdate((Hmac*)hmac, input, sz);
314:                 }
315:                 
316:                 
317:                 /* Get HMAC Final into digest */
318:                 int CRYPT_HMAC_Finalize(CRYPT_HMAC_CTX* hmac, unsigned char* digest)
319:                 {
320:                     if (hmac == NULL || digest == NULL)
321:                         return BAD_FUNC_ARG;
322:                 
323:                     return wc_HmacFinal((Hmac*)hmac, digest);
324:                 }
325:                 
326:                 #endif // NO_HMAC
327:                 
328:                 #ifdef HAVE_LIBZ
329:                 
330:                 /* Huffman Compression, set flag to do static, otherwise dynamic */
331:                 /* return compressed size, otherwise < 0 for error */
332:                 int CRYPT_HUFFMAN_Compress(unsigned char* out, unsigned int outSz,
333:                                            const unsigned char* in, unsigned int inSz,
334:                                            unsigned int flags)
335:                 {
336:                     if (out == NULL || in == NULL)
337:                         return BAD_FUNC_ARG;
338:                 
339:                     return wc_Compress(out, outSz, in, inSz, flags);
340:                 }
341:                 
342:                 
343:                 /* Huffman DeCompression, self determines type */
344:                 /* return decompressed size, otherwise < 0 for error */
345:                 int CRYPT_HUFFMAN_DeCompress(unsigned char* out, unsigned int outSz,
346:                                              const unsigned char* in, unsigned int inSz)
347:                 {
348:                     if (out == NULL || in == NULL)
349:                         return BAD_FUNC_ARG;
350:                 
351:                     return wc_DeCompress(out, outSz, in, inSz);
352:                 }
353:                 
354:                 #endif  // HAVE_LIBZ
355:                 
356:                 #ifndef NO_RNG
357:                 
358:                 /* RNG Initialize, < 0 on error */
359:                 int CRYPT_RNG_Initialize(CRYPT_RNG_CTX* rng)
360:                 {
361:                     typedef char rng_test[sizeof(CRYPT_RNG_CTX) >= sizeof(WC_RNG) ? 1 : -1];
362:                     (void)sizeof(rng_test);
363:                 
364:                     if (rng == NULL)
365:                         return BAD_FUNC_ARG;
366:                 
367:                     return wc_InitRng((WC_RNG*)rng);
368:                 }
369:                 
370:                 
371:                 /* RNG Get single bytes, < 0 on error */
372:                 int CRYPT_RNG_Get(CRYPT_RNG_CTX* rng, unsigned char* b)
373:                 {
374:                     if (rng == NULL || b == NULL)
375:                         return BAD_FUNC_ARG;
376:                 
377:                     return wc_RNG_GenerateByte((WC_RNG*)rng, (byte*)b);
378:                 }
379:                 
380:                 
381:                 /* RNG Block Generation of sz bytes, < 0 on error */
382:                 int CRYPT_RNG_BlockGenerate(CRYPT_RNG_CTX* rng, unsigned char* b,
383:                                             unsigned int sz)
384:                 {
385:                     if (rng == NULL || b == NULL)
386:                         return BAD_FUNC_ARG;
387:                 
388:                     return wc_RNG_GenerateBlock((WC_RNG*)rng, b, sz);
389:                 }
390:                 
391:                 #endif
392:                 
393:                 #ifndef NO_DES3
394:                 /* Triple DES Key Set, may have iv, will have direction */
395:                 int CRYPT_TDES_KeySet(CRYPT_TDES_CTX* tdes, const unsigned char* key,
396:                                       const unsigned char* iv, int dir)
397:                 {
398:                     typedef char tdes_test[sizeof(CRYPT_TDES_CTX) >= sizeof(Des3) ? 1 : -1];
399:                     (void)sizeof(tdes_test);
400:                 
401:                     if (tdes == NULL || key == NULL)
402:                         return BAD_FUNC_ARG;
403:                 
404:                     return wc_Des3_SetKey((Des3*)tdes, key, iv, dir);
405:                 }
406:                 
407:                 
408:                 /* Triple DES Iv Set, sometimes added later */
409:                 int CRYPT_TDES_IvSet(CRYPT_TDES_CTX* tdes, const unsigned char* iv)
410:                 {
411:                     if (tdes == NULL || iv == NULL)
412:                         return BAD_FUNC_ARG;
413:                 
414:                     return wc_Des3_SetIV((Des3*)tdes, iv);
415:                 }
416:                 
417:                 
418:                 /* Triple DES CBC Encrypt */
419:                 int CRYPT_TDES_CBC_Encrypt(CRYPT_TDES_CTX* tdes, unsigned char* out,
420:                                            const unsigned char* in, unsigned int inSz)
421:                 {
422:                     if (tdes == NULL || out == NULL || in == NULL)
423:                         return BAD_FUNC_ARG;
424:                 
425:                     return wc_Des3_CbcEncrypt((Des3*)tdes, out, in, inSz);
426:                 }
427:                 
428:                 
429:                 /* Triple DES CBC Decrypt */
430:                 int CRYPT_TDES_CBC_Decrypt(CRYPT_TDES_CTX* tdes, unsigned char* out,
431:                                            const unsigned char* in, unsigned int inSz)
432:                 {
433:                     if (tdes == NULL || out == NULL || in == NULL)
434:                         return BAD_FUNC_ARG;
435:                 
436:                     return wc_Des3_CbcDecrypt((Des3*)tdes, out, in, inSz);
437:                 }
438:                 
439:                 #endif
440:                 
441:                 #ifndef NO_AES
442:                 
443:                 /* AES Key Set, may have iv, will have direction */
444:                 int CRYPT_AES_KeySet(CRYPT_AES_CTX* aes, const unsigned char* key,
445:                                      unsigned int keyLen, const unsigned char* iv, int dir)
446:                 {
447:                     typedef char aes_test[sizeof(CRYPT_AES_CTX) >= sizeof(Aes) ? 1 : -1];
448:                     (void)sizeof(aes_test);
449:                 
450:                     if (aes == NULL || key == NULL)
451:                         return BAD_FUNC_ARG;
452:                 
453:                     return wc_AesSetKey((Aes*)aes, key, keyLen, iv, dir);
454:                 }
455:                 
456:                 
457:                 /* AES Iv Set, sometimes added later */
458:                 int CRYPT_AES_IvSet(CRYPT_AES_CTX* aes, const unsigned char* iv)
459:                 {
460:                     if (aes == NULL || iv == NULL)
461:                         return BAD_FUNC_ARG;
462:                 
463:                     return wc_AesSetIV((Aes*)aes, iv);
464:                 }
465:                 
466:                 
467:                 /* AES CBC Encrypt */
468:                 int CRYPT_AES_CBC_Encrypt(CRYPT_AES_CTX* aes, unsigned char* out,
469:                                           const unsigned char* in, unsigned int inSz)
470:                 {
471:                     if (aes == NULL || out == NULL || in == NULL)
472:                         return BAD_FUNC_ARG;
473:                 
474:                     return wc_AesCbcEncrypt((Aes*)aes, out, in, inSz);
475:                 }
476:                 
477:                 
478:                 /* AES CBC Decrypt */
479:                 int CRYPT_AES_CBC_Decrypt(CRYPT_AES_CTX* aes, unsigned char* out,
480:                                           const unsigned char* in, unsigned int inSz)
481:                 {
482:                     if (aes == NULL || out == NULL || in == NULL)
483:                         return BAD_FUNC_ARG;
484:                 
485:                     return wc_AesCbcDecrypt((Aes*)aes, out, in, inSz);
486:                 }
487:                 
488:                 #ifdef WOLFSSL_AES_COUNTER
489:                 
490:                 /* AES CTR Encrypt (used for decrypt too, with ENCRYPT key setup) */
491:                 int CRYPT_AES_CTR_Encrypt(CRYPT_AES_CTX* aes, unsigned char* out,
492:                                           const unsigned char* in, unsigned int inSz)
493:                 {
494:                     if (aes == NULL || out == NULL || in == NULL)
495:                         return BAD_FUNC_ARG;
496:                 
497:                     return wc_AesCtrEncrypt((Aes*)aes, out, in, inSz);
498:                 }
499:                 
500:                 #endif /* WOLFSSL_AES_COUNTER */
501:                 
502:                 #ifdef WOLFSSL_AES_DIRECT
503:                 
504:                 /* AES Direct mode encrypt, one block at a time */
505:                 int CRYPT_AES_DIRECT_Encrypt(CRYPT_AES_CTX* aes, unsigned char* out,
506:                                              const unsigned char* in)
507:                 {
508:                     if (aes == NULL || out == NULL || in == NULL)
509:                         return BAD_FUNC_ARG;
510:                 
511:                     wc_AesEncryptDirect((Aes*)aes, out, in);
512:                 
513:                     return 0;
514:                 }
515:                 
516:                 
517:                 /* AES Direct mode decrypt, one block at a time */
518:                 int CRYPT_AES_DIRECT_Decrypt(CRYPT_AES_CTX* aes, unsigned char* out,
519:                                              const unsigned char* in)
520:                 {
521:                     if (aes == NULL || out == NULL || in == NULL)
522:                         return BAD_FUNC_ARG;
523:                 
524:                     wc_AesDecryptDirect((Aes*)aes, out, in);
525:                 
526:                     return 0;
527:                 }
528:                 
529:                 #endif /* WOLFSSL_AES_DIRECT */
530:                 #endif /* NO_AES */
531:                 
532:                 #ifndef NO_RSA
533:                 
534:                 /* RSA Initialize */
535:                 int CRYPT_RSA_Initialize(CRYPT_RSA_CTX* rsa)
536:                 {
537:                     if (rsa == NULL)
538:                         return BAD_FUNC_ARG;
539:                 
540:                     rsa->holder = (RsaKey*)XMALLOC(sizeof(RsaKey), NULL, DYNAMIC_TYPE_RSA);
541:                     if (rsa->holder == NULL)
542:                         return -1;
543:                 
544:                     return wc_InitRsaKey((RsaKey*)rsa->holder, NULL);
545:                 }
546:                 
547:                 
548:                 /* RSA Free resources */
549:                 int CRYPT_RSA_Free(CRYPT_RSA_CTX* rsa)
550:                 {
551:                     if (rsa == NULL)
552:                         return BAD_FUNC_ARG;
553:                 
554:                     wc_FreeRsaKey((RsaKey*)rsa->holder);
555:                     XFREE(rsa->holder, NULL, DYNAMIC_TYPE_RSA);
556:                     rsa->holder = NULL;
557:                 
558:                     return 0;
559:                 }
560:                 
561:                 
562:                 /* RSA Public key decode ASN.1 */
563:                 int CRYPT_RSA_PublicKeyDecode(CRYPT_RSA_CTX* rsa, const unsigned char* in,
564:                                               unsigned int inSz)
565:                 {
566:                     unsigned int idx = 0;
567:                     (void)idx;
568:                 
569:                     if (rsa == NULL || in == NULL)
570:                         return BAD_FUNC_ARG;
571:                 
572:                     return wc_RsaPublicKeyDecode(in, &idx, (RsaKey*)rsa->holder, inSz);
573:                 }
574:                 
575:                 
576:                 /* RSA Private key decode ASN.1 */
577:                 int CRYPT_RSA_PrivateKeyDecode(CRYPT_RSA_CTX* rsa, const unsigned char* in,
578:                                                unsigned int inSz)
579:                 {
580:                     unsigned int idx = 0;
581:                     (void)idx;
582:                 
583:                     if (rsa == NULL || in == NULL)
584:                         return BAD_FUNC_ARG;
585:                 
586:                     return wc_RsaPrivateKeyDecode(in, &idx, (RsaKey*)rsa->holder, inSz);
587:                 }
588:                 
589:                 
590:                 /* RSA Public Encrypt */
591:                 int CRYPT_RSA_PublicEncrypt(CRYPT_RSA_CTX* rsa, unsigned char* out,
592:                                             unsigned int outSz, const unsigned char* in,
593:                                             unsigned int inSz, CRYPT_RNG_CTX* rng)
594:                 {
595:                     if (rsa == NULL || in == NULL || out == NULL || rng == NULL)
596:                         return BAD_FUNC_ARG;
597:                 
598:                     return wc_RsaPublicEncrypt(in, inSz, out, outSz, (RsaKey*)rsa->holder,
599:                                             (WC_RNG*)rng);
600:                 }
601:                 
602:                 
603:                 /* RSA Private Decrypt */
604:                 int CRYPT_RSA_PrivateDecrypt(CRYPT_RSA_CTX* rsa, unsigned char* out,
605:                                              unsigned int outSz, const unsigned char* in,
606:                                              unsigned int inSz)
607:                 {
608:                     if (rsa == NULL || in == NULL || out == NULL)
609:                         return BAD_FUNC_ARG;
610:                 
611:                     return wc_RsaPrivateDecrypt(in, inSz, out, outSz, (RsaKey*)rsa->holder);
612:                 }
613:                 
614:                 
615:                 /* RSA Get Encrypt size helper */
616:                 int CRYPT_RSA_EncryptSizeGet(CRYPT_RSA_CTX* rsa)
617:                 {
618:                     if (rsa == NULL)
619:                         return BAD_FUNC_ARG;
620:                 
621:                     return wc_RsaEncryptSize((RsaKey*)rsa->holder);
622:                 }
623:                 
624:                 #endif // NO_RSA
625:                 
626:                 #ifdef HAVE_ECC
627:                 
628:                 /* ECC init */
629:                 int CRYPT_ECC_Initialize(CRYPT_ECC_CTX* ecc)
630:                 {
631:                     if (ecc == NULL)
632:                         return BAD_FUNC_ARG;
633:                 
634:                     ecc->holder = (ecc_key*)XMALLOC(sizeof(ecc_key), NULL, DYNAMIC_TYPE_ECC);
635:                     if (ecc->holder == NULL)
636:                         return -1;
637:                 
638:                     return wc_ecc_init((ecc_key*)ecc->holder);
639:                 }
640:                 
641:                 
642:                 /* ECC free resources */
643:                 int CRYPT_ECC_Free(CRYPT_ECC_CTX* ecc)
644:                 {
645:                     if (ecc == NULL)
646:                         return BAD_FUNC_ARG;
647:                 
648:                     wc_ecc_free((ecc_key*)ecc->holder);
649:                     XFREE(ecc->holder, NULL, DYNAMIC_TYPE_ECC);
650:                     ecc->holder = NULL;
651:                 
652:                     return 0;
653:                 }
654:                 
655:                 
656:                 /* ECC Public x963 Export */
657:                 int CRYPT_ECC_PublicExport(CRYPT_ECC_CTX* ecc, unsigned char* out,
658:                                            unsigned int outSz, unsigned int* usedSz)
659:                 {
660:                     int          ret;
661:                     unsigned int inOut = outSz;
662:                 
663:                     if (ecc == NULL || out == NULL)
664:                         return BAD_FUNC_ARG;
665:                 
666:                     ret = wc_ecc_export_x963((ecc_key*)ecc->holder, out, &inOut);
667:                     *usedSz = inOut;
668:                 
669:                     return ret;
670:                 }
671:                 
672:                 
673:                 /* ECC Public x963 Import */
674:                 int CRYPT_ECC_PublicImport(CRYPT_ECC_CTX* ecc, const unsigned char* in,
675:                                            unsigned int inSz)
676:                 {
677:                     if (ecc == NULL || in == NULL)
678:                         return BAD_FUNC_ARG;
679:                 
680:                     return wc_ecc_import_x963(in, inSz, (ecc_key*)ecc->holder);
681:                 }
682:                 
683:                 
684:                 /* ECC Private x963 Import */
685:                 int CRYPT_ECC_PrivateImport(CRYPT_ECC_CTX* ecc, const unsigned char* priv,
686:                          unsigned int privSz, const unsigned char* pub, unsigned int pubSz)
687:                 {
688:                     if (ecc == NULL || priv == NULL || pub == NULL)
689:                         return BAD_FUNC_ARG;
690:                 
691:                     return wc_ecc_import_private_key(priv, privSz, pub, pubSz,
692:                                                  (ecc_key*)ecc->holder);
693:                 }
694:                 
695:                 
696:                 /* ECC DHE Make key */
697:                 int CRYPT_ECC_DHE_KeyMake(CRYPT_ECC_CTX* ecc, CRYPT_RNG_CTX* rng, int keySz)
698:                 {
699:                     if (ecc == NULL || rng == NULL)
700:                         return BAD_FUNC_ARG;
701:                 
702:                     return wc_ecc_make_key((WC_RNG*)rng, keySz, (ecc_key*)ecc->holder);
703:                 }
704:                 
705:                 
706:                 /* ECC DHE Make shared secret with our private and peer public */
707:                 int CRYPT_ECC_DHE_SharedSecretMake(CRYPT_ECC_CTX* priv, CRYPT_ECC_CTX* pub,
708:                                   unsigned char* out, unsigned int outSz, unsigned int* usedSz)
709:                 {
710:                     int ret;
711:                     unsigned int inOut = outSz;
712:                 
713:                     if (priv == NULL || pub == NULL || out == NULL || usedSz == NULL)
714:                         return BAD_FUNC_ARG;
715:                 
716:                     ret = wc_ecc_shared_secret((ecc_key*)priv->holder, (ecc_key*)pub->holder,
717:                                             out, &inOut);
718:                     *usedSz = inOut;
719:                 
720:                     return ret;
721:                 }
722:                 
723:                 
724:                 /* ECC DSA Hash Sign */
725:                 int CRYPT_ECC_DSA_HashSign(CRYPT_ECC_CTX* ecc, CRYPT_RNG_CTX* rng,
726:                                            unsigned char* sig, unsigned int sigSz,
727:                                            unsigned int* usedSz, const unsigned char* in,
728:                                            unsigned int inSz)
729:                 {
730:                     int ret;
731:                     unsigned int inOut = sigSz;
732:                 
733:                     if (ecc == NULL || rng == NULL || sig == NULL || usedSz == NULL ||
734:                                                                                 in == NULL)
735:                         return BAD_FUNC_ARG;
736:                 
737:                     ret = wc_ecc_sign_hash(in, inSz, sig, &inOut, (WC_RNG*)rng,
738:                                        (ecc_key*)ecc->holder);
739:                     *usedSz = inOut;
740:                 
741:                     return ret;
742:                 }
743:                 
744:                 
745:                 /* ECC DSA Hash Verify */
746:                 int CRYPT_ECC_DSA_HashVerify(CRYPT_ECC_CTX* ecc, const unsigned char* sig,
747:                                              unsigned int sigSz, unsigned char* hash,
748:                                              unsigned int hashSz, int* status)
749:                 {
750:                     if (ecc == NULL || sig == NULL || hash == NULL || status == NULL)
751:                         return BAD_FUNC_ARG;
752:                 
753:                     return wc_ecc_verify_hash(sig, sigSz, hash, hashSz, status,
754:                                           (ecc_key*)ecc->holder);
755:                 }
756:                 
757:                 
758:                 /* ECC get key size helper */
759:                 int CRYPT_ECC_KeySizeGet(CRYPT_ECC_CTX* ecc)
760:                 {
761:                     if (ecc == NULL)
762:                         return BAD_FUNC_ARG;
763:                 
764:                     return wc_ecc_size((ecc_key*)ecc->holder);
765:                 }
766:                 
767:                 
768:                 /* ECC get signature size helper */
769:                 int CRYPT_ECC_SignatureSizeGet(CRYPT_ECC_CTX* ecc)
770:                 {
771:                     if (ecc == NULL)
772:                         return BAD_FUNC_ARG;
773:                 
774:                     return wc_ecc_sig_size((ecc_key*)ecc->holder);
775:                 }
776:                 #endif // HAVE_ECC
777:                 
778:                 
779:                 /* Save error string from err to str which needs to be >= 80 chars */
780:                 int CRYPT_ERROR_StringGet(int err, char* str)
781:                 {
782:                     if (str == NULL)
783:                         return BAD_FUNC_ARG;
784:                 
785:                     wc_ErrorString(err, str);
786:                 
787:                     return 0;
788:                 }
789:                 
---  /build/bamboo/xml-data/build-dir/XC32-CYIMG-BLD/xc32-XC32-release-1_43/src48x/gcc/libgcc/libgcc2.c  
9D004B58  00C04021   ADDU T0, A2, ZERO
9D004FBC  00C04021   ADDU T0, A2, ZERO
9D004B5C  00804821   ADDU T1, A0, ZERO
9D004FC0  00801021   ADDU V0, A0, ZERO
9D004B60  14E0003B   BNE A3, ZERO, 0x9D004C50
9D004B64  00A01821   ADDU V1, A1, ZERO
9D004FC4  14E0003F   BNE A3, ZERO, 0x9D0050C4
9D004FC8  00A04821   ADDU T1, A1, ZERO
9D004B68  00A6102B   SLTU V0, A1, A2
9D004B6C  10400048   BEQ V0, ZERO, 0x9D004C90
9D004B70  70C21020   CLZ V0, A2
9D004FCC  00A6182B   SLTU V1, A1, A2
9D004FD0  10600047   BEQ V1, ZERO, 0x9D0050F0
9D004FD4  70C31820   CLZ V1, A2
9D004B74  50400008   BEQL V0, ZERO, 0x9D004B98
9D004B78  00083402   SRL A2, T0, 16
9D004FD8  50600008   BEQL V1, ZERO, 0x9D004FFC
9D004FDC  00081C02   SRL V1, T0, 16
9D004B88  00464004   SLLV T0, A2, V0
9D004FEC  00664004   SLLV T0, A2, V1
9D004B7C  00021823   SUBU V1, ZERO, V0
9D004B80  00452804   SLLV A1, A1, V0
9D004B84  00641806   SRLV V1, A0, V1
9D004B8C  00651825   OR V1, V1, A1
9D004FE0  00034823   SUBU T1, ZERO, V1
9D004FE4  00652804   SLLV A1, A1, V1
9D004FE8  01244806   SRLV T1, A0, T1
9D004FF0  01254825   OR T1, T1, A1
9D004B90  00444804   SLLV T1, A0, V0
9D004FF4  00641004   SLLV V0, A0, V1
9D004B94  00083402   SRL A2, T0, 16
9D004B98  0066001B   DIVU V1, A2
9D004B9C  00C001F4   TEQ A2, ZERO
9D004BA0  00002010   MFHI A0
9D004BA4  00005812   MFLO T3
9D004BA8  310CFFFF   ANDI T4, T0, -1
9D004BAC  00095402   SRL T2, T1, 16
9D004BB0  716C5802   MUL T3, T3, T4
9D004BB4  00042400   SLL A0, A0, 16
9D004BB8  008A5025   OR T2, A0, T2
9D004BBC  014B682B   SLTU T5, T2, T3
9D004BC0  0066001B   DIVU V1, A2
9D004BC4  00C001F4   TEQ A2, ZERO
9D004BC8  51A00009   BEQL T5, ZERO, 0x9D004BF0
9D004BCC  014B5023   SUBU T2, T2, T3
9D004BD0  01485021   ADDU T2, T2, T0
9D004BD4  0148182B   SLTU V1, T2, T0
9D004BD8  54600005   BNEL V1, ZERO, 0x9D004BF0
9D004BDC  014B5023   SUBU T2, T2, T3
9D004BE0  014B202B   SLTU A0, T2, T3
9D004BE4  01481821   ADDU V1, T2, T0
9D004BE8  0064500B   MOVN T2, V1, A0
9D004BEC  014B5023   SUBU T2, T2, T3
9D004BF0  3123FFFF   ANDI V1, T1, -1
9D004BF4  0146001B   DIVU T2, A2
9D004BF8  00C001F4   TEQ A2, ZERO
9D004BFC  00004810   MFHI T1
9D004C00  00002012   MFLO A0
9D004C04  708C2002   MUL A0, A0, T4
9D004C08  00094C00   SLL T1, T1, 16
9D004C0C  01234825   OR T1, T1, V1
9D004C10  0124182B   SLTU V1, T1, A0
9D004C14  0146001B   DIVU T2, A2
9D004C18  00C001F4   TEQ A2, ZERO
9D004C1C  50600009   BEQL V1, ZERO, 0x9D004C44
9D004C20  01244823   SUBU T1, T1, A0
9D004C24  01284821   ADDU T1, T1, T0
9D004C28  0128182B   SLTU V1, T1, T0
9D004C2C  54600005   BNEL V1, ZERO, 0x9D004C44
9D004C30  01244823   SUBU T1, T1, A0
9D004C34  0124182B   SLTU V1, T1, A0
9D004C38  01284021   ADDU T0, T1, T0
9D004C3C  0103480B   MOVN T1, T0, V1
9D004C40  01244823   SUBU T1, T1, A0
9D004FF8  00081C02   SRL V1, T0, 16
9D004FFC  0123001B   DIVU T1, V1
9D005000  006001F4   TEQ V1, ZERO
9D005004  00006010   MFHI T4
9D005008  00005812   MFLO T3
9D00500C  310AFFFF   ANDI T2, T0, -1
9D005010  00022402   SRL A0, V0, 16
9D005014  00003012   MFLO A2
9D005018  716A3802   MUL A3, T3, T2
9D00501C  000C6400   SLL T4, T4, 16
9D005020  01842025   OR A0, T4, A0
9D005024  0087602B   SLTU T4, A0, A3
9D005028  0123001B   DIVU T1, V1
9D00502C  006001F4   TEQ V1, ZERO
9D005030  1180000B   BEQ T4, ZERO, 0x9D005060
9D005034  00872823   SUBU A1, A0, A3
9D005038  00882021   ADDU A0, A0, T0
9D00503C  0088282B   SLTU A1, A0, T0
9D005040  14A00006   BNE A1, ZERO, 0x9D00505C
9D005044  2566FFFF   ADDIU A2, T3, -1
9D005048  0087282B   SLTU A1, A0, A3
9D00504C  10A00004   BEQ A1, ZERO, 0x9D005060
9D005050  00872823   SUBU A1, A0, A3
9D005054  2566FFFE   ADDIU A2, T3, -2
9D005058  00882021   ADDU A0, A0, T0
9D00505C  00872823   SUBU A1, A0, A3
9D005060  3042FFFF   ANDI V0, V0, -1
9D005064  00A3001B   DIVU A1, V1
9D005068  006001F4   TEQ V1, ZERO
9D00506C  00004810   MFHI T1
9D005070  00003812   MFLO A3
9D005074  00002012   MFLO A0
9D005078  70EA5002   MUL T2, A3, T2
9D00507C  00094C00   SLL T1, T1, 16
9D005080  01221025   OR V0, T1, V0
9D005084  004A482B   SLTU T1, V0, T2
9D005088  00A3001B   DIVU A1, V1
9D00508C  006001F4   TEQ V1, ZERO
9D005090  51200009   BEQL T1, ZERO, 0x9D0050B8
9D005094  00061400   SLL V0, A2, 16
9D005098  00481021   ADDU V0, V0, T0
9D00509C  0048402B   SLTU T0, V0, T0
9D0050A0  15000004   BNE T0, ZERO, 0x9D0050B4
9D0050A4  24E4FFFF   ADDIU A0, A3, -1
9D0050A8  004A502B   SLTU T2, V0, T2
9D0050AC  24E7FFFE   ADDIU A3, A3, -2
9D0050B0  00EA200B   MOVN A0, A3, T2
9D0050B4  00061400   SLL V0, A2, 16
9D0050B8  00821025   OR V0, A0, V0
9D0050BC  03E00008   JR RA
9D0050C0  00001821   ADDU V1, ZERO, ZERO
9D004C90  14C00006   BNE A2, ZERO, 0x9D004CAC
9D004C94  71021020   CLZ V0, T0
9D0050F0  14C00006   BNE A2, ZERO, 0x9D00510C
9D0050F4  71031820   CLZ V1, T0
9D004C98  24020001   ADDIU V0, ZERO, 1
9D004C9C  0046001B   DIVU V0, A2
9D004CA0  00C001F4   TEQ A2, ZERO
9D004CA4  00004012   MFLO T0
9D0050F8  24030001   ADDIU V1, ZERO, 1
9D0050FC  0066001B   DIVU V1, A2
9D005100  00C001F4   TEQ A2, ZERO
9D005104  00004012   MFLO T0
9D004CA8  71021020   CLZ V0, T0
9D005108  71031820   CLZ V1, T0
9D004CAC  5440007D   BNEL V0, ZERO, 0x9D004EA4
9D004CB0  00484004   SLLV T0, T0, V0
9D00510C  5460007B   BNEL V1, ZERO, 0x9D0052FC
9D005110  00684004   SLLV T0, T0, V1
9D004CB4  00A82823   SUBU A1, A1, T0
9D004CB8  00081C02   SRL V1, T0, 16
9D004CBC  3107FFFF   ANDI A3, T0, -1
9D005114  00A82023   SUBU A0, A1, T0
9D005118  00083C02   SRL A3, T0, 16
9D00511C  310BFFFF   ANDI T3, T0, -1
9D005120  24030001   ADDIU V1, ZERO, 1
9D004EA4  24090020   ADDIU T1, ZERO, 32
9D004EA8  01224823   SUBU T1, T1, V0
9D0052FC  24020020   ADDIU V0, ZERO, 32
9D005300  00431023   SUBU V0, V0, V1
9D004EAC  01255006   SRLV T2, A1, T1
9D005304  00454806   SRLV T1, A1, V0
9D004EC8  00452804   SLLV A1, A1, V0
9D004ECC  01244806   SRLV T1, A0, T1
9D004ED0  01252825   OR A1, T1, A1
9D005320  00652804   SLLV A1, A1, V1
9D005324  00441006   SRLV V0, A0, V0
9D005328  00452825   OR A1, V0, A1
9D004ED8  00444804   SLLV T1, A0, V0
9D005330  00641004   SLLV V0, A0, V1
9D004EB0  00081C02   SRL V1, T0, 16
9D004EB4  0143001B   DIVU T2, V1
9D004EB8  006001F4   TEQ V1, ZERO
9D004EBC  00003010   MFHI A2
9D004EC0  00005812   MFLO T3
9D004EC4  3107FFFF   ANDI A3, T0, -1
9D004ED4  00056402   SRL T4, A1, 16
9D004EDC  71675802   MUL T3, T3, A3
9D004EE0  00063400   SLL A2, A2, 16
9D004EE4  01863025   OR A2, T4, A2
9D004EE8  00CB202B   SLTU A0, A2, T3
9D004EEC  0143001B   DIVU T2, V1
9D004EF0  006001F4   TEQ V1, ZERO
9D004EF4  50800006   BEQL A0, ZERO, 0x9D004F10
9D004EF8  00CB3023   SUBU A2, A2, T3
9D004EFC  00C83021   ADDU A2, A2, T0
9D004F00  00C8202B   SLTU A0, A2, T0
9D004F04  10800024   BEQ A0, ZERO, 0x9D004F98
9D004F08  00CB502B   SLTU T2, A2, T3
9D004F0C  00CB3023   SUBU A2, A2, T3
9D004F10  30AAFFFF   ANDI T2, A1, -1
9D004F14  00C3001B   DIVU A2, V1
9D004F18  006001F4   TEQ V1, ZERO
9D004F1C  00002010   MFHI A0
9D004F20  00002812   MFLO A1
9D004F24  70A72802   MUL A1, A1, A3
9D004F28  00042400   SLL A0, A0, 16
9D004F2C  008A2025   OR A0, A0, T2
9D004F30  0085502B   SLTU T2, A0, A1
9D004F34  00C3001B   DIVU A2, V1
9D004F38  006001F4   TEQ V1, ZERO
9D004F3C  5140FF60   BEQL T2, ZERO, 0x9D004CC0
9D004F40  00852823   SUBU A1, A0, A1
9D004F44  00882021   ADDU A0, A0, T0
9D004F48  0088302B   SLTU A2, A0, T0
9D004F4C  54C0FF5C   BNEL A2, ZERO, 0x9D004CC0
9D004F50  00852823   SUBU A1, A0, A1
9D004F54  0085502B   SLTU T2, A0, A1
9D004F58  00883021   ADDU A2, A0, T0
9D004F5C  00CA200B   MOVN A0, A2, T2
9D004F60  0B401330   J 0x9D004CC0
9D004F64  00852823   SUBU A1, A0, A1
9D004F98  00C82021   ADDU A0, A2, T0
9D004F9C  0B4013C3   J 0x9D004F0C
9D004FA0  008A300B   MOVN A2, A0, T2
9D005308  00083C02   SRL A3, T0, 16
9D00530C  0127001B   DIVU T1, A3
9D005310  00E001F4   TEQ A3, ZERO
9D005314  00003010   MFHI A2
9D005318  00006012   MFLO T4
9D00531C  310BFFFF   ANDI T3, T0, -1
9D00532C  00056C02   SRL T5, A1, 16
9D005334  00001812   MFLO V1
9D005338  718B5002   MUL T2, T4, T3
9D00533C  00063400   SLL A2, A2, 16
9D005340  01A63025   OR A2, T5, A2
9D005344  00CA202B   SLTU A0, A2, T2
9D005348  0127001B   DIVU T1, A3
9D00534C  00E001F4   TEQ A3, ZERO
9D005350  5080000B   BEQL A0, ZERO, 0x9D005380
9D005354  00CA3023   SUBU A2, A2, T2
9D005358  00C83021   ADDU A2, A2, T0
9D00535C  00C8202B   SLTU A0, A2, T0
9D005360  14800006   BNE A0, ZERO, 0x9D00537C
9D005364  2583FFFF   ADDIU V1, T4, -1
9D005368  00CA202B   SLTU A0, A2, T2
9D00536C  50800004   BEQL A0, ZERO, 0x9D005380
9D005370  00CA3023   SUBU A2, A2, T2
9D005374  2583FFFE   ADDIU V1, T4, -2
9D005378  00C83021   ADDU A2, A2, T0
9D00537C  00CA3023   SUBU A2, A2, T2
9D005380  30ACFFFF   ANDI T4, A1, -1
9D005384  00C7001B   DIVU A2, A3
9D005388  00E001F4   TEQ A3, ZERO
9D00538C  00002010   MFHI A0
9D005390  00005012   MFLO T2
9D005394  00004812   MFLO T1
9D005398  714B2802   MUL A1, T2, T3
9D00539C  00042400   SLL A0, A0, 16
9D0053A0  008C2025   OR A0, A0, T4
9D0053A4  0085602B   SLTU T4, A0, A1
9D0053A8  00C7001B   DIVU A2, A3
9D0053AC  00E001F4   TEQ A3, ZERO
9D0053B0  5180000B   BEQL T4, ZERO, 0x9D0053E0
9D0053B4  00031C00   SLL V1, V1, 16
9D0053B8  00882021   ADDU A0, A0, T0
9D0053BC  0088302B   SLTU A2, A0, T0
9D0053C0  14C00006   BNE A2, ZERO, 0x9D0053DC
9D0053C4  2549FFFF   ADDIU T1, T2, -1
9D0053C8  0085302B   SLTU A2, A0, A1
9D0053CC  50C00004   BEQL A2, ZERO, 0x9D0053E0
9D0053D0  00031C00   SLL V1, V1, 16
9D0053D4  2549FFFE   ADDIU T1, T2, -2
9D0053D8  00882021   ADDU A0, A0, T0
9D0053DC  00031C00   SLL V1, V1, 16
9D0053E0  00852023   SUBU A0, A0, A1
9D0053E4  0B401449   J 0x9D005124
9D0053E8  01231825   OR V1, T1, V1
9D004CC0  00092402   SRL A0, T1, 16
9D004CC4  00A3001B   DIVU A1, V1
9D004CC8  006001F4   TEQ V1, ZERO
9D004CCC  00005010   MFHI T2
9D004CD0  00003012   MFLO A2
9D004CD4  70C73002   MUL A2, A2, A3
9D004CD8  000A5400   SLL T2, T2, 16
9D004CDC  01442025   OR A0, T2, A0
9D004CE0  0086502B   SLTU T2, A0, A2
9D004CE4  00A3001B   DIVU A1, V1
9D004CE8  006001F4   TEQ V1, ZERO
9D004CEC  51400009   BEQL T2, ZERO, 0x9D004D14
9D004CF0  00862023   SUBU A0, A0, A2
9D004CF4  00882021   ADDU A0, A0, T0
9D004CF8  0088282B   SLTU A1, A0, T0
9D004CFC  54A00005   BNEL A1, ZERO, 0x9D004D14
9D004D00  00862023   SUBU A0, A0, A2
9D004D04  0086502B   SLTU T2, A0, A2
9D004D08  00882821   ADDU A1, A0, T0
9D004D0C  00AA200B   MOVN A0, A1, T2
9D004D10  00862023   SUBU A0, A0, A2
9D004D14  3126FFFF   ANDI A2, T1, -1
9D004D18  0083001B   DIVU A0, V1
9D004D1C  006001F4   TEQ V1, ZERO
9D004D20  00004810   MFHI T1
9D004D24  00002812   MFLO A1
9D004D28  70A72802   MUL A1, A1, A3
9D004D2C  00094C00   SLL T1, T1, 16
9D004D30  01264825   OR T1, T1, A2
9D004D34  0125302B   SLTU A2, T1, A1
9D004D38  0083001B   DIVU A0, V1
9D004D3C  006001F4   TEQ V1, ZERO
9D004D40  50C00009   BEQL A2, ZERO, 0x9D004D68
9D004D44  01254823   SUBU T1, T1, A1
9D004D48  01284821   ADDU T1, T1, T0
9D004D4C  0128182B   SLTU V1, T1, T0
9D004D50  54600005   BNEL V1, ZERO, 0x9D004D68
9D004D54  01254823   SUBU T1, T1, A1
9D004D58  0125182B   SLTU V1, T1, A1
9D004D5C  01284021   ADDU T0, T1, T0
9D004D60  0103480B   MOVN T1, T0, V1
9D004D64  01254823   SUBU T1, T1, A1
9D005124  00023402   SRL A2, V0, 16
9D005128  0087001B   DIVU A0, A3
9D00512C  00E001F4   TEQ A3, ZERO
9D005130  00006810   MFHI T5
9D005134  00006012   MFLO T4
9D005138  00004812   MFLO T1
9D00513C  718B5002   MUL T2, T4, T3
9D005140  000D6C00   SLL T5, T5, 16
9D005144  01A63025   OR A2, T5, A2
9D005148  00CA682B   SLTU T5, A2, T2
9D00514C  0087001B   DIVU A0, A3
9D005150  00E001F4   TEQ A3, ZERO
9D005154  11A00009   BEQ T5, ZERO, 0x9D00517C
9D005158  00CA2823   SUBU A1, A2, T2
9D00515C  00C83021   ADDU A2, A2, T0
9D005160  00C8202B   SLTU A0, A2, T0
9D005164  14800004   BNE A0, ZERO, 0x9D005178
9D005168  2589FFFF   ADDIU T1, T4, -1
9D00516C  00CA202B   SLTU A0, A2, T2
9D005170  548000A6   BNEL A0, ZERO, 0x9D00540C
9D005174  2589FFFE   ADDIU T1, T4, -2
9D005178  00CA2823   SUBU A1, A2, T2
9D00517C  3042FFFF   ANDI V0, V0, -1
9D005180  00A7001B   DIVU A1, A3
9D005184  00E001F4   TEQ A3, ZERO
9D005188  00005010   MFHI T2
9D00518C  00003012   MFLO A2
9D005190  00002012   MFLO A0
9D005194  70CB5802   MUL T3, A2, T3
9D005198  000A5400   SLL T2, T2, 16
9D00519C  01421025   OR V0, T2, V0
9D0051A0  004B502B   SLTU T2, V0, T3
9D0051A4  00A7001B   DIVU A1, A3
9D0051A8  00E001F4   TEQ A3, ZERO
9D0051AC  51400009   BEQL T2, ZERO, 0x9D0051D4
9D0051B0  00091400   SLL V0, T1, 16
9D0051B4  00481021   ADDU V0, V0, T0
9D0051B8  0048402B   SLTU T0, V0, T0
9D0051BC  15000004   BNE T0, ZERO, 0x9D0051D0
9D0051C0  24C4FFFF   ADDIU A0, A2, -1
9D0051C4  004B582B   SLTU T3, V0, T3
9D0051C8  24C6FFFE   ADDIU A2, A2, -2
9D0051CC  00CB200B   MOVN A0, A2, T3
9D0051D0  00091400   SLL V0, T1, 16
9D0051D4  03E00008   JR RA
9D0051D8  00821025   OR V0, A0, V0
9D00540C  0B40145E   J 0x9D005178
9D004C44  00491006   SRLV V0, T1, V0
9D004D68  00491006   SRLV V0, T1, V0
9D004C48  03E00008   JR RA
9D004C4C  00001821   ADDU V1, ZERO, ZERO
9D004D6C  03E00008   JR RA
9D004D70  00001821   ADDU V1, ZERO, ZERO
9D004C50  00A7102B   SLTU V0, A1, A3
9D004C54  14400047   BNE V0, ZERO, 0x9D004D74
9D004C58  70EA5020   CLZ T2, A3
9D0050C4  00A7102B   SLTU V0, A1, A3
9D0050C8  14400044   BNE V0, ZERO, 0x9D0051DC
9D0050CC  70E84020   CLZ T0, A3
9D0051DC  00001821   ADDU V1, ZERO, ZERO
9D0051E0  03E00008   JR RA
9D0051E4  00001021   ADDU V0, ZERO, ZERO
9D004D74  00801021   ADDU V0, A0, ZERO
9D004D78  03E00008   JR RA
9D004D7C  00A01821   ADDU V1, A1, ZERO
9D004C5C  15400048   BNE T2, ZERO, 0x9D004D80
9D004C60  240B0020   ADDIU T3, ZERO, 32
9D0050D0  55000045   BNEL T0, ZERO, 0x9D0051E8
9D0050D4  24020020   ADDIU V0, ZERO, 32
9D004C64  00E5102B   SLTU V0, A3, A1
9D004C68  14400005   BNE V0, ZERO, 0x9D004C80
9D004C6C  00861023   SUBU V0, A0, A2
9D004C70  0086402B   SLTU T0, A0, A2
9D004C74  15000089   BNE T0, ZERO, 0x9D004E9C
9D004C78  00801021   ADDU V0, A0, ZERO
9D0050D8  00E5282B   SLTU A1, A3, A1
9D0050DC  14A000C8   BNE A1, ZERO, 0x9D005400
9D0050E0  0086302B   SLTU A2, A0, A2
9D0050E4  38C20001   XORI V0, A2, 1
9D0050E8  03E00008   JR RA
9D0050EC  00001821   ADDU V1, ZERO, ZERO
9D005400  00001821   ADDU V1, ZERO, ZERO
9D004C7C  00861023   SUBU V0, A0, A2
9D004C80  00A72823   SUBU A1, A1, A3
9D004C84  0082202B   SLTU A0, A0, V0
9D004C88  03E00008   JR RA
9D004C8C  00A41823   SUBU V1, A1, A0
9D004D80  016A5823   SUBU T3, T3, T2
9D0051E8  00481023   SUBU V0, V0, T0
9D004D84  01473804   SLLV A3, A3, T2
9D004D88  01661006   SRLV V0, A2, T3
9D004D8C  00473825   OR A3, V0, A3
9D0051EC  01073804   SLLV A3, A3, T0
9D0051F0  00461806   SRLV V1, A2, V0
9D0051F4  00673825   OR A3, V1, A3
9D004DBC  01463004   SLLV A2, A2, T2
9D004D90  01656806   SRLV T5, A1, T3
9D0051F8  00455006   SRLV T2, A1, V0
9D004DAC  01452804   SLLV A1, A1, T2
9D004DB0  01641006   SRLV V0, A0, T3
9D004DB4  00451025   OR V0, V0, A1
9D005214  01052804   SLLV A1, A1, T0
9D005218  00441006   SRLV V0, A0, V0
9D00521C  00452825   OR A1, V0, A1
9D004D94  00074C02   SRL T1, A3, 16
9D004D98  01A9001B   DIVU T5, T1
9D004D9C  012001F4   TEQ T1, ZERO
9D004DA0  00006010   MFHI T4
9D004DA4  00001812   MFLO V1
9D004DA8  30EEFFFF   ANDI T6, A3, -1
9D004DB8  00022C02   SRL A1, V0, 16
9D004DC0  00004012   MFLO T0
9D004DC4  706E7802   MUL T7, V1, T6
9D004DC8  000C6400   SLL T4, T4, 16
9D004DCC  01856025   OR T4, T4, A1
9D004DD0  018F282B   SLTU A1, T4, T7
9D004DD4  01A9001B   DIVU T5, T1
9D004DD8  012001F4   TEQ T1, ZERO
9D004DDC  10A0000A   BEQ A1, ZERO, 0x9D004E08
9D004DE0  01442004   SLLV A0, A0, T2
9D004DE4  01876021   ADDU T4, T4, A3
9D004DE8  0187282B   SLTU A1, T4, A3
9D004DEC  14A00006   BNE A1, ZERO, 0x9D004E08
9D004DF0  2468FFFF   ADDIU T0, V1, -1
9D004DF4  018F282B   SLTU A1, T4, T7
9D004DF8  50A00004   BEQL A1, ZERO, 0x9D004E0C
9D004DFC  018F6023   SUBU T4, T4, T7
9D004E00  2468FFFE   ADDIU T0, V1, -2
9D004E04  01876021   ADDU T4, T4, A3
9D004E08  018F6023   SUBU T4, T4, T7
9D004E0C  3042FFFF   ANDI V0, V0, -1
9D004E10  0189001B   DIVU T4, T1
9D004E14  012001F4   TEQ T1, ZERO
9D004E18  00002810   MFHI A1
9D004E1C  00001812   MFLO V1
9D004E20  00006812   MFLO T5
9D004E24  706E7002   MUL T6, V1, T6
9D004E28  00052C00   SLL A1, A1, 16
9D004E2C  00A21025   OR V0, A1, V0
9D004E30  004E282B   SLTU A1, V0, T6
9D004E34  0189001B   DIVU T4, T1
9D004E38  012001F4   TEQ T1, ZERO
9D004E3C  50A00006   BEQL A1, ZERO, 0x9D004E58
9D004E40  00084400   SLL T0, T0, 16
9D004E44  00471021   ADDU V0, V0, A3
9D004E48  0047282B   SLTU A1, V0, A3
9D004E4C  10A0004C   BEQ A1, ZERO, 0x9D004F80
9D004E50  246DFFFF   ADDIU T5, V1, -1
9D004E54  00084400   SLL T0, T0, 16
9D004E58  01A84025   OR T0, T5, T0
9D004E5C  004E1023   SUBU V0, V0, T6
9D004F80  004E282B   SLTU A1, V0, T6
9D004F84  50A0FFB4   BEQL A1, ZERO, 0x9D004E58
9D004F88  00084400   SLL T0, T0, 16
9D004F8C  246DFFFE   ADDIU T5, V1, -2
9D004F90  0B401395   J 0x9D004E54
9D004F94  00471021   ADDU V0, V0, A3
9D0051FC  00071C02   SRL V1, A3, 16
9D005200  0143001B   DIVU T2, V1
9D005204  006001F4   TEQ V1, ZERO
9D005208  00004810   MFHI T1
9D00520C  00006812   MFLO T5
9D005210  30EBFFFF   ANDI T3, A3, -1
9D005220  00057402   SRL T6, A1, 16
9D005224  00001012   MFLO V0
9D005228  71AB6002   MUL T4, T5, T3
9D00522C  00094C00   SLL T1, T1, 16
9D005230  012E4825   OR T1, T1, T6
9D005234  012C702B   SLTU T6, T1, T4
9D005238  0143001B   DIVU T2, V1
9D00523C  006001F4   TEQ V1, ZERO
9D005240  11C0000A   BEQ T6, ZERO, 0x9D00526C
9D005244  01063004   SLLV A2, A2, T0
9D005248  01274821   ADDU T1, T1, A3
9D00524C  0127502B   SLTU T2, T1, A3
9D005250  15400006   BNE T2, ZERO, 0x9D00526C
9D005254  25A2FFFF   ADDIU V0, T5, -1
9D005258  012C502B   SLTU T2, T1, T4
9D00525C  51400004   BEQL T2, ZERO, 0x9D005270
9D005260  012C4823   SUBU T1, T1, T4
9D005264  25A2FFFE   ADDIU V0, T5, -2
9D005268  01274821   ADDU T1, T1, A3
9D00526C  012C4823   SUBU T1, T1, T4
9D005270  30A5FFFF   ANDI A1, A1, -1
9D005274  0123001B   DIVU T1, V1
9D005278  006001F4   TEQ V1, ZERO
9D00527C  00006810   MFHI T5
9D005280  00006012   MFLO T4
9D005284  00005012   MFLO T2
9D005288  718B5802   MUL T3, T4, T3
9D00528C  000D6C00   SLL T5, T5, 16
9D005290  01A52825   OR A1, T5, A1
9D005294  00AB682B   SLTU T5, A1, T3
9D005298  0123001B   DIVU T1, V1
9D00529C  006001F4   TEQ V1, ZERO
9D0052A0  51A0000B   BEQL T5, ZERO, 0x9D0052D0
9D0052A4  00021400   SLL V0, V0, 16
9D0052A8  00A72821   ADDU A1, A1, A3
9D0052AC  00A7182B   SLTU V1, A1, A3
9D0052B0  14600006   BNE V1, ZERO, 0x9D0052CC
9D0052B4  258AFFFF   ADDIU T2, T4, -1
9D0052B8  00AB182B   SLTU V1, A1, T3
9D0052BC  50600004   BEQL V1, ZERO, 0x9D0052D0
9D0052C0  00021400   SLL V0, V0, 16
9D0052C4  258AFFFE   ADDIU T2, T4, -2
9D0052C8  00A72821   ADDU A1, A1, A3
9D0052CC  00021400   SLL V0, V0, 16
9D0052D0  01421025   OR V0, T2, V0
9D0052D4  00AB2823   SUBU A1, A1, T3
9D004E60  01060019   MULTU 0, T0, A2
9D004E64  00004810   MFHI T1
9D004E7C  00003012   MFLO A2
9D0052D8  00460019   MULTU 0, V0, A2
9D0052DC  00003810   MFHI A3
9D004E68  0049182B   SLTU V1, V0, T1
9D004E6C  1460003E   BNE V1, ZERO, 0x9D004F68
9D004E70  00004012   MFLO T0
9D004E74  1049004B   BEQ V0, T1, 0x9D004FA4
9D004E78  00491823   SUBU V1, V0, T1
9D004FA4  0088182B   SLTU V1, A0, T0
9D0052E0  00A7182B   SLTU V1, A1, A3
9D0052E4  14600044   BNE V1, ZERO, 0x9D0053F8
9D0052E8  00003012   MFLO A2
9D0052EC  10A7003F   BEQ A1, A3, 0x9D0053EC
9D0052F0  01042004   SLLV A0, A0, T0
9D0053EC  0086302B   SLTU A2, A0, A2
9D0053F0  10C0FFC0   BEQ A2, ZERO, 0x9D0052F4
9D0053F4  00000000   NOP
9D0052F4  03E00008   JR RA
9D0052F8  00001821   ADDU V1, ZERO, ZERO
9D0053F8  0B4014BD   J 0x9D0052F4
9D0053FC  2442FFFF   ADDIU V0, V0, -1
9D004F68  01063023   SUBU A2, T0, A2
9D004F6C  01271823   SUBU V1, T1, A3
9D004F70  0106402B   SLTU T0, T0, A2
9D004F74  00681823   SUBU V1, V1, T0
9D004F78  0B4013A0   J 0x9D004E80
9D004F7C  00431823   SUBU V1, V0, V1
9D004E80  00863023   SUBU A2, A0, A2
9D004E84  0086202B   SLTU A0, A0, A2
9D004E88  00641823   SUBU V1, V1, A0
9D004E8C  01631004   SLLV V0, V1, T3
9D004E90  01463006   SRLV A2, A2, T2
9D004E94  00461025   OR V0, V0, A2
9D004E98  01431806   SRLV V1, V1, T2
9D004E9C  03E00008   JR RA
9D004EA0  00000000   NOP
9D004EA4  24090020   ADDIU T1, ZERO, 32
9D004EA8  01224823   SUBU T1, T1, V0
9D004EAC  01255006   SRLV T2, A1, T1
9D004EB0  00081C02   SRL V1, T0, 16
9D004EB4  0143001B   DIVU T2, V1
9D004EB8  006001F4   TEQ V1, ZERO
9D004EBC  00003010   MFHI A2
9D004EC0  00005812   MFLO T3
9D004EC4  3107FFFF   ANDI A3, T0, -1
9D004EC8  00452804   SLLV A1, A1, V0
9D004ECC  01244806   SRLV T1, A0, T1
9D004ED0  01252825   OR A1, T1, A1
9D004ED4  00056402   SRL T4, A1, 16
9D004ED8  00444804   SLLV T1, A0, V0
9D004EDC  71675802   MUL T3, T3, A3
9D004EE0  00063400   SLL A2, A2, 16
9D004EE4  01863025   OR A2, T4, A2
9D004EE8  00CB202B   SLTU A0, A2, T3
9D004EEC  0143001B   DIVU T2, V1
9D004EF0  006001F4   TEQ V1, ZERO
9D004EF4  50800006   BEQL A0, ZERO, 0x9D004F10
9D004EF8  00CB3023   SUBU A2, A2, T3
9D004EFC  00C83021   ADDU A2, A2, T0
9D004F00  00C8202B   SLTU A0, A2, T0
9D004F04  10800024   BEQ A0, ZERO, 0x9D004F98
9D004F08  00CB502B   SLTU T2, A2, T3
9D004F0C  00CB3023   SUBU A2, A2, T3
9D004F10  30AAFFFF   ANDI T2, A1, -1
9D004F14  00C3001B   DIVU A2, V1
9D004F18  006001F4   TEQ V1, ZERO
9D004F1C  00002010   MFHI A0
9D004F20  00002812   MFLO A1
9D004F24  70A72802   MUL A1, A1, A3
9D004F28  00042400   SLL A0, A0, 16
9D004F2C  008A2025   OR A0, A0, T2
9D004F30  0085502B   SLTU T2, A0, A1
9D004F34  00C3001B   DIVU A2, V1
9D004F38  006001F4   TEQ V1, ZERO
9D004F3C  5140FF60   BEQL T2, ZERO, 0x9D004CC0
9D004F40  00852823   SUBU A1, A0, A1
9D004F44  00882021   ADDU A0, A0, T0
9D004F48  0088302B   SLTU A2, A0, T0
9D004F4C  54C0FF5C   BNEL A2, ZERO, 0x9D004CC0
9D004F50  00852823   SUBU A1, A0, A1
9D004F54  0085502B   SLTU T2, A0, A1
9D004F58  00883021   ADDU A2, A0, T0
9D004F5C  00CA200B   MOVN A0, A2, T2
9D004F60  0B401330   J 0x9D004CC0
9D004F64  00852823   SUBU A1, A0, A1
9D004F68  01063023   SUBU A2, T0, A2
9D004F6C  01271823   SUBU V1, T1, A3
9D004F70  0106402B   SLTU T0, T0, A2
9D004F74  00681823   SUBU V1, V1, T0
9D004F78  0B4013A0   J 0x9D004E80
9D004F7C  00431823   SUBU V1, V0, V1
9D004F80  004E282B   SLTU A1, V0, T6
9D004F84  50A0FFB4   BEQL A1, ZERO, 0x9D004E58
9D004F88  00084400   SLL T0, T0, 16
9D004F8C  246DFFFE   ADDIU T5, V1, -2
9D004F90  0B401395   J 0x9D004E54
9D004F94  00471021   ADDU V0, V0, A3
9D004F98  00C82021   ADDU A0, A2, T0
9D004F9C  0B4013C3   J 0x9D004F0C
9D004FA0  008A300B   MOVN A2, A0, T2
9D004FA4  0088182B   SLTU V1, A0, T0
9D004FA8  5460FFF0   BNEL V1, ZERO, 0x9D004F6C
9D004FAC  01063023   SUBU A2, T0, A2
9D004FB0  00003012   MFLO A2
9D004FB4  0B4013A0   J 0x9D004E80
9D004FB8  00001821   ADDU V1, ZERO, ZERO
9D005404  03E00008   JR RA
9D005408  24020001   ADDIU V0, ZERO, 1
9D00540C  0B40145E   J 0x9D005178
9D005410  00C83021   ADDU A2, A2, T0
9D01391C  27BDFFE0   ADDIU SP, SP, -32
9D013920  AFBF001C   SW RA, 28(SP)
9D013924  AFB00018   SW S0, 24(SP)
9D013928  00808021   ADDU S0, A0, ZERO
9D01392C  0F405206   JAL __floatunsidf
9D013930  00A02021   ADDU A0, A1, ZERO
9D013934  3C049D01   LUI A0, -25343
9D013938  8C865A38   LW A2, 23096(A0)
9D01393C  8C875A3C   LW A3, 23100(A0)
9D013940  00402021   ADDU A0, V0, ZERO
9D013944  0F4019DB   JAL dpmul
9D013948  00602821   ADDU A1, V1, ZERO
9D01394C  02002021   ADDU A0, S0, ZERO
9D013950  AFA20010   SW V0, 16(SP)
9D013954  0F405206   JAL __floatunsidf
9D013958  AFA30014   SW V1, 20(SP)
9D01395C  00402021   ADDU A0, V0, ZERO
9D013960  00602821   ADDU A1, V1, ZERO
9D013964  8FA60010   LW A2, 16(SP)
9D013968  0F40161C   JAL __adddf3
9D01396C  8FA70014   LW A3, 20(SP)
9D013970  8FBF001C   LW RA, 28(SP)
9D013974  8FB00018   LW S0, 24(SP)
9D013978  03E00008   JR RA
9D01397C  27BD0020   ADDIU SP, SP, 32
---  /build/bamboo/xml-data/build-dir/XC32-CYIMG-BLD/xc32-XC32-release-1_43/src48x/gcc/libgcc/floatunsisf.c
9D014434  27BDFFE8   ADDIU SP, SP, -24
9D014438  AFBF0014   SW RA, 20(SP)
9D01443C  04800006   BLTZ A0, 0x9D014458
9D014440  00801021   ADDU V0, A0, ZERO
9D014458  00042042   SRL A0, A0, 1
9D01445C  30420001   ANDI V0, V0, 1
9D014460  0F404ED8   JAL sitofp
9D014464  00822025   OR A0, A0, V0
9D014468  00402021   ADDU A0, V0, ZERO
9D01446C  0F401CAE   JAL fpadd
9D014470  00402821   ADDU A1, V0, ZERO
9D014444  0F404ED8   JAL sitofp
9D014448  00000000   NOP
9D01444C  8FBF0014   LW RA, 20(SP)
9D014450  03E00008   JR RA
9D014454  27BD0018   ADDIU SP, SP, 24
9D014474  8FBF0014   LW RA, 20(SP)
9D014478  03E00008   JR RA
9D01447C  27BD0018   ADDIU SP, SP, 24
---  /build/bamboo/xml-data/build-dir/XC32-CYIMG-BLD/xc32-XC32-release-1_43/src48x/gcc/libgcc/floatunsidf.c
9D014818  27BDFFE8   ADDIU SP, SP, -24
9D01481C  AFBF0014   SW RA, 20(SP)
9D014820  AFB00010   SW S0, 16(SP)
9D014824  0F404C5C   JAL __floatsidf
9D014828  00808021   ADDU S0, A0, ZERO
9D01482C  06010008   BGEZ S0, 0x9D014850
9D014830  8FBF0014   LW RA, 20(SP)
9D014834  3C049D01   LUI A0, -25343
9D014838  8C865A40   LW A2, 23104(A0)
9D01483C  8C875A44   LW A3, 23108(A0)
9D014840  00402021   ADDU A0, V0, ZERO
9D014844  0F40161C   JAL __adddf3
9D014848  00602821   ADDU A1, V1, ZERO
9D01484C  8FBF0014   LW RA, 20(SP)
9D014850  8FB00010   LW S0, 16(SP)
9D014854  03E00008   JR RA
9D014858  27BD0018   ADDIU SP, SP, 24
